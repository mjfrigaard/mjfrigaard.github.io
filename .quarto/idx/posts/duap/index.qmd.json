{"title":"Creating Shiny app-packages","markdown":{"yaml":{"title":"Creating Shiny app-packages","subtitle":"Building a Shiny app within an R package: whole-game","author":"Martin Frigaard","date":"2023-04-10","categories":["shiny","usethis","devtools","packages"],"draft":true,"image":"img/image.png","toc":true,"toc-depth":5,"toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-fold":"show","code-summary":"show/hide","callout-icon":false,"freeze":true,"execute":{"echo":true,"message":false,"warning":false,"eval":false}},"headingText":"`duap`","containsRefs":false,"markdown":"\n\n```{r}\n#| label: utils\n#| eval: true \n#| echo: false \n#| include: false\nlibrary(kableExtra)\nsource(\"../_common.R\")\n```\n\n```{r}\n#| label: co_box_long\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"r\", \n  header = \"Warning\", \n  hsize = '1.15', \n  contents = \"This is a long post because it covers many of the steps used to build R packages. If you want more information on developing R packages *without* Shiny apps, I suggest starting with [the whole game section](https://r-pkgs.org/whole-game.html).\")\n```\n\n```{r}\n#| label: co_box_test\n#| eval: false \n#| results: asis\n#| include: false\nco_box(color = \"r\", \"RED\", \"This is red\")\n```\n\nIn this post, I'll be using [`devtools`](https://devtools.r-lib.org/) and [`usethis`](https://usethis.r-lib.org/) to develop [`duap`](https://github.com/mjfrigaard/duap), an R package that *contains* a Shiny application (i.e., *`devtools`/`usethis` app-package*). You can access the `duap` app-package from the [`sapkgs` repo.]()\n\n```{r}\n#| eval: false \n#| code-fold: false\ninstall.packages(remotes)\nremotes::install_github(\n  \"https://github.com/mjfrigaard/sapkgs\", ref = \"duap\")\n```\n\nThe R package development workflow is well documented in [R Packages](https://r-pkgs.org/whole-game.html) and [Mastering Shiny](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app). I wrote this post because I frequently encountered R developers who were comfortable with Shiny application development, but had never developed an R package.\n\nWe'll walk through converting an existing Shiny application into an app-package *in detail*, because R package development differs from creating a standalone Shiny application. Hopefully by reading this you won't have to rebuild your application entirely from scratch.\n\nThe app-package development process can be organized into three areas: **Start**, **Build**, and **Use**.\n\n1.  **Start** covers the steps required to begin building a Shiny app withing a package framework (from the console and IDE).\n2.  **Build** covers the development process, which includes writing and storing code, data, external resources (i.e., data), documentation, and testing.\n3.  **Use** shows how developers can launch their application using the given framework/package locally (i.e., within the RStudio (Posit) IDE).\n\n\nBuilding a Shiny app as a package is [highly recommended](https://mastering-shiny.org/scaling-packaging.html?q=highly%20recommend#scaling-packaging). Both the [`golem`](https://thinkr-open.github.io/golem/) and [`leprechaun`](https://leprechaun.opifex.org/#/) frameworks convert your Shiny application into an R package, and while this might seem like overkill, when you consider the additional development tools accessible to R packages, I think you'll see why the advice makes sense.\n\n# Start\n\nCreate a new R package using [`devtools`](https://devtools.r-lib.org/) (which also installs [`usethis`](https://usethis.r-lib.org/)).\n\n```{r}\n#| label: install-devtools-duap\n#| code-fold: false\ninstall.packages(\"devtools\")\nlibrary(devtools)\n```\n\n## From Console\n\nTo create a new R package from the console, run `usethis::create_package()`:\n\n```{r}\n#| label: create_package-duap\n#| code-fold: false\nusethis::create_package(path = \"duap\")\n```\n\nA new RStudio session will open (and the name of the project--i.e., the name of the `.Rproj` file--will be identical to the package name).\n\n## From Project Wizard\n\nRStudio's **New Project Wizard** can create a new Shiny app package using the following:\n\n::: {#fig-rpkg-setup}\n\n![](img/rpkg-setup.png){width=\"100%\" fig-align=\"center\"}\n\nDefault `usethis::create_package` project setup\n:::\n\nA new package built from the console has the following folders and files:\n\n```{verbatim}\n#| label: duap-console-tree\n#| code-fold: false\nduap/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── duap.Rproj\n  \n1 directory, 3 files\n```\n\nPackages built from the **New Project Wizard** will have a few additional folders and files:\n\n```{verbatim}\n#| label: duap-wizard-tree\n#| code-fold: false\nduap/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   └── hello.R\n  ├── man/\n  │   └── hello.Rd\n  ├── myRPkg.Rproj\n  └── renv/\n      ├── activate.R\n      ├── sandbox/\n      │   └── R-4.2\n      └── settings.dcf\n\n4 directories, 7 files\n```\n\nThese additional files are:\n\n-   `hello.R` in the `R/` folder\\\n-   `hello.Rd` in the `man/` folder\\\n-   a `renv/` folder for package management\n\n`R/hello.R` and `man/hello.Rd` are boilerplate files and can be deleted, but both package setups have a `DESCRIPTION`, `NAMESPACE`, `R/` folder, and `.Rproj` file. These four items can be thought of as the minimal package setup required to access RStudio's **Build** tools.\n\n# Build\n\nWell work through simple application from the excellent [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) (BWAS) course. Well convert this application into an R package by 1) converting the any logic into utility functions, 2) modularizing the applications behaviors into functions (or Shiny modules), 3) creating a standalone app function for launching the app.\n\n## Modules\n\nThe application in `duap` is using [modules](https://mastering-shiny.org/scaling-modules.html#module-motivation) to separate the app into the following digestible mental chunks. We'll create two modules for our application in `duap`: one for collecting inputs, the other for displaying plot outputs.[^module-files]\n\n[^module-files]: Modules consist of two functions (one for the UI, and another in the server) but it's common practice to combine them in a single file in `R/`.\n\n\n```{r}\n#| label: co_box_r\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  header = \"R/\", \n  contents = \"The contents of our Shiny app need to be in the `R/` folder. Create new `.R` files with `usethis::use_r()`.\")\n```\n\n### Input module\n\nThe input module collects the graph parameters from the UI and returns them as reactive inputs from the server.\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_var_input'\nmod_var_input_ui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\nmod_var_input_server <- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n            \"y\" = input$y,\n            \"x\" = input$x,\n            \"z\" = input$z,\n            \"alpha\" = input$alpha,\n            \"size\" = input$size,\n            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n```\n\n### Utility function\n\nWe need a graphing function (`point_plot()`) capable of handling string inputs from Shiny (and a dynamic dataset loaded from the R package).\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide point_plot()'\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot(data = df,\n      aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      geom_point(alpha = alpha_var, size = size_var)\n\n}\n```\n\n### Display module\n\nThe display module (`mod_display_plot`) will include a `plotOutput()` in the UI and a `var_inputs` argument in the server (to collect the returned reactive values from `mod_var_input`).\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_display_plot'\nmod_display_plot_ui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\"The code for this application comes from the \",\n        tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))),\n    plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\nmod_display_plot_server <- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n\n    load(\"data/movies.rda\")\n\n    inputs <- reactive({\n      plot_title <- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n    \n    output$scatterplot <- renderPlot({\n      plot <- point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n```\n\n### Standalone app function\n\nFinally, I need to add these into a [standalone app function](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) `moviesApp()` (stored in `R/moviesApp.R`).[^standalone-app-fun] Note the `id`s in each module function pair must match to create the shared namespace.\n\n[^standalone-app-fun]: Standalone app functions contains a call to `shiny::shinyApp()` and includes the module functions (in their relative positions).\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide moviesApp()'\nmoviesApp <- function() {\n  # call to shinyApp()\n  shinyApp(\n    # UI ----\n    ui = fluidPage(\n      sidebarLayout(\n        sidebarPanel(\n          # UI input module ----\n          mod_var_input_ui(\"vars\")\n        ),\n        # UI display module ----\n        mainPanel(\n          mod_display_plot_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      # server input module (capturing inputs) ----\n      selected_vars <- mod_var_input_server(\"vars\")\n      # server display module (rendering outputs) ----\n      mod_display_plot_server(\"plot\", \n                              var_inputs = selected_vars)\n    }\n  )\n}\n```\n\n## Package files\n\nR packages have two important metadata files: `DESCRIPTION` and `NAMESPACE`. Neither of these files have extensions, and both contain vital information for your package to function properly.\n\nWe can manually edit the `DESCRIPTION` file, but the `NAMESPACE` file is automatically generated during the development process.\n\n### DESCRIPTION\n\nThe `DESCRIPTION` file plays an important role in R packages.[^desc-importance]\n\n[^desc-importance]: Creating the `DESCRIPTION` file is the first step when [converting an existing app](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) (and when creating a [new `golem` apps](https://thinkr-open.github.io/golem/articles/a_start.html#fill-the-description)).\n\n```{r}\n#| label: co_box_desc\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(\n  color = \"b\", \n  header = \"`DESCRIPTION` files\", \n  contents = \"\nThe `DESCRIPTION` file needs to have the following fields for our package to load: \n  \n`Package`, `Version`, `License`, `Description`, `Title`, `Author`, and `Maintainer`\n  \n*RStudio and `devtools` consider any directory containing `DESCRIPTION` to be a package* - [R Packages](https://r-pkgs.org/description.html#the-description-file)\")\n```\n\nThe initial `DESCRIPTION` file in `duap` is below:\n\n```{verbatim}\nPackage: duap\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.1\n```\n\nThe package name is automatically added, but the remaining fields need to be completed (consult [R packages](https://r-pkgs.org/description.html#the-description-file) for more information on filling out the `DESCRIPTION` file).\n\nThe `DESCRIPTION` file in the `duap` prompts the RStudio IDE to activate the **Build** tools pane (see below):\n\n::: {#fig-rpkg-ide}\n![](img/rpkg-ide.png){width=\"100%\" fig-align=\"center\"}\n\nPackage **Build** tools\n:::\n\nThe **Build** pane is controlled by the Package Build options in the `.Rproj` file. We can change these settings with **Tools** \\> **Project Options…** \\> **Build Tools**, the select **Package** from the dropdown:\n\n::: {#fig-pkgs_build_options}\n\n![](img/pkgs_build_options.png){#fig-pkgs_build_options width=\"100%\" fig-align=\"center\"}\n\n`.Rproj` fields when converting to and R package:\n:::\n\n\n### roxygen2\n\nWhen we're confident the app code works (and the app renders), we will make sure the functions are properly documented by describing each function with [`roxygen2`](https://roxygen2.r-lib.org/) tags. `roxygen` creates a `NAMESPACE` file, generates `.Rd` files, and can be configured to automatically build vignettes.\n\n```{r}\n#| label: co_box_roxygen2_skeleton\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  header = \"Tip: `roxygen2` skeleton\", \n  hsize = '1.25',\n  contents = \"*To quickly insert a `roxygen2` skeleton, use the RStudio IDE (or the keyboard shortcut: `Option` + `Shift` + `Command` + `R`)*\n  \n![Standard `roxygen2` skeleton](ide-roxygen-skeleton.png){width='100%' fig-align=center}\n\n\")\n```\n\nThe standard `roxygen2` skeleton tags include `@param`, `@return`, `@export`, and `@examples`\n\n-   `@param` lists the existing arguments (or variables) for the function\n\n-   `@return` should be a description of the object/side-effect/thing the function produces (and any warnings or errors if used incorrectly)\n\n#### Exports\n\nThe following [`roxygen2`](https://roxygen2.r-lib.org/) tags can be used to update the `NAMESPACE` file (which you should never edit manually!). \n\n-   `@export` will make the function available to other people when they use your package\n\n#### Imports\n\nImporting functions and objects from add-on packages is best summarized in the [`roxygen2` documentation](https://roxygen2.r-lib.org/articles/namespace.html#functions-1): \n\n> \"*If you are using just a few functions from another package, we recommending adding the package to the `Imports:` field of the `DESCRIPTION` file and calling the functions explicitly using `::`, e.g., `pkg::fun()`.*\"\n\nFollowing this advice, we should add `ggplot2`, `stringr`, rlang, and the other packages we used above to the `Imports:` field with `usethis::use_package()`.\n\n**`import` vs. `@importFrom`:**\n\n  -   If an item you're importing can't be accessed with the `pkg::fun()` syntax, you should use `@importFrom`. There's even a handy helper from `usethis` (`use_import_from(\"package\", \"function\")`.\n\n  -   `@import` should only be used when [\"*you make such heavy use of so many functions from another package that you want to import its entire namespace. This should be relatively rare.*\"](https://r-pkgs.org/dependencies-in-practice.html#in-code-below-r)\n\n`roxygen2` imports and exports are covered in more depth [in R packages.](https://r-pkgs.org/dependencies-in-practice.html#sec-dependencies-in-imports).\n\nThe `roxygen2` for `point_plot()` and `moviesApp()` is below:\n\n```{r}\n#| code-summary: 'roxygen2 for point_plot()'\n#| code-fold: true\n#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return `ggplot2` plot object\n#' \n#' @export\n#'\n#' @importFrom rlang .data\n#'\n#' @examples\n#' require(duap)\n#' movies <- duap::movies\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n```\n\n\n```{r}\n#| code-summary: 'roxygen2 for moviesApp()'\n#| code-fold: true\n#' moviesApp \n#' \n#' Standalone app function\n#'\n#' @return A shiny app object\n#' \n#' @import shiny\n#' \n#' @export \n#'\n```\n\nI've included these examples because they both use `@importFrom` and `@import` appropriately.\n\nFunction documentation is handled with the `R/` folder and `roxygen2` comments/tags, but `duap` needs a `README` file, and a place for long-form documentation. Fortunately, [RMarkdown](https://rmarkdown.rstudio.com/) handles each of these well:\n\n#### README files\n\nI can create a `README` file using [`usethis::use_readme_md()`](https://usethis.r-lib.org/reference/use_readme_rmd.html) or [`usethis::use_readme_rmd()`](https://usethis.r-lib.org/reference/use_readme_rmd.html)\n\n-   I prefer the `.Rmd` file because it comes with executable code chunks.\n\n    ```{r}\n    #| label: use_readme_rmd\n    #| code-fold: false \n    usethis::use_readme_rmd()\n    ```\n\n    ```{verbatim}\n    ✔ Setting active project to /Users/mjfrigaard/projects/duap\n    ✔ Writing README.Rmd\n    ✔ Adding ^README\\\\.Rmd$ to .Rbuildignore\n    • Modify README.Rmd\n    • Update README.Rmd to include installation instructions.\n    ✔ Writing .git/hooks/pre-commit\n    ```\n\n    -   When I knit `README.Rmd`, it automatically generates the `README.md` for the package.\n\n#### Vignettes\n\nFor long-form documentation I can use [vignettes.](https://r-pkgs.org/vignettes.html#introduction)\n\n-   Vignettes can be created with [`usethis::use_vignette()`](https://usethis.r-lib.org/reference/use_vignette.html)\n\n    ```{r}\n    #| label: use_vignette\n    #| code-fold: false \n    usethis::use_vignette(\"duap\")\n    ```\n\n    ```{verbatim}\n    ✔ Adding knitr to Suggests field in DESCRIPTION\n    ✔ Setting VignetteBuilder field in DESCRIPTION to knitr\n    ✔ Adding inst/doc to .gitignore\n    ✔ Creating vignettes/\n    ✔ Adding *.html, *.R to vignettes/.gitignore\n    ✔ Adding rmarkdown to Suggests field in DESCRIPTION\n    ✔ Writing vignettes/duap.Rmd\n    • Modify vignettes/duap.Rmd\n    ```\n\nVignettes are also written in RMarkdown and rendered whenever the package is built/installed.\n\n```{verbatim}\n#| label: use_vignette-tree\n#| code-fold: false \nduap/\n    └── vignettes/\n            └── duap.Rmd\n\n1 directory, 1 file\n```\n\nBy combining `rmarkdown` and `knitr`, R packages have a documentation framework that has the added benefit of being somewhat fool-proof: vignettes have to successfully render for the package to be installed.\n\n```{r}\n#| label: co_box_vignettes_images\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\",\n  header = \"Vignette figures\", \n  hsize = '1.25',\n  contents = \"Images in vignettes are kept in `man/figures/`\n\n\\`\\`\\`bash\nduap/\n  ├── vignettes/\n  │       └── duap.Rmd\n  └── man/\n      └── figures/\n          └── duap-img-1.png\n\\`\\`\\`\n  \")\n```\n\nThe vignettes folder will long-form documentation about how the application works, use cases, and features (and `roxygen2` will document each function).\n\n## Load, document, install\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n> \"The `load_all()` function is arguably the most important part of the devtools workflow.\" - [R Packages, 2ed](https://r-pkgs.org/workflow101.html#sec-workflow101-load-all)\n\n:::\n\nYou'll use the `devtools::load_all()` function frequently while youre developing your app-package. `load_all()` simulates how your functions will work when someone else uses your package. This removes the need to define them in the global workspace. It also gives you access to the functions from any add-on packages youve imported into your `NAMESPACE` (i.e., you wont need to run `library()`).\n\n```{r}\n#| label: co_box_load_all\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"`devtools::load_all()` keyboard shortcuts\", \n  contents = \"\nI highly recommend using the keyboard shortcuts:\n\n-   macOS: <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>\n\n-   Windows/Linux: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>\n  \n\")\n```\n\n\nThe full benefits of using `load_all()` are covered in [R packages.](https://r-pkgs.org/workflow101.html#benefits-of-load_all)\n\n### `load_all()`\n\nAfter documenting everything with `roxygen2`, I want to make sure none of the functions are in my **Environment** (remove with `rm()` if necessary) and load the functions with [`devtools::load_all()`](https://r-pkgs.org/whole-game.html#sec-whole-game-load-all).\n\n```{r}\n#| label: duap-load_all\n#| code-fold: false\ndevtools::load_all()\n```\n\n```{verbatim}\nℹ Loading duap\n```\n\n### `document()`\n\n`devtools::document()` processes the `roxygen2` tags to generate the `NAMESPACE` and the `.Rd` files in the `man/` folder. The `.Rd` files are used to access the help files (i.e., `package::function()` can be accessed with `??function`).\n\nManaging your package [NAMESPACE file](https://r-pkgs.org/dependencies-in-practice.html#sec-dependencies-NAMESPACE-workflow) is not something you do directly: its handled with the `roxygen2` tags we covered above.\n\n```{r}\n#| label: co_box_document\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"`devtools::document()` keyboard shortcuts\", \n  contents = \"\n\nThe keyboard shortcuts for `devtools::document()` are below:\n  \n-   macOS: <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>\n\n-   Windows/Linux: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>\n  \")\n```\n\nRun `devtools::document()` when youve written a new function with `roxygen2` tags or included a package in the `DESCRIPTION` file under `Imports:`\n\n```{r}\n#| label: duap-document\n#| code-fold: false\ndevtools::document()\n```\n\n```{verbatim}\nℹ Updating duap documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\nℹ Loading duap\nWriting NAMESPACE\nWriting mod_plot_ui.Rd\nWriting mod_plot_server.Rd\nWriting point_plot.Rd\nWriting mod_var_input_ui.Rd\nWriting mod_var_input_server.Rd\nWriting moviesApp.Rd\n```\n\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n`NAMESPACE` != `DESCRIPTION`\n\n:::\n\nIts important to understand that `devtools::document()` will use the `roxygen2` tags to create the `man/*.Rd` files and update the `NAMESPACE`, but **`devtools::document()` does not update the `Imports:` section in the `DESCRIPTION`.**\n\nTo add packages dependencies to the `DESCRIPTION`, we need to use the [`usethis::use_package()` function](https://usethis.r-lib.org/reference/use_package.html).[^confusion-imports] \n\n[^confusion-imports]: Read more on this topic in [Confusion about `Imports`](https://r-pkgs.org/dependencies-in-practice.html#confusion-about-imports).\n\nThe table below shows the connection between `roxygen2` tags, the resulting `NAMESPACE` entry, and what should be listed in the `DESCRIPTION`.\n\n::: {style=\"font-size: 0.80em;\"}\n```{r}\n#| label: co_box_namespace\n#| eval: true\n#| echo: false \n#| results: asis\n# roxy_ns_df -----\nroxy_ns_df <- data.frame(\n  check.names = FALSE,\n  `R/ code files` = c(\"pkg::fun()\", \"@importFrom\", \"@import\", \"@export\"),\n  NAMESPACE = c(\n    \"Nothing\",\n    \"importFrom() : import selected object from another NAMESPACE.\",\n    \"import(): import all objects from another packages NAMESPACE.\",\n    \"export() : export the function, method, generic, or class so its available to users.\"\n  ),\n  DESCRIPTION = c(\"Imports\", \"Imports\", \"Imports\", \"Nothing\")\n)\n\nco_box(\n  color = \"b\",\n  header = \"`roxygen2`, `NAMESPACE` & `DESCRPTION`\",\n  hsize = '1.25',\n  contents = kable_styling(\n    kable_input = knitr::kable(roxy_ns_df,\n      align = c(\"l\", \"l\", \"r\"),\n      bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\")\n    )\n  )\n)\n```\n:::\n\n### `install()`\n\nAfter loading and documenting the `duap` package, I want to make sure I can install the package into my library with [`devtools::install()`](https://r-pkgs.org/whole-game.html#install). \n\n```{r}\n#| label: co_box_install\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"`devtools::install()` keyboard shortcuts\", \n  contents = \"\n\nThe keyboard shortcut for `devtools::install()` is below:\n-   macOS: <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd>\n\n-   Windows/Linux: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd>\n  \n\")\n```\n\n\n```{r}\n#| label: duap-install\n#| code-fold: false\ndevtools::install()\n```\n\n```{verbatim}\n── R CMD build ────────────────────────────────────────────────────────────────\n✔  checking for file /Users/mjfrigaard/projects/duap/DESCRIPTION ...\n─  preparing duap: (1.8s)\n✔  checking DESCRIPTION meta-information\n─  checking for LF line-endings in source and make files and shell scripts (520ms)\n─  checking for empty or unneeded directories\n   Omitted LazyData from DESCRIPTION\n─  building duap_0.1.0.tar.gz\n   \nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD INSTALL \n  --install-tests \n* installing to library ...\n* installing *source* package duap ...\n** using staged installation ...\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (duap)\n```\n\nRestart your R session and ensure you have a clean workspace:\n\n```{verbatim}\n   Restarting R session...\n```\n\nThen load your package with `library()`:\n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: false\nlibrary(duap)\n```\n\nYou can also use **Install** icon in the **Build** pane, which installs the package, restarts the R session, and loads the package all with one click!\n\n::: {#fig-build-install}\n\n![](img/build-install.png){width=\"100%\" fig-align=\"center\"}\n\n**Build** install package\n:::\n\nThe sequence I've demonstrated above (create `.R` file, write function, document with `roxygen2`, load, document, install) is the minimal version of the [full development workflow](https://r-pkgs.org/whole-game.html).\n\nStoring the applications code in the `R/` folder and (using RStudio's build tools) keeps files organized, well documented, and self-contained:\n\n-   All the code is stored in the `R/` folder\n\n-   We've separated the code into smaller pieces (modules) that can be tested independently (more on this later)\n\n-   Dependencies are being managed by `roxygen2` and `devtools::document()`, which will update the `NAMESPACE` with any functions tagged with `@importFrom` (or `@import`)\n\n\nNow that I have the function documentation in the `.Rd` files, the `DESCRIPTION` and `NAMESPACE`, I can move onto adding and using **data**.\n\n## Data\n\nMost app-packages will require files beyond the `.R` files in the `R/` folder. Apps will often use data files when they're deployed, which well cover next. R Packages have a consistent and standardized way of storing data, and have designated locations for internal and external data. \n\n### `data/`\n\n[`usethis::use_data()` or `usethis::use_data_raw()`](https://usethis.r-lib.org/reference/use_data.html) make it simple to add data to the application package.\n\nIn R packages, data is stored in either [`data/` or `data-raw/`](https://r-pkgs.org/data.html). To access a copy of the `movies` dataset in `duap` (i.e., with `duap::movies`), I can load `movies.RData` into the environment and run `usethis::use_data(movies)`. This will create a `data/` folder and save `movies` as `movies.rda`:\n\n```{verbatim}\n✔ Adding R to Depends field in DESCRIPTION\n✔ Creating data/\n✔ Saving movies to data/movies.rda\n• Document your data (see https://r-pkgs.org/data.html)\n```\n\n### `data-raw/`\n\nI can also import `movies.RData` by adding the following to `data-raw/movies.R`:\n\n```{r}\n#| label: use_data_raw\n#| code-fold: false \nusethis::use_data_raw(\"movies\")\n```\n\n```{verbatim}\n✔ Creating data-raw/\n✔ Writing data-raw/movies.R\n• Modify data-raw/movies.R\n• Finish the data preparation script in data-raw/movies.R\n• Use `usethis::use_data()` to add prepared data to package\n```\n\nIn the `data-raw/movies.R` script, I want to import the `movies.RData` file, but where should I import it from? \n\n### `inst/extdata`\n\nThe `inst/` folder plays a special role when developing R packages:\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n> \"*When a package is installed, everything in `inst/` is copied into the top-level directory of the installed package*\" - [R Packages, 2ed](https://r-pkgs.org/misc.html#sec-misc-inst)\n\n:::\n\nConsider the example folder and files below: `file.txt`, `CITATION`, and `extdata/my_data.csv`:\n\n::: {layout-ncol=\"2\"}\n##### Source (development) form\n\n```{verbatim}\n#| code-fold: false\ninst/\n  ├── file.txt\n  ├── CITATION\n  └── extdata/\n        └── my_data.csv\n```\n\n##### Binary (installed) form\n\n```{verbatim}\n#| code-fold: false\nfile.txt\nCITATION\nextdata/\n  └── my_data.csv\n```\n:::\n\nThe neat thing about the `inst/` folder is that after we've loaded and installed our package, we can access the files in `inst/extdata/` with the [`system.file()` function](https://pkgload.r-lib.org/reference/system.file.html):\n\nIf I want to test functions in `duap` using `movies.RData` (or another dataset), those should be placed in `inst/extdata/`\n\n### `system.file()`\n\nA great way to understand what files are available in `inst/` when your package is to pass `system.file()` to `fs::dir_tree()`:\n\n```{r}\n#| label: tree-extdata-movies\n#| code-fold: false \nfs::dir_tree( # wrap this in a folder tree\n  system.file(package = \"duap\"))\n```\n\n```{bash}\n#| eval: false\n#| code-fold: true \n#| collapse: true \n#| code-summary: expand to see inst/ folder contents\n/path/to/installed/package/duap\n├── DESCRIPTION\n├── INDEX\n├── LICENSE\n├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R\n│   ├── duap\n│   ├── duap.rdb\n│   └── duap.rdx\n├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata\n│   └── movies.RData\n├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── duap.rdb\n│   ├── duap.rdx\n│   ├── figures\n│   └── paths.rds\n└── html\n    ├── 00Index.html\n    └── R.css\n```\n\nThe `system.file()` function will show me the path to the locally installed version of the package (hence the `/path/to/installed/package/` at the beginning of the path).\n\nThe `inst/exdata/` folder comes in handy for adding example data, but its also useful for application development (more on that later).\n\n```{r}\n#| label: co_box_ins\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"The `inst/extdata/` folder\", \n  contents = \"\n\nTake a look at the `inst/extdata/` folder [`readr::readr_example()`](https://github.com/tidyverse/readr/blob/5ac729aa9a70fef297a634d2332ff8ff1af874fb/R/example.R) function to understand more about how this works.\n  \n  \")\n```\n\n## Tests\n\nTesting is an important part of any package, and apps tend to require additional tests (especially when they're moving from development into production environments).\n\n### `use_testthat()`\n\nTo apply the testing framework provided by the [`testthat` package.](https://testthat.r-lib.org/) package, we'll use `usethis::use_testthat()`:\n\n```{r}\n#| label: use_testthat\n#| code-fold: false \nusethis::use_testthat()\n```\n\n```{verbatim}\n✔ Adding testthat to Suggests field in DESCRIPTION\n✔ Setting Config/testthat/edition field in DESCRIPTION to 3\n✔ Creating tests/testthat/\n✔ Writing tests/testthat.R\n• Call `use_test()` to initialize a basic test file and open it for editing.\n```\n\nThis creates a new `tests/` folder, with a `testthat/` sub-folder and script.\n\n```{verbatim}\n#| label: use_testthat-tree\n#| code-fold: false \nduap/\n    └── tests/\n          ├── testthat/\n          └── testthat.R\n        \n2 directories, 1 file\n```\n\n#### Writing tests\n\n[`testthat`](https://testthat.r-lib.org/) is designed for unit tests (i.e., testing each functional unit in the code), but for Shiny apps, we need to think beyond standard unit testing.\n\nWe need to confirm the functions work and return predictable results, but we also need to make sure they play well with each other (integration tests), and that the application can be deployed (system tests).\n\nTesting is well described in the [Shiny documentation](https://shiny.rstudio.com/articles/testing-overview.html) and in [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html). Generally speaking, unit tests are performed with [`testthat`](https://testthat.r-lib.org/), and module testing can be done with [Shiny's `testServer()` function](https://shiny.rstudio.com/reference/shiny/1.7.0/testserver). To test the full application (or a specific behavior) use the [`shinytest2`](https://rstudio.github.io/shinytest2/) package.\n\n# Use\n\nUsing an app built as a package is similar to using any R function we've loaded from a package. After successfully loading, documenting, and installing the package, we can run the app by loading the `duap` (with `library(duap)`) and `moviesApp()`:\n\n::: {#fig-duap-inst-app}\n\n![](img/duap-app.png){#fig-duap-inst width=\"100%\" fig-align=\"center\"}\n\n`duap::moviesApp()`\n:::\n\n## Recap\n\nWe've skipped over some important development steps covered in [R packages](https://r-pkgs.org/) (license, using Git/GitHub, code coverage, NEWS, etc.), and you should bookmark this text as you start developing Shiny app-packages. Hopefully this post has demonstrated that by building Shiny apps as R packages, a suite of developer tools are available in the IDE (and the application files and folders have a uniform structure).\n\n`duap` is a substantial improvement over a single file Shiny application--the app-package holds the code, data, documentation, *and* includes explicit information on the dependencies and requirements (in the `DESCRIPTION` and `NAMESPACE`).\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: utils\n#| eval: true \n#| echo: false \n#| include: false\nlibrary(kableExtra)\nsource(\"../_common.R\")\n```\n\n```{r}\n#| label: co_box_long\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"r\", \n  header = \"Warning\", \n  hsize = '1.15', \n  contents = \"This is a long post because it covers many of the steps used to build R packages. If you want more information on developing R packages *without* Shiny apps, I suggest starting with [the whole game section](https://r-pkgs.org/whole-game.html).\")\n```\n\n```{r}\n#| label: co_box_test\n#| eval: false \n#| results: asis\n#| include: false\nco_box(color = \"r\", \"RED\", \"This is red\")\n```\n\nIn this post, I'll be using [`devtools`](https://devtools.r-lib.org/) and [`usethis`](https://usethis.r-lib.org/) to develop [`duap`](https://github.com/mjfrigaard/duap), an R package that *contains* a Shiny application (i.e., *`devtools`/`usethis` app-package*). You can access the `duap` app-package from the [`sapkgs` repo.]()\n\n```{r}\n#| eval: false \n#| code-fold: false\ninstall.packages(remotes)\nremotes::install_github(\n  \"https://github.com/mjfrigaard/sapkgs\", ref = \"duap\")\n```\n\nThe R package development workflow is well documented in [R Packages](https://r-pkgs.org/whole-game.html) and [Mastering Shiny](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app). I wrote this post because I frequently encountered R developers who were comfortable with Shiny application development, but had never developed an R package.\n\nWe'll walk through converting an existing Shiny application into an app-package *in detail*, because R package development differs from creating a standalone Shiny application. Hopefully by reading this you won't have to rebuild your application entirely from scratch.\n\nThe app-package development process can be organized into three areas: **Start**, **Build**, and **Use**.\n\n1.  **Start** covers the steps required to begin building a Shiny app withing a package framework (from the console and IDE).\n2.  **Build** covers the development process, which includes writing and storing code, data, external resources (i.e., data), documentation, and testing.\n3.  **Use** shows how developers can launch their application using the given framework/package locally (i.e., within the RStudio (Posit) IDE).\n\n# `duap`\n\nBuilding a Shiny app as a package is [highly recommended](https://mastering-shiny.org/scaling-packaging.html?q=highly%20recommend#scaling-packaging). Both the [`golem`](https://thinkr-open.github.io/golem/) and [`leprechaun`](https://leprechaun.opifex.org/#/) frameworks convert your Shiny application into an R package, and while this might seem like overkill, when you consider the additional development tools accessible to R packages, I think you'll see why the advice makes sense.\n\n# Start\n\nCreate a new R package using [`devtools`](https://devtools.r-lib.org/) (which also installs [`usethis`](https://usethis.r-lib.org/)).\n\n```{r}\n#| label: install-devtools-duap\n#| code-fold: false\ninstall.packages(\"devtools\")\nlibrary(devtools)\n```\n\n## From Console\n\nTo create a new R package from the console, run `usethis::create_package()`:\n\n```{r}\n#| label: create_package-duap\n#| code-fold: false\nusethis::create_package(path = \"duap\")\n```\n\nA new RStudio session will open (and the name of the project--i.e., the name of the `.Rproj` file--will be identical to the package name).\n\n## From Project Wizard\n\nRStudio's **New Project Wizard** can create a new Shiny app package using the following:\n\n::: {#fig-rpkg-setup}\n\n![](img/rpkg-setup.png){width=\"100%\" fig-align=\"center\"}\n\nDefault `usethis::create_package` project setup\n:::\n\nA new package built from the console has the following folders and files:\n\n```{verbatim}\n#| label: duap-console-tree\n#| code-fold: false\nduap/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── duap.Rproj\n  \n1 directory, 3 files\n```\n\nPackages built from the **New Project Wizard** will have a few additional folders and files:\n\n```{verbatim}\n#| label: duap-wizard-tree\n#| code-fold: false\nduap/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   └── hello.R\n  ├── man/\n  │   └── hello.Rd\n  ├── myRPkg.Rproj\n  └── renv/\n      ├── activate.R\n      ├── sandbox/\n      │   └── R-4.2\n      └── settings.dcf\n\n4 directories, 7 files\n```\n\nThese additional files are:\n\n-   `hello.R` in the `R/` folder\\\n-   `hello.Rd` in the `man/` folder\\\n-   a `renv/` folder for package management\n\n`R/hello.R` and `man/hello.Rd` are boilerplate files and can be deleted, but both package setups have a `DESCRIPTION`, `NAMESPACE`, `R/` folder, and `.Rproj` file. These four items can be thought of as the minimal package setup required to access RStudio's **Build** tools.\n\n# Build\n\nWell work through simple application from the excellent [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) (BWAS) course. Well convert this application into an R package by 1) converting the any logic into utility functions, 2) modularizing the applications behaviors into functions (or Shiny modules), 3) creating a standalone app function for launching the app.\n\n## Modules\n\nThe application in `duap` is using [modules](https://mastering-shiny.org/scaling-modules.html#module-motivation) to separate the app into the following digestible mental chunks. We'll create two modules for our application in `duap`: one for collecting inputs, the other for displaying plot outputs.[^module-files]\n\n[^module-files]: Modules consist of two functions (one for the UI, and another in the server) but it's common practice to combine them in a single file in `R/`.\n\n\n```{r}\n#| label: co_box_r\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  header = \"R/\", \n  contents = \"The contents of our Shiny app need to be in the `R/` folder. Create new `.R` files with `usethis::use_r()`.\")\n```\n\n### Input module\n\nThe input module collects the graph parameters from the UI and returns them as reactive inputs from the server.\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_var_input'\nmod_var_input_ui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\nmod_var_input_server <- function(id) {\n\n  moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n            \"y\" = input$y,\n            \"x\" = input$x,\n            \"z\" = input$z,\n            \"alpha\" = input$alpha,\n            \"size\" = input$size,\n            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n```\n\n### Utility function\n\nWe need a graphing function (`point_plot()`) capable of handling string inputs from Shiny (and a dynamic dataset loaded from the R package).\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide point_plot()'\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot(data = df,\n      aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      geom_point(alpha = alpha_var, size = size_var)\n\n}\n```\n\n### Display module\n\nThe display module (`mod_display_plot`) will include a `plotOutput()` in the UI and a `var_inputs` argument in the server (to collect the returned reactive values from `mod_var_input`).\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_display_plot'\nmod_display_plot_ui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\"The code for this application comes from the \",\n        tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))),\n    plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\nmod_display_plot_server <- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n\n    load(\"data/movies.rda\")\n\n    inputs <- reactive({\n      plot_title <- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n    \n    output$scatterplot <- renderPlot({\n      plot <- point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n```\n\n### Standalone app function\n\nFinally, I need to add these into a [standalone app function](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) `moviesApp()` (stored in `R/moviesApp.R`).[^standalone-app-fun] Note the `id`s in each module function pair must match to create the shared namespace.\n\n[^standalone-app-fun]: Standalone app functions contains a call to `shiny::shinyApp()` and includes the module functions (in their relative positions).\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide moviesApp()'\nmoviesApp <- function() {\n  # call to shinyApp()\n  shinyApp(\n    # UI ----\n    ui = fluidPage(\n      sidebarLayout(\n        sidebarPanel(\n          # UI input module ----\n          mod_var_input_ui(\"vars\")\n        ),\n        # UI display module ----\n        mainPanel(\n          mod_display_plot_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      # server input module (capturing inputs) ----\n      selected_vars <- mod_var_input_server(\"vars\")\n      # server display module (rendering outputs) ----\n      mod_display_plot_server(\"plot\", \n                              var_inputs = selected_vars)\n    }\n  )\n}\n```\n\n## Package files\n\nR packages have two important metadata files: `DESCRIPTION` and `NAMESPACE`. Neither of these files have extensions, and both contain vital information for your package to function properly.\n\nWe can manually edit the `DESCRIPTION` file, but the `NAMESPACE` file is automatically generated during the development process.\n\n### DESCRIPTION\n\nThe `DESCRIPTION` file plays an important role in R packages.[^desc-importance]\n\n[^desc-importance]: Creating the `DESCRIPTION` file is the first step when [converting an existing app](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) (and when creating a [new `golem` apps](https://thinkr-open.github.io/golem/articles/a_start.html#fill-the-description)).\n\n```{r}\n#| label: co_box_desc\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(\n  color = \"b\", \n  header = \"`DESCRIPTION` files\", \n  contents = \"\nThe `DESCRIPTION` file needs to have the following fields for our package to load: \n  \n`Package`, `Version`, `License`, `Description`, `Title`, `Author`, and `Maintainer`\n  \n*RStudio and `devtools` consider any directory containing `DESCRIPTION` to be a package* - [R Packages](https://r-pkgs.org/description.html#the-description-file)\")\n```\n\nThe initial `DESCRIPTION` file in `duap` is below:\n\n```{verbatim}\nPackage: duap\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.1\n```\n\nThe package name is automatically added, but the remaining fields need to be completed (consult [R packages](https://r-pkgs.org/description.html#the-description-file) for more information on filling out the `DESCRIPTION` file).\n\nThe `DESCRIPTION` file in the `duap` prompts the RStudio IDE to activate the **Build** tools pane (see below):\n\n::: {#fig-rpkg-ide}\n![](img/rpkg-ide.png){width=\"100%\" fig-align=\"center\"}\n\nPackage **Build** tools\n:::\n\nThe **Build** pane is controlled by the Package Build options in the `.Rproj` file. We can change these settings with **Tools** \\> **Project Options…** \\> **Build Tools**, the select **Package** from the dropdown:\n\n::: {#fig-pkgs_build_options}\n\n![](img/pkgs_build_options.png){#fig-pkgs_build_options width=\"100%\" fig-align=\"center\"}\n\n`.Rproj` fields when converting to and R package:\n:::\n\n\n### roxygen2\n\nWhen we're confident the app code works (and the app renders), we will make sure the functions are properly documented by describing each function with [`roxygen2`](https://roxygen2.r-lib.org/) tags. `roxygen` creates a `NAMESPACE` file, generates `.Rd` files, and can be configured to automatically build vignettes.\n\n```{r}\n#| label: co_box_roxygen2_skeleton\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  header = \"Tip: `roxygen2` skeleton\", \n  hsize = '1.25',\n  contents = \"*To quickly insert a `roxygen2` skeleton, use the RStudio IDE (or the keyboard shortcut: `Option` + `Shift` + `Command` + `R`)*\n  \n![Standard `roxygen2` skeleton](ide-roxygen-skeleton.png){width='100%' fig-align=center}\n\n\")\n```\n\nThe standard `roxygen2` skeleton tags include `@param`, `@return`, `@export`, and `@examples`\n\n-   `@param` lists the existing arguments (or variables) for the function\n\n-   `@return` should be a description of the object/side-effect/thing the function produces (and any warnings or errors if used incorrectly)\n\n#### Exports\n\nThe following [`roxygen2`](https://roxygen2.r-lib.org/) tags can be used to update the `NAMESPACE` file (which you should never edit manually!). \n\n-   `@export` will make the function available to other people when they use your package\n\n#### Imports\n\nImporting functions and objects from add-on packages is best summarized in the [`roxygen2` documentation](https://roxygen2.r-lib.org/articles/namespace.html#functions-1): \n\n> \"*If you are using just a few functions from another package, we recommending adding the package to the `Imports:` field of the `DESCRIPTION` file and calling the functions explicitly using `::`, e.g., `pkg::fun()`.*\"\n\nFollowing this advice, we should add `ggplot2`, `stringr`, rlang, and the other packages we used above to the `Imports:` field with `usethis::use_package()`.\n\n**`import` vs. `@importFrom`:**\n\n  -   If an item you're importing can't be accessed with the `pkg::fun()` syntax, you should use `@importFrom`. There's even a handy helper from `usethis` (`use_import_from(\"package\", \"function\")`.\n\n  -   `@import` should only be used when [\"*you make such heavy use of so many functions from another package that you want to import its entire namespace. This should be relatively rare.*\"](https://r-pkgs.org/dependencies-in-practice.html#in-code-below-r)\n\n`roxygen2` imports and exports are covered in more depth [in R packages.](https://r-pkgs.org/dependencies-in-practice.html#sec-dependencies-in-imports).\n\nThe `roxygen2` for `point_plot()` and `moviesApp()` is below:\n\n```{r}\n#| code-summary: 'roxygen2 for point_plot()'\n#| code-fold: true\n#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return `ggplot2` plot object\n#' \n#' @export\n#'\n#' @importFrom rlang .data\n#'\n#' @examples\n#' require(duap)\n#' movies <- duap::movies\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n```\n\n\n```{r}\n#| code-summary: 'roxygen2 for moviesApp()'\n#| code-fold: true\n#' moviesApp \n#' \n#' Standalone app function\n#'\n#' @return A shiny app object\n#' \n#' @import shiny\n#' \n#' @export \n#'\n```\n\nI've included these examples because they both use `@importFrom` and `@import` appropriately.\n\nFunction documentation is handled with the `R/` folder and `roxygen2` comments/tags, but `duap` needs a `README` file, and a place for long-form documentation. Fortunately, [RMarkdown](https://rmarkdown.rstudio.com/) handles each of these well:\n\n#### README files\n\nI can create a `README` file using [`usethis::use_readme_md()`](https://usethis.r-lib.org/reference/use_readme_rmd.html) or [`usethis::use_readme_rmd()`](https://usethis.r-lib.org/reference/use_readme_rmd.html)\n\n-   I prefer the `.Rmd` file because it comes with executable code chunks.\n\n    ```{r}\n    #| label: use_readme_rmd\n    #| code-fold: false \n    usethis::use_readme_rmd()\n    ```\n\n    ```{verbatim}\n    ✔ Setting active project to /Users/mjfrigaard/projects/duap\n    ✔ Writing README.Rmd\n    ✔ Adding ^README\\\\.Rmd$ to .Rbuildignore\n    • Modify README.Rmd\n    • Update README.Rmd to include installation instructions.\n    ✔ Writing .git/hooks/pre-commit\n    ```\n\n    -   When I knit `README.Rmd`, it automatically generates the `README.md` for the package.\n\n#### Vignettes\n\nFor long-form documentation I can use [vignettes.](https://r-pkgs.org/vignettes.html#introduction)\n\n-   Vignettes can be created with [`usethis::use_vignette()`](https://usethis.r-lib.org/reference/use_vignette.html)\n\n    ```{r}\n    #| label: use_vignette\n    #| code-fold: false \n    usethis::use_vignette(\"duap\")\n    ```\n\n    ```{verbatim}\n    ✔ Adding knitr to Suggests field in DESCRIPTION\n    ✔ Setting VignetteBuilder field in DESCRIPTION to knitr\n    ✔ Adding inst/doc to .gitignore\n    ✔ Creating vignettes/\n    ✔ Adding *.html, *.R to vignettes/.gitignore\n    ✔ Adding rmarkdown to Suggests field in DESCRIPTION\n    ✔ Writing vignettes/duap.Rmd\n    • Modify vignettes/duap.Rmd\n    ```\n\nVignettes are also written in RMarkdown and rendered whenever the package is built/installed.\n\n```{verbatim}\n#| label: use_vignette-tree\n#| code-fold: false \nduap/\n    └── vignettes/\n            └── duap.Rmd\n\n1 directory, 1 file\n```\n\nBy combining `rmarkdown` and `knitr`, R packages have a documentation framework that has the added benefit of being somewhat fool-proof: vignettes have to successfully render for the package to be installed.\n\n```{r}\n#| label: co_box_vignettes_images\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\",\n  header = \"Vignette figures\", \n  hsize = '1.25',\n  contents = \"Images in vignettes are kept in `man/figures/`\n\n\\`\\`\\`bash\nduap/\n  ├── vignettes/\n  │       └── duap.Rmd\n  └── man/\n      └── figures/\n          └── duap-img-1.png\n\\`\\`\\`\n  \")\n```\n\nThe vignettes folder will long-form documentation about how the application works, use cases, and features (and `roxygen2` will document each function).\n\n## Load, document, install\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n> \"The `load_all()` function is arguably the most important part of the devtools workflow.\" - [R Packages, 2ed](https://r-pkgs.org/workflow101.html#sec-workflow101-load-all)\n\n:::\n\nYou'll use the `devtools::load_all()` function frequently while youre developing your app-package. `load_all()` simulates how your functions will work when someone else uses your package. This removes the need to define them in the global workspace. It also gives you access to the functions from any add-on packages youve imported into your `NAMESPACE` (i.e., you wont need to run `library()`).\n\n```{r}\n#| label: co_box_load_all\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"`devtools::load_all()` keyboard shortcuts\", \n  contents = \"\nI highly recommend using the keyboard shortcuts:\n\n-   macOS: <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>\n\n-   Windows/Linux: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>\n  \n\")\n```\n\n\nThe full benefits of using `load_all()` are covered in [R packages.](https://r-pkgs.org/workflow101.html#benefits-of-load_all)\n\n### `load_all()`\n\nAfter documenting everything with `roxygen2`, I want to make sure none of the functions are in my **Environment** (remove with `rm()` if necessary) and load the functions with [`devtools::load_all()`](https://r-pkgs.org/whole-game.html#sec-whole-game-load-all).\n\n```{r}\n#| label: duap-load_all\n#| code-fold: false\ndevtools::load_all()\n```\n\n```{verbatim}\nℹ Loading duap\n```\n\n### `document()`\n\n`devtools::document()` processes the `roxygen2` tags to generate the `NAMESPACE` and the `.Rd` files in the `man/` folder. The `.Rd` files are used to access the help files (i.e., `package::function()` can be accessed with `??function`).\n\nManaging your package [NAMESPACE file](https://r-pkgs.org/dependencies-in-practice.html#sec-dependencies-NAMESPACE-workflow) is not something you do directly: its handled with the `roxygen2` tags we covered above.\n\n```{r}\n#| label: co_box_document\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"`devtools::document()` keyboard shortcuts\", \n  contents = \"\n\nThe keyboard shortcuts for `devtools::document()` are below:\n  \n-   macOS: <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>\n\n-   Windows/Linux: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>\n  \")\n```\n\nRun `devtools::document()` when youve written a new function with `roxygen2` tags or included a package in the `DESCRIPTION` file under `Imports:`\n\n```{r}\n#| label: duap-document\n#| code-fold: false\ndevtools::document()\n```\n\n```{verbatim}\nℹ Updating duap documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\nℹ Loading duap\nWriting NAMESPACE\nWriting mod_plot_ui.Rd\nWriting mod_plot_server.Rd\nWriting point_plot.Rd\nWriting mod_var_input_ui.Rd\nWriting mod_var_input_server.Rd\nWriting moviesApp.Rd\n```\n\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n`NAMESPACE` != `DESCRIPTION`\n\n:::\n\nIts important to understand that `devtools::document()` will use the `roxygen2` tags to create the `man/*.Rd` files and update the `NAMESPACE`, but **`devtools::document()` does not update the `Imports:` section in the `DESCRIPTION`.**\n\nTo add packages dependencies to the `DESCRIPTION`, we need to use the [`usethis::use_package()` function](https://usethis.r-lib.org/reference/use_package.html).[^confusion-imports] \n\n[^confusion-imports]: Read more on this topic in [Confusion about `Imports`](https://r-pkgs.org/dependencies-in-practice.html#confusion-about-imports).\n\nThe table below shows the connection between `roxygen2` tags, the resulting `NAMESPACE` entry, and what should be listed in the `DESCRIPTION`.\n\n::: {style=\"font-size: 0.80em;\"}\n```{r}\n#| label: co_box_namespace\n#| eval: true\n#| echo: false \n#| results: asis\n# roxy_ns_df -----\nroxy_ns_df <- data.frame(\n  check.names = FALSE,\n  `R/ code files` = c(\"pkg::fun()\", \"@importFrom\", \"@import\", \"@export\"),\n  NAMESPACE = c(\n    \"Nothing\",\n    \"importFrom() : import selected object from another NAMESPACE.\",\n    \"import(): import all objects from another packages NAMESPACE.\",\n    \"export() : export the function, method, generic, or class so its available to users.\"\n  ),\n  DESCRIPTION = c(\"Imports\", \"Imports\", \"Imports\", \"Nothing\")\n)\n\nco_box(\n  color = \"b\",\n  header = \"`roxygen2`, `NAMESPACE` & `DESCRPTION`\",\n  hsize = '1.25',\n  contents = kable_styling(\n    kable_input = knitr::kable(roxy_ns_df,\n      align = c(\"l\", \"l\", \"r\"),\n      bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\")\n    )\n  )\n)\n```\n:::\n\n### `install()`\n\nAfter loading and documenting the `duap` package, I want to make sure I can install the package into my library with [`devtools::install()`](https://r-pkgs.org/whole-game.html#install). \n\n```{r}\n#| label: co_box_install\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"`devtools::install()` keyboard shortcuts\", \n  contents = \"\n\nThe keyboard shortcut for `devtools::install()` is below:\n-   macOS: <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd>\n\n-   Windows/Linux: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>B</kbd>\n  \n\")\n```\n\n\n```{r}\n#| label: duap-install\n#| code-fold: false\ndevtools::install()\n```\n\n```{verbatim}\n── R CMD build ────────────────────────────────────────────────────────────────\n✔  checking for file /Users/mjfrigaard/projects/duap/DESCRIPTION ...\n─  preparing duap: (1.8s)\n✔  checking DESCRIPTION meta-information\n─  checking for LF line-endings in source and make files and shell scripts (520ms)\n─  checking for empty or unneeded directories\n   Omitted LazyData from DESCRIPTION\n─  building duap_0.1.0.tar.gz\n   \nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD INSTALL \n  --install-tests \n* installing to library ...\n* installing *source* package duap ...\n** using staged installation ...\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (duap)\n```\n\nRestart your R session and ensure you have a clean workspace:\n\n```{verbatim}\n   Restarting R session...\n```\n\nThen load your package with `library()`:\n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: false\nlibrary(duap)\n```\n\nYou can also use **Install** icon in the **Build** pane, which installs the package, restarts the R session, and loads the package all with one click!\n\n::: {#fig-build-install}\n\n![](img/build-install.png){width=\"100%\" fig-align=\"center\"}\n\n**Build** install package\n:::\n\nThe sequence I've demonstrated above (create `.R` file, write function, document with `roxygen2`, load, document, install) is the minimal version of the [full development workflow](https://r-pkgs.org/whole-game.html).\n\nStoring the applications code in the `R/` folder and (using RStudio's build tools) keeps files organized, well documented, and self-contained:\n\n-   All the code is stored in the `R/` folder\n\n-   We've separated the code into smaller pieces (modules) that can be tested independently (more on this later)\n\n-   Dependencies are being managed by `roxygen2` and `devtools::document()`, which will update the `NAMESPACE` with any functions tagged with `@importFrom` (or `@import`)\n\n\nNow that I have the function documentation in the `.Rd` files, the `DESCRIPTION` and `NAMESPACE`, I can move onto adding and using **data**.\n\n## Data\n\nMost app-packages will require files beyond the `.R` files in the `R/` folder. Apps will often use data files when they're deployed, which well cover next. R Packages have a consistent and standardized way of storing data, and have designated locations for internal and external data. \n\n### `data/`\n\n[`usethis::use_data()` or `usethis::use_data_raw()`](https://usethis.r-lib.org/reference/use_data.html) make it simple to add data to the application package.\n\nIn R packages, data is stored in either [`data/` or `data-raw/`](https://r-pkgs.org/data.html). To access a copy of the `movies` dataset in `duap` (i.e., with `duap::movies`), I can load `movies.RData` into the environment and run `usethis::use_data(movies)`. This will create a `data/` folder and save `movies` as `movies.rda`:\n\n```{verbatim}\n✔ Adding R to Depends field in DESCRIPTION\n✔ Creating data/\n✔ Saving movies to data/movies.rda\n• Document your data (see https://r-pkgs.org/data.html)\n```\n\n### `data-raw/`\n\nI can also import `movies.RData` by adding the following to `data-raw/movies.R`:\n\n```{r}\n#| label: use_data_raw\n#| code-fold: false \nusethis::use_data_raw(\"movies\")\n```\n\n```{verbatim}\n✔ Creating data-raw/\n✔ Writing data-raw/movies.R\n• Modify data-raw/movies.R\n• Finish the data preparation script in data-raw/movies.R\n• Use `usethis::use_data()` to add prepared data to package\n```\n\nIn the `data-raw/movies.R` script, I want to import the `movies.RData` file, but where should I import it from? \n\n### `inst/extdata`\n\nThe `inst/` folder plays a special role when developing R packages:\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n> \"*When a package is installed, everything in `inst/` is copied into the top-level directory of the installed package*\" - [R Packages, 2ed](https://r-pkgs.org/misc.html#sec-misc-inst)\n\n:::\n\nConsider the example folder and files below: `file.txt`, `CITATION`, and `extdata/my_data.csv`:\n\n::: {layout-ncol=\"2\"}\n##### Source (development) form\n\n```{verbatim}\n#| code-fold: false\ninst/\n  ├── file.txt\n  ├── CITATION\n  └── extdata/\n        └── my_data.csv\n```\n\n##### Binary (installed) form\n\n```{verbatim}\n#| code-fold: false\nfile.txt\nCITATION\nextdata/\n  └── my_data.csv\n```\n:::\n\nThe neat thing about the `inst/` folder is that after we've loaded and installed our package, we can access the files in `inst/extdata/` with the [`system.file()` function](https://pkgload.r-lib.org/reference/system.file.html):\n\nIf I want to test functions in `duap` using `movies.RData` (or another dataset), those should be placed in `inst/extdata/`\n\n### `system.file()`\n\nA great way to understand what files are available in `inst/` when your package is to pass `system.file()` to `fs::dir_tree()`:\n\n```{r}\n#| label: tree-extdata-movies\n#| code-fold: false \nfs::dir_tree( # wrap this in a folder tree\n  system.file(package = \"duap\"))\n```\n\n```{bash}\n#| eval: false\n#| code-fold: true \n#| collapse: true \n#| code-summary: expand to see inst/ folder contents\n/path/to/installed/package/duap\n├── DESCRIPTION\n├── INDEX\n├── LICENSE\n├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R\n│   ├── duap\n│   ├── duap.rdb\n│   └── duap.rdx\n├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata\n│   └── movies.RData\n├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── duap.rdb\n│   ├── duap.rdx\n│   ├── figures\n│   └── paths.rds\n└── html\n    ├── 00Index.html\n    └── R.css\n```\n\nThe `system.file()` function will show me the path to the locally installed version of the package (hence the `/path/to/installed/package/` at the beginning of the path).\n\nThe `inst/exdata/` folder comes in handy for adding example data, but its also useful for application development (more on that later).\n\n```{r}\n#| label: co_box_ins\n#| eval: true \n#| results: asis\n#| echo: false\nco_box(color = \"g\", \n  hsize = '1.25',\n  header = \"The `inst/extdata/` folder\", \n  contents = \"\n\nTake a look at the `inst/extdata/` folder [`readr::readr_example()`](https://github.com/tidyverse/readr/blob/5ac729aa9a70fef297a634d2332ff8ff1af874fb/R/example.R) function to understand more about how this works.\n  \n  \")\n```\n\n## Tests\n\nTesting is an important part of any package, and apps tend to require additional tests (especially when they're moving from development into production environments).\n\n### `use_testthat()`\n\nTo apply the testing framework provided by the [`testthat` package.](https://testthat.r-lib.org/) package, we'll use `usethis::use_testthat()`:\n\n```{r}\n#| label: use_testthat\n#| code-fold: false \nusethis::use_testthat()\n```\n\n```{verbatim}\n✔ Adding testthat to Suggests field in DESCRIPTION\n✔ Setting Config/testthat/edition field in DESCRIPTION to 3\n✔ Creating tests/testthat/\n✔ Writing tests/testthat.R\n• Call `use_test()` to initialize a basic test file and open it for editing.\n```\n\nThis creates a new `tests/` folder, with a `testthat/` sub-folder and script.\n\n```{verbatim}\n#| label: use_testthat-tree\n#| code-fold: false \nduap/\n    └── tests/\n          ├── testthat/\n          └── testthat.R\n        \n2 directories, 1 file\n```\n\n#### Writing tests\n\n[`testthat`](https://testthat.r-lib.org/) is designed for unit tests (i.e., testing each functional unit in the code), but for Shiny apps, we need to think beyond standard unit testing.\n\nWe need to confirm the functions work and return predictable results, but we also need to make sure they play well with each other (integration tests), and that the application can be deployed (system tests).\n\nTesting is well described in the [Shiny documentation](https://shiny.rstudio.com/articles/testing-overview.html) and in [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html). Generally speaking, unit tests are performed with [`testthat`](https://testthat.r-lib.org/), and module testing can be done with [Shiny's `testServer()` function](https://shiny.rstudio.com/reference/shiny/1.7.0/testserver). To test the full application (or a specific behavior) use the [`shinytest2`](https://rstudio.github.io/shinytest2/) package.\n\n# Use\n\nUsing an app built as a package is similar to using any R function we've loaded from a package. After successfully loading, documenting, and installing the package, we can run the app by loading the `duap` (with `library(duap)`) and `moviesApp()`:\n\n::: {#fig-duap-inst-app}\n\n![](img/duap-app.png){#fig-duap-inst width=\"100%\" fig-align=\"center\"}\n\n`duap::moviesApp()`\n:::\n\n## Recap\n\nWe've skipped over some important development steps covered in [R packages](https://r-pkgs.org/) (license, using Git/GitHub, code coverage, NEWS, etc.), and you should bookmark this text as you start developing Shiny app-packages. Hopefully this post has demonstrated that by building Shiny apps as R packages, a suite of developer tools are available in the IDE (and the application files and folders have a uniform structure).\n\n`duap` is a substantial improvement over a single file Shiny application--the app-package holds the code, data, documentation, *and* includes explicit information on the dependencies and requirements (in the `DESCRIPTION` and `NAMESPACE`).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"fig-asp":0.618,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr","message":false},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","dpi":320,"toc":true,"toc-depth":5,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.37","knitr":{"opts_chunk":{"collapse":true,"comment":"#"}},"editor":{"mode":"source","render-on-save":true},"theme":{"light":["cosmo","../../custom.scss"]},"lightbox":true,"fontsize":"1.035em","linestretch":1.15,"code-annotations":"hover","title-block-banner":true,"title":"Creating Shiny app-packages","subtitle":"Building a Shiny app within an R package: whole-game","author":"Martin Frigaard","date":"2023-04-10","categories":["shiny","usethis","devtools","packages"],"draft":true,"image":"img/image.png","toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-summary":"show/hide","callout-icon":false},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}