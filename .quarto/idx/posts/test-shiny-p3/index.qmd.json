{"title":"How do I test shiny modules?","markdown":{"yaml":{"title":"How do I test shiny modules?","subtitle":"Part 3: Using testthat and testServer()","author":"Martin Frigaard","date":"2023-06-20","categories":["shiny","testing"],"image":"image.png","callout-icon":false,"freeze":true,"execute":{"echo":true,"message":false,"warning":false,"eval":false}},"headingText":"Testing shiny modules","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| eval: true \n#| echo: false \n#| include: false\nsource(\"https://raw.githubusercontent.com/mjfrigaard/mstsap/main/tests/testthat/helper.R\")\nco_box <- function(color, header, contents = \"Your text\") {\n  class <- switch(color,\n    b = \"note\",\n    g = \"tip\",\n    r = \"important\",\n    o = \"caution\",\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n  switch(color,\n  b = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  g = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  o = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  r = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  stop(\"Invalid `type`\", call. = FALSE)\n  )\n}\noptions(scipen = 999)\nlibrary(shiny)\nlibrary(lobstr)\nlibrary(crayon)\nlibrary(stringr)\ninstall.packages(c(\"NHANES\", \"palmerpenguins\"))\nlibrary(NHANES)\nlibrary(palmerpenguins)\n```\n\n\n```{r}\n#| label: co_box_test\n#| eval: false \n#| results: asis\n#| include: false\nco_box(color = \"r\", \"RED\", \"**This is red**\n  \n  **This is a new line**\n  \n  **this a another line**\")\n```\n\nThis is the third post in a [series on testing](https://mjfrigaard.github.io/series.html) shiny applications. I'll cover testing shiny module server functions using the [`testhat` package](https://testthat.r-lib.org/) and shiny's [`testServer()` function](https://shiny.rstudio.com/reference/shiny/1.7.0/testserver).\n\n```{r}\n#| label: co_box_dev\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(color = \"r\", \n  header = \"STATUS: Under Development\", \n  contents = \"This post is currently under development. Thank you for your patience!\")\n```\n\n\n::: {.column-margin}\n![](shiny.png){width=40%}\n:::\n\nShiny functions pose a couple of unique challenges for testing. First, we can't execute shiny `server` functions in the console. Second, as shiny apps become more complex, it's [highly](https://engineering-shiny.org/structuring-project.html#using-shiny-modules) [recommended](https://mastering-shiny.org/scaling-modules.html#module-motivation) to break up the code base into [modules](https://shiny.posit.co/r/articles/improve/modules/index.html). Modules have additional challenges due to their reactivity being split between interconnected UI and server functions.\n\n`shiny` doesn't provide a direct, built-in way to test modules, but the [`testServer()`](https://shiny.posit.co/r/articles/improve/server-function-testing/) function addresses these challenges by testing \"*reactive interactions*\" in module server functions. `testServer()` also works with [`testthat`](https://testthat.r-lib.org/), which means we can structure these 'reactive interaction' tests just like other unit tests (for non-application functions).\n\n\n## Shiny app-package\n\n`testthat` is designed to work within an R package, so I've put together the [`mstsap`](https://github.com/mjfrigaard/mstsap), (i.e., a **M**astering **S**hiny **t**est**S**erver **a**pp-**p**ackage) to demonstrate writing tests with `testServer()`. The functions, modules, and applications in `mstsap` come from the [Shiny Modules chapter](https://mastering-shiny.org/scaling-modules.html) of Mastering Shiny. Specifically, sections [19.3](https://mastering-shiny.org/scaling-modules.html#inputs-and-outputs) through [19.3.4](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules). If you haven't read this chapter--start there. \n\n```{r}\n#| eval: true \n#| echo: true \n#| message: false \n#| warning: false \n#| results: hide\n#| code-fold: false\n# to get the mstsap package used in this post:\nrenv::install(\"mjfrigaard/mstsap\", prompt = FALSE)\nlibrary(mstsap)\n```\n\n\n{{< include _co_ap.qmd >}}\n\n## Modules \n\nShiny modules are ['*a pair of UI and server functions*'](https://mastering-shiny.org/scaling-modules.html) designed to compartmentalize input and output IDs into distinct namespaces (\"*a namespace is to an ID as a directory is to a file*\"). \n\n```{r}\n#| echo: false \n#| eval: true \n#| code-fold: false\n#| comment: \"\"\nlobstr::ast(\n  shinyApp(\n    ui = `fluidPage`(\n         mod_ui(id = \"X\")),\n    server = `function(input, output, session)`,\n        mod_server(id = \"X\")\n    )\n)\n```\n\nIn [a previous post](https://mjfrigaard.github.io/posts/test-shiny-p1/#unit-tests), I used the following definition for unit tests,\n\n> \"*A unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work.*\" - [The Art of Unit Testing, 2nd edition](https://www.manning.com/books/the-art-of-unit-testing-second-edition)\n\nModules can also be broken into discrete 'units of work' with expected 'end results.' However, the 'unit of work' for a shiny module is usually accomplished using a combination of three functions: a module UI function, a module server function, and any helper/utility functions.\n\n\n{{< include _co_modules.qmd >}}\n\n### Modules in `mstsap`\n\n`mstsap` contains three modules: `dataset`, `selectVar`, and `selectDataVar`. If you're like more information on a module, click on the links in the numbered list.  \n\n#### Dataset module\n\n1) [`datasetInput`](https://mastering-shiny.org/scaling-modules.html#getting-started-ui-input-server-output)/[`datasetServer`](https://mastering-shiny.org/scaling-modules.html#getting-started-ui-input-server-output): loads and returns data object from the `datasets` package (filtered by data frames or matrices) \n\n::: {#fig-dataset}\n\n![`dataset` module](dataset.png){#fig-dataset fig-align=\"center\" width=80%}\n\n`dataset` module \n:::\n\n-   The objects from `datasets` are filtered in the UI module function with a `filter` argument that can be used to *\"limit the options to built-in datasets that are either data frames (`filter = is.data.frame`) or matrices (`filter = is.matrix`)\"*. The `names` are passed to the `choices` in the `selectInput()`:\n\n    ```{r}\n    #| eval: false \n    #| echo: true \n    #| code-fold: show \n    #| code-summary: 'show/hide choices in datasetInput()'\n    names <- ls(\"package:datasets\")\n      if (!is.null(filter)) {\n        data <- lapply(names, get, \"package:datasets\")\n        names <- names[vapply(data, filter, logical(1))]\n      }\n    ```\n\n-   The `datasets` object is returned with `get()` (wrapped in `reactive()`). See below:\n\n    ```{r}\n    #| eval: false \n    #| echo: true \n    #| code-fold: show \n    #| code-summary: 'show/hide returned data from datasetServer()'\n    shiny::reactive(\n          get(input$dataset, \"package:datasets\")\n        )\n    ```\n\n\n#### selectVar module \n\n2) [`selectVarInput`](https://mastering-shiny.org/scaling-modules.html#case-study-selecting-a-numeric-variable)/[`selectVarServer`](https://mastering-shiny.org/scaling-modules.html#server-inputs): displays a `selectInput()` that \"*allows the user to select variables of specified type from a given reactive dataset.*\"\n\n::: {#fig-selectVar}\n\n![`selectVar` module](selectVar.png){#fig-selectVar fig-align=\"center\" width=80%}\n\n`selectVar` module \n:::\n\nThe `data` argument in `selectVarServer()` is the returned value from `datasetServer()`:\n\n-   `data()` is used with the `filter` argument in the `find_vars()` function:\n\n    ```{r}\n    #| eval: false \n    #| echo: true \n    #| code-fold: true \n    #| code-summary: 'show/hide find_vars()'\n    find_vars <- function(data, filter) {\n     # I've included the updated version with the 'stopifnot()' checks!\n      stopifnot(is.data.frame(data))\n      stopifnot(is.function(filter))\n      names(data)[vapply(data, filter, logical(1))]\n    }\n    ```\n    \n    -   The filter argument can be used to return variables by class/type (using `is.*` functions like `is.numeric()` or `is.character()`)\n\n-   When `data()` changes, the output from `find_vars()` updates the choices in the variable `selectInput()` (i.e., `input$var`) (see below)\n\n::: {#fig-selectVar_find_vars}\n\n![`selectVar` and `find_vars()`](selectVar_find_vars.png){#fig-selectVar_find_vars fig-align=\"center\" width=100%}\n\n`selectVar` module and `find_vars()` function\n:::\n\n-   `selectVarServer()` also returns the selected variable (`input$var`) as a reactive value (`var()`)\n\n#### selectDataVar module \n\n3) [`selectDataVarUI`](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules)/[`selectDataVarServer`](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules): The `selectDataVar` module is from the section titled, \"[*Modules inside of modules*](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules)\", so here we see the `dataset` and `selectVar` modules placed *inside* the `selectDataVar` module (each with a new namespace (`NS()`)).\n\n::: {#fig-selectDataVar}\n\n![`selectDataVar` module](selectDataVar.png){#fig-selectDataVar fig-align=\"center\" width=80%}\n\n`selectDataVar` module \n:::\n\n{{< include _co_naming_modules.qmd >}}\n\n### Standalone app functions\n\n`mstsap` contains three [standalone functions](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) for running each set of module functions. \n\nI've made a small change to each standalone app function--each app has a call to `reactiveValuesToList()` that displays in the UI. \n\n```{r}\n#| echo: true \n#| eval: false \n#| code-fold: show\n#| code-summary: 'print reactive values'\n  shiny::verbatimTextOutput(\"vals\")\n\n  output$vals <- shiny::renderPrint({\n    x <- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n```\n\n\n#### datasetApp\n\n`datasetApp()` contains a call to the `dataset` module, and includes a `tableOutput()` to render the selected data object: \n\n::: {#fig-datasetApp}\n\n![`datasetApp`](datasetApp.png){#fig-datasetApp fig-align=\"center\" width=80%}\n\n`datasetApp` \n:::\n\nWhen `datasetApp()` is run, the app displays the dataset object in the `tableOutput()`, and the `verbatimTextOutput()` renders the reactive values as a text: \n\n::: {#fig-datasetApp_run}\n\n![`datasetApp` with reactive values](datasetApp_run.png){#fig-datasetApp_run fig-align=\"center\" width=100%}\n\n`datasetApp` with `reactiveValuesToList()`\n:::\n\nThe output above shows what `NS()` does in the `dataset` module--it appends the module `id` argument to the `inputId` (which is why we see `dataset-dataset`).\n\n- **`dataset-`:** the module id \n\n- **`dataset-dataset`** the `inputId` from the `selectInput()`\n\n#### selectVarApp\n\n`selectVarApp()` includes both `dataset` and `selectVar` modules, but instead of rendering the output in a table, the UI renders the variable output in a `verbatimTextOutput()`.\n\n::: {#fig-selectVarApp}\n\n![`selectVarApp`](selectVarApp.png){#fig-selectVarApp fig-align=\"center\" width=80%}\n\n`selectVarApp` \n:::\n\nNote that `selectVarApp()` contains namespaces for two modules: \n\n1. **`\"data\"`**: the namespace for the `datasetnput()` and `datasetServer()` modules, inheriting the `filter` argument and creating the data object \n\n2. **`\"var\"`**: the `selectVar` modules are linked with the `\"var\"` id. `selectVarServer()` uses the `data` object created by `datasetServer()` (and also inherits the `filter` argument).\n\nThese namespaced IDs are rendered below with `reactiveValuesToList()`:\n\n::: {#fig-selectVarApp_run}\n\n![`selectVarApp` with reactive values](selectVarApp_run.png){#fig-selectVarApp_run fig-align=\"center\" width=100%}\n\n`selectVarApp` with `reactiveValuesToList()`\n:::\n\nThere's a lot happening in `selectVarApp()`, so I've created the figure below to display the code for the modules with their displayed outputs: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-selectVarApp_schema}\n\n![`selectVarApp` schema](selectVarApp_schema.png){#fig-selectVarApp_schema fig-align=\"center\" width=100%}\n\n`dataset` and `selectVar` modules with rendered outputs\n:::\n\n::::\n\nAs we can see, the `data` output from the `dataset` module is used to generate the `vars()` reactive for the `verbatimTextOutput()` in `selectVarApp()`. Note that both `dataset` and `selectVar` modules don't contain any output functions--these have been provided in the UI for both `datasetApp()` and `selectVarApp()`.\n\n#### selectDataVarApp\n\nThe final app in `mstsap` is `selectDataVarApp()`. Here the inputs from `dataset` and `selectVar` have been moved into the `sidebarPanel()`, and the output is rendered in the `mainPanel()`. \n\n\n::: {#fig-selectDataVarApp}\n\n![`selectDataVarApp`](selectDataVarApp.png){#fig-selectDataVarApp fig-align=\"center\" width=80%}\n\n`selectDataVarApp` \n:::\n\n\nThe reactive values here show how the ['Modules inside of modules'](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules) work--by adding the additional call to `NS()` in the `datasetInput()` and `selectVarInput()` functions *within* `selectDataVarUI()` and `selectDataVarServer()`, an additional namespace is appended to the reactive values (`input$dataset` and `input$var`):\n\n::: {#fig-selectDataVarApp_run}\n\n![`selectDataVarApp` with reactive values](selectDataVarApp_run.png){#fig-selectDataVarApp_run fig-align=\"center\" width=100%}\n\n`selectDataVarApp` with `reactiveValuesToList()`\n:::\n\nBelow is a figure that displays the contents of the `selectDataVar` modules (I've removed the `tagList()` and `moduleServer()` for simplicity), the `selectDataVarApp()`, and the rendered outputs:\n\n:::: {.column-page-right}\n\n::: {#fig-selectDataVarApp_schema}\n\n![`selectDataVarApp` schema](selectDataVarApp_schema.png){#fig-selectDataVarApp_schema fig-align=\"center\" width=100%}\n\n`dataset` and `selectVar` modules inside `selectDataVar` module with rendered outputs\n:::\n\n::::\n\n## testServer() \n\nModule server functions can be tested the same way as a traditional shiny `server` function, as long as you provide the inputs and verify the correct outputs. Below I'll cover some general advice on module server tests (and the arguments in `testServer()`).\n\n### Testing module server functions\n\nBefore writing tests, make sure you can answer the following:\n\n1. ***What is the overall purpose of the application?***\n    -   This information is typically referred to as the 'business logic' of the application, and should be stored in a specifications or requirements document. If I can't answer this question, I'm probably better off not writing test for code that is likely to undergo major changes. \n    \n2. ***How does this module fit within that overall purpose?***\n    -   Specifically, how does this module help the application achieve the specifications or requirements? This could also be considered the 'unit of work' and 'end result' for the module.\n\n3. ***What dependencies (i.e., utility functions, data, add-on packages) are required for the module to execute?***\n    -   If the module depends on other functions, data, or packages to perform it's expected behavior, those functions should either be included in the `testServer()` test, or have their own tests (or both).\n    \n#### What should I test?\n\nThe items below have been compiled from [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html#basic-workflow), [R Packages](https://r-pkgs.org/testing-design.html#what-to-test), and [Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/build-yourself-safety-net.html#testing-your-app): \n\n1. ***Do the inputs/outputs behave as expected?***\n    -   These tests verify the module server function `inputId`s and `outputId`s are properly namespaced and accessible \n    \n2. ***Does the module contain the expected reactive values/objects?***\n    -   Tests should verify it's reactivity--module server functions will automatically recompute the outputs when it's inputs change, so tests should verify changes to inputs produce the expected behaviors and outputs. This includes any returned values from the module (and any additional function arguments).\n    \n3. ***Are the calculations correct?***\n    -   If the module server function performs calculations or data manipulations, the tests should verify the module produces the correct result (ideally for a variety of inputs and edge cases).\n    \n4. ***How are errors handled in the module?***\n    -   What errors are displayed from the module? Tests should simulate scenarios that can test if the module: 1) returns errors that are informative, 2) fails silently (when appropriate), or 3) falls back to the correct default behavior.\n    \nThe last piece of advice I've found helpful when writing tests comes from [R Packages](https://r-pkgs.org/testing-design.html#what-to-test), \n\n> *\"focus your time on code that you’re not sure about, is fragile, or has complicated interdependencies\"*\n\n\nThe quote isn't in reference to testing modules or shiny application functions, but I've found it's easy to fall into the trap of trying to test *everything* when a targeted approach is more efficient (and equally valid).\n\nThe first test I'll perform is for `datasetServer()`, the module used to return a data object from the `datasets` package.\n\n### `testServer()` arguments \n\n-   `app` can be a module server function (i.e., `datasetServer`), or any [`shiny.appobj`](https://shiny.posit.co/r/reference/shiny/1.7.0/shiny.appobj.html) \n\n-   `expr` is where I'll add the `testthat` expectations and other test code \n\n-   `args` is a `list()` I can use to include any module server function arguments\n\n### Inputs\n\nI created the test file with `usethis::use_test(\"datasetServer\")` and the module server function is the first argument in `testServer()`.\n\nI'll start by testing if the initial input value (`input$dataset`) in `datasetServer()` is set to `NULL`:\n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(app = datasetServer, expr = {\n  testthat::expect_equal(input$dataset, NULL)\n  cat(\"\\ndatasetServer: dataset$input is NULL\", \"\\n\")\n})\n```\n\n-   I'll add a custom message with `cat()` and the `inputId` I'm testing, load, document, and install the package, then run the test with `testthat::test_file()`:\n\n    ```{verbatim}\n    #| eval: false\n    #| code-fold: false\n    devtools::load_all()\n    ℹ Loading mstsap\n    devtools::document()\n    ℹ Updating mstsap documentation\n    ℹ Loading mstsap\n    \n    Restarting R session...\n    \n    library(mstsap)\n    ```\n    \n    -   And run the test with `testthat::test_file()`:\n    \n    ```{r}\n    #| eval: false\n    #| code-fold: false\n    test_file(\"tests/testthat/test-datasetServer.R\")\n    ```\n    \n    ```{verbatim}\n    #| eval: false\n    #| code-fold: false\n    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n    datasetServer: dataset$input is NULL \n    ```\n\n\n{{< include _co_test_cmt.qmd >}}\n\n#### Setting test inputs \n\n`testServer()` allows us to mimic changing application (or module) `inputId`s with `session$setInputs()` like so: \n\n```{r}\n#| eval: false\n#| code-fold: false\nsession$setInputs(inputId = \"value\")\n```\n\nI'll demonstrate with a test for `input$dataset` in `datasetServer()`:\n\n```{r}\n#| eval: false\n#| code-fold: false\n  session$setInputs(dataset = \"faithful\")\n  testthat::expect_equal(\n    object = input$dataset,\n    expected = \"faithful\")\n  test_cmt(\"datasetServer\", \"dataset$input\")\n```\n\nThe results from `test_file()` are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false \n#| echo: true\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   datasetServer: dataset$input\n```\n\n### Returned values\n\nAny returned values from module server functions can be accessed in `testServer()` with [`session$returned()`](https://shiny.posit.co/r/articles/improve/server-function-testing/#modules-with-return-values). I'll verify `input$dataset` returns an object from `datasetServer()` by testing the class of `session$returned()`:\n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: show\n#| code-summary: 'show/hide test with session$returned()' \n  session$setInputs(dataset = \"airquality\")\n  testthat::expect_equal(\n    object = class(session$returned()),\n    expected = \"data.frame\")\n  test_cmt(\"datasetServer\", \"class(session$returned())\")\n\n  session$setInputs(dataset = \"WorldPhones\")\n  testthat::expect_true(\n    object = is.matrix(session$returned()))\n  test_cmt(\"datasetServer\", \"is.matrix(session$returned())\")\n```\n\nNote that both methods above can be used to check the class of the returned object. \n\nThe updated results from `test_file()` are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false \n#| echo: true\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   datasetServer: class(session$returned()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n\t   datasetServer: is.matrix(session$returned()) \n```\n\n-   I can also use the `typeof(datasets::mtcars)` for a direct comparison: \n\n    ```{r}\n    #| eval: false\n    #| echo: true\n    #| code-fold: show\n    #| code-summary: 'show/hide test with session$returned()'\n      session$setInputs(dataset = \"mtcars\")\n      expect_equal(\n        # app value...\n        object = typeof(session$returned()), \n        # ...compared to actual output\n        expected = typeof(datasets::mtcars)) \n      test_cmt(\"datasetServer\", \"typeof(session$returned())\")\n    ```\n\n\n### Module server arguments\n\nIf the module server function has additional arguments beyond `id`, then it has additional functionality to verify with unit tests. To test additional module server arguments, pass these to [`testServer(args = list())`.](https://shiny.posit.co/r/articles/improve/server-function-testing/#modules-with-additional-parameters) The `args` list should include named arguments from the module server function, i.e., `list(arg1 = \"param1\", arg2 = \"param2\")`. \n\nFor example, `selectVarServer()` has `data` and `filter` arguments: \n\n-   `data` is the returned reactive object from `datasetServer()` \n\n-   `filter` is the function passed to the `find_vars()` utility function\n\n\n::::{.column-body-outset-right}\n\n:::{#fig-dataset_selectVar}\n\n![`dataset()` -> `selectVar()`](dataset_selectVar.png){#fig-dataset_selectVar fig-align=\"center\" width=100%}\n\nObject returned from `datasetServer()` and passed to `selectVarServer()`\n:::\n\n::::\n\nBelow is a test for `selectVarServer()` using `args` to verify the reactive `data()` is `datasets::mtcars`:\n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = datasets::mtcars,\n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n```\n\n::: {style='font-size: 1.05em; color: #A20025;'}\n\n***But this fails with the following error:***\n\n:::\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n── Error (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ───\nError in `(function (id, data, filter = is.numeric) \n{\n    stopifnot(shiny::is.reactive(data))\n    stopifnot(!shiny::is.reactive(filter))\n```\n\n::: {style='font-size: 1.05em; color: #006CD9;'}\n\n***What happened?***\n\n:::\n\nI've included this example because it's not in the [`testServer()` documentation](https://shiny.posit.co/r/articles/improve/server-function-testing/#testing-shiny-modules), and it's common to pass values between modules (see [here in Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/structuring-project.html#a.-returning-values-from-the-module) and [here in Mastering Shiny](https://mastering-shiny.org/scaling-modules.html#inputs-and-outputs)) \n\n#### Testing module communication\n\nThe error message above tells me the issue is originating from the `stopifnot()` calls in `selectVarServer()`. \n\n{{< include _co_updates.qmd >}}\n\nI'll stop a moment here to address what's happening in each module:\n\n1. The `datasetServer()` returns the results of `input$dataset` as a reactive (`data()`)\n\n2. `data()` enters `selectVarServer()` in the `data` argument \n\n3. *Inside* `selectVarServer()`, two `stopifnot()` functions evaluate the reactivity of `data` and `filter` with `shiny::is.reactive()`\n\nIn `datasetServer()`, the return object is [wrapped in the `reactive()` function](https://github.com/mjfrigaard/mstsap/blob/f10e497df195cfa188afd031e7d082ed1466989d/R/datasetServer.R#L20), so the items `args = list()` also need to be wrapped in `reactive()`. \n\nI'll re-write the test above to a more basic test using `is.reactive()`: \n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data()))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\t   selectVarServer: is.reactive(data()) \n── Failure (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ───\nis.reactive(data()) is not TRUE\n\n`actual`:   FALSE\n`expected`: TRUE \n```\n\n::: {style='font-size: 1.05em; color: #A20025;'}\n\n***Another failure???***\n\n:::\n\nThe results of this test might seem confusing given my advice to wrap the `args` list in `reactive()`, but some reading of the `x` argument in `is.reactive()` will clear up the error: \n\n> *For `is.reactive()`, an object to test. For `reactive()`, an expression.*\n\nRemoving the parentheses from `data()` will result in the proper test results: \n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\t   selectVarServer: is.reactive(data()) \n```\n\n### Utility functions\n\nNow that I have a reactive `data()` input, I can explore how this value is used inside `selectVarServer()`. To update `input$var`, the `data()` input is passed to `find_vars()` (a function that uses a `filter` argument \"*used to select which variables to list*\"). See the example below:\n\n```{r}\n#| eval: true\n#| code-fold: false\nmstsap::find_vars(\n  data = datasets::chickwts, \n  filter = is.factor)\n```\n\nI'll write an expectation that captures the behavior of `find_vars()` in `selectVarServer()`:\n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::chickwts),\n              filter = is.numeric), expr = {\n  testthat::expect_equal(\n    object = find_vars(data(), is.factor),\n    expected = \"feed\")\n  test_cmt(\"selectVarServer\", \"find_vars()\")\n})\n```\n\nThe results are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   selectVarServer: find_vars()\n```\n\nTo verify that the returned object from `selectVarServer()` is the selected column, I'll need to simulate the application behavior in the tests:\n\n-   Create a reactive `data()` input in `selectVarServer()`:\n\n    ```{r}\n    #| eval: false\n    #| code-fold: show\n    #| code-summary: 'setting args = list()'\n      shiny::testServer(selectVarServer,\n        args = list(data = reactive(datasets::chickwts),\n                    filter = is.numeric), expr = {\n        \n        # include expectations below...\n        \n      })\n    ```\n    \n-   Set the `input$var` and verify the `input$var`:\n\n    ```{r}\n    #| eval: false\n    #| code-fold: show\n    #| code-summary: 'verify input$var'\n      session$setInputs(var = \"weight\")\n      testthat::expect_equal(object = input$var,\n          expected = \"weight\")\n      test_cmt(\"selectVarServer\", \"input$var\")\n    ```\n    \n-   Set the `input$var` and verify the `session$returned()`\n\n    ```{r}\n    #| eval: false\n    #| code-fold: show\n    #| code-summary: 'verify session$returned()'\n      session$setInputs(var = \"feed\")\n      testthat::expect_equal(object = session$returned(),\n        expected = datasets::chickwts[[\"feed\"]])\n      test_cmt(\"selectVarServer\", \"session$returned()\")\n    ```\n\nThe results from these tests are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   selectVarServer: input$var \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n\t   selectVarServer: session$returned() \n```\n\n\n### Module outputs\n\nRendered outputs can be accessed in `testServer()` just like inputs (i.e., with `output$outputId`). But the modules in `mstsap` don't have outputs--these are included in the standalone app functions (`datasetApp()`, `selectVarApp()`, and `selectDaraVarApp()`). \n\nFortunately, app functions can also be passed to the `app` argument of `testServer()`. I'll use `datasetApp()` to demonstrate.\n\n![](datasetApp.png){fig-align=\"center\" width=80%}\n\nTesting a standalone app function is similar to testing a module server function, but with a few minor differences. First, the output from the standalone app function is [assigned to an object](https://shiny.posit.co/r/articles/improve/server-function-testing/#shiny-app-objects) (`ds_app`), then placed in the `app` argument: \n\n```{r}\n#| eval: false\n#| code-fold: false\nds_app <- datasetApp()\n  shiny::testServer(ds_app, expr = {\n\n  })\n```\n\n To use `session$setInputs()`  need to include the namespace for the `inputId`:\n\n![](datasetApp_reactives.png){fig-align=\"center\" width=100%}\n\nThe output from `reactiveValuesToList()` in `datasetApp()` shows me how to access the `inputId` in the `datasetServer()` module (i.e., ``` input$`dataset-dataset` ```):\n\n```{r}\n#| eval: false\n#| code-fold: false\nds_app <- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n\n})\n```\n\n\n#### Output testing strategy\n\nTesting outputs with `testServer()` is different than testing outputs in regular unit tests, because shiny outputs are executed in the server, but then rendered in the UI. The [`testServer()` documentation](https://shiny.posit.co/r/articles/improve/server-function-testing/#complex-outputs-plots-htmlwidgets) outlines a testing strategy for complex outputs:\n\n> *The goal for your tests should be to ask “is the code that I wrote producing the plot I want?” There are two components to that question:\n> \n> 1. *Does the plot generate without producing an error?*\n> 2. *Is the plot visually correct?*\n> \n> *`testServer` is great for assessing the first component here. By merely referencing `output$plot` in your test, you’ll confirm that the plot was generated without an error.*\n\nIf we replace *plot* with *table* in the advice above, the tests for `datasetApp()` should confirm `output$data` is generated without producing an error. \n\nInstead of writing an expectation, I'll use `cat()` to display the contents of `output$data` after setting the ``` `dataset-dataset` ``` input:\n    \n```{r}\n#| eval: false\n#| code-fold: false\nds_app <- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n  cat(\"\\n\\toutput$data:\\n\", output$data, \"\\n\")\n})\n```\n\nThe results from the test is below:\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n\toutput$data:\n```\n\n```{.html}\n <table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'>\n  <thead> \n\t  <tr> \n\t    <th style='text-align: right;'> weight </th> \n\t    <th style='text-align: left;'> feed </th>  \n\t </tr> \n\t</thead> \n\t  <tbody>\n      <tr> <td align=\"right\"> 179.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 160.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 136.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 227.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 217.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 168.00 </td> <td> horsebean </td> </tr>\n   </tbody> \n </table> \n```\n\nThe output is the HTML used to render the table in the UI. This doesn't add a passing test, but it confirms that the table is being generated from the `data()` reactive. \n\nThe tests for `datasetApp()` will confirm the `inputId`, and verify the `class` and `names` of the `data()` reactive (which will be passed to the `renderTable()` function): \n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_equal(\n    object = input$`dataset-dataset`,\n    expected = \"chickwts\")\n  test_cmt(\"datasetApp\", \"input$`dataset-dataset`\")\n\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  test_cmt(\"datasetApp\", \"is.data.frame(data())\")\n\n  testthat::expect_equal(\n    object = names(data()),\n    expected = names(datasets::chickwts))\n  test_cmt(\"datasetApp\", \"names(data())\")\n```\n\nI can include a test for the `class` of `output$data`, but note that this is a character output:\n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_equal(\n    object = class(output$data),\n    expected = \"character\")\n  test_cmt(\"datasetApp\", \"class(output$data)\")\n```\n\nThe results from `test_file()` are below:\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\t   datasetApp: input$`dataset-dataset` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   datasetApp: is.data.frame(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   datasetApp: names(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n\t   datasetApp: class(output$data) \n```\n\nThe same method can be used to test the `selectVarApp()`, but note this app requires passing both `inputId`s to `session$setInputs()`:\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide selectVarApp() tests'\nsv_app <- selectVarApp()\nshiny::testServer(app = sv_app, expr = {\n  session$setInputs(`var-var` = \"Ozone\",\n                    `data-dataset` = \"airquality\")\n  # confirm contents of output$out\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n  \n  # confirm var is reactive \n  testthat::expect_true(object = is.reactive(var))\n  # confirm var input\n  testthat::expect_equal(\n    object = input$`var-var`,\n    expected = \"Ozone\")\n  # confirm data is reactive\n  testthat::expect_true(object = is.reactive(data))\n  # confirm data() is a data.frame\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  # confirm 'data' can be subsetted with 'var'\n  testthat::expect_equal(\n    object = data()[[input$`var-var`]],\n    expected = airquality[[\"Ozone\"]])\n})\n```\n\n\n#### Testing nested modules \n\nI highly recommend viewing the output of `reactiveValuesToList()` if your application has nested modules. It's easy to lose track of ids if they span multiple layers. \n\nWe know `selectDataVarApp()` contains 'modules inside other modules', and these layers are reflected in the namespaces: \n\n![](selectDataVarApp_reactives.png){fig-align=\"center\" width=100%}\n\nTo access the `inputId`s in the nested modules, we need to pass the full 'appended' namespace:\n\n```{r}\n#| eval: false\n#| code-fold: false\ndv_app <- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n})\n```\n\nAfter setting the inputs, I can confirm the contents of `output$out`\n\n```{r}\n#| eval: false\n#| code-fold: false\ndv_app <- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n})\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n\toutput$out:\n   [1]  41  36  12  18  NA  28  23  19   8  NA   7  16  11  14  18\n [16]  14  34   6  30  11   1  11   4  32  NA  NA  NA  23  45 115\n [31]  37  NA  NA  NA  NA  NA  NA  29  NA  71  39  NA  NA  23  NA\n [46]  NA  21  37  20  12  13  NA  NA  NA  NA  NA  NA  NA  NA  NA\n [61]  NA 135  49  32  NA  64  40  77  97  97  85  NA  10  27  NA\n [76]   7  48  35  61  79  63  16  NA  NA  80 108  20  52  82  50\n [91]  64  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28\n[106]  65  NA  22  59  23  31  44  21   9  NA  45 168  73  NA  76\n[121] 118  84  85  96  78  73  91  47  32  20  23  21  24  44  21\n[136]  28   9  13  46  18  13  24  16  13  23  36   7  14  30  NA\n[151]  14  18  20 \n```\n\nAfter confirming `output$out`, I'll test the inputs: \n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_equal(\n    object = input$`var-var-var`,\n    expected = \"Ozone\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-var-var`\")\n\n  testthat::expect_equal(\n    object = input$`var-data-dataset`,\n    expected = \"airquality\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-data-dataset`\")\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\t   selectDataVarApp: input$`var-var-var` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   selectDataVarApp: input$`var-data-dataset`\n```\n\nI can also verify the contents of the reactive `var()` inside the test:\n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_true(object = is.reactive(var))\n  test_cmt(\"selectDataVarApp\", \"is.reactive(var)\")\n  cat(\"\\n\\tvar:\\n\", var(), \"\\n\")\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   selectDataVarApp: is.reactive(var) \n\n\tvar:\n 41 36 12 18 NA 28 23 19 8 NA 7 16 11 14 18 14 34 6 30 11 1 11 4 32 NA NA NA 23 \n\t45 115 37 NA NA NA NA NA NA 29 NA 71 39 NA NA 23 NA NA 21 37 20 12 13 NA NA NA\n\tNA NA NA NA NA NA NA 135 49 32 NA 64 40 77 97 97 85 NA 10 27 NA 7 48 35 61 79 \n\t63 16 NA NA 80 108 20 52 82 50 64 59 39 9 16 78 35 66 122 89 110 NA NA 44 28 \n\t65 NA 22 59 23 31 44 21 9 NA 45 168 73 NA 76 118 84 85 96 78 73 91 47 32 20 23\n\t21 24 44 21 28 9 13 46 18 13 24 16 13 23 36 7 14 30 NA 14 18 20 \n```\n\n \n## Recap \n\nThis post has shown how shiny's `testServer()` function allows you to isolate and test module server functions, which makes it easier to ensure that your `server` function behaves as expected (and locate and fix bugs).\n\nI hope you have a better understanding of how you can use `testServer()` to test a modules inputs/outputs, reactivity, calculations, and errors.\n\nIn the next post I'll cover performing integration tests with `shinytest2`!","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| eval: true \n#| echo: false \n#| include: false\nsource(\"https://raw.githubusercontent.com/mjfrigaard/mstsap/main/tests/testthat/helper.R\")\nco_box <- function(color, header, contents = \"Your text\") {\n  class <- switch(color,\n    b = \"note\",\n    g = \"tip\",\n    r = \"important\",\n    o = \"caution\",\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n  switch(color,\n  b = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  g = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  o = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  r = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  stop(\"Invalid `type`\", call. = FALSE)\n  )\n}\noptions(scipen = 999)\nlibrary(shiny)\nlibrary(lobstr)\nlibrary(crayon)\nlibrary(stringr)\ninstall.packages(c(\"NHANES\", \"palmerpenguins\"))\nlibrary(NHANES)\nlibrary(palmerpenguins)\n```\n\n\n```{r}\n#| label: co_box_test\n#| eval: false \n#| results: asis\n#| include: false\nco_box(color = \"r\", \"RED\", \"**This is red**\n  \n  **This is a new line**\n  \n  **this a another line**\")\n```\n\nThis is the third post in a [series on testing](https://mjfrigaard.github.io/series.html) shiny applications. I'll cover testing shiny module server functions using the [`testhat` package](https://testthat.r-lib.org/) and shiny's [`testServer()` function](https://shiny.rstudio.com/reference/shiny/1.7.0/testserver).\n\n```{r}\n#| label: co_box_dev\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(color = \"r\", \n  header = \"STATUS: Under Development\", \n  contents = \"This post is currently under development. Thank you for your patience!\")\n```\n\n## Testing shiny modules \n\n::: {.column-margin}\n![](shiny.png){width=40%}\n:::\n\nShiny functions pose a couple of unique challenges for testing. First, we can't execute shiny `server` functions in the console. Second, as shiny apps become more complex, it's [highly](https://engineering-shiny.org/structuring-project.html#using-shiny-modules) [recommended](https://mastering-shiny.org/scaling-modules.html#module-motivation) to break up the code base into [modules](https://shiny.posit.co/r/articles/improve/modules/index.html). Modules have additional challenges due to their reactivity being split between interconnected UI and server functions.\n\n`shiny` doesn't provide a direct, built-in way to test modules, but the [`testServer()`](https://shiny.posit.co/r/articles/improve/server-function-testing/) function addresses these challenges by testing \"*reactive interactions*\" in module server functions. `testServer()` also works with [`testthat`](https://testthat.r-lib.org/), which means we can structure these 'reactive interaction' tests just like other unit tests (for non-application functions).\n\n\n## Shiny app-package\n\n`testthat` is designed to work within an R package, so I've put together the [`mstsap`](https://github.com/mjfrigaard/mstsap), (i.e., a **M**astering **S**hiny **t**est**S**erver **a**pp-**p**ackage) to demonstrate writing tests with `testServer()`. The functions, modules, and applications in `mstsap` come from the [Shiny Modules chapter](https://mastering-shiny.org/scaling-modules.html) of Mastering Shiny. Specifically, sections [19.3](https://mastering-shiny.org/scaling-modules.html#inputs-and-outputs) through [19.3.4](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules). If you haven't read this chapter--start there. \n\n```{r}\n#| eval: true \n#| echo: true \n#| message: false \n#| warning: false \n#| results: hide\n#| code-fold: false\n# to get the mstsap package used in this post:\nrenv::install(\"mjfrigaard/mstsap\", prompt = FALSE)\nlibrary(mstsap)\n```\n\n\n{{< include _co_ap.qmd >}}\n\n## Modules \n\nShiny modules are ['*a pair of UI and server functions*'](https://mastering-shiny.org/scaling-modules.html) designed to compartmentalize input and output IDs into distinct namespaces (\"*a namespace is to an ID as a directory is to a file*\"). \n\n```{r}\n#| echo: false \n#| eval: true \n#| code-fold: false\n#| comment: \"\"\nlobstr::ast(\n  shinyApp(\n    ui = `fluidPage`(\n         mod_ui(id = \"X\")),\n    server = `function(input, output, session)`,\n        mod_server(id = \"X\")\n    )\n)\n```\n\nIn [a previous post](https://mjfrigaard.github.io/posts/test-shiny-p1/#unit-tests), I used the following definition for unit tests,\n\n> \"*A unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work.*\" - [The Art of Unit Testing, 2nd edition](https://www.manning.com/books/the-art-of-unit-testing-second-edition)\n\nModules can also be broken into discrete 'units of work' with expected 'end results.' However, the 'unit of work' for a shiny module is usually accomplished using a combination of three functions: a module UI function, a module server function, and any helper/utility functions.\n\n\n{{< include _co_modules.qmd >}}\n\n### Modules in `mstsap`\n\n`mstsap` contains three modules: `dataset`, `selectVar`, and `selectDataVar`. If you're like more information on a module, click on the links in the numbered list.  \n\n#### Dataset module\n\n1) [`datasetInput`](https://mastering-shiny.org/scaling-modules.html#getting-started-ui-input-server-output)/[`datasetServer`](https://mastering-shiny.org/scaling-modules.html#getting-started-ui-input-server-output): loads and returns data object from the `datasets` package (filtered by data frames or matrices) \n\n::: {#fig-dataset}\n\n![`dataset` module](dataset.png){#fig-dataset fig-align=\"center\" width=80%}\n\n`dataset` module \n:::\n\n-   The objects from `datasets` are filtered in the UI module function with a `filter` argument that can be used to *\"limit the options to built-in datasets that are either data frames (`filter = is.data.frame`) or matrices (`filter = is.matrix`)\"*. The `names` are passed to the `choices` in the `selectInput()`:\n\n    ```{r}\n    #| eval: false \n    #| echo: true \n    #| code-fold: show \n    #| code-summary: 'show/hide choices in datasetInput()'\n    names <- ls(\"package:datasets\")\n      if (!is.null(filter)) {\n        data <- lapply(names, get, \"package:datasets\")\n        names <- names[vapply(data, filter, logical(1))]\n      }\n    ```\n\n-   The `datasets` object is returned with `get()` (wrapped in `reactive()`). See below:\n\n    ```{r}\n    #| eval: false \n    #| echo: true \n    #| code-fold: show \n    #| code-summary: 'show/hide returned data from datasetServer()'\n    shiny::reactive(\n          get(input$dataset, \"package:datasets\")\n        )\n    ```\n\n\n#### selectVar module \n\n2) [`selectVarInput`](https://mastering-shiny.org/scaling-modules.html#case-study-selecting-a-numeric-variable)/[`selectVarServer`](https://mastering-shiny.org/scaling-modules.html#server-inputs): displays a `selectInput()` that \"*allows the user to select variables of specified type from a given reactive dataset.*\"\n\n::: {#fig-selectVar}\n\n![`selectVar` module](selectVar.png){#fig-selectVar fig-align=\"center\" width=80%}\n\n`selectVar` module \n:::\n\nThe `data` argument in `selectVarServer()` is the returned value from `datasetServer()`:\n\n-   `data()` is used with the `filter` argument in the `find_vars()` function:\n\n    ```{r}\n    #| eval: false \n    #| echo: true \n    #| code-fold: true \n    #| code-summary: 'show/hide find_vars()'\n    find_vars <- function(data, filter) {\n     # I've included the updated version with the 'stopifnot()' checks!\n      stopifnot(is.data.frame(data))\n      stopifnot(is.function(filter))\n      names(data)[vapply(data, filter, logical(1))]\n    }\n    ```\n    \n    -   The filter argument can be used to return variables by class/type (using `is.*` functions like `is.numeric()` or `is.character()`)\n\n-   When `data()` changes, the output from `find_vars()` updates the choices in the variable `selectInput()` (i.e., `input$var`) (see below)\n\n::: {#fig-selectVar_find_vars}\n\n![`selectVar` and `find_vars()`](selectVar_find_vars.png){#fig-selectVar_find_vars fig-align=\"center\" width=100%}\n\n`selectVar` module and `find_vars()` function\n:::\n\n-   `selectVarServer()` also returns the selected variable (`input$var`) as a reactive value (`var()`)\n\n#### selectDataVar module \n\n3) [`selectDataVarUI`](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules)/[`selectDataVarServer`](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules): The `selectDataVar` module is from the section titled, \"[*Modules inside of modules*](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules)\", so here we see the `dataset` and `selectVar` modules placed *inside* the `selectDataVar` module (each with a new namespace (`NS()`)).\n\n::: {#fig-selectDataVar}\n\n![`selectDataVar` module](selectDataVar.png){#fig-selectDataVar fig-align=\"center\" width=80%}\n\n`selectDataVar` module \n:::\n\n{{< include _co_naming_modules.qmd >}}\n\n### Standalone app functions\n\n`mstsap` contains three [standalone functions](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) for running each set of module functions. \n\nI've made a small change to each standalone app function--each app has a call to `reactiveValuesToList()` that displays in the UI. \n\n```{r}\n#| echo: true \n#| eval: false \n#| code-fold: show\n#| code-summary: 'print reactive values'\n  shiny::verbatimTextOutput(\"vals\")\n\n  output$vals <- shiny::renderPrint({\n    x <- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n```\n\n\n#### datasetApp\n\n`datasetApp()` contains a call to the `dataset` module, and includes a `tableOutput()` to render the selected data object: \n\n::: {#fig-datasetApp}\n\n![`datasetApp`](datasetApp.png){#fig-datasetApp fig-align=\"center\" width=80%}\n\n`datasetApp` \n:::\n\nWhen `datasetApp()` is run, the app displays the dataset object in the `tableOutput()`, and the `verbatimTextOutput()` renders the reactive values as a text: \n\n::: {#fig-datasetApp_run}\n\n![`datasetApp` with reactive values](datasetApp_run.png){#fig-datasetApp_run fig-align=\"center\" width=100%}\n\n`datasetApp` with `reactiveValuesToList()`\n:::\n\nThe output above shows what `NS()` does in the `dataset` module--it appends the module `id` argument to the `inputId` (which is why we see `dataset-dataset`).\n\n- **`dataset-`:** the module id \n\n- **`dataset-dataset`** the `inputId` from the `selectInput()`\n\n#### selectVarApp\n\n`selectVarApp()` includes both `dataset` and `selectVar` modules, but instead of rendering the output in a table, the UI renders the variable output in a `verbatimTextOutput()`.\n\n::: {#fig-selectVarApp}\n\n![`selectVarApp`](selectVarApp.png){#fig-selectVarApp fig-align=\"center\" width=80%}\n\n`selectVarApp` \n:::\n\nNote that `selectVarApp()` contains namespaces for two modules: \n\n1. **`\"data\"`**: the namespace for the `datasetnput()` and `datasetServer()` modules, inheriting the `filter` argument and creating the data object \n\n2. **`\"var\"`**: the `selectVar` modules are linked with the `\"var\"` id. `selectVarServer()` uses the `data` object created by `datasetServer()` (and also inherits the `filter` argument).\n\nThese namespaced IDs are rendered below with `reactiveValuesToList()`:\n\n::: {#fig-selectVarApp_run}\n\n![`selectVarApp` with reactive values](selectVarApp_run.png){#fig-selectVarApp_run fig-align=\"center\" width=100%}\n\n`selectVarApp` with `reactiveValuesToList()`\n:::\n\nThere's a lot happening in `selectVarApp()`, so I've created the figure below to display the code for the modules with their displayed outputs: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-selectVarApp_schema}\n\n![`selectVarApp` schema](selectVarApp_schema.png){#fig-selectVarApp_schema fig-align=\"center\" width=100%}\n\n`dataset` and `selectVar` modules with rendered outputs\n:::\n\n::::\n\nAs we can see, the `data` output from the `dataset` module is used to generate the `vars()` reactive for the `verbatimTextOutput()` in `selectVarApp()`. Note that both `dataset` and `selectVar` modules don't contain any output functions--these have been provided in the UI for both `datasetApp()` and `selectVarApp()`.\n\n#### selectDataVarApp\n\nThe final app in `mstsap` is `selectDataVarApp()`. Here the inputs from `dataset` and `selectVar` have been moved into the `sidebarPanel()`, and the output is rendered in the `mainPanel()`. \n\n\n::: {#fig-selectDataVarApp}\n\n![`selectDataVarApp`](selectDataVarApp.png){#fig-selectDataVarApp fig-align=\"center\" width=80%}\n\n`selectDataVarApp` \n:::\n\n\nThe reactive values here show how the ['Modules inside of modules'](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules) work--by adding the additional call to `NS()` in the `datasetInput()` and `selectVarInput()` functions *within* `selectDataVarUI()` and `selectDataVarServer()`, an additional namespace is appended to the reactive values (`input$dataset` and `input$var`):\n\n::: {#fig-selectDataVarApp_run}\n\n![`selectDataVarApp` with reactive values](selectDataVarApp_run.png){#fig-selectDataVarApp_run fig-align=\"center\" width=100%}\n\n`selectDataVarApp` with `reactiveValuesToList()`\n:::\n\nBelow is a figure that displays the contents of the `selectDataVar` modules (I've removed the `tagList()` and `moduleServer()` for simplicity), the `selectDataVarApp()`, and the rendered outputs:\n\n:::: {.column-page-right}\n\n::: {#fig-selectDataVarApp_schema}\n\n![`selectDataVarApp` schema](selectDataVarApp_schema.png){#fig-selectDataVarApp_schema fig-align=\"center\" width=100%}\n\n`dataset` and `selectVar` modules inside `selectDataVar` module with rendered outputs\n:::\n\n::::\n\n## testServer() \n\nModule server functions can be tested the same way as a traditional shiny `server` function, as long as you provide the inputs and verify the correct outputs. Below I'll cover some general advice on module server tests (and the arguments in `testServer()`).\n\n### Testing module server functions\n\nBefore writing tests, make sure you can answer the following:\n\n1. ***What is the overall purpose of the application?***\n    -   This information is typically referred to as the 'business logic' of the application, and should be stored in a specifications or requirements document. If I can't answer this question, I'm probably better off not writing test for code that is likely to undergo major changes. \n    \n2. ***How does this module fit within that overall purpose?***\n    -   Specifically, how does this module help the application achieve the specifications or requirements? This could also be considered the 'unit of work' and 'end result' for the module.\n\n3. ***What dependencies (i.e., utility functions, data, add-on packages) are required for the module to execute?***\n    -   If the module depends on other functions, data, or packages to perform it's expected behavior, those functions should either be included in the `testServer()` test, or have their own tests (or both).\n    \n#### What should I test?\n\nThe items below have been compiled from [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html#basic-workflow), [R Packages](https://r-pkgs.org/testing-design.html#what-to-test), and [Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/build-yourself-safety-net.html#testing-your-app): \n\n1. ***Do the inputs/outputs behave as expected?***\n    -   These tests verify the module server function `inputId`s and `outputId`s are properly namespaced and accessible \n    \n2. ***Does the module contain the expected reactive values/objects?***\n    -   Tests should verify it's reactivity--module server functions will automatically recompute the outputs when it's inputs change, so tests should verify changes to inputs produce the expected behaviors and outputs. This includes any returned values from the module (and any additional function arguments).\n    \n3. ***Are the calculations correct?***\n    -   If the module server function performs calculations or data manipulations, the tests should verify the module produces the correct result (ideally for a variety of inputs and edge cases).\n    \n4. ***How are errors handled in the module?***\n    -   What errors are displayed from the module? Tests should simulate scenarios that can test if the module: 1) returns errors that are informative, 2) fails silently (when appropriate), or 3) falls back to the correct default behavior.\n    \nThe last piece of advice I've found helpful when writing tests comes from [R Packages](https://r-pkgs.org/testing-design.html#what-to-test), \n\n> *\"focus your time on code that you’re not sure about, is fragile, or has complicated interdependencies\"*\n\n\nThe quote isn't in reference to testing modules or shiny application functions, but I've found it's easy to fall into the trap of trying to test *everything* when a targeted approach is more efficient (and equally valid).\n\nThe first test I'll perform is for `datasetServer()`, the module used to return a data object from the `datasets` package.\n\n### `testServer()` arguments \n\n-   `app` can be a module server function (i.e., `datasetServer`), or any [`shiny.appobj`](https://shiny.posit.co/r/reference/shiny/1.7.0/shiny.appobj.html) \n\n-   `expr` is where I'll add the `testthat` expectations and other test code \n\n-   `args` is a `list()` I can use to include any module server function arguments\n\n### Inputs\n\nI created the test file with `usethis::use_test(\"datasetServer\")` and the module server function is the first argument in `testServer()`.\n\nI'll start by testing if the initial input value (`input$dataset`) in `datasetServer()` is set to `NULL`:\n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(app = datasetServer, expr = {\n  testthat::expect_equal(input$dataset, NULL)\n  cat(\"\\ndatasetServer: dataset$input is NULL\", \"\\n\")\n})\n```\n\n-   I'll add a custom message with `cat()` and the `inputId` I'm testing, load, document, and install the package, then run the test with `testthat::test_file()`:\n\n    ```{verbatim}\n    #| eval: false\n    #| code-fold: false\n    devtools::load_all()\n    ℹ Loading mstsap\n    devtools::document()\n    ℹ Updating mstsap documentation\n    ℹ Loading mstsap\n    \n    Restarting R session...\n    \n    library(mstsap)\n    ```\n    \n    -   And run the test with `testthat::test_file()`:\n    \n    ```{r}\n    #| eval: false\n    #| code-fold: false\n    test_file(\"tests/testthat/test-datasetServer.R\")\n    ```\n    \n    ```{verbatim}\n    #| eval: false\n    #| code-fold: false\n    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n    datasetServer: dataset$input is NULL \n    ```\n\n\n{{< include _co_test_cmt.qmd >}}\n\n#### Setting test inputs \n\n`testServer()` allows us to mimic changing application (or module) `inputId`s with `session$setInputs()` like so: \n\n```{r}\n#| eval: false\n#| code-fold: false\nsession$setInputs(inputId = \"value\")\n```\n\nI'll demonstrate with a test for `input$dataset` in `datasetServer()`:\n\n```{r}\n#| eval: false\n#| code-fold: false\n  session$setInputs(dataset = \"faithful\")\n  testthat::expect_equal(\n    object = input$dataset,\n    expected = \"faithful\")\n  test_cmt(\"datasetServer\", \"dataset$input\")\n```\n\nThe results from `test_file()` are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false \n#| echo: true\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   datasetServer: dataset$input\n```\n\n### Returned values\n\nAny returned values from module server functions can be accessed in `testServer()` with [`session$returned()`](https://shiny.posit.co/r/articles/improve/server-function-testing/#modules-with-return-values). I'll verify `input$dataset` returns an object from `datasetServer()` by testing the class of `session$returned()`:\n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: show\n#| code-summary: 'show/hide test with session$returned()' \n  session$setInputs(dataset = \"airquality\")\n  testthat::expect_equal(\n    object = class(session$returned()),\n    expected = \"data.frame\")\n  test_cmt(\"datasetServer\", \"class(session$returned())\")\n\n  session$setInputs(dataset = \"WorldPhones\")\n  testthat::expect_true(\n    object = is.matrix(session$returned()))\n  test_cmt(\"datasetServer\", \"is.matrix(session$returned())\")\n```\n\nNote that both methods above can be used to check the class of the returned object. \n\nThe updated results from `test_file()` are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false \n#| echo: true\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   datasetServer: class(session$returned()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n\t   datasetServer: is.matrix(session$returned()) \n```\n\n-   I can also use the `typeof(datasets::mtcars)` for a direct comparison: \n\n    ```{r}\n    #| eval: false\n    #| echo: true\n    #| code-fold: show\n    #| code-summary: 'show/hide test with session$returned()'\n      session$setInputs(dataset = \"mtcars\")\n      expect_equal(\n        # app value...\n        object = typeof(session$returned()), \n        # ...compared to actual output\n        expected = typeof(datasets::mtcars)) \n      test_cmt(\"datasetServer\", \"typeof(session$returned())\")\n    ```\n\n\n### Module server arguments\n\nIf the module server function has additional arguments beyond `id`, then it has additional functionality to verify with unit tests. To test additional module server arguments, pass these to [`testServer(args = list())`.](https://shiny.posit.co/r/articles/improve/server-function-testing/#modules-with-additional-parameters) The `args` list should include named arguments from the module server function, i.e., `list(arg1 = \"param1\", arg2 = \"param2\")`. \n\nFor example, `selectVarServer()` has `data` and `filter` arguments: \n\n-   `data` is the returned reactive object from `datasetServer()` \n\n-   `filter` is the function passed to the `find_vars()` utility function\n\n\n::::{.column-body-outset-right}\n\n:::{#fig-dataset_selectVar}\n\n![`dataset()` -> `selectVar()`](dataset_selectVar.png){#fig-dataset_selectVar fig-align=\"center\" width=100%}\n\nObject returned from `datasetServer()` and passed to `selectVarServer()`\n:::\n\n::::\n\nBelow is a test for `selectVarServer()` using `args` to verify the reactive `data()` is `datasets::mtcars`:\n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = datasets::mtcars,\n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n```\n\n::: {style='font-size: 1.05em; color: #A20025;'}\n\n***But this fails with the following error:***\n\n:::\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n── Error (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ───\nError in `(function (id, data, filter = is.numeric) \n{\n    stopifnot(shiny::is.reactive(data))\n    stopifnot(!shiny::is.reactive(filter))\n```\n\n::: {style='font-size: 1.05em; color: #006CD9;'}\n\n***What happened?***\n\n:::\n\nI've included this example because it's not in the [`testServer()` documentation](https://shiny.posit.co/r/articles/improve/server-function-testing/#testing-shiny-modules), and it's common to pass values between modules (see [here in Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/structuring-project.html#a.-returning-values-from-the-module) and [here in Mastering Shiny](https://mastering-shiny.org/scaling-modules.html#inputs-and-outputs)) \n\n#### Testing module communication\n\nThe error message above tells me the issue is originating from the `stopifnot()` calls in `selectVarServer()`. \n\n{{< include _co_updates.qmd >}}\n\nI'll stop a moment here to address what's happening in each module:\n\n1. The `datasetServer()` returns the results of `input$dataset` as a reactive (`data()`)\n\n2. `data()` enters `selectVarServer()` in the `data` argument \n\n3. *Inside* `selectVarServer()`, two `stopifnot()` functions evaluate the reactivity of `data` and `filter` with `shiny::is.reactive()`\n\nIn `datasetServer()`, the return object is [wrapped in the `reactive()` function](https://github.com/mjfrigaard/mstsap/blob/f10e497df195cfa188afd031e7d082ed1466989d/R/datasetServer.R#L20), so the items `args = list()` also need to be wrapped in `reactive()`. \n\nI'll re-write the test above to a more basic test using `is.reactive()`: \n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data()))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\t   selectVarServer: is.reactive(data()) \n── Failure (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ───\nis.reactive(data()) is not TRUE\n\n`actual`:   FALSE\n`expected`: TRUE \n```\n\n::: {style='font-size: 1.05em; color: #A20025;'}\n\n***Another failure???***\n\n:::\n\nThe results of this test might seem confusing given my advice to wrap the `args` list in `reactive()`, but some reading of the `x` argument in `is.reactive()` will clear up the error: \n\n> *For `is.reactive()`, an object to test. For `reactive()`, an expression.*\n\nRemoving the parentheses from `data()` will result in the proper test results: \n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\t   selectVarServer: is.reactive(data()) \n```\n\n### Utility functions\n\nNow that I have a reactive `data()` input, I can explore how this value is used inside `selectVarServer()`. To update `input$var`, the `data()` input is passed to `find_vars()` (a function that uses a `filter` argument \"*used to select which variables to list*\"). See the example below:\n\n```{r}\n#| eval: true\n#| code-fold: false\nmstsap::find_vars(\n  data = datasets::chickwts, \n  filter = is.factor)\n```\n\nI'll write an expectation that captures the behavior of `find_vars()` in `selectVarServer()`:\n\n```{r}\n#| eval: false\n#| code-fold: false\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::chickwts),\n              filter = is.numeric), expr = {\n  testthat::expect_equal(\n    object = find_vars(data(), is.factor),\n    expected = \"feed\")\n  test_cmt(\"selectVarServer\", \"find_vars()\")\n})\n```\n\nThe results are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   selectVarServer: find_vars()\n```\n\nTo verify that the returned object from `selectVarServer()` is the selected column, I'll need to simulate the application behavior in the tests:\n\n-   Create a reactive `data()` input in `selectVarServer()`:\n\n    ```{r}\n    #| eval: false\n    #| code-fold: show\n    #| code-summary: 'setting args = list()'\n      shiny::testServer(selectVarServer,\n        args = list(data = reactive(datasets::chickwts),\n                    filter = is.numeric), expr = {\n        \n        # include expectations below...\n        \n      })\n    ```\n    \n-   Set the `input$var` and verify the `input$var`:\n\n    ```{r}\n    #| eval: false\n    #| code-fold: show\n    #| code-summary: 'verify input$var'\n      session$setInputs(var = \"weight\")\n      testthat::expect_equal(object = input$var,\n          expected = \"weight\")\n      test_cmt(\"selectVarServer\", \"input$var\")\n    ```\n    \n-   Set the `input$var` and verify the `session$returned()`\n\n    ```{r}\n    #| eval: false\n    #| code-fold: show\n    #| code-summary: 'verify session$returned()'\n      session$setInputs(var = \"feed\")\n      testthat::expect_equal(object = session$returned(),\n        expected = datasets::chickwts[[\"feed\"]])\n      test_cmt(\"selectVarServer\", \"session$returned()\")\n    ```\n\nThe results from these tests are below:\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   selectVarServer: input$var \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n\t   selectVarServer: session$returned() \n```\n\n\n### Module outputs\n\nRendered outputs can be accessed in `testServer()` just like inputs (i.e., with `output$outputId`). But the modules in `mstsap` don't have outputs--these are included in the standalone app functions (`datasetApp()`, `selectVarApp()`, and `selectDaraVarApp()`). \n\nFortunately, app functions can also be passed to the `app` argument of `testServer()`. I'll use `datasetApp()` to demonstrate.\n\n![](datasetApp.png){fig-align=\"center\" width=80%}\n\nTesting a standalone app function is similar to testing a module server function, but with a few minor differences. First, the output from the standalone app function is [assigned to an object](https://shiny.posit.co/r/articles/improve/server-function-testing/#shiny-app-objects) (`ds_app`), then placed in the `app` argument: \n\n```{r}\n#| eval: false\n#| code-fold: false\nds_app <- datasetApp()\n  shiny::testServer(ds_app, expr = {\n\n  })\n```\n\n To use `session$setInputs()`  need to include the namespace for the `inputId`:\n\n![](datasetApp_reactives.png){fig-align=\"center\" width=100%}\n\nThe output from `reactiveValuesToList()` in `datasetApp()` shows me how to access the `inputId` in the `datasetServer()` module (i.e., ``` input$`dataset-dataset` ```):\n\n```{r}\n#| eval: false\n#| code-fold: false\nds_app <- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n\n})\n```\n\n\n#### Output testing strategy\n\nTesting outputs with `testServer()` is different than testing outputs in regular unit tests, because shiny outputs are executed in the server, but then rendered in the UI. The [`testServer()` documentation](https://shiny.posit.co/r/articles/improve/server-function-testing/#complex-outputs-plots-htmlwidgets) outlines a testing strategy for complex outputs:\n\n> *The goal for your tests should be to ask “is the code that I wrote producing the plot I want?” There are two components to that question:\n> \n> 1. *Does the plot generate without producing an error?*\n> 2. *Is the plot visually correct?*\n> \n> *`testServer` is great for assessing the first component here. By merely referencing `output$plot` in your test, you’ll confirm that the plot was generated without an error.*\n\nIf we replace *plot* with *table* in the advice above, the tests for `datasetApp()` should confirm `output$data` is generated without producing an error. \n\nInstead of writing an expectation, I'll use `cat()` to display the contents of `output$data` after setting the ``` `dataset-dataset` ``` input:\n    \n```{r}\n#| eval: false\n#| code-fold: false\nds_app <- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n  cat(\"\\n\\toutput$data:\\n\", output$data, \"\\n\")\n})\n```\n\nThe results from the test is below:\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n\toutput$data:\n```\n\n```{.html}\n <table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'>\n  <thead> \n\t  <tr> \n\t    <th style='text-align: right;'> weight </th> \n\t    <th style='text-align: left;'> feed </th>  \n\t </tr> \n\t</thead> \n\t  <tbody>\n      <tr> <td align=\"right\"> 179.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 160.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 136.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 227.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 217.00 </td> <td> horsebean </td> </tr>\n      <tr> <td align=\"right\"> 168.00 </td> <td> horsebean </td> </tr>\n   </tbody> \n </table> \n```\n\nThe output is the HTML used to render the table in the UI. This doesn't add a passing test, but it confirms that the table is being generated from the `data()` reactive. \n\nThe tests for `datasetApp()` will confirm the `inputId`, and verify the `class` and `names` of the `data()` reactive (which will be passed to the `renderTable()` function): \n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_equal(\n    object = input$`dataset-dataset`,\n    expected = \"chickwts\")\n  test_cmt(\"datasetApp\", \"input$`dataset-dataset`\")\n\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  test_cmt(\"datasetApp\", \"is.data.frame(data())\")\n\n  testthat::expect_equal(\n    object = names(data()),\n    expected = names(datasets::chickwts))\n  test_cmt(\"datasetApp\", \"names(data())\")\n```\n\nI can include a test for the `class` of `output$data`, but note that this is a character output:\n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_equal(\n    object = class(output$data),\n    expected = \"character\")\n  test_cmt(\"datasetApp\", \"class(output$data)\")\n```\n\nThe results from `test_file()` are below:\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\t   datasetApp: input$`dataset-dataset` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   datasetApp: is.data.frame(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   datasetApp: names(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n\t   datasetApp: class(output$data) \n```\n\nThe same method can be used to test the `selectVarApp()`, but note this app requires passing both `inputId`s to `session$setInputs()`:\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide selectVarApp() tests'\nsv_app <- selectVarApp()\nshiny::testServer(app = sv_app, expr = {\n  session$setInputs(`var-var` = \"Ozone\",\n                    `data-dataset` = \"airquality\")\n  # confirm contents of output$out\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n  \n  # confirm var is reactive \n  testthat::expect_true(object = is.reactive(var))\n  # confirm var input\n  testthat::expect_equal(\n    object = input$`var-var`,\n    expected = \"Ozone\")\n  # confirm data is reactive\n  testthat::expect_true(object = is.reactive(data))\n  # confirm data() is a data.frame\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  # confirm 'data' can be subsetted with 'var'\n  testthat::expect_equal(\n    object = data()[[input$`var-var`]],\n    expected = airquality[[\"Ozone\"]])\n})\n```\n\n\n#### Testing nested modules \n\nI highly recommend viewing the output of `reactiveValuesToList()` if your application has nested modules. It's easy to lose track of ids if they span multiple layers. \n\nWe know `selectDataVarApp()` contains 'modules inside other modules', and these layers are reflected in the namespaces: \n\n![](selectDataVarApp_reactives.png){fig-align=\"center\" width=100%}\n\nTo access the `inputId`s in the nested modules, we need to pass the full 'appended' namespace:\n\n```{r}\n#| eval: false\n#| code-fold: false\ndv_app <- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n})\n```\n\nAfter setting the inputs, I can confirm the contents of `output$out`\n\n```{r}\n#| eval: false\n#| code-fold: false\ndv_app <- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n})\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n\toutput$out:\n   [1]  41  36  12  18  NA  28  23  19   8  NA   7  16  11  14  18\n [16]  14  34   6  30  11   1  11   4  32  NA  NA  NA  23  45 115\n [31]  37  NA  NA  NA  NA  NA  NA  29  NA  71  39  NA  NA  23  NA\n [46]  NA  21  37  20  12  13  NA  NA  NA  NA  NA  NA  NA  NA  NA\n [61]  NA 135  49  32  NA  64  40  77  97  97  85  NA  10  27  NA\n [76]   7  48  35  61  79  63  16  NA  NA  80 108  20  52  82  50\n [91]  64  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28\n[106]  65  NA  22  59  23  31  44  21   9  NA  45 168  73  NA  76\n[121] 118  84  85  96  78  73  91  47  32  20  23  21  24  44  21\n[136]  28   9  13  46  18  13  24  16  13  23  36   7  14  30  NA\n[151]  14  18  20 \n```\n\nAfter confirming `output$out`, I'll test the inputs: \n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_equal(\n    object = input$`var-var-var`,\n    expected = \"Ozone\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-var-var`\")\n\n  testthat::expect_equal(\n    object = input$`var-data-dataset`,\n    expected = \"airquality\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-data-dataset`\")\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\t   selectDataVarApp: input$`var-var-var` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n\t   selectDataVarApp: input$`var-data-dataset`\n```\n\nI can also verify the contents of the reactive `var()` inside the test:\n\n```{r}\n#| eval: false\n#| code-fold: false\n  testthat::expect_true(object = is.reactive(var))\n  test_cmt(\"selectDataVarApp\", \"is.reactive(var)\")\n  cat(\"\\n\\tvar:\\n\", var(), \"\\n\")\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n\t   selectDataVarApp: is.reactive(var) \n\n\tvar:\n 41 36 12 18 NA 28 23 19 8 NA 7 16 11 14 18 14 34 6 30 11 1 11 4 32 NA NA NA 23 \n\t45 115 37 NA NA NA NA NA NA 29 NA 71 39 NA NA 23 NA NA 21 37 20 12 13 NA NA NA\n\tNA NA NA NA NA NA NA 135 49 32 NA 64 40 77 97 97 85 NA 10 27 NA 7 48 35 61 79 \n\t63 16 NA NA 80 108 20 52 82 50 64 59 39 9 16 78 35 66 122 89 110 NA NA 44 28 \n\t65 NA 22 59 23 31 44 21 9 NA 45 168 73 NA 76 118 84 85 96 78 73 91 47 32 20 23\n\t21 24 44 21 28 9 13 46 18 13 24 16 13 23 36 7 14 30 NA 14 18 20 \n```\n\n \n## Recap \n\nThis post has shown how shiny's `testServer()` function allows you to isolate and test module server functions, which makes it easier to ensure that your `server` function behaves as expected (and locate and fix bugs).\n\nI hope you have a better understanding of how you can use `testServer()` to test a modules inputs/outputs, reactivity, calculations, and errors.\n\nIn the next post I'll cover performing integration tests with `shinytest2`!"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","dpi":320,"toc":true,"toc-depth":5,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"show/hide","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","knitr":{"opts_chunk":{"collapse":true}},"theme":{"light":["litera","../../custom.scss"]},"fig-asp":0.618,"fontsize":"10.5","toc-title":"Contents","toc-location":"left","callout-icon":false,"code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","title-block-banner":true,"title":"How do I test shiny modules?","subtitle":"Part 3: Using testthat and testServer()","author":"Martin Frigaard","date":"2023-06-20","categories":["shiny","testing"],"image":"image.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}