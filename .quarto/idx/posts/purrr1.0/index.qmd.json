{"title":"purrr updates (v1.0.0)","markdown":{"yaml":{"title":"purrr updates (v1.0.0)","author":"Martin Frigaard","date":"2023-04-05","image":"image.png","categories":["iteration","code"],"toc":true,"toc-depth":5,"toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-fold":"show","code-summary":"show/hide","callout-icon":false,"freeze":true,"execute":{"echo":true,"warning":false,"eval":true}},"headingText":"remotes::install_github(\"tidyverse/purrr\",","containsRefs":false,"markdown":"\n\n```{r}\n#| label: utils\n#| eval: true\n#| echo: false\n#| include: false\nsource(\"../_common.R\")\nlibrary(kableExtra)\nmixed_list <- make_mixed_list()\nmy_list <- make_my_list()\n```\n\n<!--\nhttps://mjfrigaard.github.io/posts/vanilla-shiny/\n\nhttps://mjfrigaard.github.io/posts/my-pkg-app/\n\nhttps://mjfrigaard.github.io/posts/my-golem-app/\n\nhttps://mjfrigaard.github.io/posts/my-leprechaun-app/\n\nhttps://mjfrigaard.github.io/posts/my-rhino-app/\n-->\n\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: pkgs\n#| echo: true\n#| message: false \n#| warning: false\n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(sloop)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(waldo)\n```\n:::\n\nThis post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I will cover below. But first, I'll dive into some attributes of R's functions and objects that make `purrr` particularly useful, and I'll work through iteration problems I've encountered (and solved with `purrr`).\n\n# **Refresher**: functions and objects \n\nIf you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.\n\nIn a functional programming language like R, it's nice when to have functions perform a lot of the work I'd have to write into a `for` loop. \n\n## Generic functions & S3 objects\n\nR's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` and `summary()` functions are S3 generic function: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r isS3stdGeneric}\nsloop::ftype(plot)\nsloop::ftype(summary)\n```\n:::\n\nWhich means `plot()` can be applied to S3 objects, like time-series (`ts`) and rectangular datasets (`data.frame`):\n\n::: {style=\"font-size: 0.90em;\"}\n```{r LakeHuron}\n#| label: LakeHuron\n#| echo: true\n#| eval: true\n#| collapse: true\nsloop::otype(datasets::LakeHuron)\nclass(datasets::LakeHuron)\nsloop::otype(datasets::chickwts)\nclass(datasets::chickwts)\n```\n\n```{r chickwts}\n#| label: summary_demo\n#| collapse: true\nsummary(datasets::LakeHuron)\nsummary(datasets::chickwts)\n```\n\n```{r}\n#| layout-ncol: 2\n#| fig-cap: \n#|   - \"Time-series plot\"\n#|   - \"Scatter Plot\"\nplot(datasets::LakeHuron)\nplot(datasets::chickwts)\n```\n:::\n\n`summary()` is a particularly versatile function, because it can be used on `data.frame`s, a single column in a `data.frame`, model outputs, and more. \n\n::: {style=\"font-size: 0.90em; color: #696969;\"}\n*Click **Code** below to view an example using `summary()`*\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n```{r lm}\n#| label: lm_generic\n#| code-fold: true\n#| collapse: true\n\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\nsummary(mtcars$mpg)\n\n# store model output  -------------------------------------------------------\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n```\n:::\n\n\n## FP + OOP \n\n> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition\n\n`plot()` and `summary()` are parametric polymorphic (generic) functions, which means they have slightly different behaviors based on the objects passed into them. \n\nAs I can see, generic functions are flexible and efficient because of not having to re-define a new function for each input object--outputs from generic functions will automatically change (in part) depending on the structure of the object provided to them.\n\nThe relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving iteration problems we commonly encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.\n\n## Iteration problems \n\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: \n\n  1. You have a list of objects and you'd like to apply a function (or a series of functions) over the elements in the list\n  \n  2. You have a folder full of files you'd like to rename or copy to a new directory   \n\n  3. You'd like to download a collection of files from separate URLS  \n\n  4. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset\n\n  5. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. \n\nThese are all problems I've personally encountered that required a variety of iteration tools to tackle. I'll start with the first example because the principles remain the same (regardless of the size/scope of the problem):\n\n\n# **The `for` loop**\n\n`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: \n\n> \"*for each `item` in `object`, do `operation`*\"\n\nI have a list (`my_list`), with items in various cases:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r my_list}\n#| label: my_list\n#| collapse: true\nmy_list\n```\n:::\n\nIf I try to use the `tolower()` on `my_list`, it returns a vector.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: tolower_my_list\n#| collapse: true\ntolower(my_list) |> str()\n```\n:::\n\nHow can I apply the `tolower()` function to each item in `my_list`, and return the original object type? I'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:\n\n-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'\n\n      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`) \n      \n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| collapse: true\n    seq_along(my_list)\n    # take single value of 'x'\n    seq_along(my_list)[1]\n    # use this to get 'items in object'\n    my_list[[seq_along(my_list)[1]]]\n    ```\n    :::\n    \n-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)\n\n    - Test this with a few values if you like\n    \n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    tolower(my_list[[2]])\n    ```\n    :::\n\n-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size\n\n    - Two methods for creating empty lists  \n    \n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| label: empty_list\n    #| collapse: true\n    vector(mode = \"list\", length = 3)\n    list(NULL, NULL, NULL)\n    ```\n    :::\n\nFinally, we put it all together in a `for` loop\n\n::: {style=\"font-size: 1.0em;\"}\n```{r}\n#| label: for_loop\n# define capture object\nlc_list <- vector(mode = \"list\", length = 3)\n# write sequence\nfor (x in seq_along(my_list)) {        \n  # write operations/capture in object\n  lc_list[[x]] <- tolower(my_list[[x]])\n  # clean up container\n  names(lc_list) <- c(\"words\", \"sentences\", \"letters\")\n}\nlc_list\n```\n:::\n\nThis was a simple example, but it demonstrates the basic components in a `for` loop: \n\n1. The sequence to index \n    - `for (x in seq_along(my_list))`  \n2. The operations to iterate   \n    - `tolower(my_list[[x]])`   \n3. The object to capture the results  \n    - `lc_list <- vector(mode = \"list\", length = 3)` and  \n    - `lc_list[[x]]`\n  \n# **Base R**\n\nbase R has the `_apply` family of functions (`apply()`, `lapply()`, `sapply()`, `vapply()`, etc.) that remove a lot of the 'book keeping' code we had to write in the `for` loop.\n\n\n## `lapply()`\n\n\nSticking with the `my_list` and `tolower()` example, the `apply` function I want is `lapply()` (pronounced 'l-apply'), and the `l` stands for list.\n\n`lapply()` has only two required arguments: \n\n  - `X` the object we want to iterate over \n\n  - `FUN` being the function we want iterated \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: lapply_intro\nlapply(X = my_list, FUN = tolower)\n```\n:::\n\n\n## `sapply()`\n\n`sapply()` attempts to simplify the result depending on the `X` argument. If `X` is a list containing vectors where every element has the same length (and it's greater than 1), then `sapply()` returns a matrix:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: sapply_list\nstr(my_list[1])\nsapply(X = my_list[1], FUN = tolower)\n```\n:::\n\nIf a vector is passed to `X` where every element is length 1, then a vector is returned: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: sapply_vector\nstr(my_list[[1]])\nsapply(X = my_list[[1]], FUN = tolower) \n```\n:::\n\nFinally, if `X` is a list where elements have a length greater than 1, then a list is returned (making it identical to `lapply()`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n```\n:::\n\nThis is because `sapply` is a wrapper around `lapply`, but has `simplify` and `USE.NAMES` set to  `FALSE` (see what happens below when I change them to `TRUE`)\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: sapply_waldo\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n```\n:::\n\n## Anonmymous functions \n\nThe `FUN` argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in `my_list`, I could pass an anonymous function the `FUN` (with the index):\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: lapply_anon_fun\nlapply(X = my_list, FUN = function(x) x[[2]])\n```\n:::\n\n## `vapply()`\n\nFinally `vapply()` is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: vapply_anon_fun\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n```\n:::\n\n\nThe `apply` functions get us much further than writing `for` loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) **write less code.** Unlike generic functions, `apply` functions are designed to work with specific object types, and return values depending on these objects.\n\n\nOne downside of apply functions is they don't play well with `data.frame`s or `tibble`s. However, we can control their return values (and manually supply these to `tibble::tibble()` or `data.frame()`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: tibble_from_list\n#| code-fold: true\n#| eval: false\ntibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n```\n:::\n\n\nAnother downside of the `apply` functions is they're not very uniform. Each function has slight variations in their arguments and rules for return values. This is where `purrr` comes in...\n\n# **`purrr`**\n\nIf you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)\n\n1. Do it for one element\n\n2. Turn it into a recipe\n\n3. Use `purrr::map()` to do it for all elements\n\nI'll work through these three steps below using `my_list` and `tolower()`\n\n## 1. Do it for one element\n\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\n\nFor this example, I need to subset `my_list` for a single element at position `[[1]]`, `[[2]]`, or `[[3]]` (or using one of the vector names). \n\nI'll then pass this element to `tolower()` and make sure it's the desired behavior:\n\n::: {style=\"font-size: 0.90em;\"}\n```r\n# subset an element from the list\n? <- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n```\n:::\n\n- `? <- my_list[[?]]` = subset element from the list (`my_list`)\n\n- `tolower(?)` = apply operation (i.e., function) to extracted element.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nmy_words <- my_list[['words']]\ntolower(my_words)\n```\n:::\n\nNow that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.\n\n## 2. Turn it into a recipe\n\nA standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.\n\n- `.x` =  a list or atomic vector \n\n- `.f` = the function we want to apply over every element in `.x`\n\n::: {style=\"font-size: .90em;\"}\n```r\n.x = my_list, .f = tolower\n```\n:::\n\n## 3. `map()` it across all elements\n\nIn `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` \n\nIf I want to convert the case of every element in `my_list` to lowercase with `tolower()` I would use the following standard `purrr::map()` format:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: my_list_purrr_standard\n#| results: hold\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\nAnd there you have it! `map()` is the core function and workhorse of the `purrr` package. It's important to note that `purrr::map()` always returns a list, regardless of the object supplied to `.x`. \n\n# **Version 1.0.0 updates**\n\nNow I'll cover some of the updates in `purrr` 1.0.0. I'll be using `mixed_list`, a list with five different types of vectors. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r mixed_list}\n#| label: mixed_list\nmixed_list\n```\n:::\n\n## `map()` updates \n\nAs noted above, by default `purrr::map()` returns a list. If I'd like to return a vector, I can use one of the `map_` variations (there's one for each vector type). \n\n-   By mapping the `is.<type>()` functions the elements in `mixed_list`, I can test which elements in `mixed_list` return `TRUE`:\n\n    -   `map_lgl()`: returns a logical vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: false\n    #| collapse: false\n    mixed_list |> purrr::map_lgl(\\(x) is.logical(x))\n    ```\n    :::\n\n    -   `map_int()`: returns an integer vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: false\n    #| collapse: false\n    mixed_list |> purrr::map_int(\\(x) is.integer(x))\n    ```\n    :::\n\n    -   `map_dbl()`: returns a double vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: false\n    #| collapse: false\n    mixed_list |> purrr::map_dbl(\\(x) is.double(x))\n    ```\n    :::\n\n    -   `map_chr()`: returns a character vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: true\n    #| message: true\n    #| collapse: false\n    mixed_list |> purrr::map_chr(\\(x) is.character(x))\n    ```\n    :::\n    \nWhen we test for characters in `mixed_list`, we see the following warning:\n\n::: {style=\"font-size: 0.90em;\"}\n> `Warning: Automatic coercion from logical to character was deprecated in purrr`\n> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`\n:::\n\nAs we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).\n\n### `map_vec()`\n\n<br>\n\nHowever, the previous `purrr::map_raw()` function has been replaced with `purrr::map_vec()`, which \"*simplifies to the common type of the output.*\" I'll demonstrate below with the characters in `mixed_list`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| warning: true\n#| message: true\n#| eval: true\nmixed_list |> purrr::map_vec(\\(x) is.character(x))\n```\n:::\n\nNotice the difference in output?  The results are the same as above, but output is not commented (`##`). The same is true when I test the dates in `mixed_list` using `lubridate::is.Date()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| warning: true\n#| message: true\n#| eval: true\nmixed_list |> purrr::map_vec(\\(x) lubridate::is.Date(x))\n```\n:::\n\n## Anonymous functions\n\nR introduced the shorthand anonymous function syntax in version [4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html):\n\n> \"*`\\(x) x + 1` is parsed as `function(x) x + 1`.*\" \n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\n-   Standard anonymous function  \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    (function(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    :::\n\n-   The updated anonymous syntax is below:\n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    (\\(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    :::\n\nWriting the code above using an anonymous function would look like this:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: my_list_purrr_anonymous_fun\n#| results: hold\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\nAnonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* \n\nI'll confirm the outputs from both methods are identical using `waldo::compare()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: my_list_purrr_test_waldo\n#| results: hold\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(\\(x) tolower(x)))\n```\n:::\n\n:::: {.callout-important icon=false}\n## The formula (`~ .x + 1`)\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\nPrior to `purrr` v1.0.0, I could also use the formula syntax, but now it's \"*only recommended if you require backward compatibility with older versions of R.*\" I'll cover the formula syntax briefly because you're likely to encounter it. \n:::\n\n::: {style=\"font-size: 1.10em;\"}\nThe formula syntax is typically used with pipes, so the contents of `purrr::map()` become the right-hand side of the formula, with the function we want to iterate (`<FUNCTION>`) and a placeholder (`.x`) in the appropriate argument.\n:::\n\n::: {style=\"font-size: 1.20em;\"}\n``` bash\n<OBJECT> |> purrr::map(~ <FUNCTION>(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nFor the example above, `my_list` is 'piped' to `purrr::map()`, where the formula maps the `tolower()` function (using the `.x` placeholder).\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n```r\n# written as normal expression\n my_list |> purrr::map(~ tolower(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nJenny Bryan offers a great description on [her `purrr` tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), \n\n> \"*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*\"\n\nI can double-check to see that the output from two variations are identical using `waldo::compare()`.\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n```{r}\n#| label: my_list_purrr_anonymous\n#| results: hold\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n:::\n\n::::\n\n\n\n<!--\n# map for `data.frame` and `tibble`s\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nswdata <- dplyr::select(dplyr::starwars, !where(is.list))\npurrr::map_df(.x = swdata, .f = tolower)\n```\n:::\n-->\n\n# Worked Examples\n\nIn this section, I'll be working through some of the uses I've for `purrr`'s functions. I've tried to choose tasks that are common across *most* projects so my code can be easily copied and adapted. \n\n## Downloading files \n\n> *You'd like to download a collection of files from separate URLS*\n\nI have a collection of 30 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) in a [GitHub repo](https://github.com/mjfrigaard/dds-data). Let's assume I want to download one week of these files into my RStudio session (without downloading the repo).\n\nI'll navigate to the raw url for the first data file (`nyt1.csv`), then paste this into a character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nnyt_url <- \"https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n```\n:::\n\nKnowing that all of the files on GitHub with have a similar sheme and domain, I can use `nyt_url` to generate urls for each of the 7 files. \n\n1. First I get the folder of the files on GitHub with `fs::path_dir()` \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_file_url\n#| eval: true\n#| collapse: false\n# create file urls \nnyt_dir_url <- fs::path_dir(nyt_url)\nnyt_dir_url\n```\n:::\n\n2. I create a vector with the 7 file names\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_file_nms\n#| eval: true\n#| collapse: false\n# create file names for 7th through 13th\nnyt_file_nms <- paste0(\"nyt\", 7:13, \".csv\")\nnyt_file_nms\n```\n:::\n\n3. I combine the directory portion of the url with file name in `nyt_file_urls`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_file_urls\n#| eval: true\n#| collapse: false\n# combine\nnyt_file_urls <- paste(nyt_dir_url, nyt_file_nms, sep = \"/\")\nnyt_file_urls\n```\n:::\n\nI'll need another vector of destination file names on my local machine, which I can do by combining the file names (`nyt_file_nms`) with the local destination folder (`dds-nyt`).\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_local_pths\n#| eval: true\n#| collapse: false\nnyt_local_pths <- paste(\"dds-nyt\", nyt_file_nms, sep = \"/\")\nnyt_local_pths\n```\n:::\n\nAfter creating the destination folder, I'll use the `download.file()` function to test downloading a single `.csv` files into my local folder (`dds-nyt/`). `download.file()` has a progress bar which tells me if the file downloaded successfully. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: download.file\n#| eval: true\n#| collapse: false\n#| results: asis\n# do it for one\nfs::dir_create(\"dds-nyt\")\ndownload.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])\n```\n\n```bash\ntrying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'\nContent type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)\n==================================================\ndownloaded 4.7 MB\n```\n:::\n\n\n`download.file()` takes two inputs (`url` and `destfile`), which changes the recipe a bit, because I need a `purrr` function with the following:\n\n1. `.x` the input vector of existing url paths \n\n2. `.y` the output vector of destination file paths \n\n3. Additional arguments passed from `download.file()` (like `quiet = TRUE`)\n\nIn this case, I don't need `purrr` to return value--I just need the `purrr` function to iterate over the items and write them to the new location.\n\n`walk()` is ideal for this circumstance:\n\n> \"*`walk()` returns the input `.x` (invisibly)*\" and \"*The return value of `.f()` is ignored*\"\n\n***What do 'return `.x` invisibly' and 'the side-effect of `.f`' mean?***\n\n### Return invisibly \n\nThe previous `purrr` functions I covered varied in the kinds of values they returned (lists vs. vectors), but for some operations I won't need a return value. If I'm ever curious about whether I should be using `map()` or `walk()`, I'll ask myself, *\"would it make sense to assign the output from this function to an object?*\"\n\nIf the answer is no, then I probably need to be thinking `walk()` instead of `map()`\n\n### Side-effects \n\nIn the help documentation `walk()`'s description states, \"*calls .f for its side-effect*\", which can be generally interpreted as, \"*there's nothing to assign the output from that function to.*\"\n\n### `purrr` progress bars \n\nI'll use `walk2()` below and add `.progress = TRUE` to view the `purrr` progress bar (and `quiet = TRUE` to silence the `download.file()` progress bar).  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: walk2_download_files\nwalk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, \n      .progress = TRUE, quiet = TRUE)\n```\n:::\n\n<br>\n\n\n```{r}\n#| label: purrr-progress\n#| echo: false\n#| fig-align: center\n#| out-width: '100%'\n#| fig-dpi: 320\n#| fig-asp: 0.618\nknitr::include_graphics(path = \"purrr-progress.gif\")\n```\n\n\n<br>\n\nI can confirm the download using `fs::dir_tree()`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: dir_tree_download_files\nfs::dir_tree(\"dds-nyt\")\n```\n:::\n\n\n## Copying a directory of files \n\n> *You have a folder of files you'd like to rename or copy to a new directory*\n\nThe collection of 7 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) are now in the `dds-nyt/` folder. \n\nAs with any project, I don't want to alter the raw data, so I'm going to copy these files into `dds-nyt-raw/` and `dds-nyt-processed/`. I also want the processed file names to have a date stamp prefix. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: file_pths\nfile_pths <- list.files(\"dds-nyt\", full.names = TRUE, pattern = \".csv$\")\nfile_pths\n```\n:::\n\nI'll start with the raw data folder. I need to create a vector of the new raw file paths and names: `raw_file_pths` (the raw data paths will have the original file names)\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: raw_file_pths\n#| eval: true\n#| collapse: true\n# do it for one\ngsub(pattern = \"^dds-nyt\",\n  replacement = \"dds-nyt/raw\",\n  x = file_pths[1])\n\n# write the recipe\nfile_pths |> purrr::map_chr(\\(x) gsub(x, \n                                pattern = \"^dds-nyt\", \n                                replacement = \"dds-nyt/raw\")) |> head()\n\n# map it across all\nraw_file_pths <- file_pths |> \n                  purrr::map_chr(\\(x) gsub(x, \n                                        pattern = \"^dds-nyt\", \n                                        replacement = \"dds-nyt/raw\"))\n```\n:::\n\nBefore copying the files, I need to create the destination folder for the raw data (`dds-nyt/raw`). Then, I'll make sure I can copy the first element from `file_pths` into the path in the first element of `raw_file_pths`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: create_paths\n#| eval: true\nfs::dir_create(\"dds-nyt/raw\")\n# do it for one\nfs::file_copy(\n  path = file_pths[1], \n  new_path = raw_file_pths[1], \n  overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n```\n:::\n\n\nI can see this is working, so I can use `purrr::walk2()` to move all the files from `dds-nyt/` to `dds-nyt/raw/`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: walk2_file_copy\npurrr::walk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, \n      .progress = TRUE, overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n```\n:::\n\nNow that I've copied the files into their respective folders, I'll need to remove the files from their original location in the parent `dds-nyt` folder.\n\nFortunately, I have a vector of these files in `file_pths`, and I can test removal with `fs::file_delete()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: test_file_delete\nfs::file_delete(file_pths[1])\n```\n:::\n\nGreat! Now that I know this will work, I'll use `walk()` because I want `.x` returned invisibly and the side-effect of `.f`. \n\nBut I've also deleted the first element in `file_pths`, so when `fs::file_delete()` goes looking for that file, it will find nothing and returned an error. \n\n::: {style=\"font-size: 0.90em;\"}\n```{bash, eval=FALSE}\nError in `map()`:\nâ„¹ In index: 1.\nCaused by error:\n! [ENOENT] Failed to remove 'dds-nyt/nyt10.csv': no such file or directory\n```\n:::\n\nI can protect against this by supplying the output from `list.files()` directly to `purrr::walk2()`, but include a `pattern` so it only matches the `.csv` files.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\npurrr:::walk(\n  # list CURRENT files \n    .x = list.files(\n      path = \"dds-nyt\",\n      pattern = \".csv$\",\n      full.names = TRUE),\n    # map function\n    .f = fs::file_delete)\n```\n:::\n\n\nAnd confirm the new folder contents and structure\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nfs::dir_tree(\"dds-nyt\", type = \"any\", recurse = TRUE)\n```\n:::\n\n\n## Import multiple datasets \n\n> *You have several days of data, and each day is contained in separate file. You'd like to read these data into R, and combine them into a single dataset*\n\nNow that I have separate raw and processed folders, I can import the NYT data into R. Below I've imported a single file from the `raw` data folder to examine it's contents:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt1}\n#| label: import_nyt1.csv\nnyt1 <- vroom::vroom(file = raw_file_pths[1],\n  delim = \",\", \n  show_col_types = FALSE)\nstr(nyt1)\n```\n:::\n\nEach `nyt` file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: `Age`, `Gender` (0 = female, 1 = male), `Impressions` (number impressions), `Clicks` (number clicks), and a binary indicator for signed in or not `Signed_in`. \n\nI'll add some hypothetical wrangling steps to make this example more realistic.\n\n  1. Create `age_group`, an ordered factor which contains six levels of Age (\"<18\", \"18-24\", \"25-34\", \"35-44\", \"45-54\", \"55-64\", and \"65+\")\n\n  2. Create `ctr_rate` or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.\n\n  3. Create `female`, a factor version of `Gender`, where when `Gender` = `0`, then `female` = `\"yes\"`, and when `Gender` = `1`, then `female` = `\"no\"` \n\n  4. Create `signed_in`, a factor variable with levels `\"no\"` and `\"yes\"` from the `Signed_In` = `0` and `1`\n\nI've bundled all of these steps into a function (`nyt_data_processing()`) that I can pass each dataset through:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt_data_processing}\n#| label: fun_nyt_data_processing\n#| code-fold: true \nnyt_data_processing <- function(nyt_csv) {\n  orig_nms <- c(\"Age\", \"Gender\", \"Impressions\", \"Clicks\", \"Signed_In\")\n  nyt_nms <- names(nyt_csv)\n  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {\n    cli::cli_abort(\"these data don't have the correct columns!\")\n  } else {\n    nyt_proc <- nyt_csv |>\n      dplyr::mutate(\n        # create age_group variable\n        age_group = case_when(\n          Age < 18 ~ \"<18\",\n          Age >= 18 & Age < 25 ~ \"18-24\",\n          Age >= 25 & Age < 35 ~ \"25-34\",\n          Age >= 35 & Age < 45 ~ \"35-44\",\n          Age >= 45 & Age < 55 ~ \"45-54\",\n          Age >= 55 & Age < 65 ~ \"55-64\",\n          Age >= 65 ~ \"65+\"\n        ),\n        # factor age_group (ordered)\n        age_group = factor(age_group,\n          levels = c(\n            \"<18\", \"18-24\", \"25-34\",\n            \"35-44\", \"45-54\", \"55-64\", \"65+\"\n          ),\n          ordered = TRUE\n        ),\n        # create CTR variable\n        ctr_rate = round(x = Clicks / Impressions, digits = 3),\n        # create new Female variable\n        female = case_when(\n          Gender == 0 ~ \"yes\",\n          Gender == 1 ~ \"no\",\n          TRUE ~ NA_character_\n        ),\n        # factor female (un-ordered)\n        female = factor(female,\n          levels = c(\"no\", \"yes\")\n        ),\n        Signed_In = case_when(\n          Signed_In == 0 ~ \"no\", \n          Signed_In == 1 ~ \"yes\", \n          TRUE ~ NA_character_),\n        # factor Signed_In (un-ordered) \n        Signed_In = factor(Signed_In, levels = c(\"no\", \"yes\"))) |>\n      # format columns\n      janitor::clean_names()\n  }\n  return(nyt_proc)\n}\n```\n:::\n\nI'll do some quick checks to make sure it only works with the raw data columns:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt1_proc}\n#| label: test_nyt_data_processing\n#| error: false\nnyt1_proc <- nyt_data_processing(nyt1)\nstr(nyt1_proc)\n```\n:::\n\nI'll run `nyt_data_processing()` against a processed data file (`nyt1_proc`)\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: test_nyt_data_processing_error\n#| error: true\nnyt_data_processing(nyt1_proc)\n```\n:::\n\nNow I'm ready to write the import step. First I'll store the raw file paths in `raw_data_pths`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r raw_data_pths}\nraw_data_pths <- list.files(path = \"dds-nyt/raw\", pattern = \".csv$\", full.names = TRUE)\n```\n:::\n\nWe'll test `purrr::map()` and `vroom::vroom()` to import the `.csv` files in `raw_data_pths` into a list. I also add `utils::head()` and `dplyr::glimpse()` to limit the output.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # import\n  purrr::map(\n    vroom::vroom, \n        delim = \",\", show_col_types = FALSE) |> \n  utils::head(2) |> \n  dplyr::glimpse()\n```\n:::\n\nThis returns a list, but you may have noticed I don't have a great way for keeping track of the data files in the list--this is where `purrr::set_names()` comes in handy. \n\n`purrr::set_names()` works a lot like `names()`, but `purrr::set_names()` will automatically set the names of `x` to `as.character(x)` if no names are provided to `nm`. See below:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> purrr::set_names()\n```\n:::\n\nNow the imported file will have their file path and name associated with the dataset:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import  \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  utils::head(2) |> \n  dplyr::glimpse()\n```\n:::\n\nTo add the wrangling function, I can pipe in another call to `purrr::map()`, and add  `nyt_data_processing()`. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  utils::head(2) |> \n  dplyr::glimpse()\n```\n:::\n\n### `list_rbind()`\n\nFor the final step, I'll bind all the data into a `data.frame` with the updated `purrr::list_rbind()` function (set `names_to = \"id\"`).\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") |> \n  dplyr::glimpse()\n```\n:::\n\nNow that we have a complete recipe, I store the result in `nyt_data_proc`. I can also confirm all files were imported and wrangled by checking the `count()` of `id`.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt_data_proc}\nnyt_data_proc <- raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") \n```\n\n```{r}\nnyt_data_proc |> dplyr::count(id)\n```\n:::\n\n## Export multiple datasets \n\n> *You have a dataset you'd like to split into individual `data.frame`s, then export these into separate file paths*\n\nI have a processed dataset with seven data files (`nyt_data_proc`), and I want to export these into seven processed data files in a `dds-nyt/processed/` folder. \n\nCreating a vector of processed data file paths is a little more involved because I wanted to add a date prefix to the exported files, and because I want to add this path as a variable *in the `nyt_data_proc` dataset*. \n\nBelow I create a new `file_nm` and `proc_file_pth` column to `nyt_data_proc`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: proc_file_pth\n#| eval: true\n#| collapse: true\n# create file names \nnyt_data_proc <- dplyr::mutate(.data = nyt_data_proc,\n        file_nm = tools::file_path_sans_ext(base::basename(id)),\n        proc_file_pth = paste0(\"dds-nyt/processed/\", \n                        as.character(Sys.Date()), \"-\", \n                        file_nm))\nnyt_data_proc |> dplyr::count(proc_file_pth)\n```\n:::\n\nNote that I don't include the file extension in `proc_file_pth`, because I might want to use different file types when I'm exporting. \n\nI'll cover two methods for exporting datasets from a list. \n\nIn this first method, I'll use the `base::split()` function to split `nyt_data_proc` by the `proc_file_pth` variable into a list of data frames. I'll also use `utils::head()`, `purrr::walk()`, and `dplyr::glimpse()` to view the output. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: split_samp_nyt_proc\n#| eval: true\n#| collapse: true\nsplit(x = nyt_data_proc, f = nyt_data_proc$proc_file_pth) |>\n  utils::head(3) |> \n  purrr::walk(.f = glimpse)\n```\n:::\n\nI can see this is returning a list of data frames as expected, so now I need to pass this list into `purrr::walk2()` so I can iterate `vroom::vroom_write()` over the processed data paths in `proc_file_pth`.\n\n1. First I create the processed data folder (`dds-nyt/processed/`)   \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: create_processed\n#| eval: true\n#| collapse: true\nfs::dir_create(\"dds-nyt/processed/\")\n```\n:::\n\n2. Second, I create the `.x` argument, which is the split list of `nyt_data_proc` by `proc_file_pth`   \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: by_proc_pths\n#| eval: true\n#| collapse: true\n# split nyt_data_proc (.x)\nby_proc_pths <- nyt_data_proc |> \n  split(nyt_data_proc$proc_file_pth)\n```\n:::\n\n3. Third, I get the unique processed data paths in the `proc_file_pth` column and store it as a vector for the `.y`  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: proc_pths\n#| eval: true\n#| collapse: true\n# get unique processed paths in nyt_data_proc (.y) with .csv extension\nproc_pths <- paste0(unique(nyt_data_proc$proc_file_pth), \".csv\")\nproc_pths\n```\n:::\n\nNow I can perform `purrr::walk2()` on `by_proc_pths` using `proc_pths` and `vroom::vroom_write()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: split_samp_nyt_proc_walk2\n#| eval: true\n#| collapse: true\n# iterate with .f\nwalk2(.x = by_proc_pths, .y = proc_pths, \n      .f = vroom::vroom_write, delim = \",\")\n# or as an anonymous function \n```\n:::\n\nOr I could write this as an an anonymous function:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: split_samp_nyt_proc_walk2_anon\n#| eval: true\n#| collapse: true\nnyt_data_proc |> \n  split(nyt_data_proc$proc_file_pth) |> \n  walk2(.y = proc_pths, \n    \\(x, y)\n    vroom::vroom_write(x = x, \n      file = y,  delim = \",\"))\n```\n:::\n\nI'll want to perform a sanity check on this output with the first exported item in `dds-nyt/processed` and check it against the `nyt1_proc` data to evaluate the differences. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt1_proc_check_01\n#| eval: true\n#| collapse: true\nnyt1_proc_check_01 <- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n```\n:::\n\nI'll check the differences with `diffobj::diffStr()`. Click on Code below to view the differences: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: diffStr_nyt1_proc_check_01\n#| code-fold: true\n#| eval: true\nwaldo::compare(\n  x = names(nyt1_proc),\n  y = names(nyt1_proc_check_01), \n  max_diffs = 20)\n```\n:::\n\nThese are differences I'd expect, given the two data frames will have *slightly* different columns (`id`, `file_nm`, and `proc_file_pth`)\n\n### `group_walk()`\n\nAnother option involves the `group_walk()` function from `dplyr` (**WARNING:** this is experimental). But I need to remove the processed folder so I'm not confusing myself: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: delete_processed\n#| eval: true\nwalk(.x = list.files(path = \"dds-nyt/processed\", \n                     full.names = TRUE, \n                     pattern = \".csv$\"),\n    .f = fs::file_delete)\nfs::dir_tree(\"dds-nyt\", recurse = TRUE)\n```\n:::\n\nThe [help file on `group_walk()`](https://dplyr.tidyverse.org/reference/group_map.html) gives an example with `purrr`'s formula syntax (which I've adapted below):  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: group_walk_formula\n#| eval: false\n#| collapse: true\nnyt_data_proc |> \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk( ~vroom::vroom_write(x = .x, \n                          file = paste0(.y$proc_file_pth, \".csv\"),\n                          delim = \",\"))\n```\n:::\n\nI've also re-written this as an anonymous function (which is more stable, since the formula syntax is no longer recommended). \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: group_walk_anon\n#| eval: true\n#| collapse: true\n# now re-create\nfs::dir_create(\"dds-nyt/processed/\")\nnyt_data_proc |> \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk(\\(x, y) \n    vroom::vroom_write(\n    x = x, \n    file = paste0(y$proc_file_pth, \".csv\"),\n    delim = \", \")\n    )\n# check\nfs::dir_tree(\"dds-nyt/processed/\", pattern = \"csv$\")\n```\n:::\n\nOnce again, I'll import the first file in the new processed data folder and check it against the columns `nyt1_proc_check_01` data to evaluate the differences.  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt1_proc_check_02\n#| eval: true\n#| collapse: true\n# now re-check\nnyt1_proc_check_02 <- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n```\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: waldo_nyt1_proc_check_02\n#| eval: true\n#| collapse: true\nwaldo::compare(\n  x = names(nyt1_proc_check_01),\n  y = names(nyt1_proc_check_02), \n  max_diffs = 20)\n```\n:::\n\n\n```{r}\n#| label: master_clean_up_dds_nyt\n#| echo: false\nfs::dir_delete(\"dds-nyt/raw\")\nfs::dir_delete(\"dds-nyt/processed/\")\nfs::dir_delete(\"dds-nyt\")\n```\n\n\n# Recap: `purrr` and iteration\n\nIn this post I've covered iteration and some of the new additions to the `purrr` version 1.0. These include: \n\n1. `purrr::map_vec()` (replaces `map_raw()`)\n\n2. Progress bars \n\n3. `purrr::list_rbind()` (replaces `map_dfr()`)\n\n4. The experimental `dplyr::group_walk()` function \n\nFor more information, check out the following: \n\n- [`purrr` package website](https://purrr.tidyverse.org/) \n\n- [Iteration chapter in R for data science](https://r4ds.hadley.nz/iteration.html) \n\n- [`purrr` version 1.0 blog post](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) and [video from Posit](https://www.youtube.com/watch?v=EGAs7zuRutY) \n\n\n:::: {style=\"font-size: 1.10em;\"}\n::: {.callout-tip icon=false}\n## REACP: `purrr` syntax variations\n\n::: {style=\"font-size: 1.25em;\"}\n**Standard**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# define .x and .f\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Anonymous function**\n:::\n\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# anonymous shorthand notation\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Formula (deprecated)**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as normal expression\nmy_list |> purrr::map(~ tolower(.x))\n```\n:::\n:::\n::::\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: utils\n#| eval: true\n#| echo: false\n#| include: false\nsource(\"../_common.R\")\nlibrary(kableExtra)\nmixed_list <- make_mixed_list()\nmy_list <- make_my_list()\n```\n\n<!--\nhttps://mjfrigaard.github.io/posts/vanilla-shiny/\n\nhttps://mjfrigaard.github.io/posts/my-pkg-app/\n\nhttps://mjfrigaard.github.io/posts/my-golem-app/\n\nhttps://mjfrigaard.github.io/posts/my-leprechaun-app/\n\nhttps://mjfrigaard.github.io/posts/my-rhino-app/\n-->\n\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: pkgs\n#| echo: true\n#| message: false \n#| warning: false\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(sloop)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(waldo)\n```\n:::\n\nThis post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I will cover below. But first, I'll dive into some attributes of R's functions and objects that make `purrr` particularly useful, and I'll work through iteration problems I've encountered (and solved with `purrr`).\n\n# **Refresher**: functions and objects \n\nIf you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.\n\nIn a functional programming language like R, it's nice when to have functions perform a lot of the work I'd have to write into a `for` loop. \n\n## Generic functions & S3 objects\n\nR's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` and `summary()` functions are S3 generic function: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r isS3stdGeneric}\nsloop::ftype(plot)\nsloop::ftype(summary)\n```\n:::\n\nWhich means `plot()` can be applied to S3 objects, like time-series (`ts`) and rectangular datasets (`data.frame`):\n\n::: {style=\"font-size: 0.90em;\"}\n```{r LakeHuron}\n#| label: LakeHuron\n#| echo: true\n#| eval: true\n#| collapse: true\nsloop::otype(datasets::LakeHuron)\nclass(datasets::LakeHuron)\nsloop::otype(datasets::chickwts)\nclass(datasets::chickwts)\n```\n\n```{r chickwts}\n#| label: summary_demo\n#| collapse: true\nsummary(datasets::LakeHuron)\nsummary(datasets::chickwts)\n```\n\n```{r}\n#| layout-ncol: 2\n#| fig-cap: \n#|   - \"Time-series plot\"\n#|   - \"Scatter Plot\"\nplot(datasets::LakeHuron)\nplot(datasets::chickwts)\n```\n:::\n\n`summary()` is a particularly versatile function, because it can be used on `data.frame`s, a single column in a `data.frame`, model outputs, and more. \n\n::: {style=\"font-size: 0.90em; color: #696969;\"}\n*Click **Code** below to view an example using `summary()`*\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n```{r lm}\n#| label: lm_generic\n#| code-fold: true\n#| collapse: true\n\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\nsummary(mtcars$mpg)\n\n# store model output  -------------------------------------------------------\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n```\n:::\n\n\n## FP + OOP \n\n> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition\n\n`plot()` and `summary()` are parametric polymorphic (generic) functions, which means they have slightly different behaviors based on the objects passed into them. \n\nAs I can see, generic functions are flexible and efficient because of not having to re-define a new function for each input object--outputs from generic functions will automatically change (in part) depending on the structure of the object provided to them.\n\nThe relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving iteration problems we commonly encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.\n\n## Iteration problems \n\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: \n\n  1. You have a list of objects and you'd like to apply a function (or a series of functions) over the elements in the list\n  \n  2. You have a folder full of files you'd like to rename or copy to a new directory   \n\n  3. You'd like to download a collection of files from separate URLS  \n\n  4. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset\n\n  5. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. \n\nThese are all problems I've personally encountered that required a variety of iteration tools to tackle. I'll start with the first example because the principles remain the same (regardless of the size/scope of the problem):\n\n\n# **The `for` loop**\n\n`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: \n\n> \"*for each `item` in `object`, do `operation`*\"\n\nI have a list (`my_list`), with items in various cases:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r my_list}\n#| label: my_list\n#| collapse: true\nmy_list\n```\n:::\n\nIf I try to use the `tolower()` on `my_list`, it returns a vector.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: tolower_my_list\n#| collapse: true\ntolower(my_list) |> str()\n```\n:::\n\nHow can I apply the `tolower()` function to each item in `my_list`, and return the original object type? I'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:\n\n-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'\n\n      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`) \n      \n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| collapse: true\n    seq_along(my_list)\n    # take single value of 'x'\n    seq_along(my_list)[1]\n    # use this to get 'items in object'\n    my_list[[seq_along(my_list)[1]]]\n    ```\n    :::\n    \n-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)\n\n    - Test this with a few values if you like\n    \n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    tolower(my_list[[2]])\n    ```\n    :::\n\n-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size\n\n    - Two methods for creating empty lists  \n    \n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| label: empty_list\n    #| collapse: true\n    vector(mode = \"list\", length = 3)\n    list(NULL, NULL, NULL)\n    ```\n    :::\n\nFinally, we put it all together in a `for` loop\n\n::: {style=\"font-size: 1.0em;\"}\n```{r}\n#| label: for_loop\n# define capture object\nlc_list <- vector(mode = \"list\", length = 3)\n# write sequence\nfor (x in seq_along(my_list)) {        \n  # write operations/capture in object\n  lc_list[[x]] <- tolower(my_list[[x]])\n  # clean up container\n  names(lc_list) <- c(\"words\", \"sentences\", \"letters\")\n}\nlc_list\n```\n:::\n\nThis was a simple example, but it demonstrates the basic components in a `for` loop: \n\n1. The sequence to index \n    - `for (x in seq_along(my_list))`  \n2. The operations to iterate   \n    - `tolower(my_list[[x]])`   \n3. The object to capture the results  \n    - `lc_list <- vector(mode = \"list\", length = 3)` and  \n    - `lc_list[[x]]`\n  \n# **Base R**\n\nbase R has the `_apply` family of functions (`apply()`, `lapply()`, `sapply()`, `vapply()`, etc.) that remove a lot of the 'book keeping' code we had to write in the `for` loop.\n\n\n## `lapply()`\n\n\nSticking with the `my_list` and `tolower()` example, the `apply` function I want is `lapply()` (pronounced 'l-apply'), and the `l` stands for list.\n\n`lapply()` has only two required arguments: \n\n  - `X` the object we want to iterate over \n\n  - `FUN` being the function we want iterated \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: lapply_intro\nlapply(X = my_list, FUN = tolower)\n```\n:::\n\n\n## `sapply()`\n\n`sapply()` attempts to simplify the result depending on the `X` argument. If `X` is a list containing vectors where every element has the same length (and it's greater than 1), then `sapply()` returns a matrix:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: sapply_list\nstr(my_list[1])\nsapply(X = my_list[1], FUN = tolower)\n```\n:::\n\nIf a vector is passed to `X` where every element is length 1, then a vector is returned: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: sapply_vector\nstr(my_list[[1]])\nsapply(X = my_list[[1]], FUN = tolower) \n```\n:::\n\nFinally, if `X` is a list where elements have a length greater than 1, then a list is returned (making it identical to `lapply()`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n```\n:::\n\nThis is because `sapply` is a wrapper around `lapply`, but has `simplify` and `USE.NAMES` set to  `FALSE` (see what happens below when I change them to `TRUE`)\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: sapply_waldo\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n```\n:::\n\n## Anonmymous functions \n\nThe `FUN` argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in `my_list`, I could pass an anonymous function the `FUN` (with the index):\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: lapply_anon_fun\nlapply(X = my_list, FUN = function(x) x[[2]])\n```\n:::\n\n## `vapply()`\n\nFinally `vapply()` is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: vapply_anon_fun\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n```\n:::\n\n\nThe `apply` functions get us much further than writing `for` loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) **write less code.** Unlike generic functions, `apply` functions are designed to work with specific object types, and return values depending on these objects.\n\n\nOne downside of apply functions is they don't play well with `data.frame`s or `tibble`s. However, we can control their return values (and manually supply these to `tibble::tibble()` or `data.frame()`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: tibble_from_list\n#| code-fold: true\n#| eval: false\ntibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n```\n:::\n\n\nAnother downside of the `apply` functions is they're not very uniform. Each function has slight variations in their arguments and rules for return values. This is where `purrr` comes in...\n\n# **`purrr`**\n\nIf you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)\n\n1. Do it for one element\n\n2. Turn it into a recipe\n\n3. Use `purrr::map()` to do it for all elements\n\nI'll work through these three steps below using `my_list` and `tolower()`\n\n## 1. Do it for one element\n\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\n\nFor this example, I need to subset `my_list` for a single element at position `[[1]]`, `[[2]]`, or `[[3]]` (or using one of the vector names). \n\nI'll then pass this element to `tolower()` and make sure it's the desired behavior:\n\n::: {style=\"font-size: 0.90em;\"}\n```r\n# subset an element from the list\n? <- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n```\n:::\n\n- `? <- my_list[[?]]` = subset element from the list (`my_list`)\n\n- `tolower(?)` = apply operation (i.e., function) to extracted element.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nmy_words <- my_list[['words']]\ntolower(my_words)\n```\n:::\n\nNow that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.\n\n## 2. Turn it into a recipe\n\nA standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.\n\n- `.x` =  a list or atomic vector \n\n- `.f` = the function we want to apply over every element in `.x`\n\n::: {style=\"font-size: .90em;\"}\n```r\n.x = my_list, .f = tolower\n```\n:::\n\n## 3. `map()` it across all elements\n\nIn `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` \n\nIf I want to convert the case of every element in `my_list` to lowercase with `tolower()` I would use the following standard `purrr::map()` format:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: my_list_purrr_standard\n#| results: hold\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\nAnd there you have it! `map()` is the core function and workhorse of the `purrr` package. It's important to note that `purrr::map()` always returns a list, regardless of the object supplied to `.x`. \n\n# **Version 1.0.0 updates**\n\nNow I'll cover some of the updates in `purrr` 1.0.0. I'll be using `mixed_list`, a list with five different types of vectors. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r mixed_list}\n#| label: mixed_list\nmixed_list\n```\n:::\n\n## `map()` updates \n\nAs noted above, by default `purrr::map()` returns a list. If I'd like to return a vector, I can use one of the `map_` variations (there's one for each vector type). \n\n-   By mapping the `is.<type>()` functions the elements in `mixed_list`, I can test which elements in `mixed_list` return `TRUE`:\n\n    -   `map_lgl()`: returns a logical vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: false\n    #| collapse: false\n    mixed_list |> purrr::map_lgl(\\(x) is.logical(x))\n    ```\n    :::\n\n    -   `map_int()`: returns an integer vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: false\n    #| collapse: false\n    mixed_list |> purrr::map_int(\\(x) is.integer(x))\n    ```\n    :::\n\n    -   `map_dbl()`: returns a double vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: false\n    #| collapse: false\n    mixed_list |> purrr::map_dbl(\\(x) is.double(x))\n    ```\n    :::\n\n    -   `map_chr()`: returns a character vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    #| warning: true\n    #| message: true\n    #| collapse: false\n    mixed_list |> purrr::map_chr(\\(x) is.character(x))\n    ```\n    :::\n    \nWhen we test for characters in `mixed_list`, we see the following warning:\n\n::: {style=\"font-size: 0.90em;\"}\n> `Warning: Automatic coercion from logical to character was deprecated in purrr`\n> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`\n:::\n\nAs we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).\n\n### `map_vec()`\n\n<br>\n\nHowever, the previous `purrr::map_raw()` function has been replaced with `purrr::map_vec()`, which \"*simplifies to the common type of the output.*\" I'll demonstrate below with the characters in `mixed_list`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| warning: true\n#| message: true\n#| eval: true\nmixed_list |> purrr::map_vec(\\(x) is.character(x))\n```\n:::\n\nNotice the difference in output?  The results are the same as above, but output is not commented (`##`). The same is true when I test the dates in `mixed_list` using `lubridate::is.Date()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| warning: true\n#| message: true\n#| eval: true\nmixed_list |> purrr::map_vec(\\(x) lubridate::is.Date(x))\n```\n:::\n\n## Anonymous functions\n\nR introduced the shorthand anonymous function syntax in version [4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html):\n\n> \"*`\\(x) x + 1` is parsed as `function(x) x + 1`.*\" \n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\n-   Standard anonymous function  \n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    (function(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    :::\n\n-   The updated anonymous syntax is below:\n\n    ::: {style=\"font-size: 0.90em;\"}\n    ```{r}\n    (\\(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    :::\n\nWriting the code above using an anonymous function would look like this:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: my_list_purrr_anonymous_fun\n#| results: hold\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\nAnonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* \n\nI'll confirm the outputs from both methods are identical using `waldo::compare()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: my_list_purrr_test_waldo\n#| results: hold\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(\\(x) tolower(x)))\n```\n:::\n\n:::: {.callout-important icon=false}\n## The formula (`~ .x + 1`)\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\nPrior to `purrr` v1.0.0, I could also use the formula syntax, but now it's \"*only recommended if you require backward compatibility with older versions of R.*\" I'll cover the formula syntax briefly because you're likely to encounter it. \n:::\n\n::: {style=\"font-size: 1.10em;\"}\nThe formula syntax is typically used with pipes, so the contents of `purrr::map()` become the right-hand side of the formula, with the function we want to iterate (`<FUNCTION>`) and a placeholder (`.x`) in the appropriate argument.\n:::\n\n::: {style=\"font-size: 1.20em;\"}\n``` bash\n<OBJECT> |> purrr::map(~ <FUNCTION>(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nFor the example above, `my_list` is 'piped' to `purrr::map()`, where the formula maps the `tolower()` function (using the `.x` placeholder).\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n```r\n# written as normal expression\n my_list |> purrr::map(~ tolower(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nJenny Bryan offers a great description on [her `purrr` tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), \n\n> \"*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*\"\n\nI can double-check to see that the output from two variations are identical using `waldo::compare()`.\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n```{r}\n#| label: my_list_purrr_anonymous\n#| results: hold\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n:::\n\n::::\n\n\n\n<!--\n# map for `data.frame` and `tibble`s\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nswdata <- dplyr::select(dplyr::starwars, !where(is.list))\npurrr::map_df(.x = swdata, .f = tolower)\n```\n:::\n-->\n\n# Worked Examples\n\nIn this section, I'll be working through some of the uses I've for `purrr`'s functions. I've tried to choose tasks that are common across *most* projects so my code can be easily copied and adapted. \n\n## Downloading files \n\n> *You'd like to download a collection of files from separate URLS*\n\nI have a collection of 30 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) in a [GitHub repo](https://github.com/mjfrigaard/dds-data). Let's assume I want to download one week of these files into my RStudio session (without downloading the repo).\n\nI'll navigate to the raw url for the first data file (`nyt1.csv`), then paste this into a character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nnyt_url <- \"https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n```\n:::\n\nKnowing that all of the files on GitHub with have a similar sheme and domain, I can use `nyt_url` to generate urls for each of the 7 files. \n\n1. First I get the folder of the files on GitHub with `fs::path_dir()` \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_file_url\n#| eval: true\n#| collapse: false\n# create file urls \nnyt_dir_url <- fs::path_dir(nyt_url)\nnyt_dir_url\n```\n:::\n\n2. I create a vector with the 7 file names\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_file_nms\n#| eval: true\n#| collapse: false\n# create file names for 7th through 13th\nnyt_file_nms <- paste0(\"nyt\", 7:13, \".csv\")\nnyt_file_nms\n```\n:::\n\n3. I combine the directory portion of the url with file name in `nyt_file_urls`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_file_urls\n#| eval: true\n#| collapse: false\n# combine\nnyt_file_urls <- paste(nyt_dir_url, nyt_file_nms, sep = \"/\")\nnyt_file_urls\n```\n:::\n\nI'll need another vector of destination file names on my local machine, which I can do by combining the file names (`nyt_file_nms`) with the local destination folder (`dds-nyt`).\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt_local_pths\n#| eval: true\n#| collapse: false\nnyt_local_pths <- paste(\"dds-nyt\", nyt_file_nms, sep = \"/\")\nnyt_local_pths\n```\n:::\n\nAfter creating the destination folder, I'll use the `download.file()` function to test downloading a single `.csv` files into my local folder (`dds-nyt/`). `download.file()` has a progress bar which tells me if the file downloaded successfully. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: download.file\n#| eval: true\n#| collapse: false\n#| results: asis\n# do it for one\nfs::dir_create(\"dds-nyt\")\ndownload.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])\n```\n\n```bash\ntrying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'\nContent type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)\n==================================================\ndownloaded 4.7 MB\n```\n:::\n\n\n`download.file()` takes two inputs (`url` and `destfile`), which changes the recipe a bit, because I need a `purrr` function with the following:\n\n1. `.x` the input vector of existing url paths \n\n2. `.y` the output vector of destination file paths \n\n3. Additional arguments passed from `download.file()` (like `quiet = TRUE`)\n\nIn this case, I don't need `purrr` to return value--I just need the `purrr` function to iterate over the items and write them to the new location.\n\n`walk()` is ideal for this circumstance:\n\n> \"*`walk()` returns the input `.x` (invisibly)*\" and \"*The return value of `.f()` is ignored*\"\n\n***What do 'return `.x` invisibly' and 'the side-effect of `.f`' mean?***\n\n### Return invisibly \n\nThe previous `purrr` functions I covered varied in the kinds of values they returned (lists vs. vectors), but for some operations I won't need a return value. If I'm ever curious about whether I should be using `map()` or `walk()`, I'll ask myself, *\"would it make sense to assign the output from this function to an object?*\"\n\nIf the answer is no, then I probably need to be thinking `walk()` instead of `map()`\n\n### Side-effects \n\nIn the help documentation `walk()`'s description states, \"*calls .f for its side-effect*\", which can be generally interpreted as, \"*there's nothing to assign the output from that function to.*\"\n\n### `purrr` progress bars \n\nI'll use `walk2()` below and add `.progress = TRUE` to view the `purrr` progress bar (and `quiet = TRUE` to silence the `download.file()` progress bar).  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: walk2_download_files\nwalk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, \n      .progress = TRUE, quiet = TRUE)\n```\n:::\n\n<br>\n\n\n```{r}\n#| label: purrr-progress\n#| echo: false\n#| fig-align: center\n#| out-width: '100%'\n#| fig-dpi: 320\n#| fig-asp: 0.618\nknitr::include_graphics(path = \"purrr-progress.gif\")\n```\n\n\n<br>\n\nI can confirm the download using `fs::dir_tree()`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: dir_tree_download_files\nfs::dir_tree(\"dds-nyt\")\n```\n:::\n\n\n## Copying a directory of files \n\n> *You have a folder of files you'd like to rename or copy to a new directory*\n\nThe collection of 7 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) are now in the `dds-nyt/` folder. \n\nAs with any project, I don't want to alter the raw data, so I'm going to copy these files into `dds-nyt-raw/` and `dds-nyt-processed/`. I also want the processed file names to have a date stamp prefix. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: file_pths\nfile_pths <- list.files(\"dds-nyt\", full.names = TRUE, pattern = \".csv$\")\nfile_pths\n```\n:::\n\nI'll start with the raw data folder. I need to create a vector of the new raw file paths and names: `raw_file_pths` (the raw data paths will have the original file names)\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: raw_file_pths\n#| eval: true\n#| collapse: true\n# do it for one\ngsub(pattern = \"^dds-nyt\",\n  replacement = \"dds-nyt/raw\",\n  x = file_pths[1])\n\n# write the recipe\nfile_pths |> purrr::map_chr(\\(x) gsub(x, \n                                pattern = \"^dds-nyt\", \n                                replacement = \"dds-nyt/raw\")) |> head()\n\n# map it across all\nraw_file_pths <- file_pths |> \n                  purrr::map_chr(\\(x) gsub(x, \n                                        pattern = \"^dds-nyt\", \n                                        replacement = \"dds-nyt/raw\"))\n```\n:::\n\nBefore copying the files, I need to create the destination folder for the raw data (`dds-nyt/raw`). Then, I'll make sure I can copy the first element from `file_pths` into the path in the first element of `raw_file_pths`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: create_paths\n#| eval: true\nfs::dir_create(\"dds-nyt/raw\")\n# do it for one\nfs::file_copy(\n  path = file_pths[1], \n  new_path = raw_file_pths[1], \n  overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n```\n:::\n\n\nI can see this is working, so I can use `purrr::walk2()` to move all the files from `dds-nyt/` to `dds-nyt/raw/`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: walk2_file_copy\npurrr::walk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, \n      .progress = TRUE, overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n```\n:::\n\nNow that I've copied the files into their respective folders, I'll need to remove the files from their original location in the parent `dds-nyt` folder.\n\nFortunately, I have a vector of these files in `file_pths`, and I can test removal with `fs::file_delete()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: test_file_delete\nfs::file_delete(file_pths[1])\n```\n:::\n\nGreat! Now that I know this will work, I'll use `walk()` because I want `.x` returned invisibly and the side-effect of `.f`. \n\nBut I've also deleted the first element in `file_pths`, so when `fs::file_delete()` goes looking for that file, it will find nothing and returned an error. \n\n::: {style=\"font-size: 0.90em;\"}\n```{bash, eval=FALSE}\nError in `map()`:\nâ„¹ In index: 1.\nCaused by error:\n! [ENOENT] Failed to remove 'dds-nyt/nyt10.csv': no such file or directory\n```\n:::\n\nI can protect against this by supplying the output from `list.files()` directly to `purrr::walk2()`, but include a `pattern` so it only matches the `.csv` files.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\npurrr:::walk(\n  # list CURRENT files \n    .x = list.files(\n      path = \"dds-nyt\",\n      pattern = \".csv$\",\n      full.names = TRUE),\n    # map function\n    .f = fs::file_delete)\n```\n:::\n\n\nAnd confirm the new folder contents and structure\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nfs::dir_tree(\"dds-nyt\", type = \"any\", recurse = TRUE)\n```\n:::\n\n\n## Import multiple datasets \n\n> *You have several days of data, and each day is contained in separate file. You'd like to read these data into R, and combine them into a single dataset*\n\nNow that I have separate raw and processed folders, I can import the NYT data into R. Below I've imported a single file from the `raw` data folder to examine it's contents:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt1}\n#| label: import_nyt1.csv\nnyt1 <- vroom::vroom(file = raw_file_pths[1],\n  delim = \",\", \n  show_col_types = FALSE)\nstr(nyt1)\n```\n:::\n\nEach `nyt` file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: `Age`, `Gender` (0 = female, 1 = male), `Impressions` (number impressions), `Clicks` (number clicks), and a binary indicator for signed in or not `Signed_in`. \n\nI'll add some hypothetical wrangling steps to make this example more realistic.\n\n  1. Create `age_group`, an ordered factor which contains six levels of Age (\"<18\", \"18-24\", \"25-34\", \"35-44\", \"45-54\", \"55-64\", and \"65+\")\n\n  2. Create `ctr_rate` or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.\n\n  3. Create `female`, a factor version of `Gender`, where when `Gender` = `0`, then `female` = `\"yes\"`, and when `Gender` = `1`, then `female` = `\"no\"` \n\n  4. Create `signed_in`, a factor variable with levels `\"no\"` and `\"yes\"` from the `Signed_In` = `0` and `1`\n\nI've bundled all of these steps into a function (`nyt_data_processing()`) that I can pass each dataset through:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt_data_processing}\n#| label: fun_nyt_data_processing\n#| code-fold: true \nnyt_data_processing <- function(nyt_csv) {\n  orig_nms <- c(\"Age\", \"Gender\", \"Impressions\", \"Clicks\", \"Signed_In\")\n  nyt_nms <- names(nyt_csv)\n  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {\n    cli::cli_abort(\"these data don't have the correct columns!\")\n  } else {\n    nyt_proc <- nyt_csv |>\n      dplyr::mutate(\n        # create age_group variable\n        age_group = case_when(\n          Age < 18 ~ \"<18\",\n          Age >= 18 & Age < 25 ~ \"18-24\",\n          Age >= 25 & Age < 35 ~ \"25-34\",\n          Age >= 35 & Age < 45 ~ \"35-44\",\n          Age >= 45 & Age < 55 ~ \"45-54\",\n          Age >= 55 & Age < 65 ~ \"55-64\",\n          Age >= 65 ~ \"65+\"\n        ),\n        # factor age_group (ordered)\n        age_group = factor(age_group,\n          levels = c(\n            \"<18\", \"18-24\", \"25-34\",\n            \"35-44\", \"45-54\", \"55-64\", \"65+\"\n          ),\n          ordered = TRUE\n        ),\n        # create CTR variable\n        ctr_rate = round(x = Clicks / Impressions, digits = 3),\n        # create new Female variable\n        female = case_when(\n          Gender == 0 ~ \"yes\",\n          Gender == 1 ~ \"no\",\n          TRUE ~ NA_character_\n        ),\n        # factor female (un-ordered)\n        female = factor(female,\n          levels = c(\"no\", \"yes\")\n        ),\n        Signed_In = case_when(\n          Signed_In == 0 ~ \"no\", \n          Signed_In == 1 ~ \"yes\", \n          TRUE ~ NA_character_),\n        # factor Signed_In (un-ordered) \n        Signed_In = factor(Signed_In, levels = c(\"no\", \"yes\"))) |>\n      # format columns\n      janitor::clean_names()\n  }\n  return(nyt_proc)\n}\n```\n:::\n\nI'll do some quick checks to make sure it only works with the raw data columns:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt1_proc}\n#| label: test_nyt_data_processing\n#| error: false\nnyt1_proc <- nyt_data_processing(nyt1)\nstr(nyt1_proc)\n```\n:::\n\nI'll run `nyt_data_processing()` against a processed data file (`nyt1_proc`)\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: test_nyt_data_processing_error\n#| error: true\nnyt_data_processing(nyt1_proc)\n```\n:::\n\nNow I'm ready to write the import step. First I'll store the raw file paths in `raw_data_pths`\n\n::: {style=\"font-size: 0.90em;\"}\n```{r raw_data_pths}\nraw_data_pths <- list.files(path = \"dds-nyt/raw\", pattern = \".csv$\", full.names = TRUE)\n```\n:::\n\nWe'll test `purrr::map()` and `vroom::vroom()` to import the `.csv` files in `raw_data_pths` into a list. I also add `utils::head()` and `dplyr::glimpse()` to limit the output.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # import\n  purrr::map(\n    vroom::vroom, \n        delim = \",\", show_col_types = FALSE) |> \n  utils::head(2) |> \n  dplyr::glimpse()\n```\n:::\n\nThis returns a list, but you may have noticed I don't have a great way for keeping track of the data files in the list--this is where `purrr::set_names()` comes in handy. \n\n`purrr::set_names()` works a lot like `names()`, but `purrr::set_names()` will automatically set the names of `x` to `as.character(x)` if no names are provided to `nm`. See below:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> purrr::set_names()\n```\n:::\n\nNow the imported file will have their file path and name associated with the dataset:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import  \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  utils::head(2) |> \n  dplyr::glimpse()\n```\n:::\n\nTo add the wrangling function, I can pipe in another call to `purrr::map()`, and add  `nyt_data_processing()`. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  utils::head(2) |> \n  dplyr::glimpse()\n```\n:::\n\n### `list_rbind()`\n\nFor the final step, I'll bind all the data into a `data.frame` with the updated `purrr::list_rbind()` function (set `names_to = \"id\"`).\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\nraw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") |> \n  dplyr::glimpse()\n```\n:::\n\nNow that we have a complete recipe, I store the result in `nyt_data_proc`. I can also confirm all files were imported and wrangled by checking the `count()` of `id`.\n\n::: {style=\"font-size: 0.90em;\"}\n```{r nyt_data_proc}\nnyt_data_proc <- raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") \n```\n\n```{r}\nnyt_data_proc |> dplyr::count(id)\n```\n:::\n\n## Export multiple datasets \n\n> *You have a dataset you'd like to split into individual `data.frame`s, then export these into separate file paths*\n\nI have a processed dataset with seven data files (`nyt_data_proc`), and I want to export these into seven processed data files in a `dds-nyt/processed/` folder. \n\nCreating a vector of processed data file paths is a little more involved because I wanted to add a date prefix to the exported files, and because I want to add this path as a variable *in the `nyt_data_proc` dataset*. \n\nBelow I create a new `file_nm` and `proc_file_pth` column to `nyt_data_proc`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: proc_file_pth\n#| eval: true\n#| collapse: true\n# create file names \nnyt_data_proc <- dplyr::mutate(.data = nyt_data_proc,\n        file_nm = tools::file_path_sans_ext(base::basename(id)),\n        proc_file_pth = paste0(\"dds-nyt/processed/\", \n                        as.character(Sys.Date()), \"-\", \n                        file_nm))\nnyt_data_proc |> dplyr::count(proc_file_pth)\n```\n:::\n\nNote that I don't include the file extension in `proc_file_pth`, because I might want to use different file types when I'm exporting. \n\nI'll cover two methods for exporting datasets from a list. \n\nIn this first method, I'll use the `base::split()` function to split `nyt_data_proc` by the `proc_file_pth` variable into a list of data frames. I'll also use `utils::head()`, `purrr::walk()`, and `dplyr::glimpse()` to view the output. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: split_samp_nyt_proc\n#| eval: true\n#| collapse: true\nsplit(x = nyt_data_proc, f = nyt_data_proc$proc_file_pth) |>\n  utils::head(3) |> \n  purrr::walk(.f = glimpse)\n```\n:::\n\nI can see this is returning a list of data frames as expected, so now I need to pass this list into `purrr::walk2()` so I can iterate `vroom::vroom_write()` over the processed data paths in `proc_file_pth`.\n\n1. First I create the processed data folder (`dds-nyt/processed/`)   \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: create_processed\n#| eval: true\n#| collapse: true\nfs::dir_create(\"dds-nyt/processed/\")\n```\n:::\n\n2. Second, I create the `.x` argument, which is the split list of `nyt_data_proc` by `proc_file_pth`   \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: by_proc_pths\n#| eval: true\n#| collapse: true\n# split nyt_data_proc (.x)\nby_proc_pths <- nyt_data_proc |> \n  split(nyt_data_proc$proc_file_pth)\n```\n:::\n\n3. Third, I get the unique processed data paths in the `proc_file_pth` column and store it as a vector for the `.y`  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: proc_pths\n#| eval: true\n#| collapse: true\n# get unique processed paths in nyt_data_proc (.y) with .csv extension\nproc_pths <- paste0(unique(nyt_data_proc$proc_file_pth), \".csv\")\nproc_pths\n```\n:::\n\nNow I can perform `purrr::walk2()` on `by_proc_pths` using `proc_pths` and `vroom::vroom_write()`:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: split_samp_nyt_proc_walk2\n#| eval: true\n#| collapse: true\n# iterate with .f\nwalk2(.x = by_proc_pths, .y = proc_pths, \n      .f = vroom::vroom_write, delim = \",\")\n# or as an anonymous function \n```\n:::\n\nOr I could write this as an an anonymous function:\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: split_samp_nyt_proc_walk2_anon\n#| eval: true\n#| collapse: true\nnyt_data_proc |> \n  split(nyt_data_proc$proc_file_pth) |> \n  walk2(.y = proc_pths, \n    \\(x, y)\n    vroom::vroom_write(x = x, \n      file = y,  delim = \",\"))\n```\n:::\n\nI'll want to perform a sanity check on this output with the first exported item in `dds-nyt/processed` and check it against the `nyt1_proc` data to evaluate the differences. \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt1_proc_check_01\n#| eval: true\n#| collapse: true\nnyt1_proc_check_01 <- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n```\n:::\n\nI'll check the differences with `diffobj::diffStr()`. Click on Code below to view the differences: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: diffStr_nyt1_proc_check_01\n#| code-fold: true\n#| eval: true\nwaldo::compare(\n  x = names(nyt1_proc),\n  y = names(nyt1_proc_check_01), \n  max_diffs = 20)\n```\n:::\n\nThese are differences I'd expect, given the two data frames will have *slightly* different columns (`id`, `file_nm`, and `proc_file_pth`)\n\n### `group_walk()`\n\nAnother option involves the `group_walk()` function from `dplyr` (**WARNING:** this is experimental). But I need to remove the processed folder so I'm not confusing myself: \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: delete_processed\n#| eval: true\nwalk(.x = list.files(path = \"dds-nyt/processed\", \n                     full.names = TRUE, \n                     pattern = \".csv$\"),\n    .f = fs::file_delete)\nfs::dir_tree(\"dds-nyt\", recurse = TRUE)\n```\n:::\n\nThe [help file on `group_walk()`](https://dplyr.tidyverse.org/reference/group_map.html) gives an example with `purrr`'s formula syntax (which I've adapted below):  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: group_walk_formula\n#| eval: false\n#| collapse: true\nnyt_data_proc |> \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk( ~vroom::vroom_write(x = .x, \n                          file = paste0(.y$proc_file_pth, \".csv\"),\n                          delim = \",\"))\n```\n:::\n\nI've also re-written this as an anonymous function (which is more stable, since the formula syntax is no longer recommended). \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: group_walk_anon\n#| eval: true\n#| collapse: true\n# now re-create\nfs::dir_create(\"dds-nyt/processed/\")\nnyt_data_proc |> \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk(\\(x, y) \n    vroom::vroom_write(\n    x = x, \n    file = paste0(y$proc_file_pth, \".csv\"),\n    delim = \", \")\n    )\n# check\nfs::dir_tree(\"dds-nyt/processed/\", pattern = \"csv$\")\n```\n:::\n\nOnce again, I'll import the first file in the new processed data folder and check it against the columns `nyt1_proc_check_01` data to evaluate the differences.  \n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: nyt1_proc_check_02\n#| eval: true\n#| collapse: true\n# now re-check\nnyt1_proc_check_02 <- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n```\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n```{r}\n#| label: waldo_nyt1_proc_check_02\n#| eval: true\n#| collapse: true\nwaldo::compare(\n  x = names(nyt1_proc_check_01),\n  y = names(nyt1_proc_check_02), \n  max_diffs = 20)\n```\n:::\n\n\n```{r}\n#| label: master_clean_up_dds_nyt\n#| echo: false\nfs::dir_delete(\"dds-nyt/raw\")\nfs::dir_delete(\"dds-nyt/processed/\")\nfs::dir_delete(\"dds-nyt\")\n```\n\n\n# Recap: `purrr` and iteration\n\nIn this post I've covered iteration and some of the new additions to the `purrr` version 1.0. These include: \n\n1. `purrr::map_vec()` (replaces `map_raw()`)\n\n2. Progress bars \n\n3. `purrr::list_rbind()` (replaces `map_dfr()`)\n\n4. The experimental `dplyr::group_walk()` function \n\nFor more information, check out the following: \n\n- [`purrr` package website](https://purrr.tidyverse.org/) \n\n- [Iteration chapter in R for data science](https://r4ds.hadley.nz/iteration.html) \n\n- [`purrr` version 1.0 blog post](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) and [video from Posit](https://www.youtube.com/watch?v=EGAs7zuRutY) \n\n\n:::: {style=\"font-size: 1.10em;\"}\n::: {.callout-tip icon=false}\n## REACP: `purrr` syntax variations\n\n::: {style=\"font-size: 1.25em;\"}\n**Standard**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# define .x and .f\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Anonymous function**\n:::\n\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# anonymous shorthand notation\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Formula (deprecated)**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as normal expression\nmy_list |> purrr::map(~ tolower(.x))\n```\n:::\n:::\n::::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"fig-asp":0.618,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","dpi":320,"toc":true,"toc-depth":5,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","knitr":{"opts_chunk":{"collapse":true}},"editor":{"mode":"source"},"theme":{"light":["cosmo","../../custom.scss"]},"fontsize":"1.065em","linestretch":1.25,"title-block-banner":true,"title":"purrr updates (v1.0.0)","author":"Martin Frigaard","date":"2023-04-05","image":"image.png","categories":["iteration","code"],"toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-summary":"show/hide","callout-icon":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}