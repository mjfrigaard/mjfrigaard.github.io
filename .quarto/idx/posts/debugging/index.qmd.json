{"title":"Debugging in RStudio","markdown":{"yaml":{"title":"Debugging in RStudio","subtitle":"Developing code with `browser()`","author":"Martin Frigaard","date":"2023-06-01","categories":["code","debugging"],"image":"image.png","code-fold":"show","code-summary":"show/hide","callout-icon":false,"freeze":true,"execute":{"echo":true,"message":false,"warning":false,"eval":false}},"headingText":"renv::install(\"lobstr\")","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| eval: true \n#| echo: false \n#| include: false\nco_box <- function(color, header, contents = \"Your text\") {\n  class <- switch(color,\n    b = \"note\",\n    g = \"tip\",\n    r = \"important\",\n    o = \"caution\",\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n  switch(color,\n  b = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  g = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  o = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  r = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  stop(\"Invalid `type`\", call. = FALSE)\n  )\n}\noptions(scipen = 999)\nrenv::install(\"mjfrigaard/dbap\", prompt = FALSE)\nlibrary(lobstr)\nlibrary(dbap)\nlibrary(lubridate)\nlibrary(forcats)\n# co_box(color = \"r\", \n#   header = \"ALERT!\", \n#   contents = \"This post is currently under development. Thank you for your patience.\")\n```\n\nIn this post I'll cover using the `browser()` function with RStudio's debugger. RStudio's debugging tools are built into the IDE, which provides a seamless transition between writing, running, and debugging code.\n\n::: {.column-margin}\n![](image.png){width=70%}\n:::\n\n\n# Debugging\n\nDebuggers are a critical tool when you're programming, and they have several benefits that make them a must-use for any R user. You’ll inevitably encounter an error or unexpected behavior while you’re programming. Using a debugger allows you to 'step through' your code line-by-line, which makes it easier to find the precise location of bugs and errors and the conditions under which they occur. \n\nBut debuggers aren't only helpful in dealing with errors. The debugger can also be a great learning tool because it provides an interactive way to see how the code is being executed and the order in which functions are being called. For example, you might know that a function returns a particular object but can't determine how that object was created. Debugging lets us get 'under the hood' of our code and see how it's really working.\n\nYou’re probably doing some version of debugging already. If you’ve ever dropped a call to `print()` or `return()` at some well-placed intermediate point in a function to try and understand its behavior, then you know the challenge debugging tries to solve: **We can’t see what happens inside the parentheses when code is executed.** When you use `print()` or `return()` in this way, it's an attempt to indirectly investigate how/if/where the code is performing its intended purpose. \n\nIn this post, I’ll cover using the `browser()` function and RStudio’s debugger while developing a series of small, modular functions for returning a table of 'package data structures.' The code for this post comes from [`dbap`](https://github.com/mjfrigaard/dbap) ('debugging app-package').\n\n## Getting started\n\nI want to create a function that returns a table of 'data structure' columns that describe the available `data.frame` or `tibble` objects loaded with a package. Below is a small example of the desired return object from this function:\n\n\n::: {style='font-size: 0.90em;'}\n```{r}\n#| eval: true\n#| echo: false\nknitr::kable(\n  data.frame(\n          Package = c(\"dplyr\", \"datasets\"),\n          Dataset = c(\"starwars\", \"mtcars\"),\n               # Title = c(\"Storm tracks data\",\n               #         \"Motor Trend Car Road Tests\"),\n            Class = c(\"tbl_df, tbl, data.frame\", \"data.frame\"),\n          Columns = c(\"13\", \"11\"),\n             Rows = c(\"19066\", \"32\"),\n          Logical = c(\"0\", \"0\"),\n          Numeric = c(\"11\", \"11\"),\n        Character = c(\"1\", \"0\"),\n           Factor = c(\"1\", \"0\"),\n             List = c(\"0\", \"0\"),\n        check.names = FALSE)\n  )\n```\n:::\n\nThis table shows the `storms` data from `dplyr` and the `mtcars` data from `datasets`. The columns include the `Package` the data came from, the dataset name (`Dataset`), the data `Title` from the documentation, the `Class` of the data object, the total number of `Columns` and `Rows`, and the number of columns by type (`Logical`, `Numeric`, `Character`, `Factor` and `List`).\n\nOne of the first steps for creating this function is to verify a package's namespace is loaded. I’ve written the `check_pkg_ns()` to check this.\n\n```{r}\n#| label: check_pkg_ns\n#| eval: true\n#| code-fold: show\n#| code-summary: 'check_pkg_ns()'\ncheck_pkg_ns <- function(pkg, quiet = FALSE) {\n  if (isFALSE(quiet)) {\n    # with messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = FALSE)) {\n        cat(paste0(\"Loading package: \", pkg, \"\\n\"))\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    } else {\n      cat(paste0(\"Package \", pkg, \" loaded\\n\"))\n    }\n  } else {\n    # without messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = TRUE)) {\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    }\n  }\n}\n```\n\n`check_pkg_ns()` checks if a packages’s namespace is loaded, and if not, loads it. This function assumes the package (`pkg`) has been installed with `install.packages()` (I've also written [`check_pkg_inst()`](https://github.com/mjfrigaard/dbap/blob/main/R/check_pkg_inst.R) to check if the package has been installed.)\n\n### Experiment\n\nBefore debugging, I'll read the documentation and help files to find examples or use cases for ‘mini-experiments.' These are designed to clarify any function arguments and learn how the code truly works. Experiments should produce predictable, definitive (preferably incompatible) outputs from each function.\n\n#### Namespace functions\n\nThe help file contains the following helpful statement on `isNamespaceLoaded()`:\n\n> *\"`isNamespaceLoaded(pkg)` is equivalent to but more efficient than `pkg %in% loadedNamespaces()`\"*\n\nFirst, I'll check the loaded namespaces with `loadedNamespaces()`, then look for a package I know *isn't* in the namespace with `isNamespaceLoaded()`. I'll use the `fs` package because it isn't loaded or attached to the `search()` list:\n\n```{r}\n#| eval: false\n#| code-fold: false\n# what's in the namespace? \nloadedNamespaces()\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n [1] \"compiler\"   \"rsconnect\"  \"graphics\"  \n [4] \"tools\"      \"rstudioapi\" \"utils\"     \n [7] \"grDevices\"  \"stats\"      \"datasets\"  \n[10] \"methods\"    \"base\"\n```\n\nCheck if `fs` is in the loaded namespace:\n\n```{r}\n#| eval: false\n#| code-fold: false\n# verify fs is not loaded\nisNamespaceLoaded(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[1] FALSE\n```\n\nThe help file tells me the following about `requireNamespace`:\n\n> *\"`requireNamespace` is a wrapper for `loadNamespace` analogous to `require()` that returns a logical value.\"*\n\n...and...\n\n> *\"`requireNamespace` returns `TRUE` if it succeeds or `FALSE`\"*\n\nI'll load a package (`\"fs\"`) with `requireNamespace()` and verify it's in the namespace with `isNamespaceLoaded()`. \n\n```{r}\n#| eval: false\n#| code-fold: false\n# add \"fs\" to the namespace\nrequireNamespace(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\nLoading required namespace: fs\n[1] TRUE\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\n# verify it's been added \nisNamespaceLoaded(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[1] TRUE\n```\n\nFinally, I'll unload the `\"fs\"` package from the namespace so it can be tested in the debugger.\n    \n```{r}\n#| eval: false\n#| code-fold: false\n#| collapse: true\n# remove fs\nunloadNamespace(\"fs\")\n# verify fs has been unloaded\nisNamespaceLoaded(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[1] FALSE\n```\n\nThe great thing about designing these mini experiments is that they can be quickly converted into [`testthat` tests](https://testthat.r-lib.org/). I'm now confident I can use the namespace functions to:\n\n1. View loaded packages namespaces  \n2. Check for a specific package in the loaded namespaces       \n3. Require a package namespace is loaded    \n4. Remove a loaded package namespace    \n\nThese are the behaviors I want to confirm in `check_pkg_ns()` using the `browser()` function.\n\n## browser()\n\nIf I want to explore the behaviors of the namespace functions in `check_pkg_ns()`, I need to add `browser()` somewhere I can ‘step into’ this function and then proceed through line-by-line. In this case, the top of the function makes sense:\n\n::: {#fig-browser_fun}\n\n![`browser()` in `check_pkg_ns()`](dbg-browser_fun.png){#fig-browser_fun fig-align=\"center\" width=80%}\n\n`browser()` placement in `check_pkg_ns()`\n:::\n\n### Debug mode\n\nTo enter debugging mode, I'll need to run `check_pkg_ns()` or source `R/check_pkg_ns.R` with the package I used in my experiments.  \n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: false\ncheck_pkg_ns(\"fs\")\n```\n\n:::: {.column-page-inset-right} \n\n::: {#fig-dbg-debug_mode}\n\n![Debug mode](dbg-debug_mode.png){#fig-dbg-debug_mode fig-align=\"center\" width=100%}\n\nRStudio IDE in debug mode\n:::\n\n::::\n\nThe `browser()` function is one of the multiple methods for using RStudio debugging tools (see the **TIP** callout box below for more).\n\n:::: {.callout-tip collapse='false'}\n## TIP: Other debugging methods \n::: {style='font-size: 1.15em; color: #063E23;'}\n\nIn this post, I focused on using the [`browser()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/browser.html) function to enter debug mode, but RStudio has several built-in tools that can help you debug your R code:\n\n-   **Debug function on error:** You can set R to automatically enter the debugger when an error occurs by using `options(error = utils::recover)`. Then, when an error occurs, you'll be given a menu of places to browse, the most recent (the location where the error occurred) first.\n\n-   **Breakpoints:** Breakpoints can be set in your R scripts to pause execution at a particular line of code. You can add breakpoints by clicking to the left of the line number in the script editor or by pressing Shift+F9 with your cursor on the desired line. Then, run your code. Execution will stop just before the line with the breakpoint, allowing you to inspect the current state of the environment.\n\n-   **`debug()`:** You can use `debug(function_name)` to flag a function for \"debug\" mode. When you call the function, the debugger will open and stop at the first line of the function, where you can step through the function line by line, inspect the environment, and see what's happening at each step.\n\n-   **`traceback()`**: When an error occurs, you can call `traceback()` to get a stack trace that shows you the sequence of calls that led up to the error.\n\n-   **Code Diagnostics**: RStudio provides real-time notifications about potential issues in your code, like syntax errors or unused variables. These are not technically part of the debugger, but diagnostics will help you avoid bugs before you run your code. \n\nYou should read [this blog post](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE) and [this chapter](https://adv-r.hadley.nz/debugging.html) of Advanced R, 2nd Ed. for more information on the various debugging methods.\n\n:::\n::::\n\n\n### Console\n\nWhen the `browser()` function is called, the **Console** enters the 'reactive browser environment,' tells me where the debugging function was called from, and changes the prompt to `Browse[1]>`: \n\n```{verbatim}\nCalled from: check_pkg_ns(\"fs\")\nBrowse[1]> \n```\n\nI can use the **Console** to inspect variables and 'step through' the function code. \n\n:::: {.column-page-inset-right}\n\n::: {#fig-console}\n\n![Debug mode in **Console**](dbg-browse-console.png){#fig-console fig-align=\"center\" width=80%}\n\nDebug mode with `browser()` in Console\n:::\n\n::::\n\nThe debugger toolbar is also placed at the top of the **Console**: \n\n::: {#fig-browser_toolbar}\n\n![Debug toolbar **Console**](dbg-browser_toolbar.png){#fig-browser_toolbar width=100%}\n\nDebug toolbar in Console\n:::\n\nI can use the toolbar or enter the following commands in the **Console**:\n\n-   `n` (next): execute the next step in the function\n\n-   `s` (step into): step into the function call on the current line\n\n-   `c` (continue): continue normal execution without stepping\n\n-   `f` (finish): execute the rest of the current loop or function\n\n-   `Q` (Quit): quit the debugger\n\nI'll return to the **Console** in a bit (this is where most of the debugging is done), but let's view the other changes to the IDE first.\n\n### Source  \n\nIn the **Source** pane, we can see the line with `browser()` has been highlighted with an arrow:\n\n:::: {.column-page-inset-right}\n::: {#fig-source}\n\n![Debug mode in **Source**](dbg-browse-source.png){#fig-source fig-align=\"center\" width=80%}\n\nDebug mode with `browser()` in Source\n:::\n::::\n\nThe **Source** pane will continually update and highlight my execution position (i.e., what's going to be executed next) as I 'step through' the code.\n\n\\**After we’ve finished debugging, it’s important to remember to remove the `browser()` function so it isn’t triggered the next time it is executed.* \n\n### Environment \n\nThe *(Environment)* pane is changed from the global environment to the environment of the function that’s currently being executed in the **Console**:\n\n:::: {.column-page-inset-right}\n::: {#fig-env}\n\n![Debug mode in **Environment**](dbg-browse-env.png){#fig-env fig-align=\"center\" width=80%}\n\nDebug mode with `browser()` in Environment\n:::\n::::\n\nIn the case of `check_pkg_ns()`, I can see the **Values** section contains the `pkg` (`\"fs\"`) and `quiet` (`FALSE`) arguments. \n\n#### Other environments\n\nThe drop-down list of environments above the **Values** is arranged in reverse hierarchical order: The **Global Environment** is listed under the drop-down list, but it's above the `check_pkg_ns()` environment in the search path:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-env layout-ncol=2}\n\n![Items in **Environment** debug mode](dbg-browse-env-list.png){#fig-env-list fig-align=\"center\" width=90%}\n\n![[Package environments and the search path](https://adv-r.hadley.nz/environments.html#search-path)](search-path.png \"Source: https://adv-r.hadley.nz/environments.html#search-path\"){#fig-env-list fig-align=\"center\" width=90%}\n\nEnvironments with debugger\n:::\n\n::::\n\n#### Traceback\n\nThe traceback (or 'call stack') is the 'stack' of functions that have been run thus far:\n\n::: {#fig-traceback}\n\n![Traceback in **Environment**](dbg-browse-traceback.png){#fig-traceback fig-align=\"center\" width=100%}\n\nEnvironment Traceback viewer\n:::\n\nClicking on an item in traceback will display the environment contents in the function’s code. Right now, it includes the call to `source(\"R/check_pkg_ns.R\")`, and 'Debug source' call to `check_pkg_ns(\"fs\")`.\n\nIf the ***Show internals*** option is selected, the internal functions are shown (slightly subdued in gray).\n\n::: {#fig-traceback-internals}\n\n![Traceback internals](dbg-browse-traceback-internals.png){#fig-traceback-internals fig-align=\"center\" width=100%}\n\nTraceback internals\n:::\n\n### Arguments\n\nThe `pkg` argument can be printed to verify it's contents. \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> pkg\n[1] \"fs\"\n```\n\nThe debugger lets me view the state of a function's values or variables at each execution step, which helps me understand any incorrect or unexpected values.\n\nBased on the help files and my experiments, `check_pkg_ns()` should be looking through the namespace to see if a `pkg` is loaded; if it isn't, that `pkg` is loaded in the namespace. \n\nI can also check the code from the mini experiments inside the debugger **Console** to see if the `fs` namespace has been loaded:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> isNamespaceLoaded(\"fs\")\n[1] FALSE\n```\n\nAt my current location in `check_pkg_ns()`, the `fs` package hasn't been loaded. \n\n### Stepping through \n\nI can begin 'stepping through' `check_pkg_ns()` by entering **`n`** in the **Console**:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> n\n```\n\nNotice after the entering **`n`** in the **Console**, the debugger tells me where the `browser()` function has paused execution (`debug at /path/to/function/file.R`), the line number (`#27`), and the `check_pkg_ns()` function is printed to console (I've omitted it here): \n\n\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> n\ndebug at ~/projects/apps/dbap/R/check_pkg_ns.R#27:\n\n<...check_pkg_ns() function...>\n\nBrowse[2]>\n```\n\nThe prompt also changes from `Browse[1]>` to `Browse[2]>` to let me know I'm inside the `check_pkg_ns()` function. \n\nI'll use **`n`** (or Next) to continue following the path `pkg` takes through the function:  \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-next-console}\n\n![Use Console to step through function](dbg-next-console.png){#fig-dbg-next-console fig-align=\"center\" width=100%}\n\nUse `n` to step through `check_pkg_ns()`\n:::\n\n::::\n\n\nWhen I land on the line *after* the call to `requireNamespace()`, I can check to see if the `fs` namespace has been loaded with `isNamespaceLoaded(\"fs\")`\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> isNamespaceLoaded(\"fs\")\n[1] TRUE\n```\n\n### Inspect values\n\nNow that I've confirmed `check_pkg_ns()` works with `fs`, I should also confirm it works with a development package (i.e., not on CRAN). I can test this with the [`roxygen2Comment` package](https://github.com/csgillespie/roxygen2Comment)--it contains an addin for pasting `roxygen2` comment blocks.\n\nTo quit debug mode, I can enter **`Q`** in the **Console** or click on the red square (***Stop***) icon in the toolbar. \n\n```{verbatim}\n#| eval: false\n#| echo: true\n#| code-fold: false\nBrowse[2]> Q\n```\n\nI'll confirm `roxygen2Comment` is not loaded with `isNamespaceLoaded()`, then change the `pkg` argument in `check_pkg_ns()` and re-run the function\n\n```{verbatim}\n#| eval: false\n#| echo: true\n#| code-fold: false\nisNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\n```\n\n```{verbatim}\n#| eval: false\n#| echo: true\n#| code-fold: false\n> check_pkg_ns(\"roxygen2Comment\")\nCalled from: check_pkg_ns(\"roxygen2Comment\")\nBrowse[1]> \n```\n\n\nThis time, when I step through `check_pkg_ns()`, I notice `pkg` takes an alternative path: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-next-console-02}\n\n![Alternative path through function](dbg-next-console-02.png){#fig-dbg-next-console-02 fig-align=\"center\" width=100%}\n\nDevelopment package in `check_pkg_ns()`\n:::\n\n::::\n\nWhen the **Source** pane highlights the `stop()` function, I can check to confirm this package wasn't loaded:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> isNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\n```\n\nIf I enter **`n`** one more time in the **Console**, I see the `stop()` error from the function is returned: \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\nError in check_pkg_ns(\"roxygen2Comment\") : \n  roxygen2Comment not available\n```\n\n\nI'll perform one last check on `check_pkg_ns()`: what if I want to pass multiple packages to `pkg`? I'll check this with [`fs`](https://fs.r-lib.org/) and [`box`](https://klmr.me/box/index.html).\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n# First make sure these aren't loaded...\nunloadNamespace(\"fs\")\nunloadNamespace(\"box\")\n# Now combine into vector\npkgs <- c(\"fs\", \"box\")\ncheck_pkg_ns(pkgs)\n```\n\n\nAfter entering debug mode, I want to proceed to the control flow and verify the `pkgs` variable: \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\n> check_pkg_ns(pkgs)\nCalled from: check_pkg_ns(pkgs)\nBrowse[1]> n\nBrowse[2]> pkgs\n[1] \"fs\"  \"box\"\n```\n\nThis confirms both packages are in the `pkg` variable. If I use **`n`** to proceed through to end of `check_pkg_ns()`, I see the final line returns the successful loading message twice: \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\nLoading package: fs\nLoading package: box\n```\n\n\n### *browser() recap*\n\nOnce execution is paused with `browser()`, using the **`n`** command in the **Console** (or in the debugging toolbar at the top-right of the pane) lets me step through the code line-by-line. \n\n::: {#fig-next_toolbar}\n\n![Step through/over](dbg-next_toolbar.png){#fig-next_toolbar fig-align=\"center\" width=75%}\n\nStep through/over code\n:::\n\nThis allows me to inspect the state of the variables at various points within a function.\n\n## Nested functions\n\nThe `check_pkg_ns()` function is fairly basic in that it performs a single 'unit of work' (i.e., *check if add-on packages package have been loaded and attached; if not, load and attach them*). When functions become more complex, it's more efficient to use nested functions--i.e., functions within other functions--which allow me to execute multiple commands simultaneously. \n\nAn example of this is the `pkg_data_results()` function below: \n\n```{r}\n#| label: initial_pkg_data_results\n#| eval: true\n#| echo: false \n#| code-fold: false \npkg_data_results <- function(pkg) {\n  # load packages\n  check_pkg_ns(pkg = pkg, quiet = TRUE)\n\n  tibble::as_tibble(\n    data.frame(\n      Package = data(package = pkg)$results[, \"Package\"],\n      Item = data(package = pkg)$results[, \"Item\"],\n      Title = data(package = pkg)$results[, \"Title\"],\n      stringsAsFactors = FALSE,\n      check.names = FALSE,\n      row.names = NULL\n    )\n  )\n}\n```\n\n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: show \n#| code-summary: 'pkg_data_results()'\npkg_data_results(\"dplyr\")\n```\n\n`pkg_data_results()` returns a `data.frame` with three columns: `Package`, `Item`, and `Title`. \n\nThe output from `pkg_data_results()` comes from the `data(package = \"pkg\")` output:\n\n::: {#fig-next_toolbar}\n\n![Output from `data(package = )`](dbg-data_output.png){#fig-dbg-data_output fig-align=\"center\" width=100%}\n\n`data(package = \"dplyr\")`\n:::\n\nThis output is normally opened in a separate window, but it's created as a matrix. \n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: show \n#| code-summary: 'structure of data(package =)'\nstr(data(package = \"dplyr\"))\n```\n\n`pkg_data_results()` converts the matrix output into a `data.frame` three columns in (`Package`, `Title`, `Item`).\n\nI've placed `browser()` at the top of `pkg_data_results()` and run it with the  [`fivethirtyeight` package](https://fivethirtyeight-r.netlify.app/). \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\npkg_data_results(\"fivethirtyeight\")\n```\n\n\n\n::: {#fig-pkg_data_results_538}\n\n![browser() in pkg_data_results(\"fivethirtyeight\")](dbg-pkg_data_results_538.png){#fig-dbg-pkg_data_results_538 fig-align=\"center\" width=100%}\n\n`browser()` in `pkg_data_results(\"fivethirtyeight\")`\n:::\n\n\n### Step into\n\nWhen the debugger lands on `check_pkg_ns()`, I can follow the `fivethirtyeight` package through this function by 'stepping into' this function by entering **`s`** in the **Console** (or the toolbar icon): \n\n:::: {.column-margin}\n\n![Step into a function](dbg-step_into_toolbar.png){width=100%}\n\n::::\n\n\n\n::: {#fig-step_into_pkg_data_results}\n\n![browser() in pkg_data_results(\"fivethirtyeight\")](dbg-step_into_pkg_data_results.png){#fig-dbg-step_into_pkg_data_results fig-align=\"center\" width=70%}\n\nStep into in `pkg_data_results(\"fivethirtyeight\")`\n:::\n\n\n### Debugging 'at' vs 'in'\n\nIn the **Console**, there are now `debugging in` and `debug at` locations:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> s\ndebugging in: check_pkg_ns(pkg = pkg, quiet = TRUE)\ndebug at /apps/dbap/R/check_pkg_ns.R#25: \n```\n\nThe `debug at` location is the the we location of the initial call to `browser()`, and `debugging in` is the function I *stepped into*.\n\nThe prompt has also changed from `Browse[2]>` to `Browse[3]>`:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[3]>\n```\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-step_into_01}\n\n![Use `s` to step into check_pkg_ns()](dbg-step_into_01.png){#fig-dbg-step_into_01 fig-align=\"center\" width=100%}\n\nUse `s` to step through `check_pkg_ns()`\n:::\n\n::::\n\nThe `R/check_pkg_ns.R` file will open with the highlighted function. I can proceed through `check_pkg_ns()` using **`n`** until I reach `requireNamespace()`:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-step_into_02}\n\n![Use `n` to step through `check_pkg_ns()`](dbg-step_into_02.png){#fig-dbg-step_into_02 fig-align=\"center\" width=70%}\n\nUse `n` to step through `check_pkg_ns()`\n:::\n\n::::\n\nWhen I reach the final line in `check_pkg_ns()`, I can use either method below verify the `pkg` namespace is loaded:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[3]> pkg %in% loadedNamespaces()\n[1] TRUE\nBrowse[3]> isNamespaceLoaded(pkg)\n[1] TRUE\n```\n\n\nAfter the last line of `check_pkg_ns()` has been evaluated, the debugger will automatically return to the `pkg_data_results()` function. The **Source** pane will highlight the final step (and the prompt returns to `Browse[2]>`):\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-step_into_03}\n\n![Step into/through `check_pkg_ns()` from  `pkg_data_results()`](dbg-step_into_03.png){#fig-dbg-step_into_03 fig-align=\"center\" width=100%}\n\nStep into and through `check_pkg_ns()` from  `pkg_data_results()`\n:::\n\n::::\n\nA final **`n`** command in the **Console** will return the output table:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\n### A tibble: 129 × 3\n##    Package         Item                Title\n##    <chr>           <chr>               <chr>\n##  1 fivethirtyeight US_births_1994_2003 Some People Are Too Superstitious To …\n##  2 fivethirtyeight US_births_2000_2014 Some People Are Too Superstitious To …\n##  3 fivethirtyeight ahca_polls          American Health Care Act Polls\n##  4 fivethirtyeight airline_safety      Should Travelers Avoid Flying Airline…\n##  5 fivethirtyeight antiquities_act     Trump Might Be The First President To…\n##  6 fivethirtyeight august_senate_polls How Much Trouble Is Ted Cruz Really  …\n##  7 fivethirtyeight avengers            Joining The Avengers Is As Deadly As\n##  8 fivethirtyeight bachelorette        Bachelorette / Bachelor\n##  9 fivethirtyeight bad_drivers         Dear Mona, Which State Has The Worst …\n## 10 fivethirtyeight bechdel             The Dollar-And-Cents Case Against Hol…\n## # ℹ 119 more rows\n## # ℹ Use `print(n = ...)` to see more rows\n```\n\n## Put it all together\n\nThe initial `pkg_data_str()` function for returning a table of 'package data structures' is below.\n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: true\n#| code-summary: 'expand to see initial pkg_data_str()'\npkg_data_str <- function(pkg) {\n\n  data_results <- pkg_data_results(pkg = pkg)\n\n  ds_list <- purrr::map2(\n    .x = data_results[[\"Item\"]], \n    .y = data_results[[\"Package\"]],\n    .f = pkg_data_object, .progress = TRUE\n  )\n\n  cols_tbl <- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |>\n      purrr::map(paste0, collapse = \", \") |> unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |>\n      purrr::map(paste0, \" columns\") |> unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |>\n      purrr::map(paste0, \" rows\") |> unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |> unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |> unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |> unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |> unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |> unlist(),\n  )\n\n  pkg_tbls_dfs <- dplyr::filter(cols_tbl,\n    stringr::str_detect(Class, \"data.frame\")\n  )\n\n  return(pkg_tbls_dfs)\n}\n```\n\n`pkg_data_str()` uses nested functions to create the following intermediate objects I can check while developing with `browser()` (the example below uses the [`forcats` package](https://forcats.tidyverse.org/))\n\n\n### Data results \n\nThe output from `pkg_data_results()` is stored in `data_results`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ndata_results <- pkg_data_results(pkg = pkg)\n```\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> data_results\n# A tibble: 1 × 3\n  Package Item    Title                                                           \n  <chr>   <chr>   <chr>                                                           \n1 forcats gss_cat A sample of categorical variables from the General Social su...\n```\n\n### Package data objects\n\nAfter extracting the `Package`, `Title`, and `Type` columns from `pkg_data_results()`, I use `purrr:map2()` to iterate over each `Item` and `Package`, which builds a list of datasets (`ds_list`). The `.f` argument is a [nested `pkg_data_object()` function](https://github.com/mjfrigaard/dbap/blob/main/R/pkg_data_object.R), which calls `base::get()`.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nds_list <- purrr::map2(\n  .x = data_results[[\"Item\"]],\n  .y = data_results[[\"Package\"]],\n  .f = pkg_data_object, .progress = TRUE\n)\n```\n\nI'll view the contents of the list with `str()`\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> str(ds_list)\nList of 1\n $ : tibble [21,483 × 9] (S3: tbl_df/tbl/data.frame)\n  ..$ year   : int [1:21483] 2000 2000 2000 2000 2000 2000 2000 2000 ...\n  ..$ marital: Factor w/ 6 levels \"No answer\",\"Never married\",..: 2 4 ...\n  ..$ age    : int [1:21483] 26 48 67 39 25 25 36 44 44 47 ...\n  ..$ race   : Factor w/ 4 levels \"Other\",\"Black\",..: 3 3 3 3 3 3 3 3 3 3 ...\n  ..$ rincome: Factor w/ 16 levels \"No answer\",\"Don't know\",..: 8 8 16 16 ...\n  ..$ partyid: Factor w/ 10 levels \"No answer\",\"Don't know\",..: 6 5 7 6  ...\n  ..$ relig  : Factor w/ 16 levels \"No answer\",\"Don't know\",..: 15 15 15 ...\n  ..$ denom  : Factor w/ 30 levels \"No answer\",\"Don't know\",..: 25 23 3 ...\n  ..$ tvhours: int [1:21483] 12 NA 2 4 1 NA 3 NA 0 3 ...\n```\n\n\n### Column counts\n\nThe `ds_list` created above is used to add the `Class`, `Columns`, and `Rows` columns to `data_results` using the `class()`, `ncol()`, `nrow()`. The column counts are added with the [`col_type_count()` function](https://github.com/mjfrigaard/dbap/blob/main/R/col_type_count.R). \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  cols_tbl <- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |>\n      purrr::map(paste0, collapse = \", \") |> unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |>\n      purrr::map(paste0, \" columns\") |> unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |>\n      purrr::map(paste0, \" rows\") |> unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |> unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |> unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |> unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |> unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |> unlist(),\n  )\n```\n\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> cols_tbl\n# A tibble: 1 × 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  <chr>   <chr>   <chr>          <chr> <chr>   <chr>   <int>   <int>     <int>  <int> <int>\n1 forcats gss_cat A sample of c… tbl_… 9 colu… 2148…       0       3         0      6     0\n```\n\n### Rectangular objects \n\nFinally, `cols_tbl` is filtered to only those objects with a `class()` containing the string '`data.frame`'.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\npkg_tbls_dfs <- dplyr::filter(.data = cols_tbl,\n                  stringr::str_detect(Class, \"data.frame\"))\n```\n\nThis is exactly the same as the previous tibble because forcats has only one data object (`gss_cat`), and it's a tibble: \n\n```{verbatim}\nBrowse[2]> pkg_tbls_dfs\n# A tibble: 1 × 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  <chr>   <chr>   <chr>          <chr> <chr>   <chr>   <int>   <int>     <int>  <int> <int>\n1 forcats gss_cat A sample of c… tbl_… 9 colu… 2148…       0       3         0      6     0\n```\n\n\nI'm explicitly returning `pkg_tbls_dfs` to view it in the debugger. When I'm confident it's behaving as expected, I'll remove this final object and '[rely on R to return the result of the last evaluated expression](https://style.tidyverse.org/functions.html#return).'\n\n### Error!\n\nWhen I tried using the initial `pkg_data_str()` with a package that had zero data objects (`fs`), I get the following error: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\npkg_data_str(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nError in `dplyr::filter()` at dbap/R/pkg_data_str.R:78:2:\nℹ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\nIn the debugger, I was able to pinpoint the source of this error (and the underlying condition causing it to occur).\n\n#### Replicate the error\n\nThe `browser()` beings at the top of `pkg_data_str()`, where I'll step into `pkg_data_results()` \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_01}\n\n![`pkg_data_results()` from  `pkg_data_str()`](dbg-all_together_01.png){#fig-dbg-all_together_01 fig-align=\"center\" width=100%}\n\nStep into `pkg_data_results()` from  `pkg_data_str()`\n:::\n\n::::\n\nWhen I'm inside `pkg_data_results()`, I'll use **`n`** to verify the `fs` package namespace was loaded and the `tibble` was created: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_02}\n\n![Step through `pkg_data_results()`](dbg-all_together_02.png){#fig-dbg-all_together_02 fig-align=\"center\" width=100%}\n\nStep through `pkg_data_results()` (from  `pkg_data_str()`)\n:::\n\n::::\n\nBack in `pkg_data_str()`, the output from `pkg_data_results()` is stored as `data_results`. I can check the contents of `data_results` in the **Console**. \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> data_results\n# A tibble: 0 × 3\n# ℹ 3 variables: Package <chr>, Item <chr>, Title <chr>\n```\n\nI see it's empty. An empty `data_results` results in an empty list output from `purrr::map2()`:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_03}\n\n![Step out of `pkg_data_results()`](dbg-all_together_03.png){#fig-dbg-all_together_03 fig-align=\"center\" width=100%}\n\nStep out of `pkg_data_results()` back into `pkg_data_str()`\n:::\n\n::::\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> ds_list\nlist()\n```\n\nThe empty `ds_list` results in `dplyr::mutate()` being unable to create the `Class` column in `cols_tbl`:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_04}\n\n![`dplyr::mutate()` call in `get_ds_strs()`](dbg-all_together_04.png){#fig-dbg-all_together_04 fig-align=\"center\" width=65%}\n\nCreate `Class` column in `get_ds_strs()`\n:::\n\n::::\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> cols_tbl\n# A tibble: 0 × 3\n# ℹ 3 variables: Package <chr>, Item <chr>, Title <chr>\n```\n\nWhich triggers the error in `dplyr::filter()`\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\nError in `dplyr::filter()` at dbap/R/get_ds_str.R:60:2:\nℹ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\nThe full path for the `fs` package through the initial `get_ds_str()` is outlined in the figure below:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_05}\n\n![Error path in `get_ds_strs()`](dbg-all_together_05.png){#fig-dbg-all_together_05 fig-align=\"center\" width=100%}\n\nReplicate the error from `get_ds_strs()`\n:::\n\n::::\n\n### Solution\n\nTo fix this error, I had to make some changes to *both* `pkg_data_results()` *and* `pkg_data_str()`:\n\nIn `pkg_data_results()`, I added control flow to return a `tibble` of logical columns (all `NA`) if the package doesn't have any data objects: \n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: true \n#| code-summary: 'Expand to view the updated pkg_data_results()'\npkg_data_results <- function(pkg) {\n  # load packages\n  check_pkg_ns(pkg = pkg, quiet = TRUE)\n\n  results <- tibble::as_tibble(\n    data.frame(\n      Package = data(package = pkg)$results[, \"Package\"],\n      Item = data(package = pkg)$results[, \"Item\"],\n      Title = data(package = pkg)$results[, \"Title\"],\n      stringsAsFactors = FALSE,\n      check.names = FALSE,\n      row.names = NULL\n    )\n  )\n\n  if (nrow(results) == 0) {\n\n  data_results <- tibble::as_tibble(\n    data.frame(\n\t\tmatrix(\n\t\t\tnrow = 1, ncol = 11,\n\t\t\tbyrow = TRUE,\n\t\t\tdimnames = list(NULL,\n\t\t\t  c(\"Package\", \"Item\", \"Title\",\n\t\t\t    \"Class\", \"Columns\", \"Rows\",\n\t\t\t    \"Logical\", \"Numeric\", \n\t\t\t    \"Character\", \"Factor\", \n\t\t\t    \"List\"))\n\t\t\t\t),\n\t\trow.names = NULL))\n\n    return(data_results)\n\n\n  } else {\n\n    results\n\n  }\n\n}\n```\n\n\nIn `pkg_data_str()`, I added two `if` statements:\n\n-   the first `if` statement identifies the logical `NA` columns (indicating the results from `data(package = pkg)` didn't have any data objects) \n\n-   the second `if` statement creates the `Class` column *first*, then filters the rows to only those containing a `data.frame` string pattern. If none of the data objects have the `data.frame` string pattern in their class, an empty `data_results` table is returned\n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: true \n#| code-summary: 'Expand to view the updated pkg_data_str()'\npkg_data_str <- function(pkg) {\n  \n  data_results <- pkg_data_results(pkg = pkg)\n  \n  if (!is.logical(data_results[[\"Item\"]])) {\n    # data_results contains data objects\n    ds_list <- purrr::map2(\n      .x = data_results[[\"Item\"]], \n      .y = data_results[[\"Package\"]],\n      .f = pkg_data_object, .progress = TRUE\n    )\n\n    class_tbl <- dplyr::mutate(data_results,\n      Class = purrr::map(.x = ds_list, .f = class) |>\n        purrr::map(paste0, collapse = \", \") |> unlist()\n    )\n\n    df_tbl <- dplyr::filter(\n      class_tbl,\n      stringr::str_detect(Class, \"data.frame\")\n    )\n\n    if (nrow(df_tbl) == 0) {\n      # df_tbl does not contain 'data.frame' classes\n      data_results <- tibble::as_tibble(\n        data.frame(\n          matrix(\n            nrow = 1, ncol = 11,\n            byrow = TRUE,\n            dimnames = list(\n              NULL,\n              c(\n                \"Package\", \"Item\", \"Title\",\n                \"Class\", \"Columns\", \"Rows\",\n                \"Logical\", \"Numeric\", \"Character\",\n                \"Factor\", \"List\"\n              )\n            )\n          ),\n          row.names = NULL\n        )\n      )\n\n      return(data_results)\n      \n    } else {\n      \n      # df_tbl contains 'data.frame' classes\n      dplyr::mutate(df_tbl,\n        Columns = purrr::map(.x = ds_list, .f = ncol) |>\n          purrr::map(paste0, \" columns\") |> unlist(),\n        Rows = purrr::map(.x = ds_list, .f = nrow) |>\n          purrr::map(paste0, \" rows\") |> unlist(),\n        Logical = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"log\") |> unlist(),\n        Numeric = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"num\") |> unlist(),\n        Character = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"chr\") |> unlist(),\n        Factor = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"fct\") |> unlist(),\n        List = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"lst\") |> unlist())\n      \n    }\n    \n  } else {\n    \n    # data_results does not contains data objects\n    return(data_results)\n    \n  }\n  \n}\n```\n\nRather than go through the debugger process again, I'll go through each of the the mini experiments I used to check the updated `pkg_data_results()` and `pkg_data_str()` functions: \n\n-   Check single package without any data objects (`box`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n      pkg_data_str(\"box\"))\n    ```\n\n-   Check single package with data objects, but none with classes that contain `data.frame` (`stringr`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n    pkg_data_str(\"stringr\"))\n    ```\n    \n-   Check single package with multiple data objects (`dplyr`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n    pkg_data_str(\"dplyr\"))\n    ```\n    \n-   Check multiple packages with multiple data objects (`dplyr`, `forcats` and `lubridate`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n    pkg_data_str(c(\"dplyr\", \"forcats\", \"lubridate\")))\n    ```\n\n## Recap\n\nRStudio's debugger is a powerful tool that can save tons of time when you're developing new functions, discovering how a function's code is executed, or dealing with errors. When you've finished debugging, remember to remove the `browser()` call from your function.\n\nThe steps above should help get you started, and if you'd like to learn more, check out the [debugging chapter of Advanced R](https://adv-r.hadley.nz/debugging.html), and the documentation for [`browser()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/browser.html),  [`debug()`/`debugonce()`/`undebug()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/debug.html), and [`traceback()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/traceback.html) functions.","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| eval: true \n#| echo: false \n#| include: false\nco_box <- function(color, header, contents = \"Your text\") {\n  class <- switch(color,\n    b = \"note\",\n    g = \"tip\",\n    r = \"important\",\n    o = \"caution\",\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n  switch(color,\n  b = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  g = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  o = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  r = cat(paste0(\n    \"\\n\",\n    \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n    \"## \", header, \"\\n\\n\", \n    \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n    glue::glue_collapse(contents), \"\\n\\n\",\n    \"::: \\n\\n\",\n    \"::::\", \"\\n\")),\n  stop(\"Invalid `type`\", call. = FALSE)\n  )\n}\noptions(scipen = 999)\nrenv::install(\"mjfrigaard/dbap\", prompt = FALSE)\n# renv::install(\"lobstr\")\nlibrary(lobstr)\nlibrary(dbap)\nlibrary(lubridate)\nlibrary(forcats)\n# co_box(color = \"r\", \n#   header = \"ALERT!\", \n#   contents = \"This post is currently under development. Thank you for your patience.\")\n```\n\nIn this post I'll cover using the `browser()` function with RStudio's debugger. RStudio's debugging tools are built into the IDE, which provides a seamless transition between writing, running, and debugging code.\n\n::: {.column-margin}\n![](image.png){width=70%}\n:::\n\n\n# Debugging\n\nDebuggers are a critical tool when you're programming, and they have several benefits that make them a must-use for any R user. You’ll inevitably encounter an error or unexpected behavior while you’re programming. Using a debugger allows you to 'step through' your code line-by-line, which makes it easier to find the precise location of bugs and errors and the conditions under which they occur. \n\nBut debuggers aren't only helpful in dealing with errors. The debugger can also be a great learning tool because it provides an interactive way to see how the code is being executed and the order in which functions are being called. For example, you might know that a function returns a particular object but can't determine how that object was created. Debugging lets us get 'under the hood' of our code and see how it's really working.\n\nYou’re probably doing some version of debugging already. If you’ve ever dropped a call to `print()` or `return()` at some well-placed intermediate point in a function to try and understand its behavior, then you know the challenge debugging tries to solve: **We can’t see what happens inside the parentheses when code is executed.** When you use `print()` or `return()` in this way, it's an attempt to indirectly investigate how/if/where the code is performing its intended purpose. \n\nIn this post, I’ll cover using the `browser()` function and RStudio’s debugger while developing a series of small, modular functions for returning a table of 'package data structures.' The code for this post comes from [`dbap`](https://github.com/mjfrigaard/dbap) ('debugging app-package').\n\n## Getting started\n\nI want to create a function that returns a table of 'data structure' columns that describe the available `data.frame` or `tibble` objects loaded with a package. Below is a small example of the desired return object from this function:\n\n\n::: {style='font-size: 0.90em;'}\n```{r}\n#| eval: true\n#| echo: false\nknitr::kable(\n  data.frame(\n          Package = c(\"dplyr\", \"datasets\"),\n          Dataset = c(\"starwars\", \"mtcars\"),\n               # Title = c(\"Storm tracks data\",\n               #         \"Motor Trend Car Road Tests\"),\n            Class = c(\"tbl_df, tbl, data.frame\", \"data.frame\"),\n          Columns = c(\"13\", \"11\"),\n             Rows = c(\"19066\", \"32\"),\n          Logical = c(\"0\", \"0\"),\n          Numeric = c(\"11\", \"11\"),\n        Character = c(\"1\", \"0\"),\n           Factor = c(\"1\", \"0\"),\n             List = c(\"0\", \"0\"),\n        check.names = FALSE)\n  )\n```\n:::\n\nThis table shows the `storms` data from `dplyr` and the `mtcars` data from `datasets`. The columns include the `Package` the data came from, the dataset name (`Dataset`), the data `Title` from the documentation, the `Class` of the data object, the total number of `Columns` and `Rows`, and the number of columns by type (`Logical`, `Numeric`, `Character`, `Factor` and `List`).\n\nOne of the first steps for creating this function is to verify a package's namespace is loaded. I’ve written the `check_pkg_ns()` to check this.\n\n```{r}\n#| label: check_pkg_ns\n#| eval: true\n#| code-fold: show\n#| code-summary: 'check_pkg_ns()'\ncheck_pkg_ns <- function(pkg, quiet = FALSE) {\n  if (isFALSE(quiet)) {\n    # with messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = FALSE)) {\n        cat(paste0(\"Loading package: \", pkg, \"\\n\"))\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    } else {\n      cat(paste0(\"Package \", pkg, \" loaded\\n\"))\n    }\n  } else {\n    # without messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = TRUE)) {\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    }\n  }\n}\n```\n\n`check_pkg_ns()` checks if a packages’s namespace is loaded, and if not, loads it. This function assumes the package (`pkg`) has been installed with `install.packages()` (I've also written [`check_pkg_inst()`](https://github.com/mjfrigaard/dbap/blob/main/R/check_pkg_inst.R) to check if the package has been installed.)\n\n### Experiment\n\nBefore debugging, I'll read the documentation and help files to find examples or use cases for ‘mini-experiments.' These are designed to clarify any function arguments and learn how the code truly works. Experiments should produce predictable, definitive (preferably incompatible) outputs from each function.\n\n#### Namespace functions\n\nThe help file contains the following helpful statement on `isNamespaceLoaded()`:\n\n> *\"`isNamespaceLoaded(pkg)` is equivalent to but more efficient than `pkg %in% loadedNamespaces()`\"*\n\nFirst, I'll check the loaded namespaces with `loadedNamespaces()`, then look for a package I know *isn't* in the namespace with `isNamespaceLoaded()`. I'll use the `fs` package because it isn't loaded or attached to the `search()` list:\n\n```{r}\n#| eval: false\n#| code-fold: false\n# what's in the namespace? \nloadedNamespaces()\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n [1] \"compiler\"   \"rsconnect\"  \"graphics\"  \n [4] \"tools\"      \"rstudioapi\" \"utils\"     \n [7] \"grDevices\"  \"stats\"      \"datasets\"  \n[10] \"methods\"    \"base\"\n```\n\nCheck if `fs` is in the loaded namespace:\n\n```{r}\n#| eval: false\n#| code-fold: false\n# verify fs is not loaded\nisNamespaceLoaded(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[1] FALSE\n```\n\nThe help file tells me the following about `requireNamespace`:\n\n> *\"`requireNamespace` is a wrapper for `loadNamespace` analogous to `require()` that returns a logical value.\"*\n\n...and...\n\n> *\"`requireNamespace` returns `TRUE` if it succeeds or `FALSE`\"*\n\nI'll load a package (`\"fs\"`) with `requireNamespace()` and verify it's in the namespace with `isNamespaceLoaded()`. \n\n```{r}\n#| eval: false\n#| code-fold: false\n# add \"fs\" to the namespace\nrequireNamespace(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\nLoading required namespace: fs\n[1] TRUE\n```\n\n```{r}\n#| eval: false\n#| code-fold: false\n# verify it's been added \nisNamespaceLoaded(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[1] TRUE\n```\n\nFinally, I'll unload the `\"fs\"` package from the namespace so it can be tested in the debugger.\n    \n```{r}\n#| eval: false\n#| code-fold: false\n#| collapse: true\n# remove fs\nunloadNamespace(\"fs\")\n# verify fs has been unloaded\nisNamespaceLoaded(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| code-fold: false\n[1] FALSE\n```\n\nThe great thing about designing these mini experiments is that they can be quickly converted into [`testthat` tests](https://testthat.r-lib.org/). I'm now confident I can use the namespace functions to:\n\n1. View loaded packages namespaces  \n2. Check for a specific package in the loaded namespaces       \n3. Require a package namespace is loaded    \n4. Remove a loaded package namespace    \n\nThese are the behaviors I want to confirm in `check_pkg_ns()` using the `browser()` function.\n\n## browser()\n\nIf I want to explore the behaviors of the namespace functions in `check_pkg_ns()`, I need to add `browser()` somewhere I can ‘step into’ this function and then proceed through line-by-line. In this case, the top of the function makes sense:\n\n::: {#fig-browser_fun}\n\n![`browser()` in `check_pkg_ns()`](dbg-browser_fun.png){#fig-browser_fun fig-align=\"center\" width=80%}\n\n`browser()` placement in `check_pkg_ns()`\n:::\n\n### Debug mode\n\nTo enter debugging mode, I'll need to run `check_pkg_ns()` or source `R/check_pkg_ns.R` with the package I used in my experiments.  \n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: false\ncheck_pkg_ns(\"fs\")\n```\n\n:::: {.column-page-inset-right} \n\n::: {#fig-dbg-debug_mode}\n\n![Debug mode](dbg-debug_mode.png){#fig-dbg-debug_mode fig-align=\"center\" width=100%}\n\nRStudio IDE in debug mode\n:::\n\n::::\n\nThe `browser()` function is one of the multiple methods for using RStudio debugging tools (see the **TIP** callout box below for more).\n\n:::: {.callout-tip collapse='false'}\n## TIP: Other debugging methods \n::: {style='font-size: 1.15em; color: #063E23;'}\n\nIn this post, I focused on using the [`browser()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/browser.html) function to enter debug mode, but RStudio has several built-in tools that can help you debug your R code:\n\n-   **Debug function on error:** You can set R to automatically enter the debugger when an error occurs by using `options(error = utils::recover)`. Then, when an error occurs, you'll be given a menu of places to browse, the most recent (the location where the error occurred) first.\n\n-   **Breakpoints:** Breakpoints can be set in your R scripts to pause execution at a particular line of code. You can add breakpoints by clicking to the left of the line number in the script editor or by pressing Shift+F9 with your cursor on the desired line. Then, run your code. Execution will stop just before the line with the breakpoint, allowing you to inspect the current state of the environment.\n\n-   **`debug()`:** You can use `debug(function_name)` to flag a function for \"debug\" mode. When you call the function, the debugger will open and stop at the first line of the function, where you can step through the function line by line, inspect the environment, and see what's happening at each step.\n\n-   **`traceback()`**: When an error occurs, you can call `traceback()` to get a stack trace that shows you the sequence of calls that led up to the error.\n\n-   **Code Diagnostics**: RStudio provides real-time notifications about potential issues in your code, like syntax errors or unused variables. These are not technically part of the debugger, but diagnostics will help you avoid bugs before you run your code. \n\nYou should read [this blog post](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE) and [this chapter](https://adv-r.hadley.nz/debugging.html) of Advanced R, 2nd Ed. for more information on the various debugging methods.\n\n:::\n::::\n\n\n### Console\n\nWhen the `browser()` function is called, the **Console** enters the 'reactive browser environment,' tells me where the debugging function was called from, and changes the prompt to `Browse[1]>`: \n\n```{verbatim}\nCalled from: check_pkg_ns(\"fs\")\nBrowse[1]> \n```\n\nI can use the **Console** to inspect variables and 'step through' the function code. \n\n:::: {.column-page-inset-right}\n\n::: {#fig-console}\n\n![Debug mode in **Console**](dbg-browse-console.png){#fig-console fig-align=\"center\" width=80%}\n\nDebug mode with `browser()` in Console\n:::\n\n::::\n\nThe debugger toolbar is also placed at the top of the **Console**: \n\n::: {#fig-browser_toolbar}\n\n![Debug toolbar **Console**](dbg-browser_toolbar.png){#fig-browser_toolbar width=100%}\n\nDebug toolbar in Console\n:::\n\nI can use the toolbar or enter the following commands in the **Console**:\n\n-   `n` (next): execute the next step in the function\n\n-   `s` (step into): step into the function call on the current line\n\n-   `c` (continue): continue normal execution without stepping\n\n-   `f` (finish): execute the rest of the current loop or function\n\n-   `Q` (Quit): quit the debugger\n\nI'll return to the **Console** in a bit (this is where most of the debugging is done), but let's view the other changes to the IDE first.\n\n### Source  \n\nIn the **Source** pane, we can see the line with `browser()` has been highlighted with an arrow:\n\n:::: {.column-page-inset-right}\n::: {#fig-source}\n\n![Debug mode in **Source**](dbg-browse-source.png){#fig-source fig-align=\"center\" width=80%}\n\nDebug mode with `browser()` in Source\n:::\n::::\n\nThe **Source** pane will continually update and highlight my execution position (i.e., what's going to be executed next) as I 'step through' the code.\n\n\\**After we’ve finished debugging, it’s important to remember to remove the `browser()` function so it isn’t triggered the next time it is executed.* \n\n### Environment \n\nThe *(Environment)* pane is changed from the global environment to the environment of the function that’s currently being executed in the **Console**:\n\n:::: {.column-page-inset-right}\n::: {#fig-env}\n\n![Debug mode in **Environment**](dbg-browse-env.png){#fig-env fig-align=\"center\" width=80%}\n\nDebug mode with `browser()` in Environment\n:::\n::::\n\nIn the case of `check_pkg_ns()`, I can see the **Values** section contains the `pkg` (`\"fs\"`) and `quiet` (`FALSE`) arguments. \n\n#### Other environments\n\nThe drop-down list of environments above the **Values** is arranged in reverse hierarchical order: The **Global Environment** is listed under the drop-down list, but it's above the `check_pkg_ns()` environment in the search path:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-env layout-ncol=2}\n\n![Items in **Environment** debug mode](dbg-browse-env-list.png){#fig-env-list fig-align=\"center\" width=90%}\n\n![[Package environments and the search path](https://adv-r.hadley.nz/environments.html#search-path)](search-path.png \"Source: https://adv-r.hadley.nz/environments.html#search-path\"){#fig-env-list fig-align=\"center\" width=90%}\n\nEnvironments with debugger\n:::\n\n::::\n\n#### Traceback\n\nThe traceback (or 'call stack') is the 'stack' of functions that have been run thus far:\n\n::: {#fig-traceback}\n\n![Traceback in **Environment**](dbg-browse-traceback.png){#fig-traceback fig-align=\"center\" width=100%}\n\nEnvironment Traceback viewer\n:::\n\nClicking on an item in traceback will display the environment contents in the function’s code. Right now, it includes the call to `source(\"R/check_pkg_ns.R\")`, and 'Debug source' call to `check_pkg_ns(\"fs\")`.\n\nIf the ***Show internals*** option is selected, the internal functions are shown (slightly subdued in gray).\n\n::: {#fig-traceback-internals}\n\n![Traceback internals](dbg-browse-traceback-internals.png){#fig-traceback-internals fig-align=\"center\" width=100%}\n\nTraceback internals\n:::\n\n### Arguments\n\nThe `pkg` argument can be printed to verify it's contents. \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> pkg\n[1] \"fs\"\n```\n\nThe debugger lets me view the state of a function's values or variables at each execution step, which helps me understand any incorrect or unexpected values.\n\nBased on the help files and my experiments, `check_pkg_ns()` should be looking through the namespace to see if a `pkg` is loaded; if it isn't, that `pkg` is loaded in the namespace. \n\nI can also check the code from the mini experiments inside the debugger **Console** to see if the `fs` namespace has been loaded:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> isNamespaceLoaded(\"fs\")\n[1] FALSE\n```\n\nAt my current location in `check_pkg_ns()`, the `fs` package hasn't been loaded. \n\n### Stepping through \n\nI can begin 'stepping through' `check_pkg_ns()` by entering **`n`** in the **Console**:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> n\n```\n\nNotice after the entering **`n`** in the **Console**, the debugger tells me where the `browser()` function has paused execution (`debug at /path/to/function/file.R`), the line number (`#27`), and the `check_pkg_ns()` function is printed to console (I've omitted it here): \n\n\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[1]> n\ndebug at ~/projects/apps/dbap/R/check_pkg_ns.R#27:\n\n<...check_pkg_ns() function...>\n\nBrowse[2]>\n```\n\nThe prompt also changes from `Browse[1]>` to `Browse[2]>` to let me know I'm inside the `check_pkg_ns()` function. \n\nI'll use **`n`** (or Next) to continue following the path `pkg` takes through the function:  \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-next-console}\n\n![Use Console to step through function](dbg-next-console.png){#fig-dbg-next-console fig-align=\"center\" width=100%}\n\nUse `n` to step through `check_pkg_ns()`\n:::\n\n::::\n\n\nWhen I land on the line *after* the call to `requireNamespace()`, I can check to see if the `fs` namespace has been loaded with `isNamespaceLoaded(\"fs\")`\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> isNamespaceLoaded(\"fs\")\n[1] TRUE\n```\n\n### Inspect values\n\nNow that I've confirmed `check_pkg_ns()` works with `fs`, I should also confirm it works with a development package (i.e., not on CRAN). I can test this with the [`roxygen2Comment` package](https://github.com/csgillespie/roxygen2Comment)--it contains an addin for pasting `roxygen2` comment blocks.\n\nTo quit debug mode, I can enter **`Q`** in the **Console** or click on the red square (***Stop***) icon in the toolbar. \n\n```{verbatim}\n#| eval: false\n#| echo: true\n#| code-fold: false\nBrowse[2]> Q\n```\n\nI'll confirm `roxygen2Comment` is not loaded with `isNamespaceLoaded()`, then change the `pkg` argument in `check_pkg_ns()` and re-run the function\n\n```{verbatim}\n#| eval: false\n#| echo: true\n#| code-fold: false\nisNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\n```\n\n```{verbatim}\n#| eval: false\n#| echo: true\n#| code-fold: false\n> check_pkg_ns(\"roxygen2Comment\")\nCalled from: check_pkg_ns(\"roxygen2Comment\")\nBrowse[1]> \n```\n\n\nThis time, when I step through `check_pkg_ns()`, I notice `pkg` takes an alternative path: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-next-console-02}\n\n![Alternative path through function](dbg-next-console-02.png){#fig-dbg-next-console-02 fig-align=\"center\" width=100%}\n\nDevelopment package in `check_pkg_ns()`\n:::\n\n::::\n\nWhen the **Source** pane highlights the `stop()` function, I can check to confirm this package wasn't loaded:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> isNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\n```\n\nIf I enter **`n`** one more time in the **Console**, I see the `stop()` error from the function is returned: \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\nError in check_pkg_ns(\"roxygen2Comment\") : \n  roxygen2Comment not available\n```\n\n\nI'll perform one last check on `check_pkg_ns()`: what if I want to pass multiple packages to `pkg`? I'll check this with [`fs`](https://fs.r-lib.org/) and [`box`](https://klmr.me/box/index.html).\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n# First make sure these aren't loaded...\nunloadNamespace(\"fs\")\nunloadNamespace(\"box\")\n# Now combine into vector\npkgs <- c(\"fs\", \"box\")\ncheck_pkg_ns(pkgs)\n```\n\n\nAfter entering debug mode, I want to proceed to the control flow and verify the `pkgs` variable: \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\n> check_pkg_ns(pkgs)\nCalled from: check_pkg_ns(pkgs)\nBrowse[1]> n\nBrowse[2]> pkgs\n[1] \"fs\"  \"box\"\n```\n\nThis confirms both packages are in the `pkg` variable. If I use **`n`** to proceed through to end of `check_pkg_ns()`, I see the final line returns the successful loading message twice: \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\nLoading package: fs\nLoading package: box\n```\n\n\n### *browser() recap*\n\nOnce execution is paused with `browser()`, using the **`n`** command in the **Console** (or in the debugging toolbar at the top-right of the pane) lets me step through the code line-by-line. \n\n::: {#fig-next_toolbar}\n\n![Step through/over](dbg-next_toolbar.png){#fig-next_toolbar fig-align=\"center\" width=75%}\n\nStep through/over code\n:::\n\nThis allows me to inspect the state of the variables at various points within a function.\n\n## Nested functions\n\nThe `check_pkg_ns()` function is fairly basic in that it performs a single 'unit of work' (i.e., *check if add-on packages package have been loaded and attached; if not, load and attach them*). When functions become more complex, it's more efficient to use nested functions--i.e., functions within other functions--which allow me to execute multiple commands simultaneously. \n\nAn example of this is the `pkg_data_results()` function below: \n\n```{r}\n#| label: initial_pkg_data_results\n#| eval: true\n#| echo: false \n#| code-fold: false \npkg_data_results <- function(pkg) {\n  # load packages\n  check_pkg_ns(pkg = pkg, quiet = TRUE)\n\n  tibble::as_tibble(\n    data.frame(\n      Package = data(package = pkg)$results[, \"Package\"],\n      Item = data(package = pkg)$results[, \"Item\"],\n      Title = data(package = pkg)$results[, \"Title\"],\n      stringsAsFactors = FALSE,\n      check.names = FALSE,\n      row.names = NULL\n    )\n  )\n}\n```\n\n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: show \n#| code-summary: 'pkg_data_results()'\npkg_data_results(\"dplyr\")\n```\n\n`pkg_data_results()` returns a `data.frame` with three columns: `Package`, `Item`, and `Title`. \n\nThe output from `pkg_data_results()` comes from the `data(package = \"pkg\")` output:\n\n::: {#fig-next_toolbar}\n\n![Output from `data(package = )`](dbg-data_output.png){#fig-dbg-data_output fig-align=\"center\" width=100%}\n\n`data(package = \"dplyr\")`\n:::\n\nThis output is normally opened in a separate window, but it's created as a matrix. \n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: show \n#| code-summary: 'structure of data(package =)'\nstr(data(package = \"dplyr\"))\n```\n\n`pkg_data_results()` converts the matrix output into a `data.frame` three columns in (`Package`, `Title`, `Item`).\n\nI've placed `browser()` at the top of `pkg_data_results()` and run it with the  [`fivethirtyeight` package](https://fivethirtyeight-r.netlify.app/). \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\npkg_data_results(\"fivethirtyeight\")\n```\n\n\n\n::: {#fig-pkg_data_results_538}\n\n![browser() in pkg_data_results(\"fivethirtyeight\")](dbg-pkg_data_results_538.png){#fig-dbg-pkg_data_results_538 fig-align=\"center\" width=100%}\n\n`browser()` in `pkg_data_results(\"fivethirtyeight\")`\n:::\n\n\n### Step into\n\nWhen the debugger lands on `check_pkg_ns()`, I can follow the `fivethirtyeight` package through this function by 'stepping into' this function by entering **`s`** in the **Console** (or the toolbar icon): \n\n:::: {.column-margin}\n\n![Step into a function](dbg-step_into_toolbar.png){width=100%}\n\n::::\n\n\n\n::: {#fig-step_into_pkg_data_results}\n\n![browser() in pkg_data_results(\"fivethirtyeight\")](dbg-step_into_pkg_data_results.png){#fig-dbg-step_into_pkg_data_results fig-align=\"center\" width=70%}\n\nStep into in `pkg_data_results(\"fivethirtyeight\")`\n:::\n\n\n### Debugging 'at' vs 'in'\n\nIn the **Console**, there are now `debugging in` and `debug at` locations:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> s\ndebugging in: check_pkg_ns(pkg = pkg, quiet = TRUE)\ndebug at /apps/dbap/R/check_pkg_ns.R#25: \n```\n\nThe `debug at` location is the the we location of the initial call to `browser()`, and `debugging in` is the function I *stepped into*.\n\nThe prompt has also changed from `Browse[2]>` to `Browse[3]>`:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[3]>\n```\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-step_into_01}\n\n![Use `s` to step into check_pkg_ns()](dbg-step_into_01.png){#fig-dbg-step_into_01 fig-align=\"center\" width=100%}\n\nUse `s` to step through `check_pkg_ns()`\n:::\n\n::::\n\nThe `R/check_pkg_ns.R` file will open with the highlighted function. I can proceed through `check_pkg_ns()` using **`n`** until I reach `requireNamespace()`:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-step_into_02}\n\n![Use `n` to step through `check_pkg_ns()`](dbg-step_into_02.png){#fig-dbg-step_into_02 fig-align=\"center\" width=70%}\n\nUse `n` to step through `check_pkg_ns()`\n:::\n\n::::\n\nWhen I reach the final line in `check_pkg_ns()`, I can use either method below verify the `pkg` namespace is loaded:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[3]> pkg %in% loadedNamespaces()\n[1] TRUE\nBrowse[3]> isNamespaceLoaded(pkg)\n[1] TRUE\n```\n\n\nAfter the last line of `check_pkg_ns()` has been evaluated, the debugger will automatically return to the `pkg_data_results()` function. The **Source** pane will highlight the final step (and the prompt returns to `Browse[2]>`):\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-step_into_03}\n\n![Step into/through `check_pkg_ns()` from  `pkg_data_results()`](dbg-step_into_03.png){#fig-dbg-step_into_03 fig-align=\"center\" width=100%}\n\nStep into and through `check_pkg_ns()` from  `pkg_data_results()`\n:::\n\n::::\n\nA final **`n`** command in the **Console** will return the output table:\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\n### A tibble: 129 × 3\n##    Package         Item                Title\n##    <chr>           <chr>               <chr>\n##  1 fivethirtyeight US_births_1994_2003 Some People Are Too Superstitious To …\n##  2 fivethirtyeight US_births_2000_2014 Some People Are Too Superstitious To …\n##  3 fivethirtyeight ahca_polls          American Health Care Act Polls\n##  4 fivethirtyeight airline_safety      Should Travelers Avoid Flying Airline…\n##  5 fivethirtyeight antiquities_act     Trump Might Be The First President To…\n##  6 fivethirtyeight august_senate_polls How Much Trouble Is Ted Cruz Really  …\n##  7 fivethirtyeight avengers            Joining The Avengers Is As Deadly As\n##  8 fivethirtyeight bachelorette        Bachelorette / Bachelor\n##  9 fivethirtyeight bad_drivers         Dear Mona, Which State Has The Worst …\n## 10 fivethirtyeight bechdel             The Dollar-And-Cents Case Against Hol…\n## # ℹ 119 more rows\n## # ℹ Use `print(n = ...)` to see more rows\n```\n\n## Put it all together\n\nThe initial `pkg_data_str()` function for returning a table of 'package data structures' is below.\n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: true\n#| code-summary: 'expand to see initial pkg_data_str()'\npkg_data_str <- function(pkg) {\n\n  data_results <- pkg_data_results(pkg = pkg)\n\n  ds_list <- purrr::map2(\n    .x = data_results[[\"Item\"]], \n    .y = data_results[[\"Package\"]],\n    .f = pkg_data_object, .progress = TRUE\n  )\n\n  cols_tbl <- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |>\n      purrr::map(paste0, collapse = \", \") |> unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |>\n      purrr::map(paste0, \" columns\") |> unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |>\n      purrr::map(paste0, \" rows\") |> unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |> unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |> unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |> unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |> unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |> unlist(),\n  )\n\n  pkg_tbls_dfs <- dplyr::filter(cols_tbl,\n    stringr::str_detect(Class, \"data.frame\")\n  )\n\n  return(pkg_tbls_dfs)\n}\n```\n\n`pkg_data_str()` uses nested functions to create the following intermediate objects I can check while developing with `browser()` (the example below uses the [`forcats` package](https://forcats.tidyverse.org/))\n\n\n### Data results \n\nThe output from `pkg_data_results()` is stored in `data_results`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ndata_results <- pkg_data_results(pkg = pkg)\n```\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> data_results\n# A tibble: 1 × 3\n  Package Item    Title                                                           \n  <chr>   <chr>   <chr>                                                           \n1 forcats gss_cat A sample of categorical variables from the General Social su...\n```\n\n### Package data objects\n\nAfter extracting the `Package`, `Title`, and `Type` columns from `pkg_data_results()`, I use `purrr:map2()` to iterate over each `Item` and `Package`, which builds a list of datasets (`ds_list`). The `.f` argument is a [nested `pkg_data_object()` function](https://github.com/mjfrigaard/dbap/blob/main/R/pkg_data_object.R), which calls `base::get()`.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nds_list <- purrr::map2(\n  .x = data_results[[\"Item\"]],\n  .y = data_results[[\"Package\"]],\n  .f = pkg_data_object, .progress = TRUE\n)\n```\n\nI'll view the contents of the list with `str()`\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> str(ds_list)\nList of 1\n $ : tibble [21,483 × 9] (S3: tbl_df/tbl/data.frame)\n  ..$ year   : int [1:21483] 2000 2000 2000 2000 2000 2000 2000 2000 ...\n  ..$ marital: Factor w/ 6 levels \"No answer\",\"Never married\",..: 2 4 ...\n  ..$ age    : int [1:21483] 26 48 67 39 25 25 36 44 44 47 ...\n  ..$ race   : Factor w/ 4 levels \"Other\",\"Black\",..: 3 3 3 3 3 3 3 3 3 3 ...\n  ..$ rincome: Factor w/ 16 levels \"No answer\",\"Don't know\",..: 8 8 16 16 ...\n  ..$ partyid: Factor w/ 10 levels \"No answer\",\"Don't know\",..: 6 5 7 6  ...\n  ..$ relig  : Factor w/ 16 levels \"No answer\",\"Don't know\",..: 15 15 15 ...\n  ..$ denom  : Factor w/ 30 levels \"No answer\",\"Don't know\",..: 25 23 3 ...\n  ..$ tvhours: int [1:21483] 12 NA 2 4 1 NA 3 NA 0 3 ...\n```\n\n\n### Column counts\n\nThe `ds_list` created above is used to add the `Class`, `Columns`, and `Rows` columns to `data_results` using the `class()`, `ncol()`, `nrow()`. The column counts are added with the [`col_type_count()` function](https://github.com/mjfrigaard/dbap/blob/main/R/col_type_count.R). \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  cols_tbl <- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |>\n      purrr::map(paste0, collapse = \", \") |> unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |>\n      purrr::map(paste0, \" columns\") |> unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |>\n      purrr::map(paste0, \" rows\") |> unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |> unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |> unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |> unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |> unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |> unlist(),\n  )\n```\n\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> cols_tbl\n# A tibble: 1 × 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  <chr>   <chr>   <chr>          <chr> <chr>   <chr>   <int>   <int>     <int>  <int> <int>\n1 forcats gss_cat A sample of c… tbl_… 9 colu… 2148…       0       3         0      6     0\n```\n\n### Rectangular objects \n\nFinally, `cols_tbl` is filtered to only those objects with a `class()` containing the string '`data.frame`'.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\npkg_tbls_dfs <- dplyr::filter(.data = cols_tbl,\n                  stringr::str_detect(Class, \"data.frame\"))\n```\n\nThis is exactly the same as the previous tibble because forcats has only one data object (`gss_cat`), and it's a tibble: \n\n```{verbatim}\nBrowse[2]> pkg_tbls_dfs\n# A tibble: 1 × 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  <chr>   <chr>   <chr>          <chr> <chr>   <chr>   <int>   <int>     <int>  <int> <int>\n1 forcats gss_cat A sample of c… tbl_… 9 colu… 2148…       0       3         0      6     0\n```\n\n\nI'm explicitly returning `pkg_tbls_dfs` to view it in the debugger. When I'm confident it's behaving as expected, I'll remove this final object and '[rely on R to return the result of the last evaluated expression](https://style.tidyverse.org/functions.html#return).'\n\n### Error!\n\nWhen I tried using the initial `pkg_data_str()` with a package that had zero data objects (`fs`), I get the following error: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\npkg_data_str(\"fs\")\n```\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nError in `dplyr::filter()` at dbap/R/pkg_data_str.R:78:2:\nℹ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\nIn the debugger, I was able to pinpoint the source of this error (and the underlying condition causing it to occur).\n\n#### Replicate the error\n\nThe `browser()` beings at the top of `pkg_data_str()`, where I'll step into `pkg_data_results()` \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_01}\n\n![`pkg_data_results()` from  `pkg_data_str()`](dbg-all_together_01.png){#fig-dbg-all_together_01 fig-align=\"center\" width=100%}\n\nStep into `pkg_data_results()` from  `pkg_data_str()`\n:::\n\n::::\n\nWhen I'm inside `pkg_data_results()`, I'll use **`n`** to verify the `fs` package namespace was loaded and the `tibble` was created: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_02}\n\n![Step through `pkg_data_results()`](dbg-all_together_02.png){#fig-dbg-all_together_02 fig-align=\"center\" width=100%}\n\nStep through `pkg_data_results()` (from  `pkg_data_str()`)\n:::\n\n::::\n\nBack in `pkg_data_str()`, the output from `pkg_data_results()` is stored as `data_results`. I can check the contents of `data_results` in the **Console**. \n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> data_results\n# A tibble: 0 × 3\n# ℹ 3 variables: Package <chr>, Item <chr>, Title <chr>\n```\n\nI see it's empty. An empty `data_results` results in an empty list output from `purrr::map2()`:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_03}\n\n![Step out of `pkg_data_results()`](dbg-all_together_03.png){#fig-dbg-all_together_03 fig-align=\"center\" width=100%}\n\nStep out of `pkg_data_results()` back into `pkg_data_str()`\n:::\n\n::::\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> ds_list\nlist()\n```\n\nThe empty `ds_list` results in `dplyr::mutate()` being unable to create the `Class` column in `cols_tbl`:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_04}\n\n![`dplyr::mutate()` call in `get_ds_strs()`](dbg-all_together_04.png){#fig-dbg-all_together_04 fig-align=\"center\" width=65%}\n\nCreate `Class` column in `get_ds_strs()`\n:::\n\n::::\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> cols_tbl\n# A tibble: 0 × 3\n# ℹ 3 variables: Package <chr>, Item <chr>, Title <chr>\n```\n\nWhich triggers the error in `dplyr::filter()`\n\n```{verbatim}\n#| eval: false\n#| echo: true \n#| code-fold: false\nBrowse[2]> n\nError in `dplyr::filter()` at dbap/R/get_ds_str.R:60:2:\nℹ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\nThe full path for the `fs` package through the initial `get_ds_str()` is outlined in the figure below:\n\n:::: {.column-page-inset-right}\n\n::: {#fig-dbg-all_together_05}\n\n![Error path in `get_ds_strs()`](dbg-all_together_05.png){#fig-dbg-all_together_05 fig-align=\"center\" width=100%}\n\nReplicate the error from `get_ds_strs()`\n:::\n\n::::\n\n### Solution\n\nTo fix this error, I had to make some changes to *both* `pkg_data_results()` *and* `pkg_data_str()`:\n\nIn `pkg_data_results()`, I added control flow to return a `tibble` of logical columns (all `NA`) if the package doesn't have any data objects: \n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: true \n#| code-summary: 'Expand to view the updated pkg_data_results()'\npkg_data_results <- function(pkg) {\n  # load packages\n  check_pkg_ns(pkg = pkg, quiet = TRUE)\n\n  results <- tibble::as_tibble(\n    data.frame(\n      Package = data(package = pkg)$results[, \"Package\"],\n      Item = data(package = pkg)$results[, \"Item\"],\n      Title = data(package = pkg)$results[, \"Title\"],\n      stringsAsFactors = FALSE,\n      check.names = FALSE,\n      row.names = NULL\n    )\n  )\n\n  if (nrow(results) == 0) {\n\n  data_results <- tibble::as_tibble(\n    data.frame(\n\t\tmatrix(\n\t\t\tnrow = 1, ncol = 11,\n\t\t\tbyrow = TRUE,\n\t\t\tdimnames = list(NULL,\n\t\t\t  c(\"Package\", \"Item\", \"Title\",\n\t\t\t    \"Class\", \"Columns\", \"Rows\",\n\t\t\t    \"Logical\", \"Numeric\", \n\t\t\t    \"Character\", \"Factor\", \n\t\t\t    \"List\"))\n\t\t\t\t),\n\t\trow.names = NULL))\n\n    return(data_results)\n\n\n  } else {\n\n    results\n\n  }\n\n}\n```\n\n\nIn `pkg_data_str()`, I added two `if` statements:\n\n-   the first `if` statement identifies the logical `NA` columns (indicating the results from `data(package = pkg)` didn't have any data objects) \n\n-   the second `if` statement creates the `Class` column *first*, then filters the rows to only those containing a `data.frame` string pattern. If none of the data objects have the `data.frame` string pattern in their class, an empty `data_results` table is returned\n\n```{r}\n#| eval: true\n#| echo: true \n#| code-fold: true \n#| code-summary: 'Expand to view the updated pkg_data_str()'\npkg_data_str <- function(pkg) {\n  \n  data_results <- pkg_data_results(pkg = pkg)\n  \n  if (!is.logical(data_results[[\"Item\"]])) {\n    # data_results contains data objects\n    ds_list <- purrr::map2(\n      .x = data_results[[\"Item\"]], \n      .y = data_results[[\"Package\"]],\n      .f = pkg_data_object, .progress = TRUE\n    )\n\n    class_tbl <- dplyr::mutate(data_results,\n      Class = purrr::map(.x = ds_list, .f = class) |>\n        purrr::map(paste0, collapse = \", \") |> unlist()\n    )\n\n    df_tbl <- dplyr::filter(\n      class_tbl,\n      stringr::str_detect(Class, \"data.frame\")\n    )\n\n    if (nrow(df_tbl) == 0) {\n      # df_tbl does not contain 'data.frame' classes\n      data_results <- tibble::as_tibble(\n        data.frame(\n          matrix(\n            nrow = 1, ncol = 11,\n            byrow = TRUE,\n            dimnames = list(\n              NULL,\n              c(\n                \"Package\", \"Item\", \"Title\",\n                \"Class\", \"Columns\", \"Rows\",\n                \"Logical\", \"Numeric\", \"Character\",\n                \"Factor\", \"List\"\n              )\n            )\n          ),\n          row.names = NULL\n        )\n      )\n\n      return(data_results)\n      \n    } else {\n      \n      # df_tbl contains 'data.frame' classes\n      dplyr::mutate(df_tbl,\n        Columns = purrr::map(.x = ds_list, .f = ncol) |>\n          purrr::map(paste0, \" columns\") |> unlist(),\n        Rows = purrr::map(.x = ds_list, .f = nrow) |>\n          purrr::map(paste0, \" rows\") |> unlist(),\n        Logical = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"log\") |> unlist(),\n        Numeric = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"num\") |> unlist(),\n        Character = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"chr\") |> unlist(),\n        Factor = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"fct\") |> unlist(),\n        List = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"lst\") |> unlist())\n      \n    }\n    \n  } else {\n    \n    # data_results does not contains data objects\n    return(data_results)\n    \n  }\n  \n}\n```\n\nRather than go through the debugger process again, I'll go through each of the the mini experiments I used to check the updated `pkg_data_results()` and `pkg_data_str()` functions: \n\n-   Check single package without any data objects (`box`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n      pkg_data_str(\"box\"))\n    ```\n\n-   Check single package with data objects, but none with classes that contain `data.frame` (`stringr`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n    pkg_data_str(\"stringr\"))\n    ```\n    \n-   Check single package with multiple data objects (`dplyr`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n    pkg_data_str(\"dplyr\"))\n    ```\n    \n-   Check multiple packages with multiple data objects (`dplyr`, `forcats` and `lubridate`)\n\n    ```{r}\n    #| eval: true\n    #| echo: true \n    #| code-fold: false\n    knitr::kable(\n    pkg_data_str(c(\"dplyr\", \"forcats\", \"lubridate\")))\n    ```\n\n## Recap\n\nRStudio's debugger is a powerful tool that can save tons of time when you're developing new functions, discovering how a function's code is executed, or dealing with errors. When you've finished debugging, remember to remove the `browser()` call from your function.\n\nThe steps above should help get you started, and if you'd like to learn more, check out the [debugging chapter of Advanced R](https://adv-r.hadley.nz/debugging.html), and the documentation for [`browser()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/browser.html),  [`debug()`/`debugonce()`/`undebug()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/debug.html), and [`traceback()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/traceback.html) functions."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","dpi":320,"toc":true,"toc-depth":5,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"show/hide","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","knitr":{"opts_chunk":{"collapse":true}},"theme":{"light":["litera","../../custom.scss"]},"fig-asp":0.618,"fontsize":"10.5","toc-title":"Contents","toc-location":"left","callout-icon":false,"code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","title-block-banner":true,"title":"Debugging in RStudio","subtitle":"Developing code with `browser()`","author":"Martin Frigaard","date":"2023-06-01","categories":["code","debugging"],"image":"image.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}