{"title":"Testing Shiny apps with `shinytest2`","markdown":{"yaml":{"title":"Testing Shiny apps with `shinytest2`","subtitle":"Part 4: recording tests and snapshots","author":"Martin Frigaard","date":"2023-07-04","categories":["shiny","testing"],"image":"image.svg","toc":true,"toc-depth":5,"toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-fold":"show","code-summary":"show/hide","callout-icon":false,"freeze":true,"execute":{"echo":true,"message":false,"warning":false,"eval":false}},"headingText":"renv::install(\"mjfrigaard/msst2ap\")","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| eval: true\n#| echo: false\n#| include: false\nco_box <- function(color, header, contents = \"Your text\") {\n  class <- switch(color,\n    b = \"note\",\n    g = \"tip\",\n    r = \"important\",\n    o = \"caution\",\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n  switch(color,\n    b = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='true'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    g = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='true'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    o = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    r = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n}\noptions(scipen = 999)\n# renv::install(\"lobstr\")\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(Lahman)\nlibrary(NHANES)\nlibrary(palmerpenguins)\n```\n\n```{r}\n#| label: pkgs\n#| eval: true\n#| code-summary: packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\n```\n\n\n```{r}\n#| label: co_box_test\n#| eval: false\n#| results: asis\n#| include: false\nco_box(color = \"r\", \"RED\", \"**This is red**\n\n  **This is a new line**\n\n  **this a another line**\")\n```\n\n\nThis is the fourth post in a [series on testing](https://mjfrigaard.github.io/series.html#testing-shiny-applications) shiny applications. My previous posts have covered [unit testing utility functions](https://mjfrigaard.github.io/posts/test-shiny-p1/) and [testing module server functions with `testServer()`](https://mjfrigaard.github.io/posts/test-shiny-p3/). In this post, I'll be covering testing shiny applications using `testthat` and `shinytest2`.\n\n::: {.column-margin}\n![](image.svg){width=70%}\n:::\n\n```{r}\n#| label: co_box_dev\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(\n  color = \"r\",\n  header = \"ALERT!\",\n  contents = \"This post is currently under development. Thank you for your patience.\"\n)\n```\n\n## Set up\n\n[`shinytest2`](https://rstudio.github.io/shinytest2/index.html) requires a few steps to get up and running, so I've included my start up steps below (in hopes that someone might find them useful).\n\n### Chromium\n\nFirst make sure you have [Chromium headless browser](https://www.chromium.org/chromium-projects/) installed. Chromium is the browser used to test and debug shiny apps with `shinytest2`.\n\nIf you're using macOS, you can install Chromium using [homebrew](https://formulae.brew.sh/cask/chromium): \n\n```{bash}\n#| eval: false\n#| code-fold: false \nbrew install --cask chromium\n```\n\n```{bash}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide output'\n==> Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==> Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==> Installing Cask chromium\n==> Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==> Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nüç∫  chromium was successfully installed!\n```\n\n\n### [`chromote`]{style=\"font-size: 1.20em\"}\n\nThe [`chromote` package](https://rstudio.github.io/chromote/index.html) allows R to open Chromium. I had to make sure R knew where to find the Chromium application ([this section helps](https://rstudio.github.io/chromote/#specifying-which-browser-to-use)) by passing the path to the app to `Sys.setenv()`\n\n```{r}\n#| eval: false\n#| code-fold: false\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n```\n\nYou can use `find_chrome()` to find your chrome app: \n\n```{r}\n#| eval: false\n#| code-fold: false\nchromote::find_chrome()\n```\n\n*You can also locate the path to Chromium using by holding command <kbd>‚åò</kbd> and clicking on the application icon*\n\nThen set the `CHROMOTE_CHROME` environment variable to the `Chromium` path (**make sure it's not the path to `Chrome.app`**:\n\n```{r}\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n```\n\nVerify the Chromium app/`chromote` install with `ChromoteSession$new()`\n\n```{r}\n#| eval: false\n#| code-fold: false\n#| code-summary: verify ChromoteSession$new()\nb <- ChromoteSession$new()\nb$view()\n```\n\n\n:::: {.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![Chromium](chromium.png){#fig-chromium width=100% fig-align=\"center\"}\n\nChromium headless browser\n:::\n\n::::\n\nGreat! Going through this step means `shinytest2`'s test recorder will (*should*) deploy when I'm recording tests. \n\n## App-package contents\n\nI've created [`msst2ap`](https://github.com/mjfrigaard/msst2ap) (i.e., **M**astering **S**hiny **s**hiny**t**est**2** **a**pp-**p**ackage) with [`devtools` and `usethis`](https://r-pkgs.org/). It somewhat resembles an application using the [`golem` framework](https://engineering-shiny.org/), but with fewer opinions. You can download `msst2ap` [here](https://github.com/mjfrigaard/msst2ap/archive/refs/heads/main.zip) or install it using the following: \n\n```{r}\n#| code-fold: false\n#| eval: false\n#| results: hide\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n```\n\nThe applications in `msst2ap` can be run with the their standalone app functions.\n\n{{< include _modules_apps.qmd >}}\n\n## Using [`shinytest2`]{style=\"font-size: 1.20em\"}\n\n`shinytest2` is extremely [well documentation](https://rstudio.github.io/shinytest2/index.html). I highly recommended the [Get Started vignette](https://rstudio.github.io/shinytest2/articles/shinytest2.html). In the next sections, I'll cover some examples for what I've included in the `msst2ap`.\n\n```{r}\n#| label: co_box_shinytest\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(\n  color = \"b\",\n  header = \"Why `shinytest2`?\",\n  contents = \"\n  **What happened to `shinytest`?**\n  \n  `shinytest2` replaced `shinytest` on 2022-04-27. If you've previously written tests with `shinytest`--or are curious how `shinytest2` if different--I recommend going through the [Migrating from `shinytest`](https://cran.r-project.org/web/packages/shinytest2/vignettes/z-migration.html#:~:text) vignette.\n  \"\n)\n```\n\nRun `shinytest2::use_shinytest2()` to create the initial files for `shinytest2`:\n\n```{r}\n#| echo: true\n#| eval: false\n#| code-fold: false\nshinytest2::use_shinytest2()\n```\n\n```{bash}\n#| echo: true\n#| eval: false\n#| code-fold: true\n#| code-summary: 'show/hide output from use_shinytest2()'\n! Runner already found: tests/testthat.R\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚úî Adding '*_.new.png' to '.gitignore'\n‚úî Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\n‚úî Setting active project to '/projects/msst2ap'\n‚úî Adding 'shinytest2' to Suggests field in DESCRIPTION\n‚Ä¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\n‚Ä¢ Then directly refer to functions with `shinytest2::fun()`\n‚úî Setting active project to '<no active project>'\n```\n\n-   `use_shinytest2()` adds the `setup-shinytest2.R` script to my `tests/testthat/` folder:\n\n    ```{bash}\n    #| echo: true\n    #| eval: false\n    #| code-fold: false\n    tests/testthat/\n    ‚îú‚îÄ‚îÄ _snaps/\n    ‚îî‚îÄ‚îÄ setup-shinytest2.R\n    ```\n\nThe `setup-shinytest2.R` file contains a single call to `shinytest2::load_app_env()`, which \"*Executes all `./R` files and `global.R` into the current environment*\"\n\n## Recording tests\n\nNew tests with [`shinytest2`](https://rstudio.github.io/shinytest2/index.html) can be created by launching the test event recorder, which allows us interact with our application, observe it's behavior, and record inputs, reactive values, and outputs. To record a test, run `shinytest2::record_test()`.\n\nThe first argument in `record_test()` is the path to application. If you've stored your application in an `app.R` file, `record_test()` will automatically load that application. \n\n-   If you encounter a message telling you [Chromium is disconnected](https://github.com/rstudio/shinytest2/issues/331), try installing the development version of `chromote`: \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    # run this in the console to make sure you have dev version of chromote\n    remotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\n    library(chromote)\n    ```\n\nIn `msst2ap`, the application in `app.R` is the `histogramApp()`, so the test recorder will automatically open with this application if I run `record_test()` (without providing the path to a `shiny` app).\n\n```{r}\n#| echo: true\n#| eval: false\n#| code-fold: false\nshinytest2::record_test()\n```\n\n### In Chromium \n\n::::{.column-body-outset-right}\n\n::: {#fig-record_test_histogramApp layout-ncol=1}\n![shinytest2::record_test()](record_test_histogramApp.png){#fig-record_test_histogramApp width=100% fig-align=\"center\"}\n\n`record_test()` with application in `app.R`\n:::\n\n::::\n\nThe `app` argument can also be a \"*path to a Shiny application*\". For example, I have 'development' versions of each application in `msst2ap` in [`inst/dev/`](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev):\n\n```{bash}\n#| echo: true\n#| eval: false \n#| code-fold: true\n#| code-summary: 'show/hide contents of msst2ap/inst/dev'\ninst/dev\n‚îú‚îÄ‚îÄ datasetApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ histogramApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ selectDataVarApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îî‚îÄ‚îÄ selectVarApp\n    ‚îú‚îÄ‚îÄ DESCRIPTION\n    ‚îú‚îÄ‚îÄ R\n    ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n    ‚îú‚îÄ‚îÄ README.md\n    ‚îî‚îÄ‚îÄ app.R\n\n9 directories, 16 files\n```\n\nI can pass the path to each application to the `app` argument in `record_test()`:\n\n```{r}\n#| echo: true\n#| eval: false \n#| code-fold: false\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n```\n\nThis opens Chromium with our shiny app: \n\n::::{.column-body-outset-right}\n\n::: {#fig-record_test_datasetApp layout-ncol=1}\n\n![record_test(\"inst/dev/histogramApp/\")](record_test_histogramApp.png){#fig-record_test_datasetApp width=100% fig-align=\"center\"}\n\n`record_test()` with app in `inst/dev/histogramApp/` folder\n:::\n\n::::\n\nThe test event recorder displays the `shiny` app, but also includes a window for recording each application 'event.' \n\n#### Expectations\n\nI'll start by recording a test for `histogramApp()`. On the right-hand side of the Chromium headless browser, you'll see the **`shinytest2` expectations** window:\n\n::::{.column-body-outset-right}\n\n::: {#fig-shinytest2-expectations layout-ncol=1}\n![`shinytest2` expectations](shinytest2-expectations.png){#fig-expectations}\n\n`shinytest2` expectations in `record_test()`\n:::\n\n::::\n\nThe initial value in the **Code** window displays the dimensions of the application in Chromium (`app$set_window_size(width = , height = )`).\n\n#### Events\n\nWhen I interact with the application (i.e., make changes to the inputs), each change is an 'event' that is recorded in the test:\n\n::::{.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![change inputs](shinytest2-change-inputs.png){#fig-change-values-shinytest2 width=100% fig-align=\"center\"}\n\nChanging app inputs \n:::\n\n::::\n\n#### Code \n\nAll events are recorded as code in the **Code** section of **`shinytest2` expectations**:\n\n::::{.column-body-outset-right}\n\n::: {#fig-shinytest2-code-expectations layout-ncol=1}\n\n![shinytest2 code expectations](shinytest2-expectations-code.png){#fig-shinytest2-expectations-code width=100% fig-align=\"center\"}\n\nRecorded code for each event\n:::\n\n::::\n\n#### Expect Shiny values \n\nWhen I've finished interacting with the application, I click on the **Expect Shiny values** button at the top of **`shinytest2` expectations**. This will add `app$expect_values()` to the **Code** section:\n\n::::{.column-body-outset-right}\n\n::: {#fig-expect-shiny-values layout-ncol=1}\n\n\n![expect-shiny-values](shinytest2-expect-shiny-values.png){#fig-expect-shiny-values width=100% fig-align=\"center\"}\n\n**Expect Shiny values** in `shinytest2` expectations\n:::\n\n::::\n\n#### Save test and exit\n\nFinally, to save the test, enter a **Test name** and click **Save test and exit**\n\n::::{.column-body-outset-right}\n\n::: {#fig-name-save-exit layout-ncol=1}\n\n![name-save-exit](shinytest2-name-save.png){#fig-shinytest2-name-save width=100% fig-align=\"center\"}\n\nName, save and exit `record_test()`\n:::\n\n::::\n\n### In Console\n\nBack in the **Console**, the `shinytest2` test recorder is performing the following actions behind the scenes:\n\n-   The Chromium headless browser opens with the `histogramApp()` and `shiny` is loaded \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    Listening on http://127.0.0.1:7418\n    {shiny} R stderr ----------- Loading required package: shiny\n    ```\n\n\n-   [**`Warning`**]{style=\"font-size: 1.20em\"}: The first warning is a caused by the call to `shiny::loadSupport()`. It's a [known issue](https://github.com/rstudio/shinytest2/issues/264#issuecomment-1251422788), so we can assume the developers are working on it!\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    Warning message:\n    In shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n      Loading R/ subdirectory for Shiny application, but this directory appears to\n      contain an R package. Sourcing files in R/ may cause unexpected behavior.\n    ```\n\n-   We are told the application is being run in [`test mode`](https://rstudio.github.io/shinytest2/reference/AppDriver.html#test-mode), which '*lets the `AppDriver` retrieve values*' from the app \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    {shiny} R stderr ----------- Running application in test mode.\n    {shiny} R stdout ----------- ‚Ñπ Loading msst2ap\n    ```\n\n-   [**`Warning`**]{style=\"font-size: 1.20em\"}: The `tests/testthat.R` file (i.e., the 'test runner') was overwritten and tests are now run with `shinytest2::test_app()`\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    Warning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\n    call to ensure proper a testing environment.\n    ```\n\n-   When I clicked \"**Save test and exit**\", the changes made to `tests/testthat.R` and `tests/testthat/test-shinytest2.R` are saved: \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    ‚Ä¢ Saving test runner: tests/testthat.R\n    ‚Ä¢ Saving test file: tests/testthat/test-shinytest2.R\n    ```\n\n-   A call to `shinytest2::load_app_env()` is added to `setup-shinytest2.R` and the test file (`tests/testthat/test-shinytest2.R`) is opened: \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    ‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n    ‚Ä¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n    ```\n\n-   The new test is saved in the `tests/testthat/test-shinytest2.R` file and automatically run. \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    ‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n    ```\n    \n## Test contents\n\nThe contents of the test file generated from the test recorder are below: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app <- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n```\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on **Run Test** or by using `test_file()` from `testthat`:\n\n```{r}\n#| echo: true\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n```\n\n\n:::: {.callout-important collapse='false' title='WARNING'}\n\n::: {style='font-size: 1.10em; color: #000000;'}\n\nBecause `msst2ap` is a package, running tests with `shinytest2` will produce the warning below:\n  \n![`shiny::loadSupport()` warning](run_tests_out.png){width=100%}\n\nAs noted above, this warning is [known by the `shinytest2` package authors](https://github.com/rstudio/shinytest2/issues/264#issuecomment-1251422788) and is being addressed in a future release. \n\n:::\n\n::::\n\nNow that I know the first `shinytest2` test is passing, I'll dive into each line in the test. \n\n### [`AppDriver`]{style=\"font-size: 1.15em\"}\n\n`shinytest2` uses the [`AppDriver`](https://rstudio.github.io/shinytest2/reference/AppDriver.html) to create \"*a full simulation of a Shiny app*\". When recording tests, this will be the first argument (along with the `name` of the `.png` and `.json` snapshot `testthat` files, and the `height` and `width` of the [`ChromoteSession`](https://rstudio.github.io/chromote/reference/ChromoteSession.html)).\n\n-   The example from the test above is below: \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n     app <- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n    ```\n\n\n### [`set_inputs()`]{style=\"font-size: 1.15em\"}\n\nWhen recording `shinytest2` tests, every change to the applications inputs will result in a call to `app$set_inputs()`. This function is similar to the `testServer()` call to `session$setInputs()` (i.e., the inputs are provided as \"*name-value pairs*\", i.e., `inputId` = `\"value\"`). \n\n-   In the `histogramApp()`, these are provided with the appended namespaces:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      app$set_inputs(`data-dataset` = \"attitude\")\n      app$set_inputs(`var-var` = \"privileges\")\n      app$set_inputs(`hist-bins` = 11)\n      app$set_inputs(`hist-bins` = 12)\n      app$set_inputs(`hist-bins` = 13)\n      app$set_inputs(`hist-bins` = 14)\n      app$set_inputs(`hist-bins` = 15)\n    ```\n\n### [`expect_values()`]{style=\"font-size: 1.15em\"}\n\n[The documentation](https://rstudio.github.io/shinytest2/articles/in-depth.html#making-expectations) on `expect_values()` is definitely worth reading. `expect_values()` is added to the test file when **Expect Shiny values** is clicked in the test recorder and \"*creates a list of values and compares them to the current values of the application*.\"\n\n-   `expect_values()` = \"*Expect all `input`, `output`, and `export` values are consistent*\"\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      app$expect_values()\n    ```\n\n\n## Test results\n\nThe results from running the new test file (`test-shinytest2.R`) are below: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n‚úî | F W S  OK | Context\n‚úî |   2     1 | shinytest2 [6.3s]                                             \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n```\n\nTwo warnings are displayed because the test adds two new files to the `tests/testthat/_snaps/` folder: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntests/testthat/_snaps/\n‚îî‚îÄ‚îÄ shinytest2\n    ‚îú‚îÄ‚îÄ histogramApp-001.json\n    ‚îî‚îÄ‚îÄ histogramApp-001_.png\n\n2 directories, 2 files\n```\n\nThese are the files new test runs will be compared against (i.e., our 'baseline' snapshots). I'll briefly cover their contents below: \n\n### [`_snaps`]{style=\"font-size: 1.15em\"}\n\n`expect_values()` generates two snapshot files in the `tests/testthat/_snaps/` folder: one `.png` and one `.json` file:\n\n#### [`.png`]{style=\"font-size: 1.20em\"}\n\nThe image saved in `tests/testthat/_snaps/histogramApp-001_.png` is below:\n\n![](histogramApp-001_.png){fig-align='center'}\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (**`attitude`** and **`privileges`**).\n\n#### [`.json`]{style=\"font-size: 1.20em\"}\n\nThe `.json` file saved in `tests/testthat/_snaps/histogramApp-001.json` contains the snapshot `input`s, `output`s, and `export`s:\n\n-   The inputs show the three changed values (`\"data-dataset\"`, `\"var-var\"`, and `\"hist-bins\"`).\n \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: show\n    #| code-summary: 'show/hide snapshot inputs' \n    {\n      \"input\": {\n        \"data-dataset\": \"attitude\",\n        \"hist-bins\": 15,\n        \"var-var\": \"privileges\"\n      },\n    ```\n    \nThe two outputs are stored in `\"hist-hist\"` and `\"vals\"`:\n\n-   `\"hist-hist\"` holds the updated image (stored in the `image data hash`), along with various other characteristics of the plot:\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: true  \n    #| code-summary: 'show/hide snapshot outputs'\n      \"output\": {\n        \"hist-hist\": {\n          \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n          \"width\": 682.6640625,\n          \"height\": 400,\n          \"alt\": \"Plot object\",\n          \"coordmap\": {\n            \"panels\": [\n              {\n                \"domain\": {\n                  \"left\": 27.8,\n                  \"right\": 87.2,\n                  \"bottom\": -0.24,\n                  \"top\": 6.24\n                },\n                \"range\": {\n                  \"left\": 78.79664956011726,\n                  \"right\": 642.3048029692084,\n                  \"bottom\": 301.08,\n                  \"top\": 77.71999999999998\n                },\n                \"log\": {\n                  \"x\": null,\n                  \"y\": null\n                },\n                \"mapping\": {\n    \n                }\n              }\n            ],\n            \"dims\": {\n              \"width\": 682.6640625,\n              \"height\": 400\n            }\n          }\n        },\n    ```\n    \n-   `\"vals\"` contains the reactive values from `reactiveValuesToList()`:\n    \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: show  \n    #| code-summary: 'show/hide snapshot outputs'\n        \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n      },\n    ```\n\n-   I didn't export any values in this test, so `\"export\"` is empty:\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: show  \n    #| code-summary: 'show/hide snapshot outputs'\n      \"export\": {\n    \n      }\n    }\n    ```\n\n    -   *I'll cover this in a later test.*\n  \n#### Namespaces\n\nThe contents of the `.json` snapshot should look *somewhat* familiar for the three modules contained in  `histogramApp()`:\n\n-   For example, the `inputId` for `\"dataset\"` in the `datasetInput/Server` module communicates between the UI and server using the shared `id` argument `\"data\"`\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false  \n    # in datasetInput()\n      shiny::selectInput(\n        shiny::NS(id, \"dataset\"),\n        \"Pick a dataset\",\n        choices = names)\n    # in histogramApp()\n      shiny::sidebarPanel(\n            datasetInput(\"data\", is.data.frame)\n          )\n    ```\n    \n-   This creates the ```` $`data-dataset` ```` output we see the `verbatimTextOutput()` at the bottom of the application: \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    $`data-dataset`\n    [1] \"attitude\"\n    ```\n    \n-   In the `.json` snapshot, this `inputId` is represented in the following `\"input\"`:\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    {\n      \"input\": {\n        \"data-dataset\": \"attitude\",\n      },\n    ```\n    \nNamespaces and `inputId`s will come up again if you start writing your own tests, which I'll cover below. \n\n## Writing tests\n\nThe great thing about testing with `shinytest2` is the ability to interact with the `AppDriver` as you write tests. I'll demo writing a test for the `datasetApp()` by adapting the contents of `test-shinytest2.R` into a new `test-shinytest2-datasetApp.R` file.\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îÇ   ‚îî‚îÄ‚îÄ shinytest2/\n‚îÇ       ‚îú‚îÄ‚îÄ histogramApp-001.json\n‚îÇ       ‚îî‚îÄ‚îÄ histogramApp-001_.png\n‚îú‚îÄ‚îÄ setup-shinytest2.R\n‚îú‚îÄ‚îÄ test-shinytest2-datasetApp.R <- new test file!\n‚îî‚îÄ‚îÄ test-shinytest2.R\n\n3 directories, 5 files\n```\n\n\nIn the new test `test-shinytest2-datasetApp.R` file, I'll start with a call to `testthat::test_that(),` then create a new `app` object with the Chromium headless browser. \n\nThe namespaced standalone app function can be used to create a `ds_app` object, then `ds_app` is passed to the first argument of `AppDriver$new()` (I've adjusted the `height` and `weight` to fit the `datasetApp()`).\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n})\n```\n\nIn the **Console**, I can use `app$view()` to open the Chromium browser: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\napp$view()\n```\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view layout-ncol=1}\n\n![`app$view()`](app_view.png){#fig-app_view}\n\nView application with `app$view()`\n:::\n\n::::\n\nChromium displays the same app I see when I run `msst2ap::datasetApp()` in the console, but the headless browser has some additional developer tools ([read more](https://www.browserstack.com/guide/difference-between-chrome-and-chromium)).  \n\n### Setting inputs \n\nIf I continue to adapt each line in `test-shinytest2.R` to the `datasetApp()`, I see that next lines set the `inputId`s for `dataset-dataset` to the `attitude` dataset with `app$set_input()` (*Note that this uses the module notation above (i.e., `\"id-inputId\"`*):\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n```\n\nIf you can see both windows, you'll see the application values change in the Chromium browser: \n\n::::{.column-page-right}\n\n::: {#fig-set_inputs layout-ncol=1}\n\n![`app$set_inputs()`](app_set_inputs.png){#fig-app_set_inputs}\n\nSet application inputs with `app$set_inputs()`\n:::\n\n::::\n\n### Checking inputs\n\nIn the previous test, I used the `expect_values()` to capture a list of all the app values (`input`, `output`, `export`). I can also capture these values in a list *inside* the test by including a call to `app$get_values()` and assigning the output to `app_values`.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n})\n```\n\n`app_values` has a similar structure to the `.json` snapshot covered above (i.e., with `input`, `output`, and `export`): \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nstr(app_values)\n```\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"<table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n```\n\nI can narrow the scope of the test by using `app_values` to verify only the `input` that was changed with `app$set_inputs()`::\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n```\n\nAt the end of the test, I'll add a call [`app$stop()`](https://rstudio.github.io/shinytest2/articles/zzz-faq.html#should-i-manually-shut-down-my-appdriver) to close the Chromium app.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n```\n\n### Running tests\n\nI'll save the `test-shinytest2-datasetApp.R` file and run the test with `testthat::test_file()`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n```\n\n:::: {.callout-important collapse='false' title='WARNING'}\n\n::: {style='font-size: 1.10em; color: #000000;'}\n\nIf you encounter the error message below: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\n‚îÄ‚îÄ Skipped tests (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚Ä¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n```\n\nTry installing and loading `chromote` and `shinytest2` again (this seemed to work for me).\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n```\n\n:::\n\n::::\n\nIn the initial run of the test for `datasetApp()`, no snapshot files are generated because the test didn't include a call to `app$export_values()`. \n\nI see this initial test passes:  \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n```\n\n## Exporting test values \n\nThe `shinytest2` documentation [repeatedly](https://rstudio.github.io/shinytest2/articles/in-depth.html#exported-values) [recommends](https://rstudio.github.io/shinytest2/articles/robust.html#exported-values) exporting test values from shiny applications with `shiny::exportTestValues()`. \n\n### [`exportTestValues()`]{style=\"font-size: 1.20em\"}\n\nI'll demonstrate exporting test values from `selectVarApp()` by adding the following to the `server` function in `inst/dev/app.R`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  server <- function(input, output, session) {\n\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n```\n\n### Using [`system.file()`]{style=\"font-size: 1.20em\"}\n\nAfter loading, documenting and installing the package, I'll create a `test-shinytest2-selectVarApp.R` test file and add the initial contents to create the `AppDriver` object:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n```\n\nNote that to test the development version of `selectVarApp()`, I pass a call to `system.file()` to the `app_dir` argument (this is a similar folder structure to apps built with [`golem`](https://thinkr-open.github.io/golem/articles/a_start.html) and [`leprechaun`](https://leprechaun.opifex.org/#/guide/build) frameworks) \n\n\nAfter entering `app$view()` in the **Console**, the application opens in the Chromium headless browser again:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\napp$view()\n```\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_selectVarApp layout-ncol=1}\n\n![`app$view()`](app_view_selectVarApp.png){#fig-app_view_selectVarApp}\n\nView `selectVarApp()` application with `app$view()`\n:::\n\n::::\n\nIn the test file, I'll use `app$set_values()` to change the ```` $`data-dataset` ```` and ```` $`var-var` ```` inputs:\n\n-   Change ```` $`data-dataset` ```` to `mtcars`:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    testthat::test_that(\"{shinytest2}: selectVarApp\", {\n      app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                                 package = \"msst2ap\"),\n                           height = 600, width = 600)\n      \n        app$set_inputs(`data-dataset` = \"mtcars\")\n        \n    })\n    ```\n\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_set_data_selectVarApp layout-ncol=1}\n\n![Set `data-dataset`](app_view_set_data_selectVarApp.png){#fig-app_view_set_data_selectVarApp}\n\nView `selectVarApp()` after setting `data-dataset` with `app$set_inputs()`\n:::\n\n::::\n\n-   Change ```` $`var-var` ```` to `wt`:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    testthat::test_that(\"{shinytest2}: selectVarApp\", {\n      app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                                 package = \"msst2ap\"),\n                           height = 600, width = 600)\n      \n        app$set_inputs(`data-dataset` = \"mtcars\")\n        app$set_inputs(`var-var` = \"wt\")\n        \n    })\n    ```\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_set_var_selectVarApp layout-ncol=1}\n\n![Set `var-var`](app_view_set_var_selectVarApp.png){#fig-app_view_set_var_selectVarApp}\n\nView `selectVarApp()` after setting `var-var` with `app$set_inputs()`\n:::\n\n::::\n\n### [`get_values()`]{style=\"font-size: 1.20em\"} \n\nI'll use `app$get_values()` to store the exported `input`, `output`, and `export` test values in `app_values`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values <- app$get_values()\n    \n})\n```\n\n`app_values` is a list (similar to the `.json` snapshot file), but now we've explicitly `export`ed values from the server in `selectVarApp()`: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nnames(app_values$export)\n```\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[1] \"data\" \"var\" \n```\n\n### [`export`]{style=\"font-size: 1.20em\"}ed expectations\n\nI can use `app_values` to verify the structure of each exported object: \n\n-   `data` should be a `data.frame()`\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n```\n\n-   `var` should be a single column `data.frame()`\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n```\n\nOnce again, I end the test with a call to `app$stop()`. The completed test for `selectVarApp()` is below:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values <- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n```\n\nI can run the test with `testthat::test_file()`.  \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n```\n\nThe results are below: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n```\n\n## Testing complex outputs \n\nI've created an adapted version of the `histogramApp()` in the `inst/dev/gghistApp/` folder (view contents [here](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev/gghistApp#gghistapp)):\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false \ninst/dev/gghistApp/\n            ‚îú‚îÄ‚îÄ DESCRIPTION\n            ‚îú‚îÄ‚îÄ R/\n            ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n            ‚îú‚îÄ‚îÄ README.md\n            ‚îî‚îÄ‚îÄ app.R\n\n2 directories, 4 files\n```\n\n`gghistApp()` renders a `ggplot2` graph, which makes it easier to demonstrate [this example of checking a plot](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the `shinytest2` package website. \n\n::::{.column-page-inset-right}\n\n::: {#fig-sbs_histogramApp_gghistApp layout-ncol=2}\n\n![`histogramApp()`](sbs_histogramApp.png){#fig-sbs_histogramApp}\n\n![`gghistApp()`](sbs_gghistApp.png){#fig-sbs_gghistApp}\n\n\n`histogramApp()` vs. `gghistApp()`\n\n:::\n\n::::\n\nThe `gghistApp()` is similar to `histogramApp()`, but instead of using `hist()` to generate the plot, a reactive `plot_obj()` is passed to `shiny::renderPlot()` (like the example above).\n\nDue to the structure of the modules in the application, the `exportTestValues()` function is placed in the `gghistServer()` function:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: show \n#| code-summary: 'show/hide gghistServer()'\ngghistServer <- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj <- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist <- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |>\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n```\n\n-   `gghistServer()` is replaces `histogramServer()` in the standalone app function (`gghistApp()`): \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: true \n    #| code-summary: 'show/hide gghistApp()'\n    gghistApp <- function() {\n      ui <- shiny::fluidPage(\n        shiny::sidebarLayout(\n          shiny::sidebarPanel(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n          ),\n          shiny::mainPanel(\n            histogramOutput(\"hist\"),\n            shiny::verbatimTextOutput(\"vals\")\n          )\n        )\n      )\n    \n      server <- function(input, output, session) {\n    \n        data <- datasetServer(\"data\")\n    \n        x <- selectVarServer(\"var\", data)\n    \n        gghistServer(\"hist\", x)\n    \n        output$vals <- shiny::renderPrint({\n          x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n          print(x, width = 30, max.levels = NULL)\n          }, width = 30)\n    \n      }\n    \n      shiny::shinyApp(ui, server)\n    }\n    ```\n\nIn the `test-shinytest2-gghistApp.R` test file, I'll verify the [`vdiffr` package](https://vdiffr.r-lib.org/) is installed with `testthat::skip_if_not_installed()`, then create the `AppDriver` object with a call to `system.file()` and set the `height` and `width`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false \ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n```\n\nView the application in the Chromium browser by running `app$view()` in the **Console**:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\napp$view()\n```\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_gghistApp layout-ncol=1}\n\n![`app$view()`](app_view_gghistApp.png){#fig-app_view_gghistApp}\n\nView `gghistApp()` application with `app$view()`\n:::\n\n::::\n\nI'll replicate the [example](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the website using the `gghistApp()`:\n\n### Verify initial [`input`]{style=\"font-size: 1.20em\"}\n\n-   The first expectations in the example test the default `input` values with **`app$get_value(input = )`**:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify initial data\n      app_init_data <- app$get_value(input = \"data-dataset\")\n      testthat::expect_equal(\n        object = app_init_data,\n        expected = \"BOD\")\n    \n      # Verify initial variable\n      app_init_var <- app$get_value(input = \"var-var\")\n      testthat::expect_equal(\n        object = app_init_var,\n        expected = \"Time\")\n    ```\n    \n### Set and verify [`export`]{style=\"font-size: 1.20em\"}\n    \n-   Next, we check the exported values after changing the inputs with `app$set_values()` and **`app$get_value(export = )`**\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify exported `x()` data\n      app$set_inputs(`data-dataset` = \"mtcars\")\n      app_exp_x_01 <- app$get_value(export = \"hist-x\")\n      testthat::expect_equal(\n        object = app_exp_x_01, \n        expected = mtcars[1])\n      \n      # Verify exported `plot_obj()` data\n      app$set_inputs(`var-var` = \"wt\")\n      app_exp_plot_obj_01 <- app$get_value(export = \"hist-plot_obj\")\n      testthat::expect_equal(\n        object = app_exp_plot_obj_01,\n        expected = purrr::as_vector(app_exp_plot_obj_01))\n    ```\n    \n-   The `bins` are also set to a new value with `app$set_inputs()` *after* verifying the exported values:\n    \n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify `hist-bins` changes\n      app$set_inputs(`hist-bins` = 15)\n      app_set_bins_01 <- app$get_value(input = \"hist-bins\")\n      testthat::expect_equal(\n        object = app_set_bins_01,\n        expected = 15)\n    ```\n    \n::::{.column-page-inset-right}\n\n::: {#fig-app_view_set_inputs_gghistApp layout-ncol=1}\n\n![`set_inputs()` and `get_value()` in `gghistApp()` ](app_view_set_inputs_gghistApp.png){#fig-app_view_set_inputs_gghistApp width=100%}\n\nSet `input`s and get `export`ed values in `gghistApp()`\n:::\n\n::::\n    \n### Verify plot with [`vdiffr`]{style=\"font-size: 1.20em\"}\n\n-   Now we verify the plot with the exported `plot_obj` (in the `hist` module) with `expect_doppelganger()` from the `vdiffr` package. \n    \n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify `hist-plot_obj` changes\n      plot_obj_15 <- app$get_value(export = \"hist-plot_obj\")\n      vdiffr::expect_doppelganger(\n        title = \"hist-plot_obj-15\",\n        fig = plot_obj_15)\n    ```\n    \n    -   *I saved the test file and ran the test to confirm the snapshot file was created in `tests/testthat/_snaps/`*:\n    \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n    ‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\n    Adding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n    ```\n    \n### [`set_`, `get_`, `expect_`]{style=\"font-size: 1.10em\"}\n\nThe process above is repeated with new values passed to **`app$set_inputs()`** and verified with **`app$get_value(export = )`**:\n    \n-   The `x()`, `plot_obj()` and `hist-bins` are updated again with new values: \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      ## Update `data` to USArrests\n      app$set_inputs(`data-dataset` = \"USArrests\")\n      app_exp_x_02 <- app$get_value(export = \"hist-x\")\n      testthat::expect_equal(\n        object = app_exp_x_02,\n        expected = USArrests[1])\n    \n      ## Update `var` to UrbanPop\n      app$set_inputs(`var-var` = \"UrbanPop\")\n      app_exp_plot_obj_02 <- app$get_value(export = \"hist-plot_obj\")\n      testthat::expect_equal(\n        object = app_exp_plot_obj_02,\n        expected = purrr::as_vector(app_exp_plot_obj_02))\n    \n      ## Update `bins` to 12\n      app$set_inputs(`hist-bins` = 12)\n      app_set_bins_02 <- app$get_value(input = \"hist-bins\")\n      expect_equal(\n        object = app_set_bins_02,\n        expected = 12)\n    ```\n    \n-   The new plot is verified again with `expect_doppelganger()`\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      ## Verify updates to `hist-plot_obj`\n      plot_obj_12 <- app$get_value(export = \"hist-plot_obj\")\n      vdiffr::expect_doppelganger(\n        title = \"hist-plot_obj-12\",\n        fig = plot_obj_12)\n    ```\n\n    -   *This initial run of this test will show a warning again as the snapshot file is saved to `tests/testthat/_snaps/`*:\n    \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n    ‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\n    Adding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n    ```\n    \n### Results \n\nThe final results of the `test-shinytest2-gghistApp.R` are below:\n    \n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n```\n    \n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n```\n\nThe vector in each `plot_obj()` test is printed with `expect_doppelganger()`, but this doesn't interfere with the results. \n\nI can run `devtools::test()` to run all the tests in `msst2ap`: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ndevtools::test()\n```\n\n\n## Recap\n\nThis post has covered creating tests with `testthat` and `shinytest2` for an app-package containing a shiny application (with modules!). As you can see, the test recorder makes it easier to test specific app behaviors, and the `AppDriver` makes it possible to build a set of test expectations iteratively. Other items to consider when writing `shinytest2` tests include: \n\n1. **Define What to Test**: Since Shiny apps are interactive, so `shinytest2` tests should simulate user interaction as much as possible. The tests should focus on key user interactions and the output they should generate. `shinytest2` provides functions for simulating user clicks, inputs, and other interactions. Not every interaction needs to be tested, but crucial ones and those that handle complex logic should be.\n\n2. **Organize Your Tests & Use Descriptive Test Names**: Organize your tests into separate files based on what they are testing. Each test should have a descriptive name that clarifies what the test is for. Organizing your test files with unambiguous names will make it easier to manage multiple tests, and it will make it easier to understand what's going wrong when a test fails.\n\n3. **Create snapshots for expected outputs**: Use snapshot files to verify that an app's output matches the expected results. `AppDriver$expect_values()` generates `.json` and `.png` snapshot files for the application. The .json file contains `input`, `output`, and `export` values, and the .png file is a *debug* screenshot, which records how the app looked when the values where captured. These files can then be compared to a baseline snapshot.\n\n4. **Export app values**: While snapshot files are great for detecting changes, it's important to remember that \"*differences in the captured screenshot will never cause test failures.*\" Manually inspecting the snapshot .png files during test development can also be time-consuming and tedious. Wherever possible, export app values and compare them against expected reference values.\n\nIn general, `shinytest2` is designed for end-to-end testing of shiny applications. These tests can capture the state of a shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots), which is useful for regression testing. \n\n`shinytest2` tests can also simulate user interaction in a way that `shiny::testServer()` tests can't, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. `shinytest2` can also be resource-intensive, so it's recommended to write these tests after you've completed the standard `testthat` unit tests and `testServer()` tests.\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| eval: true\n#| echo: false\n#| include: false\nco_box <- function(color, header, contents = \"Your text\") {\n  class <- switch(color,\n    b = \"note\",\n    g = \"tip\",\n    r = \"important\",\n    o = \"caution\",\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n  switch(color,\n    b = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='true'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    g = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='true'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    o = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    r = cat(paste0(\n      \"\\n\",\n      \":::: {.callout-\", class, \" collapse='false'}\", \"\\n\\n\",\n      \"## \", header, \"\\n\\n\",\n      \"::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\\n\\n\",\n      glue::glue_collapse(contents), \"\\n\\n\",\n      \"::: \\n\\n\",\n      \"::::\", \"\\n\"\n    )),\n    stop(\"Invalid `type`\", call. = FALSE)\n  )\n}\noptions(scipen = 999)\n# renv::install(\"mjfrigaard/msst2ap\")\n# renv::install(\"lobstr\")\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(Lahman)\nlibrary(NHANES)\nlibrary(palmerpenguins)\n```\n\n```{r}\n#| label: pkgs\n#| eval: true\n#| code-summary: packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\n```\n\n\n```{r}\n#| label: co_box_test\n#| eval: false\n#| results: asis\n#| include: false\nco_box(color = \"r\", \"RED\", \"**This is red**\n\n  **This is a new line**\n\n  **this a another line**\")\n```\n\n\nThis is the fourth post in a [series on testing](https://mjfrigaard.github.io/series.html#testing-shiny-applications) shiny applications. My previous posts have covered [unit testing utility functions](https://mjfrigaard.github.io/posts/test-shiny-p1/) and [testing module server functions with `testServer()`](https://mjfrigaard.github.io/posts/test-shiny-p3/). In this post, I'll be covering testing shiny applications using `testthat` and `shinytest2`.\n\n::: {.column-margin}\n![](image.svg){width=70%}\n:::\n\n```{r}\n#| label: co_box_dev\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(\n  color = \"r\",\n  header = \"ALERT!\",\n  contents = \"This post is currently under development. Thank you for your patience.\"\n)\n```\n\n## Set up\n\n[`shinytest2`](https://rstudio.github.io/shinytest2/index.html) requires a few steps to get up and running, so I've included my start up steps below (in hopes that someone might find them useful).\n\n### Chromium\n\nFirst make sure you have [Chromium headless browser](https://www.chromium.org/chromium-projects/) installed. Chromium is the browser used to test and debug shiny apps with `shinytest2`.\n\nIf you're using macOS, you can install Chromium using [homebrew](https://formulae.brew.sh/cask/chromium): \n\n```{bash}\n#| eval: false\n#| code-fold: false \nbrew install --cask chromium\n```\n\n```{bash}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide output'\n==> Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==> Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==> Installing Cask chromium\n==> Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==> Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nüç∫  chromium was successfully installed!\n```\n\n\n### [`chromote`]{style=\"font-size: 1.20em\"}\n\nThe [`chromote` package](https://rstudio.github.io/chromote/index.html) allows R to open Chromium. I had to make sure R knew where to find the Chromium application ([this section helps](https://rstudio.github.io/chromote/#specifying-which-browser-to-use)) by passing the path to the app to `Sys.setenv()`\n\n```{r}\n#| eval: false\n#| code-fold: false\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n```\n\nYou can use `find_chrome()` to find your chrome app: \n\n```{r}\n#| eval: false\n#| code-fold: false\nchromote::find_chrome()\n```\n\n*You can also locate the path to Chromium using by holding command <kbd>‚åò</kbd> and clicking on the application icon*\n\nThen set the `CHROMOTE_CHROME` environment variable to the `Chromium` path (**make sure it's not the path to `Chrome.app`**:\n\n```{r}\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n```\n\nVerify the Chromium app/`chromote` install with `ChromoteSession$new()`\n\n```{r}\n#| eval: false\n#| code-fold: false\n#| code-summary: verify ChromoteSession$new()\nb <- ChromoteSession$new()\nb$view()\n```\n\n\n:::: {.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![Chromium](chromium.png){#fig-chromium width=100% fig-align=\"center\"}\n\nChromium headless browser\n:::\n\n::::\n\nGreat! Going through this step means `shinytest2`'s test recorder will (*should*) deploy when I'm recording tests. \n\n## App-package contents\n\nI've created [`msst2ap`](https://github.com/mjfrigaard/msst2ap) (i.e., **M**astering **S**hiny **s**hiny**t**est**2** **a**pp-**p**ackage) with [`devtools` and `usethis`](https://r-pkgs.org/). It somewhat resembles an application using the [`golem` framework](https://engineering-shiny.org/), but with fewer opinions. You can download `msst2ap` [here](https://github.com/mjfrigaard/msst2ap/archive/refs/heads/main.zip) or install it using the following: \n\n```{r}\n#| code-fold: false\n#| eval: false\n#| results: hide\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n```\n\nThe applications in `msst2ap` can be run with the their standalone app functions.\n\n{{< include _modules_apps.qmd >}}\n\n## Using [`shinytest2`]{style=\"font-size: 1.20em\"}\n\n`shinytest2` is extremely [well documentation](https://rstudio.github.io/shinytest2/index.html). I highly recommended the [Get Started vignette](https://rstudio.github.io/shinytest2/articles/shinytest2.html). In the next sections, I'll cover some examples for what I've included in the `msst2ap`.\n\n```{r}\n#| label: co_box_shinytest\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(\n  color = \"b\",\n  header = \"Why `shinytest2`?\",\n  contents = \"\n  **What happened to `shinytest`?**\n  \n  `shinytest2` replaced `shinytest` on 2022-04-27. If you've previously written tests with `shinytest`--or are curious how `shinytest2` if different--I recommend going through the [Migrating from `shinytest`](https://cran.r-project.org/web/packages/shinytest2/vignettes/z-migration.html#:~:text) vignette.\n  \"\n)\n```\n\nRun `shinytest2::use_shinytest2()` to create the initial files for `shinytest2`:\n\n```{r}\n#| echo: true\n#| eval: false\n#| code-fold: false\nshinytest2::use_shinytest2()\n```\n\n```{bash}\n#| echo: true\n#| eval: false\n#| code-fold: true\n#| code-summary: 'show/hide output from use_shinytest2()'\n! Runner already found: tests/testthat.R\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚úî Adding '*_.new.png' to '.gitignore'\n‚úî Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\n‚úî Setting active project to '/projects/msst2ap'\n‚úî Adding 'shinytest2' to Suggests field in DESCRIPTION\n‚Ä¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\n‚Ä¢ Then directly refer to functions with `shinytest2::fun()`\n‚úî Setting active project to '<no active project>'\n```\n\n-   `use_shinytest2()` adds the `setup-shinytest2.R` script to my `tests/testthat/` folder:\n\n    ```{bash}\n    #| echo: true\n    #| eval: false\n    #| code-fold: false\n    tests/testthat/\n    ‚îú‚îÄ‚îÄ _snaps/\n    ‚îî‚îÄ‚îÄ setup-shinytest2.R\n    ```\n\nThe `setup-shinytest2.R` file contains a single call to `shinytest2::load_app_env()`, which \"*Executes all `./R` files and `global.R` into the current environment*\"\n\n## Recording tests\n\nNew tests with [`shinytest2`](https://rstudio.github.io/shinytest2/index.html) can be created by launching the test event recorder, which allows us interact with our application, observe it's behavior, and record inputs, reactive values, and outputs. To record a test, run `shinytest2::record_test()`.\n\nThe first argument in `record_test()` is the path to application. If you've stored your application in an `app.R` file, `record_test()` will automatically load that application. \n\n-   If you encounter a message telling you [Chromium is disconnected](https://github.com/rstudio/shinytest2/issues/331), try installing the development version of `chromote`: \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    # run this in the console to make sure you have dev version of chromote\n    remotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\n    library(chromote)\n    ```\n\nIn `msst2ap`, the application in `app.R` is the `histogramApp()`, so the test recorder will automatically open with this application if I run `record_test()` (without providing the path to a `shiny` app).\n\n```{r}\n#| echo: true\n#| eval: false\n#| code-fold: false\nshinytest2::record_test()\n```\n\n### In Chromium \n\n::::{.column-body-outset-right}\n\n::: {#fig-record_test_histogramApp layout-ncol=1}\n![shinytest2::record_test()](record_test_histogramApp.png){#fig-record_test_histogramApp width=100% fig-align=\"center\"}\n\n`record_test()` with application in `app.R`\n:::\n\n::::\n\nThe `app` argument can also be a \"*path to a Shiny application*\". For example, I have 'development' versions of each application in `msst2ap` in [`inst/dev/`](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev):\n\n```{bash}\n#| echo: true\n#| eval: false \n#| code-fold: true\n#| code-summary: 'show/hide contents of msst2ap/inst/dev'\ninst/dev\n‚îú‚îÄ‚îÄ datasetApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ histogramApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ selectDataVarApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îî‚îÄ‚îÄ selectVarApp\n    ‚îú‚îÄ‚îÄ DESCRIPTION\n    ‚îú‚îÄ‚îÄ R\n    ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n    ‚îú‚îÄ‚îÄ README.md\n    ‚îî‚îÄ‚îÄ app.R\n\n9 directories, 16 files\n```\n\nI can pass the path to each application to the `app` argument in `record_test()`:\n\n```{r}\n#| echo: true\n#| eval: false \n#| code-fold: false\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n```\n\nThis opens Chromium with our shiny app: \n\n::::{.column-body-outset-right}\n\n::: {#fig-record_test_datasetApp layout-ncol=1}\n\n![record_test(\"inst/dev/histogramApp/\")](record_test_histogramApp.png){#fig-record_test_datasetApp width=100% fig-align=\"center\"}\n\n`record_test()` with app in `inst/dev/histogramApp/` folder\n:::\n\n::::\n\nThe test event recorder displays the `shiny` app, but also includes a window for recording each application 'event.' \n\n#### Expectations\n\nI'll start by recording a test for `histogramApp()`. On the right-hand side of the Chromium headless browser, you'll see the **`shinytest2` expectations** window:\n\n::::{.column-body-outset-right}\n\n::: {#fig-shinytest2-expectations layout-ncol=1}\n![`shinytest2` expectations](shinytest2-expectations.png){#fig-expectations}\n\n`shinytest2` expectations in `record_test()`\n:::\n\n::::\n\nThe initial value in the **Code** window displays the dimensions of the application in Chromium (`app$set_window_size(width = , height = )`).\n\n#### Events\n\nWhen I interact with the application (i.e., make changes to the inputs), each change is an 'event' that is recorded in the test:\n\n::::{.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![change inputs](shinytest2-change-inputs.png){#fig-change-values-shinytest2 width=100% fig-align=\"center\"}\n\nChanging app inputs \n:::\n\n::::\n\n#### Code \n\nAll events are recorded as code in the **Code** section of **`shinytest2` expectations**:\n\n::::{.column-body-outset-right}\n\n::: {#fig-shinytest2-code-expectations layout-ncol=1}\n\n![shinytest2 code expectations](shinytest2-expectations-code.png){#fig-shinytest2-expectations-code width=100% fig-align=\"center\"}\n\nRecorded code for each event\n:::\n\n::::\n\n#### Expect Shiny values \n\nWhen I've finished interacting with the application, I click on the **Expect Shiny values** button at the top of **`shinytest2` expectations**. This will add `app$expect_values()` to the **Code** section:\n\n::::{.column-body-outset-right}\n\n::: {#fig-expect-shiny-values layout-ncol=1}\n\n\n![expect-shiny-values](shinytest2-expect-shiny-values.png){#fig-expect-shiny-values width=100% fig-align=\"center\"}\n\n**Expect Shiny values** in `shinytest2` expectations\n:::\n\n::::\n\n#### Save test and exit\n\nFinally, to save the test, enter a **Test name** and click **Save test and exit**\n\n::::{.column-body-outset-right}\n\n::: {#fig-name-save-exit layout-ncol=1}\n\n![name-save-exit](shinytest2-name-save.png){#fig-shinytest2-name-save width=100% fig-align=\"center\"}\n\nName, save and exit `record_test()`\n:::\n\n::::\n\n### In Console\n\nBack in the **Console**, the `shinytest2` test recorder is performing the following actions behind the scenes:\n\n-   The Chromium headless browser opens with the `histogramApp()` and `shiny` is loaded \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    Listening on http://127.0.0.1:7418\n    {shiny} R stderr ----------- Loading required package: shiny\n    ```\n\n\n-   [**`Warning`**]{style=\"font-size: 1.20em\"}: The first warning is a caused by the call to `shiny::loadSupport()`. It's a [known issue](https://github.com/rstudio/shinytest2/issues/264#issuecomment-1251422788), so we can assume the developers are working on it!\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    Warning message:\n    In shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n      Loading R/ subdirectory for Shiny application, but this directory appears to\n      contain an R package. Sourcing files in R/ may cause unexpected behavior.\n    ```\n\n-   We are told the application is being run in [`test mode`](https://rstudio.github.io/shinytest2/reference/AppDriver.html#test-mode), which '*lets the `AppDriver` retrieve values*' from the app \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    {shiny} R stderr ----------- Running application in test mode.\n    {shiny} R stdout ----------- ‚Ñπ Loading msst2ap\n    ```\n\n-   [**`Warning`**]{style=\"font-size: 1.20em\"}: The `tests/testthat.R` file (i.e., the 'test runner') was overwritten and tests are now run with `shinytest2::test_app()`\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    Warning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\n    call to ensure proper a testing environment.\n    ```\n\n-   When I clicked \"**Save test and exit**\", the changes made to `tests/testthat.R` and `tests/testthat/test-shinytest2.R` are saved: \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    ‚Ä¢ Saving test runner: tests/testthat.R\n    ‚Ä¢ Saving test file: tests/testthat/test-shinytest2.R\n    ```\n\n-   A call to `shinytest2::load_app_env()` is added to `setup-shinytest2.R` and the test file (`tests/testthat/test-shinytest2.R`) is opened: \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    ‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n    ‚Ä¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n    ```\n\n-   The new test is saved in the `tests/testthat/test-shinytest2.R` file and automatically run. \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    ‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n    ```\n    \n## Test contents\n\nThe contents of the test file generated from the test recorder are below: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app <- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n```\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on **Run Test** or by using `test_file()` from `testthat`:\n\n```{r}\n#| echo: true\n#| eval: false\n#| code-fold: false\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n```\n\n\n:::: {.callout-important collapse='false' title='WARNING'}\n\n::: {style='font-size: 1.10em; color: #000000;'}\n\nBecause `msst2ap` is a package, running tests with `shinytest2` will produce the warning below:\n  \n![`shiny::loadSupport()` warning](run_tests_out.png){width=100%}\n\nAs noted above, this warning is [known by the `shinytest2` package authors](https://github.com/rstudio/shinytest2/issues/264#issuecomment-1251422788) and is being addressed in a future release. \n\n:::\n\n::::\n\nNow that I know the first `shinytest2` test is passing, I'll dive into each line in the test. \n\n### [`AppDriver`]{style=\"font-size: 1.15em\"}\n\n`shinytest2` uses the [`AppDriver`](https://rstudio.github.io/shinytest2/reference/AppDriver.html) to create \"*a full simulation of a Shiny app*\". When recording tests, this will be the first argument (along with the `name` of the `.png` and `.json` snapshot `testthat` files, and the `height` and `width` of the [`ChromoteSession`](https://rstudio.github.io/chromote/reference/ChromoteSession.html)).\n\n-   The example from the test above is below: \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n     app <- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n    ```\n\n\n### [`set_inputs()`]{style=\"font-size: 1.15em\"}\n\nWhen recording `shinytest2` tests, every change to the applications inputs will result in a call to `app$set_inputs()`. This function is similar to the `testServer()` call to `session$setInputs()` (i.e., the inputs are provided as \"*name-value pairs*\", i.e., `inputId` = `\"value\"`). \n\n-   In the `histogramApp()`, these are provided with the appended namespaces:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      app$set_inputs(`data-dataset` = \"attitude\")\n      app$set_inputs(`var-var` = \"privileges\")\n      app$set_inputs(`hist-bins` = 11)\n      app$set_inputs(`hist-bins` = 12)\n      app$set_inputs(`hist-bins` = 13)\n      app$set_inputs(`hist-bins` = 14)\n      app$set_inputs(`hist-bins` = 15)\n    ```\n\n### [`expect_values()`]{style=\"font-size: 1.15em\"}\n\n[The documentation](https://rstudio.github.io/shinytest2/articles/in-depth.html#making-expectations) on `expect_values()` is definitely worth reading. `expect_values()` is added to the test file when **Expect Shiny values** is clicked in the test recorder and \"*creates a list of values and compares them to the current values of the application*.\"\n\n-   `expect_values()` = \"*Expect all `input`, `output`, and `export` values are consistent*\"\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      app$expect_values()\n    ```\n\n\n## Test results\n\nThe results from running the new test file (`test-shinytest2.R`) are below: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n‚úî | F W S  OK | Context\n‚úî |   2     1 | shinytest2 [6.3s]                                             \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n```\n\nTwo warnings are displayed because the test adds two new files to the `tests/testthat/_snaps/` folder: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntests/testthat/_snaps/\n‚îî‚îÄ‚îÄ shinytest2\n    ‚îú‚îÄ‚îÄ histogramApp-001.json\n    ‚îî‚îÄ‚îÄ histogramApp-001_.png\n\n2 directories, 2 files\n```\n\nThese are the files new test runs will be compared against (i.e., our 'baseline' snapshots). I'll briefly cover their contents below: \n\n### [`_snaps`]{style=\"font-size: 1.15em\"}\n\n`expect_values()` generates two snapshot files in the `tests/testthat/_snaps/` folder: one `.png` and one `.json` file:\n\n#### [`.png`]{style=\"font-size: 1.20em\"}\n\nThe image saved in `tests/testthat/_snaps/histogramApp-001_.png` is below:\n\n![](histogramApp-001_.png){fig-align='center'}\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (**`attitude`** and **`privileges`**).\n\n#### [`.json`]{style=\"font-size: 1.20em\"}\n\nThe `.json` file saved in `tests/testthat/_snaps/histogramApp-001.json` contains the snapshot `input`s, `output`s, and `export`s:\n\n-   The inputs show the three changed values (`\"data-dataset\"`, `\"var-var\"`, and `\"hist-bins\"`).\n \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: show\n    #| code-summary: 'show/hide snapshot inputs' \n    {\n      \"input\": {\n        \"data-dataset\": \"attitude\",\n        \"hist-bins\": 15,\n        \"var-var\": \"privileges\"\n      },\n    ```\n    \nThe two outputs are stored in `\"hist-hist\"` and `\"vals\"`:\n\n-   `\"hist-hist\"` holds the updated image (stored in the `image data hash`), along with various other characteristics of the plot:\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: true  \n    #| code-summary: 'show/hide snapshot outputs'\n      \"output\": {\n        \"hist-hist\": {\n          \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n          \"width\": 682.6640625,\n          \"height\": 400,\n          \"alt\": \"Plot object\",\n          \"coordmap\": {\n            \"panels\": [\n              {\n                \"domain\": {\n                  \"left\": 27.8,\n                  \"right\": 87.2,\n                  \"bottom\": -0.24,\n                  \"top\": 6.24\n                },\n                \"range\": {\n                  \"left\": 78.79664956011726,\n                  \"right\": 642.3048029692084,\n                  \"bottom\": 301.08,\n                  \"top\": 77.71999999999998\n                },\n                \"log\": {\n                  \"x\": null,\n                  \"y\": null\n                },\n                \"mapping\": {\n    \n                }\n              }\n            ],\n            \"dims\": {\n              \"width\": 682.6640625,\n              \"height\": 400\n            }\n          }\n        },\n    ```\n    \n-   `\"vals\"` contains the reactive values from `reactiveValuesToList()`:\n    \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: show  \n    #| code-summary: 'show/hide snapshot outputs'\n        \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n      },\n    ```\n\n-   I didn't export any values in this test, so `\"export\"` is empty:\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: show  \n    #| code-summary: 'show/hide snapshot outputs'\n      \"export\": {\n    \n      }\n    }\n    ```\n\n    -   *I'll cover this in a later test.*\n  \n#### Namespaces\n\nThe contents of the `.json` snapshot should look *somewhat* familiar for the three modules contained in  `histogramApp()`:\n\n-   For example, the `inputId` for `\"dataset\"` in the `datasetInput/Server` module communicates between the UI and server using the shared `id` argument `\"data\"`\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false  \n    # in datasetInput()\n      shiny::selectInput(\n        shiny::NS(id, \"dataset\"),\n        \"Pick a dataset\",\n        choices = names)\n    # in histogramApp()\n      shiny::sidebarPanel(\n            datasetInput(\"data\", is.data.frame)\n          )\n    ```\n    \n-   This creates the ```` $`data-dataset` ```` output we see the `verbatimTextOutput()` at the bottom of the application: \n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false \n    $`data-dataset`\n    [1] \"attitude\"\n    ```\n    \n-   In the `.json` snapshot, this `inputId` is represented in the following `\"input\"`:\n\n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    {\n      \"input\": {\n        \"data-dataset\": \"attitude\",\n      },\n    ```\n    \nNamespaces and `inputId`s will come up again if you start writing your own tests, which I'll cover below. \n\n## Writing tests\n\nThe great thing about testing with `shinytest2` is the ability to interact with the `AppDriver` as you write tests. I'll demo writing a test for the `datasetApp()` by adapting the contents of `test-shinytest2.R` into a new `test-shinytest2-datasetApp.R` file.\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îÇ   ‚îî‚îÄ‚îÄ shinytest2/\n‚îÇ       ‚îú‚îÄ‚îÄ histogramApp-001.json\n‚îÇ       ‚îî‚îÄ‚îÄ histogramApp-001_.png\n‚îú‚îÄ‚îÄ setup-shinytest2.R\n‚îú‚îÄ‚îÄ test-shinytest2-datasetApp.R <- new test file!\n‚îî‚îÄ‚îÄ test-shinytest2.R\n\n3 directories, 5 files\n```\n\n\nIn the new test `test-shinytest2-datasetApp.R` file, I'll start with a call to `testthat::test_that(),` then create a new `app` object with the Chromium headless browser. \n\nThe namespaced standalone app function can be used to create a `ds_app` object, then `ds_app` is passed to the first argument of `AppDriver$new()` (I've adjusted the `height` and `weight` to fit the `datasetApp()`).\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n})\n```\n\nIn the **Console**, I can use `app$view()` to open the Chromium browser: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\napp$view()\n```\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view layout-ncol=1}\n\n![`app$view()`](app_view.png){#fig-app_view}\n\nView application with `app$view()`\n:::\n\n::::\n\nChromium displays the same app I see when I run `msst2ap::datasetApp()` in the console, but the headless browser has some additional developer tools ([read more](https://www.browserstack.com/guide/difference-between-chrome-and-chromium)).  \n\n### Setting inputs \n\nIf I continue to adapt each line in `test-shinytest2.R` to the `datasetApp()`, I see that next lines set the `inputId`s for `dataset-dataset` to the `attitude` dataset with `app$set_input()` (*Note that this uses the module notation above (i.e., `\"id-inputId\"`*):\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n```\n\nIf you can see both windows, you'll see the application values change in the Chromium browser: \n\n::::{.column-page-right}\n\n::: {#fig-set_inputs layout-ncol=1}\n\n![`app$set_inputs()`](app_set_inputs.png){#fig-app_set_inputs}\n\nSet application inputs with `app$set_inputs()`\n:::\n\n::::\n\n### Checking inputs\n\nIn the previous test, I used the `expect_values()` to capture a list of all the app values (`input`, `output`, `export`). I can also capture these values in a list *inside* the test by including a call to `app$get_values()` and assigning the output to `app_values`.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n})\n```\n\n`app_values` has a similar structure to the `.json` snapshot covered above (i.e., with `input`, `output`, and `export`): \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nstr(app_values)\n```\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"<table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n```\n\nI can narrow the scope of the test by using `app_values` to verify only the `input` that was changed with `app$set_inputs()`::\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n```\n\nAt the end of the test, I'll add a call [`app$stop()`](https://rstudio.github.io/shinytest2/articles/zzz-faq.html#should-i-manually-shut-down-my-appdriver) to close the Chromium app.\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n```\n\n### Running tests\n\nI'll save the `test-shinytest2-datasetApp.R` file and run the test with `testthat::test_file()`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n```\n\n:::: {.callout-important collapse='false' title='WARNING'}\n\n::: {style='font-size: 1.10em; color: #000000;'}\n\nIf you encounter the error message below: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\n‚îÄ‚îÄ Skipped tests (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚Ä¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n```\n\nTry installing and loading `chromote` and `shinytest2` again (this seemed to work for me).\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n```\n\n:::\n\n::::\n\nIn the initial run of the test for `datasetApp()`, no snapshot files are generated because the test didn't include a call to `app$export_values()`. \n\nI see this initial test passes:  \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n```\n\n## Exporting test values \n\nThe `shinytest2` documentation [repeatedly](https://rstudio.github.io/shinytest2/articles/in-depth.html#exported-values) [recommends](https://rstudio.github.io/shinytest2/articles/robust.html#exported-values) exporting test values from shiny applications with `shiny::exportTestValues()`. \n\n### [`exportTestValues()`]{style=\"font-size: 1.20em\"}\n\nI'll demonstrate exporting test values from `selectVarApp()` by adding the following to the `server` function in `inst/dev/app.R`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  server <- function(input, output, session) {\n\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n```\n\n### Using [`system.file()`]{style=\"font-size: 1.20em\"}\n\nAfter loading, documenting and installing the package, I'll create a `test-shinytest2-selectVarApp.R` test file and add the initial contents to create the `AppDriver` object:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n```\n\nNote that to test the development version of `selectVarApp()`, I pass a call to `system.file()` to the `app_dir` argument (this is a similar folder structure to apps built with [`golem`](https://thinkr-open.github.io/golem/articles/a_start.html) and [`leprechaun`](https://leprechaun.opifex.org/#/guide/build) frameworks) \n\n\nAfter entering `app$view()` in the **Console**, the application opens in the Chromium headless browser again:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\napp$view()\n```\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_selectVarApp layout-ncol=1}\n\n![`app$view()`](app_view_selectVarApp.png){#fig-app_view_selectVarApp}\n\nView `selectVarApp()` application with `app$view()`\n:::\n\n::::\n\nIn the test file, I'll use `app$set_values()` to change the ```` $`data-dataset` ```` and ```` $`var-var` ```` inputs:\n\n-   Change ```` $`data-dataset` ```` to `mtcars`:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    testthat::test_that(\"{shinytest2}: selectVarApp\", {\n      app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                                 package = \"msst2ap\"),\n                           height = 600, width = 600)\n      \n        app$set_inputs(`data-dataset` = \"mtcars\")\n        \n    })\n    ```\n\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_set_data_selectVarApp layout-ncol=1}\n\n![Set `data-dataset`](app_view_set_data_selectVarApp.png){#fig-app_view_set_data_selectVarApp}\n\nView `selectVarApp()` after setting `data-dataset` with `app$set_inputs()`\n:::\n\n::::\n\n-   Change ```` $`var-var` ```` to `wt`:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    testthat::test_that(\"{shinytest2}: selectVarApp\", {\n      app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                                 package = \"msst2ap\"),\n                           height = 600, width = 600)\n      \n        app$set_inputs(`data-dataset` = \"mtcars\")\n        app$set_inputs(`var-var` = \"wt\")\n        \n    })\n    ```\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_set_var_selectVarApp layout-ncol=1}\n\n![Set `var-var`](app_view_set_var_selectVarApp.png){#fig-app_view_set_var_selectVarApp}\n\nView `selectVarApp()` after setting `var-var` with `app$set_inputs()`\n:::\n\n::::\n\n### [`get_values()`]{style=\"font-size: 1.20em\"} \n\nI'll use `app$get_values()` to store the exported `input`, `output`, and `export` test values in `app_values`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values <- app$get_values()\n    \n})\n```\n\n`app_values` is a list (similar to the `.json` snapshot file), but now we've explicitly `export`ed values from the server in `selectVarApp()`: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\nnames(app_values$export)\n```\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[1] \"data\" \"var\" \n```\n\n### [`export`]{style=\"font-size: 1.20em\"}ed expectations\n\nI can use `app_values` to verify the structure of each exported object: \n\n-   `data` should be a `data.frame()`\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n```\n\n-   `var` should be a single column `data.frame()`\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n```\n\nOnce again, I end the test with a call to `app$stop()`. The completed test for `selectVarApp()` is below:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values <- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n```\n\nI can run the test with `testthat::test_file()`.  \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n```\n\nThe results are below: \n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n```\n\n## Testing complex outputs \n\nI've created an adapted version of the `histogramApp()` in the `inst/dev/gghistApp/` folder (view contents [here](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev/gghistApp#gghistapp)):\n\n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false \ninst/dev/gghistApp/\n            ‚îú‚îÄ‚îÄ DESCRIPTION\n            ‚îú‚îÄ‚îÄ R/\n            ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n            ‚îú‚îÄ‚îÄ README.md\n            ‚îî‚îÄ‚îÄ app.R\n\n2 directories, 4 files\n```\n\n`gghistApp()` renders a `ggplot2` graph, which makes it easier to demonstrate [this example of checking a plot](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the `shinytest2` package website. \n\n::::{.column-page-inset-right}\n\n::: {#fig-sbs_histogramApp_gghistApp layout-ncol=2}\n\n![`histogramApp()`](sbs_histogramApp.png){#fig-sbs_histogramApp}\n\n![`gghistApp()`](sbs_gghistApp.png){#fig-sbs_gghistApp}\n\n\n`histogramApp()` vs. `gghistApp()`\n\n:::\n\n::::\n\nThe `gghistApp()` is similar to `histogramApp()`, but instead of using `hist()` to generate the plot, a reactive `plot_obj()` is passed to `shiny::renderPlot()` (like the example above).\n\nDue to the structure of the modules in the application, the `exportTestValues()` function is placed in the `gghistServer()` function:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: show \n#| code-summary: 'show/hide gghistServer()'\ngghistServer <- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj <- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist <- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |>\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n```\n\n-   `gghistServer()` is replaces `histogramServer()` in the standalone app function (`gghistApp()`): \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: true \n    #| code-summary: 'show/hide gghistApp()'\n    gghistApp <- function() {\n      ui <- shiny::fluidPage(\n        shiny::sidebarLayout(\n          shiny::sidebarPanel(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n          ),\n          shiny::mainPanel(\n            histogramOutput(\"hist\"),\n            shiny::verbatimTextOutput(\"vals\")\n          )\n        )\n      )\n    \n      server <- function(input, output, session) {\n    \n        data <- datasetServer(\"data\")\n    \n        x <- selectVarServer(\"var\", data)\n    \n        gghistServer(\"hist\", x)\n    \n        output$vals <- shiny::renderPrint({\n          x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n          print(x, width = 30, max.levels = NULL)\n          }, width = 30)\n    \n      }\n    \n      shiny::shinyApp(ui, server)\n    }\n    ```\n\nIn the `test-shinytest2-gghistApp.R` test file, I'll verify the [`vdiffr` package](https://vdiffr.r-lib.org/) is installed with `testthat::skip_if_not_installed()`, then create the `AppDriver` object with a call to `system.file()` and set the `height` and `width`:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false \ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n```\n\nView the application in the Chromium browser by running `app$view()` in the **Console**:\n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\napp$view()\n```\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_gghistApp layout-ncol=1}\n\n![`app$view()`](app_view_gghistApp.png){#fig-app_view_gghistApp}\n\nView `gghistApp()` application with `app$view()`\n:::\n\n::::\n\nI'll replicate the [example](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the website using the `gghistApp()`:\n\n### Verify initial [`input`]{style=\"font-size: 1.20em\"}\n\n-   The first expectations in the example test the default `input` values with **`app$get_value(input = )`**:\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify initial data\n      app_init_data <- app$get_value(input = \"data-dataset\")\n      testthat::expect_equal(\n        object = app_init_data,\n        expected = \"BOD\")\n    \n      # Verify initial variable\n      app_init_var <- app$get_value(input = \"var-var\")\n      testthat::expect_equal(\n        object = app_init_var,\n        expected = \"Time\")\n    ```\n    \n### Set and verify [`export`]{style=\"font-size: 1.20em\"}\n    \n-   Next, we check the exported values after changing the inputs with `app$set_values()` and **`app$get_value(export = )`**\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify exported `x()` data\n      app$set_inputs(`data-dataset` = \"mtcars\")\n      app_exp_x_01 <- app$get_value(export = \"hist-x\")\n      testthat::expect_equal(\n        object = app_exp_x_01, \n        expected = mtcars[1])\n      \n      # Verify exported `plot_obj()` data\n      app$set_inputs(`var-var` = \"wt\")\n      app_exp_plot_obj_01 <- app$get_value(export = \"hist-plot_obj\")\n      testthat::expect_equal(\n        object = app_exp_plot_obj_01,\n        expected = purrr::as_vector(app_exp_plot_obj_01))\n    ```\n    \n-   The `bins` are also set to a new value with `app$set_inputs()` *after* verifying the exported values:\n    \n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify `hist-bins` changes\n      app$set_inputs(`hist-bins` = 15)\n      app_set_bins_01 <- app$get_value(input = \"hist-bins\")\n      testthat::expect_equal(\n        object = app_set_bins_01,\n        expected = 15)\n    ```\n    \n::::{.column-page-inset-right}\n\n::: {#fig-app_view_set_inputs_gghistApp layout-ncol=1}\n\n![`set_inputs()` and `get_value()` in `gghistApp()` ](app_view_set_inputs_gghistApp.png){#fig-app_view_set_inputs_gghistApp width=100%}\n\nSet `input`s and get `export`ed values in `gghistApp()`\n:::\n\n::::\n    \n### Verify plot with [`vdiffr`]{style=\"font-size: 1.20em\"}\n\n-   Now we verify the plot with the exported `plot_obj` (in the `hist` module) with `expect_doppelganger()` from the `vdiffr` package. \n    \n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      # Verify `hist-plot_obj` changes\n      plot_obj_15 <- app$get_value(export = \"hist-plot_obj\")\n      vdiffr::expect_doppelganger(\n        title = \"hist-plot_obj-15\",\n        fig = plot_obj_15)\n    ```\n    \n    -   *I saved the test file and ran the test to confirm the snapshot file was created in `tests/testthat/_snaps/`*:\n    \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n    ‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\n    Adding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n    ```\n    \n### [`set_`, `get_`, `expect_`]{style=\"font-size: 1.10em\"}\n\nThe process above is repeated with new values passed to **`app$set_inputs()`** and verified with **`app$get_value(export = )`**:\n    \n-   The `x()`, `plot_obj()` and `hist-bins` are updated again with new values: \n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      ## Update `data` to USArrests\n      app$set_inputs(`data-dataset` = \"USArrests\")\n      app_exp_x_02 <- app$get_value(export = \"hist-x\")\n      testthat::expect_equal(\n        object = app_exp_x_02,\n        expected = USArrests[1])\n    \n      ## Update `var` to UrbanPop\n      app$set_inputs(`var-var` = \"UrbanPop\")\n      app_exp_plot_obj_02 <- app$get_value(export = \"hist-plot_obj\")\n      testthat::expect_equal(\n        object = app_exp_plot_obj_02,\n        expected = purrr::as_vector(app_exp_plot_obj_02))\n    \n      ## Update `bins` to 12\n      app$set_inputs(`hist-bins` = 12)\n      app_set_bins_02 <- app$get_value(input = \"hist-bins\")\n      expect_equal(\n        object = app_set_bins_02,\n        expected = 12)\n    ```\n    \n-   The new plot is verified again with `expect_doppelganger()`\n\n    ```{r}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n      ## Verify updates to `hist-plot_obj`\n      plot_obj_12 <- app$get_value(export = \"hist-plot_obj\")\n      vdiffr::expect_doppelganger(\n        title = \"hist-plot_obj-12\",\n        fig = plot_obj_12)\n    ```\n\n    -   *This initial run of this test will show a warning again as the snapshot file is saved to `tests/testthat/_snaps/`*:\n    \n    ```{bash}\n    #| eval: false\n    #| echo: true \n    #| code-fold: false\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n    ‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\n    Adding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n    ```\n    \n### Results \n\nThe final results of the `test-shinytest2-gghistApp.R` are below:\n    \n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n```\n    \n```{bash}\n#| eval: false\n#| echo: true \n#| code-fold: false\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n```\n\nThe vector in each `plot_obj()` test is printed with `expect_doppelganger()`, but this doesn't interfere with the results. \n\nI can run `devtools::test()` to run all the tests in `msst2ap`: \n\n```{r}\n#| eval: false\n#| echo: true \n#| code-fold: false\ndevtools::test()\n```\n\n\n## Recap\n\nThis post has covered creating tests with `testthat` and `shinytest2` for an app-package containing a shiny application (with modules!). As you can see, the test recorder makes it easier to test specific app behaviors, and the `AppDriver` makes it possible to build a set of test expectations iteratively. Other items to consider when writing `shinytest2` tests include: \n\n1. **Define What to Test**: Since Shiny apps are interactive, so `shinytest2` tests should simulate user interaction as much as possible. The tests should focus on key user interactions and the output they should generate. `shinytest2` provides functions for simulating user clicks, inputs, and other interactions. Not every interaction needs to be tested, but crucial ones and those that handle complex logic should be.\n\n2. **Organize Your Tests & Use Descriptive Test Names**: Organize your tests into separate files based on what they are testing. Each test should have a descriptive name that clarifies what the test is for. Organizing your test files with unambiguous names will make it easier to manage multiple tests, and it will make it easier to understand what's going wrong when a test fails.\n\n3. **Create snapshots for expected outputs**: Use snapshot files to verify that an app's output matches the expected results. `AppDriver$expect_values()` generates `.json` and `.png` snapshot files for the application. The .json file contains `input`, `output`, and `export` values, and the .png file is a *debug* screenshot, which records how the app looked when the values where captured. These files can then be compared to a baseline snapshot.\n\n4. **Export app values**: While snapshot files are great for detecting changes, it's important to remember that \"*differences in the captured screenshot will never cause test failures.*\" Manually inspecting the snapshot .png files during test development can also be time-consuming and tedious. Wherever possible, export app values and compare them against expected reference values.\n\nIn general, `shinytest2` is designed for end-to-end testing of shiny applications. These tests can capture the state of a shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots), which is useful for regression testing. \n\n`shinytest2` tests can also simulate user interaction in a way that `shiny::testServer()` tests can't, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. `shinytest2` can also be resource-intensive, so it's recommended to write these tests after you've completed the standard `testthat` unit tests and `testServer()` tests.\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","dpi":320,"toc":true,"toc-depth":5,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","description-meta":"Martin Frigaard's personal website.","knitr":{"opts_chunk":{"collapse":true}},"editor":{"mode":"source"},"theme":{"light":["litera","../../custom.scss"]},"fig-asp":0.618,"fontsize":"10.5","title-block-banner":true,"title":"Testing Shiny apps with `shinytest2`","subtitle":"Part 4: recording tests and snapshots","author":"Martin Frigaard","date":"2023-07-04","categories":["shiny","testing"],"image":"image.svg","toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-summary":"show/hide","callout-icon":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}