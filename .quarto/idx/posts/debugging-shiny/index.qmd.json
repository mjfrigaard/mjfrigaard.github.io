{"title":"Debugging Shiny apps","markdown":{"yaml":{"title":"Debugging Shiny apps","subtitle":"call stacks, browser(), and tests","author":"Martin Frigaard","date":"2023-06-23","categories":["code","debugging","shiny","testing"],"image":"image.png","toc":true,"toc-depth":5,"toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-fold":"show","code-summary":"show/hide","callout-icon":false,"draft":true,"freeze":true,"execute":{"echo":true,"message":false,"warning":false,"eval":false}},"headingText":"remotes::install_github(\"mjfrigaard/tsap\",","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| eval: true \n#| echo: false \n#| include: false\nsource(\"../_common.R\")\noptions(scipen = 999)\n#   force = TRUE, quiet = TRUE)\nlibrary(mstsap)\n```\n\n\n```{r}\n#| label: co_box_dev\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(color = \"r\", \n  header = \"ALERT!\", \n  contents = \"This post is currently under development--thank you for your patience.\")\n```\n\n```{r}\n#| label: pkgs\n#| code-summary: 'show/hide packages'\n#| eval: false \n#| message: false \n#| warning: false\nlibrary(debugApp) # app package \nlibrary(palmerpenguins) # data\nlibrary(NHANES) # data\nlibrary(rlang) # traceback/stack trace\nlibrary(gt) # tables\n```\n\n\n::: {.column-margin}\n![](shiny-test-bugs.png){width=70%}\n:::\n\n## Bugs!\n\nIn [a previous post](https://mjfrigaard.github.io/series.html), I covered writing tests for module server functions with Shiny's `testServer()` function. The application in that post displays an error similar to the one below:\n\n::: {#fig-graph_error_gif_intro}\n\n![UI error](01-debugApp-error.gif){#fig-graph_error_gif_intro width=100% fig-align=\"center\"}\n\nShiny app displaying `Error: Column 'species' not found in '.data'`\n:::\n\n\nThe warning resolves itself without causing the application to crash, but it's displayed in the UI, so leaving it is not an option. In this post, I'll cover reading the call stack (or stack trace) and using `browse()` to debug errors in a Shiny app-package.\n\n## `debugApp` app-package\n\nThe `debugApp` app-package allows users to select a dataset from an R package and visualize a scatter-plot of\n\nIf you'd like to follow along, you can download `debugApp` [here](https://github.com/mjfrigaard/debugApp/archive/refs/heads/main.zip) or install it using the following: \n\n```{r}\n#| code-fold: false\n#| eval: false\n#| results: hide\nremotes::install_github(\"mjfrigaard/debugApp\", force = TRUE)\nlibrary(debugApp)\n```\n\nI'll quickly review the contents of `debugApp`. The [`R/` folder](https://github.com/mjfrigaard/debugApp/tree/main/R) contains files for the modules: \n\n```{verbatim}\n#| code-fold: false\n#| eval: false\n#| echo: true\nR/\n├── mod_cols.R\n├── mod_ds.R\n├── mod_pkg.R\n└── mod_plot.R\n```\n\n-   Each module file has it's own utility function file: \n\n    ```{verbatim}\n    #| code-fold: false\n    #| eval: false\n    #| echo: true\n    R/\n    ├── utils_vars.R\n    ├── utils_datasets.R\n    ├── utils_pkg.R\n    └── utils_scatter.R\n    ```\n\n\nThe module functions are split between the `appUI()` and `appServer()` functions.  \n\n```{verbatim}\n#| code-fold: false\n#| eval: false\n#| echo: true\nR/\n├── appServer.R # <- _server() module functions\n├── appUI.R # <- _ui() module functions\n└── pkgDataApp.R # <- standalone app function\n```\n\n-   `pkgDataApp()` is a stand-alone app function, which calls `appUI()` and `appServer()`:\n\n    ```{verbatim}\n    #| code-fold: false\n    #| eval: false\n    #| echo: true\n    pkgDataApp <- function() {\n        shiny::shinyApp(\n          ui = appUI,\n          server = appServer)\n    \n    }\n    pkgDataApp()\n    ```\n    \nEach of the modules have tests in the `tests/testthat/` folder: \n\n```{verbatim}\n#| code-fold: false\n#| eval: false\n#| echo: true\ntests/testthat/\n├── test-mod_cols_server.R\n├── test-mod_ds_server.R\n├── test-mod_pkg_server.R\n└── test-mod_plot_server.R\n```\n\n-   As do the module utility functions: \n\n    ```{verbatim}\n    #| code-fold: false\n    #| eval: false\n    #| echo: true\n    tests/testthat\n    ├── test-check_binary_vec.R\n    ├── test-check_facet_vec.R\n    ├── test-get_col_types.R\n    ├── test-make_binary_vec.R\n    ├── test-make_facet_vec.R\n    ├── test-pull_binary_cols.R\n    ├── test-pull_cat_cols.R\n    ├── test-pull_facet_cols.R\n    └── test-pull_numeric_cols.R\n    ```\n\n\n## Modules \n\nI've created the figure below to illustrate how the modules in `pkgDataApp()` work together: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-module_flow}\n\n![`tsap` modules](module_flow.png){#fig-module_flow width=100%}\n\nModules in `tsap::pkgDataApp()`\n:::\n\n::::\n\nAs you can see, the modules are connected by a chain of reactive values, and each module returns a slightly more complicated reactive value (`character` -> `data.frame`/`tibble` -> `list` ). \n\n### `mod_pkg`\n\n1. The `mod_pkg` module displays the packages with `data.frame`s or `tibble`s (and returns the package as a reactive character string, `pkg()`)\n\n::: {#fig-mod_pkg_schema}\n\n![`mod_pkg`](mod_pkg_schema.png){#fig-mod_pkg_schema width=70%}\n\n\n`mod_pkg` in `pkgDataApp()`\n:::\n\n### `mod_ds`\n\n2. `mod_ds` renames `pkg()` as `pkg_input()` and uses it to update the `selectInput()` options for the selected package datasets (the selected dataset is returned as a reactive `dataset()`) \n\n::: {#fig-mod_ds_schema}\n\n![`mod_ds`](mod_ds_schema.png){#fig-mod_ds_schema width=70%}\n\n`mod_pkg` and `mod_ds` in `pkgDataApp()`\n:::\n\n### `mod_cols`\n\n3. `mod_cols` receives `dataset()` as `ds_input()` and updates the `selectInput()`s with the columns in the `ds_input()`. Columns are displayed by 'type' (i.e., two numeric columns (`x` and `y`), binary columns (`color`), and a  `facet` column. Then `ds_input()`, the selected columns (`x`, `y`, `color` and `facet`) and graph aesthetics (`size` and `alpha`) are combined and returned as the reactive list `plot_values()`\n\n::: {#fig-mod_cols_schema}\n\n![`mod_cols`](mod_cols_schema.png){#fig-mod_cols_schema width=100%}\n\n`mod_pkg`, `mod_ds`, and `mod_cols` in `pkgDataApp()`\n:::\n\n\n### `mod_plot`\n\n4. `mod_plot` uses `plot_values()` as `plot_inputs()` and a custom `ggplot2` utility function (`gg_color_scatter_facet()`) to render the plot\n\n:::: {.column-body-outset-right}\n\n::: {#fig-mod_plot_schema}\n\n![`mod_plot` in `tsap::pkgDataApp()`](mod_plot_schema.png){#fig-mod_plot_schema width=100%}\n\n`mod_pkg`,`mod_ds`, `mod_cols`, and `mod_plot` modules in `pkgDataApp()`\n:::\n\n::::\n\nThe `ggplot2` function used to generate the plot (`gg_color_scatter_facet()`) is below:\n\n```{r}\n#| code-fold: true\n#| code-summary: 'gg_color_scatter_facet()'\n#| eval: false\ngg_color_scatter_facet <- function(df, x_var, y_var,\n                                col_var = NULL, facet_var = NULL,\n                                ...) {\n  # missing both color and facet vars\n  if (is.null(col_var) & is.null(facet_var)) {\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]], \n          y = .data[[y_var]])\n      ) +\n        ggplot2::geom_point(...) +\n        # add labels\n        ggplot2::labs(\n          title = make_x_y_title(\n            x = x_var, y = y_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n\n    # no facet, but has color\n  } else if (!is.null(col_var) & is.null(facet_var)) {\n\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]], \n          y = .data[[y_var]])\n      ) +\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(\n          ggplot2::aes(\n            colour = .data[[col_var]], \n            group = .data[[col_var]]),\n            ...\n        ) +\n        # add labels\n        ggplot2::labs(\n          title = make_x_y_color_title(\n            x = x_var, y = y_var, color = col_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          ),\n          color = stringr::str_replace_all(\n            snakecase::to_title_case(col_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n    # no color, but has facet\n  } else if (is.null(col_var) & !is.null(facet_var)) {\n\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]], \n          y = .data[[y_var]])\n      ) +\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(...) +\n        # add facet layer\n        ggplot2::facet_wrap(ggplot2::vars(.data[[facet_var]])) +\n        # add labels\n        ggplot2::labs(\n          title = make_x_y_title(\n            x = x_var, y = y_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n  } else {\n\n      # has both color and facet vars\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]],\n          y = .data[[y_var]])\n      ) +\n        # points layer\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(\n          ggplot2::aes(\n            colour = .data[[col_var]],\n            group = .data[[col_var]]), ...\n        ) +\n        # add facet layer\n        ggplot2::facet_wrap(ggplot2::vars(.data[[facet_var]])) +\n        # add labels\n        ggplot2::labs(title =\n            make_x_y_col_facet_title(x = x_var,\n                                     y = y_var,\n                                     color = col_var,\n                                     facets = facet_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          ),\n          color = stringr::str_replace_all(\n            snakecase::to_title_case(col_var), \"_\", \" \"\n          ),\n          group = stringr::str_replace_all(\n            snakecase::to_title_case(facet_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n  }\n}\n\n```\n\n\n## Stack trace\n\nDuring development, the warning below is printed to the **Console** when I change the package input of `tsap::pkgDataApp()`:\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n`# Warning: Error in [[: Column 'race1' not found in '.data'.`\n\n:::\n\nBelow the warning, the **Console** also prints the following abbreviated numbered list of items: \n\n::: {style='font-size: 0.90em;'}\n\n```{verbatim}\n#| eval: false\n#| code-fold: show\n#| code-summary: 'show/hide stack trace from console'\nWarning: Error in [[: Column `race1` not found in `.data`.\n  202: <Anonymous>\n  201: signalCondition\n  200: signal_abort\n  199: abort\n  198: abort_data_pronoun\n  197: data_pronoun_get\n  196: [[.rlang_data_pronoun\n  195: [[\n  194: eval_tidy\n  189: FUN\n  188: lapply\n  185: FUN\n  184: lapply\n  181: combine_vars\n  180: compute_layout\n  179: self$facet$compute_layout\n  178: setup\n  177: layout$setup\n  176: ggplot_build.ggplot\n  174: print.ggplot\n  169: func\n  167: f\n  166: Reduce\n  157: do\n  156: hybrid_chain\n  128: drawPlot\n  114: <reactive:plotObj>\n   98: drawReactive\n   85: renderFunc\n   84: output$plot-graph\n    3: runApp\n    2: print.shiny.appobj\n    1: <Anonymous>\n```\n\n:::\n\nThe output above is referred to as a [stack trace (or traceback)](https://en.wikipedia.org/wiki/Stack_trace?oldformat=true), which is a report that provides information about a function call (or sequence of calls) at a certain point. The numbered items are 'frames', and collectively they're referred to as the ['call stack' or 'stack frame'](https://en.wikipedia.org/wiki/Call_stack).\n\n::: {.callout-note icon=false collapse='true'}\n\n## Stack traces in shiny\n\nBelieve it or not, the output shown above actually isn't the *full* stack trace for the error--`shiny` performs some post-processing to trim it down. If you'd like to view the full stack trace for the warning, try setting `options(shiny.fullstacktrace = TRUE)` before running your application.\n\n:::\n\nA stack trace is usually generated when an error occurs, and it gives developers a snapshot of the function calls preceding the error.\n\n### Stack traces in R\n\nThe output above is automatically returned to the **Console** while if you're developing a shiny app in RStudio, but I'll cover two methods for manually creating a stack trace from an error. \n\n#### `traceback()`\n\nIn base R, you can generate a stack trace by calling the `traceback()` function directly following the error. \n\nI'll use `gg_color_scatter_facet()` in the code chunk below, but I've written it to reproduce the error I'm seeing above (i.e., the variable arguments are from the `NHANES::NHANES` data, but the `df` argument has been changed to `palmerpenguins::penguins`). \n\nI'll pass the `gg_color_scatter_facet()` call in to the **Console:**\n\n```{r}\n#| error: true\n#| code-fold: show\n#| code-summary: 'ggplot2 error with traceback()'\n#| eval: true\ntsap::gg_color_scatter_facet(\n  df = janitor::clean_names(palmerpenguins::penguins),\n  x_var = \"poverty\",\n  y_var = \"weight\",\n  col_var = \"survey_yr\",\n  facet_var = \"race1\",\n  alpha = 1 / 3,\n  size = 2)\n```\n\nAfter the error, I call `traceback()`:\n\n```{r}\n#| eval: false\n#| code-fold: false\ntraceback()\n```\n\nThe output from `traceback()` is below: \n\n::: {style=\"font-size: 0.90em;\"}\n\n```{bash}\n#| eval: false\n#| code-fold: show \n#| code-summary: 'show/hide traceback() output'\n29: stop(fallback)\n28: signal_abort(cnd, .file)\n27: abort(msg, \"rlang_error_data_pronoun_not_found\", call = call)\n26: abort_data_pronoun(x, call = y)\n25: data_pronoun_get(x, i, call = I(call(\"[[\", quote(.data), substitute(i))))\n24: `[[.rlang_data_pronoun`(.data, \"race1\")\n23: .data[[\"race1\"]]\n22: eval_tidy(facet, mask)\n21: doTryCatch(return(expr), name, parentenv, handler)\n20: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n19: tryCatchList(expr, classes, parentenv, handlers)\n18: tryCatch(eval_tidy(facet, mask), ggplot2_missing_facet_var = function(e) NULL)\n17: FUN(X[[i]], ...)\n16: lapply(facets, eval_facet, data, possible_columns = possible_columns)\n15: vapply(x, is.null, logical(1))\n14: compact(lapply(facets, eval_facet, data, possible_columns = possible_columns))\n13: FUN(X[[i]], ...)\n12: lapply(data, eval_facets, facets = vars, possible_columns = possible_columns)\n11: vapply(x, is.null, logical(1))\n10: compact(lapply(data, eval_facets, facets = vars, possible_columns = possible_columns))\n9: combine_vars(data, params$plot_env, vars, drop = params$drop)\n8: compute_layout(..., self = self)\n7: self$facet$compute_layout(data, self$facet_params)\n6: setup(..., self = self)\n5: layout$setup(data, plot$data, plot$plot_env)\n4: ggplot_build.ggplot(x)\n3: ggplot_build(x)\n2: print.ggplot(x)\n1: (function (x, ...) \n   UseMethod(\"print\"))(x)\n```\n\n:::\n\nThe output from `traceback()` is a [pairlist](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Pairlist-objects), and it contains the \"[stack of the last uncaught errors](https://stat.ethz.ch/R-manual/R-devel/library/base/html/traceback.html).\" \n\n::: {.callout-tip icon=false collapse='true'}\n\n## Adding `traceback()` to `.Rprofile`\n\nIf you'd like to view the `traceback()` output whenever an error occurs, you can add the following to your `.Rprofile`:\n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: false\noptions(error = traceback)\n```\n\nRead more debugging tips in the [Posit support documentation](https://support.posit.co/hc/en-us/articles/200713843#using-the-debugger). \n\n:::\n\nIf the output from `traceback()` is too large to read in the **Console**, I'll store it and use `grep()` or [`stringr::str_view_all()`](https://stringr.tidyverse.org/) to explore its contents: \n\n```{r}\n#| label: bug\n#| eval: true \n#| echo: false\nbug <- pairlist(\"stop(fallback)\", \"signal_abort(cnd, .file)\", \"abort(msg, \\\"rlang_error_data_pronoun_not_found\\\", call = call)\", \"abort_data_pronoun(x, call = y)\", \"data_pronoun_get(x, i, call = I(call(\\\"[[\\\", quote(.data), substitute(i))))\", \"`[[.rlang_data_pronoun`(.data, \\\"race1\\\")\", \".data[[\\\"race1\\\"]]\", \"eval_tidy(facet, mask)\", \"doTryCatch(return(expr), name, parentenv, handler)\", \"tryCatchOne(expr, names, parentenv, handlers[[1L]])\", \"tryCatchList(expr, classes, parentenv, handlers)\", \"tryCatch(eval_tidy(facet, mask), ggplot2_missing_facet_var = function(e) NULL)\", \"FUN(X[[i]], ...)\", \"lapply(facets, eval_facet, data, possible_columns = possible_columns)\", \"vapply(x, is.null, logical(1))\", \"compact(lapply(facets, eval_facet, data, possible_columns = possible_columns))\", \"FUN(X[[i]], ...)\", \"lapply(data, eval_facets, facets = vars, possible_columns = possible_columns)\", \"vapply(x, is.null, logical(1))\", \"compact(lapply(data, eval_facets, facets = vars, possible_columns = possible_columns))\", \"combine_vars(data, params$plot_env, vars, drop = params$drop)\", \"compute_layout(..., self = self)\", \"self$facet$compute_layout(data, self$facet_params)\", \"setup(..., self = self)\", \"layout$setup(data, plot$data, plot$plot_env)\", \"ggplot_build.ggplot(x)\", \"ggplot_build(x)\", \"print.ggplot(x)\", c(\"(function (x, ...) \", \n\"UseMethod(\\\"print\\\"))(x)\"))\n```\n\n\n```{r}\n#| eval: false \n#| echo: true\n#| code-fold: false\nbug <- traceback()\n```\n\nBelow I'll narrow the stack trace down to the terms I see in the UI (like `.data` and `race1`): \n\n```{r}\n#| eval: true \n#| echo: true\n#| code-fold: false \nlibrary(stringr) \nstringr::str_view_all(\n  string = unlist(bug), \n  pattern = \"\\\\.data|race1\", \n  match = TRUE)\n```\n\n#### `rlang::last_trace()`\n\nWhen I entered the previous call to `gg_color_scatter_facet()` in the **Console**, there was a suggestion to run `rlang::last_trace()`: \n\n```{verbatim}\n#| eval: false\n#| code-fold: false\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\n`last_trace()` is similar to `traceback()`, but prints the stack trace in a hierarchical tree structure: \n\n```{r}\n#| eval: false\n#| code-fold: false\nrlang::last_trace()\n```\n\n::: {style=\"font-size: 0.90em;\"}\n\n```{bash}\n#| eval: false\n#| code-fold: show\n#| code-summary: 'show/hide rlang::last_trace() output'\n<error/rlang_error_data_pronoun_not_found>\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\n---\nBacktrace:\n     ▆\n  1. ├─base (local) `<fn>`(x)\n  2. ├─ggplot2:::print.ggplot(x)\n  3. │ ├─ggplot2::ggplot_build(x)\n  4. │ └─ggplot2:::ggplot_build.ggplot(x)\n  5. │   └─layout$setup(data, plot$data, plot$plot_env)\n  6. │     └─ggplot2 (local) setup(..., self = self)\n  7. │       └─self$facet$compute_layout(data, self$facet_params)\n  8. │         └─ggplot2 (local) compute_layout(..., self = self)\n  9. │           └─ggplot2::combine_vars(data, params$plot_env, vars, drop = params$drop)\n 10. │             ├─ggplot2:::compact(lapply(data, eval_facets, facets = vars, possible_columns = possible_columns))\n 11. │             │ └─base::vapply(x, is.null, logical(1))\n 12. │             └─base::lapply(data, eval_facets, facets = vars, possible_columns = possible_columns)\n 13. │               └─ggplot2 (local) FUN(X[[i]], ...)\n 14. │                 ├─ggplot2:::compact(lapply(facets, eval_facet, data, possible_columns = possible_columns))\n 15. │                 │ └─base::vapply(x, is.null, logical(1))\n 16. │                 └─base::lapply(facets, eval_facet, data, possible_columns = possible_columns)\n 17. │                   └─ggplot2 (local) FUN(X[[i]], ...)\n 18. │                     ├─base::tryCatch(eval_tidy(facet, mask), ggplot2_missing_facet_var = function(e) NULL)\n 19. │                     │ └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 20. │                     │   └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 21. │                     │     └─base (local) doTryCatch(return(expr), name, parentenv, handler)\n 22. │                     └─rlang::eval_tidy(facet, mask)\n 23. ├─race1\n 24. ├─rlang:::`[[.rlang_data_pronoun`(.data, \"race1\")\n 25. │ └─rlang:::data_pronoun_get(...)\n 26. └─rlang:::abort_data_pronoun(x, call = y)\n\n```\n\n:::\n\nBoth `traceback()` and `last_trace()` print each preceding function call before the error. I prefer using `rlang::last_trace()` because I find the tree output to be easier to read. However, I usually follow the second piece of advice from the **Console** output and set `drop` to `FALSE`:\n\n```{verbatim}\n#| eval: false\n#| code-fold: true \nRun rlang::last_trace(drop = FALSE) to see 1 hidden frame.\n```\n\nBy default, `last_trace()` will `drop` technical function calls, but I like to see *all* of the calls in a stack trace, so I usually change `drop` to `FALSE`. \n\n```{r}\n#| eval: false\n#| code-fold: false\nrlang::last_trace(drop = FALSE)\n```\n\nAfter changing `drop` to `FALSE` I can see one additional frame in the stack (I've omitted frames `1.` through `22.`, but you can see frame `27.` has been added below).\n\n::: {style=\"font-size: 0.90em;\"}\n\n```{bash}\n#| eval: false\n#| code-fold: false \n<error/rlang_error_data_pronoun_not_found>\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\n---\nBacktrace:\n     ▆\n 23. ├─race1\n 24. ├─rlang:::`[[.rlang_data_pronoun`(.data, \"race1\")\n 25. │ └─rlang:::data_pronoun_get(...)\n 26. └─rlang:::abort_data_pronoun(x, call = y)\n 27.   └─rlang::abort(msg, \"rlang_error_data_pronoun_not_found\", call = call)\n```\n\n:::\n\n### What did I expect?\n\nI generally try to write code that executes without errors, so the output from `traceback()` or `last_trace()` is always a little bewildering. I never know *exactly* what I'm looking for in the stack trace (if so, I would've written the code to avoid encountering it), but I like to start with a clear understanding of the behavior I'm expecting the function to perform. \n\nIn this case, I'm expecting the data (in `mod_ds`) and columns (in `mod_cols`) to update in `plot_values()` when I change the package input to `palmerpenguins`:\n\n::: {#fig-mods_pkg_ds_cols}\n\n![Changes to package, data and columns](mods_pkg_ds_cols.png){#fig-mods_pkg_ds_cols width=100%}\n\nUpdating package input, data, and columns\n:::\n\nThe updated `plot_values()` reactive list is passed to the `plot_inputs` argument `mod_plot` (where the graph is rendered). \n\nI've included the call to `renderPlot()` with `gg_color_scatter_facet()` in the code block below for reference: \n\n```{r}\n#| eval: false\n#| code-fold: false \n output$graph <- shiny::renderPlot({\n    gg_color_scatter_facet(\n        df = plot_inputs()$df,\n        x_var = plot_inputs()$x_var,\n        y_var = plot_inputs()$y_var,\n        col_var = plot_inputs()$col_var,\n        facet_var = plot_inputs()$facet_var,\n        alpha = plot_inputs()$alpha,\n        size = plot_inputs()$size)\n   })\n```\n\n\n### What happened instead? \n\nThe error I'm seeing is telling me there is something wrong with the facet variable in `mod_plot`:\n\n``` r\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\n```\n\n`race1` is the facet variable from the `NHANES` data, so I am assuming the `plot_inputs()` list isn't updating when I change `input$pkg` in `mod_pkg` to `palmerpenguins`. \n\n::: {#fig-default_nhanes_vars}\n\n![Default `NHANES::NHANES` data and columns](default_nhanes_vars.png){#fig-default_nhanes_vars width=100%}\n\n`pkgDataApp()` automatically loads with `NHANES::NHANES`\n:::\n\n\nthe `plot_values()` list would contain the updated `penguins` data (from `mod_ds`), and the `penguins` columns (from `mod_cols`). \n\nIf the `penguins` data is updated in `plot_values()` *before* the columns and graph aesthetics, then why is the facet variable causing the error? \n\n::: {#fig-mods_pkg_ds_cols_warn_plot}\n\n![Possible location of bug in `pkgDataApp()`](mods_pkg_ds_cols_warn_plot.png){#fig-mods_pkg_ds_cols_warn_plot width=100%}\n\n\nLocation of bug in `pkgDataApp()`?\n:::\n\nThere are hints to what is causing the warning/error in the call stack. Frame `1.` through `.6` of show the initialization of the `ggplot2` graph, but frame `.7` references the facet layout: \n\n```{bash}\n#| eval: false\n#| code-fold: false \nBacktrace:\n     ▆\n  1. ├─base (local) `<fn>`(x)\n  2. ├─ggplot2:::print.ggplot(x)\n  3. │ ├─ggplot2::ggplot_build(x)\n  4. │ └─ggplot2:::ggplot_build.ggplot(x)\n  5. │   └─layout$setup(data, plot$data, plot$plot_env)\n  6. │     └─ggplot2 (local) setup(..., self = self)\n  7. │       └─self$facet$compute_layout(data, self$facet_params)\n```\n\n\nFrame `.7` is a hint because it tells me where/when the facet layer is referenced in the call stack.\n\nIf I look down to frame `23.`, I see `race1` (the facet variable) and the data masking method used to find the facet variable in the custom `ggplot2` function (`.data[[facet_var]]`):\n\n```{bash}\n#| eval: false\n#| code-fold: false \nBacktrace:\n     ▆\n 22. │                     └─rlang::eval_tidy(facet, mask)\n 23. ├─race1\n 24. ├─rlang:::`[[.rlang_data_pronoun`(.data, \"race1\")\n 25. │ └─rlang:::data_pronoun_get(...)\n 26. └─rlang:::abort_data_pronoun(x, call = y)\n```\n\nThe stack ends in a call to `rlang::abort_data_pronoun()` (because `race1` isn't in `.data`).\n\n#### Check (and re-check) function \n\nThe order of the frames in the stack trace is counter-intuitive, because the facet variable (`.data[[facet_var]]`) is added to the `ggplot2` graph *after* the x, y, and color variables (*I've included this portion of `gg_color_scatter_facet()` below*):\n\n```{r}\n#| eval: false\n#| code-fold: false \n# has both color and facet vars\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]],\n          y = .data[[y_var]])\n      ) +\n        # points layer\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(\n          ggplot2::aes(\n            colour = .data[[col_var]],\n            group = .data[[col_var]]), ...\n        ) +\n        # add facet layer\n        ggplot2::facet_wrap(ggplot2::vars(.data[[facet_var]])) +\n        # add labels \n        # ...\n```\n\n1. The `x` and `y` are in the initial `aes()` layer    \n2. The `colour` layer is added with the `geom_point()`    \n3. Finally, the facet variable is added in the `facet_wrap()` layer\n\n\nWhen I change the package input in `mod_pkg`, I'm assuming the `plot_values()` list is updated with the `penguins` data, followed by the column arguments from `mod_cols`.\n\nBut the column values are still from the `NHANES` data, which is triggering the warning. The warning/error is eventually resolved when the `penguins` column inputs make their way from `mod_cols` to `mod_plot` (where the plot is rendered).\n\n## Using the debugger \n\nNow I'm ready to experiment with `plot_values` and `gg_color_scatter_facet()` in the debugger: \n\n1.  Below I've create `plot_values_test`, with `penguins` assigned to `df`, and the `NHANES` columns assigned to the column arguments: \n\n    ```{r}\n    #| eval: true\n    #| code-fold: false \n    plot_values_test <- list(\n      # data from palmerpenguins::penguins\n      df = janitor::clean_names(palmerpenguins::penguins),\n      # columns from NHANES::NHANES\n      x_var = \"poverty\",\n      y_var = \"weight\",\n      col_var = \"survey_yr\",\n      facet_var = \"race1\",\n      size = 2L,\n      alpha = 0.75\n    )\n    ```\n\n2.  I'll pass the `plot_values_test` list to the `gg_color_scatter_facet()` function, but with a call to `browser()`: \n\n    ```{.r}\n    source(\"~/tsap/R/utils_scatter.R\")\n    Called from: gg_color_scatter_facet(\n      df = plot_values_test$df, \n      x_var = plot_values_test$x_var, \n      y_var = plot_values_test$y_var, \n      col_var = plot_values_test$col_var, \n      facet_var = plot_values_test$facet_var, \n      alpha = plot_values_test$alpha, \n      size = plot_values_test$size)\n    ```\n\n### Inside the function\n\n\nThe first few steps take me through the control flow in `gg_color_scatter_facet()`. \n\n```{.r}\n# are both col_var and facet_var NULL?\nBrowse[1]> n\ndebug at ~/tsap/R/utils_scatter.R#452: if (is.null(col_var) & is.null(facet_var)) {\n```\n\n```{.r}\n# facet_var NULL? \nBrowse[2]> n\ndebug at ~/tsap/R/utils_scatter.R#452: if (!is.null(col_var) & is.null(facet_var)) {\n```\n\nAt this step, I can see the values for `col_var` and `facet_var` are present in the function **Environment**: \n\n::: {#fig-env_vars_col_facet}\n\n![Function variables in `gg_color_scatter_facet()`](env_vars_col_facet.png){#fig-env_vars_col_facet width=100%}\n\nColor and facet variables in `gg_color_scatter_facet()`\n:::\n\nI continue stepping through the control flow until I arrive at the `ggplot2` function: \n\n```{.r}\n# col_var NULL?\nBrowse[2]> n\ndebug at ~/tsap/R/utils_scatter.R#452: if (is.null(col_var) & !is.null(facet_var)) {\n```\n\nWhen I arrive at the `ggplot2` functions, I'll see this code highlighted in the **Source** pane, \n\n::: {#fig-debugger_ggplot2}\n\n![Function variables in `gg_color_scatter_facet()`](debugger_ggplot2.png){#fig-debugger_ggplot2 width=75%}\n\n`ggplot2` code in `gg_color_scatter_facet()`\n:::\n\nWhen I attempt to execute this step, I see the error: \n\n### Confirmation!\n\n```{.r}\nBrowse[2]> n\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\nThe error in the debugger tells me that when I update the package in `mod_pkg`, the dataset (from `mod_ds`) is updated in `plot_values()` *before* the column values (from `mod_cols`). \n\nThis explains why the error I'm seeing is referring to data masking (`.data[[\"race1\"]]`), because in `gg_color_scatter_facet()`, when `.data` changes to `penguins`, the `facet_var` is still `race1`. \n\n## Solution 1\n\nI have a few options for dealing with this warning. I can rewrite the custom `ggplot2` function to only execute if all of the column arguments are present in `.data`. This can be implemented using something like `graph_check()` below:\n\n```{r graph_check}\n#| eval: true\n#| code-fold: false\ngraph_check <- function(df, x_var, y_var, col_var = NULL, facet_var = NULL, ...)\nif (sum(c(x_var, y_var, col_var, facet_var) %in% names(df)) == 4) {\n  cli::cli_alert_success(\"Plot renders\") \n} else {\n  cli::cli_alert_warning(\"Columns not in .data\") \n}\n```\n\n`graph_check()` will search the names of `df` to confirm the values provided in the column arguments are present. \n\nI can confirm this with `plot_values_test` (the list with `penguins` data and `NHANES` columns) and `plot_values` (a list with `NHANES` data and columns).\n\n-   Check mismatched data and columns: \n\n    ```{r}\n    #| eval: true\n    #| code-fold: false\n    graph_check(\n      df = plot_values_test$df,\n      x_var = plot_values_test$x_var,\n      y_var = plot_values_test$y_var,\n      col_var = plot_values_test$col_var,\n      facet_var = plot_values_test$facet_var,\n      alpha = plot_values_test$alpha,\n      size = plot_values_test$size\n    )\n    ```\n    ```\n    ! Columns not in .data\n    ```\n    \n    -   Create correct `plot_values` list: \n\n    ```{r}\n    #| eval: true\n    #| code-fold: false\n    plot_values <- list(\n      df = janitor::clean_names(NHANES::NHANES),\n      x_var = \"poverty\",\n      y_var = \"weight\",\n      col_var = \"survey_yr\",\n      facet_var = \"race1\",\n      size = 2L,\n      alpha = 0.75\n    )\n    ```\n    \n    -   Confirm `graph_check()`:\n\n    ```{r}\n    #| eval: true\n    #| code-fold: false\n    graph_check(\n      df = plot_values$df,\n      x_var = plot_values$x_var,\n      y_var = plot_values$y_var,\n      col_var = plot_values$col_var,\n      facet_var = plot_values$facet_var,\n      alpha = plot_values$alpha,\n      size = plot_values$size\n    )\n    ```\n    ```\n    ✔ Plot renders\n    ```\n\nI can also separate the graph aesthetic *variables* (`x_var`, `y_var`, `col_var`, and `facet_var`) from the two graph aesthetic *values* (`alpha` and `size`). I've implemented this solution in the `mod_vars` and `mod_graph` modules, which you can view below: \n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_vars'\nmod_vars_ui <- function(id) {\n  ns <- shiny::NS(id)\n  shiny::tagList(\n    shiny::fluidRow(\n      column(\n        width = 6,\n        shiny::selectInput(\n          inputId = ns(\"x\"),\n          label = \"X variable:\",\n          choices = NULL\n        ),\n        shiny::selectInput(\n          inputId = ns(\"y\"),\n          label = \"Y variable:\",\n          choices = NULL\n        )\n      ),\n      column(\n        6,\n        shiny::selectInput(\n          inputId = ns(\"col\"),\n          label = \"Color variable:\",\n          choices = NULL\n        ),\n        shiny::selectInput(\n          inputId = ns(\"facet\"),\n          label = \"Facet variable:\",\n          choices = NULL\n        )\n      )\n    )\n  )\n}\nmod_vars_server <- function(id, ds_input) {\n  shiny::moduleServer(id, function(input, output, session) {\n    pkg_data <- shiny::reactive({\n      janitor::clean_names(ds_input())\n    }) |>\n      shiny::bindEvent(ds_input(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      num_vars <- pull_numeric_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"x\",\n        choices = num_vars,\n        selected = num_vars[1]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      num_vars <- pull_numeric_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"y\",\n        choices = num_vars,\n        selected = num_vars[2]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      col_vars <- pull_binary_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"col\",\n        choices = col_vars,\n        selected = col_vars[1]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      facet_vars <- pull_facet_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"facet\",\n        choices = facet_vars,\n        selected = facet_vars[1]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    df_vars <- shiny::reactive({\n      cols <- c(input$x, input$y, input$col, input$facet)\n      if (sum(cols %in% names(pkg_data())) == 4) {\n        dplyr::select(\n          .data = pkg_data(),\n          dplyr::all_of(c(\n            input$x, input$y,\n            input$col, input$facet\n          ))\n        )\n      }\n    }) |>\n      shiny::bindEvent(\n        c(\n          pkg_data(),\n          input$x, input$y,\n          input$col, input$facet\n        ),\n        ignoreNULL = TRUE\n      )\n    return(\n      shiny::reactive({\n        cols <- c(input$x, input$y, input$col, input$facet)\n        if (sum(cols %in% names(pkg_data())) == 4) {\n          dplyr::select(\n            .data = pkg_data(),\n            dplyr::all_of(c(\n              input$x, input$y,\n              input$col, input$facet\n            ))\n          )\n        }\n      }) |>\n        shiny::bindEvent(\n          c(\n            pkg_data(),\n            input$x, input$y,\n            input$col, input$facet\n          ),\n          ignoreNULL = TRUE\n        )\n    )\n  })\n}\n```\n\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_graph'\nmod_graph_ui <- function(id) {\n  ns <- shiny::NS(id)\n  shiny::tagList(\n    shiny::fluidRow(\n      shiny::column(\n        width = 6,\n        shiny::sliderInput(\n          inputId = ns(\"alpha\"),\n          label = \"Point opacity:\",\n          min = 0, max = 1, step = 0.1,\n          value = 0.7)\n        ),\n      shiny::column(\n        width = 6,\n        shiny::sliderInput(\n          inputId = ns(\"size\"),\n          label = \"Point size:\",\n          min = 0, max = 5,\n          step = 0.2,\n          value = 3)\n        )\n    ),\n    shiny::fluidRow(\n      shiny::column(\n        width = 12,\n        shiny::plotOutput(outputId = ns(\"graph\"))\n      )\n    )\n  )\n}\nmod_graph_server <- function(id, graph_inputs) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n        output$vals <- shiny::renderPrint({\n            c(input$alpha, input$size)\n           }) |>\n          shiny::bindEvent(graph_inputs(),\n                           ignoreNULL = TRUE)\n\n          shiny::observe({\n              output$graph <- shiny::renderPlot({\n                 gg_scatter_color_facet(\n                     df = graph_inputs(),\n                     x_var = names(graph_inputs())[1],\n                     y_var = names(graph_inputs())[2],\n                     col_var = names(graph_inputs())[3],\n                     facet_var = names(graph_inputs())[4],\n                     alpha = input$alpha,\n                     size = input$size)\n                })\n              }) |>\n             shiny::bindEvent(graph_inputs(),\n                              input$alpha, input$size,\n                              ignoreNULL = TRUE)\n\n  })\n}\n```\n\nThese are added to `appUI()` and `appServer()` the same way I used the `mod_cols` and `mod_plot` modules, and results in the following:\n\n::: {#fig-mod_vars_graph}\n\n![`mod_vars` and `mod_graph` in `pkgDataApp()` error](mod_vars_graph.gif){#fig-mod_vars_graph width=100%}\n\nShiny app displaying `mod_vars` and `mod_graph`\n:::\n\nI can see the warning/error is no longer displayed in UI or the **Console.**\n\n## Solution 2\n\nA second option is using the [`gargoyle` package](https://github.com/ColinFay/gargoyle) from Colin Fay. This package is designed to provide 'Event-Based Structures for Shiny', and it works like so: \n\nIn `appServer()`, I use `gargoyle::init()` to initiate a series of 'trigger flags' and a environment (`env_vars`) to store the function values: \n\n```{r}\n#| eval: false \n#| code-fold: false \n#| echo: true\ngargoyle::init(\"tf_ds\", \"tf_cols\", \"tf_plot\")\nenv_vars <- new.env()\n```\n\nThen I use `gargoyle::trigger()` and `gargoyle::watch()` to link the modules together in a 'reactive daisy-chain':\n\n```{r}\n# pkg module ----\nshiny::observe({\n  env_vars$pkg <- mod_pkg_server(\"pkg\")\n  return(env_vars$pkg)\n  gargoyle::trigger(\"tf_ds\")\n}) |>\n  shiny::bindEvent(env_vars)\n\n# dataset module ----\nshiny::observe({\n  env_vars$dataset <- mod_ds_server(\"ds\",\n    pkg_input = env_vars$pkg\n  )\n  return(env_vars$dataset)\n  gargoyle::trigger(\"tf_cols\")\n}) |>\n  shiny::bindEvent(\n    gargoyle::watch(\"tf_ds\")\n  )\n\n# column select module ----\nshiny::observe({\n  env_vars$plot_values <- mod_cols_server(\n    id = \"cols\",\n    ds_input = env_vars$dataset\n  )\n  return(env_vars$plot_values)\n  gargoyle::trigger(\"tf_plot\")\n}) |>\n  shiny::bindEvent(\n    gargoyle::watch(\"tf_cols\")\n  )\n\n# plot module ----\nshiny::observe({\n  mod_plot_server(\"plot\",\n    ds_input = env_vars$dataset,\n    col_inputs = env_vars$plot_values\n  )\n}) |>\n  shiny::bindEvent(\n    gargoyle::watch(\"tf_plot\")\n  )\n```\n\nI've deployed a version of this application [here in showcase mode](https://mjfrigaard.shinyapps.io/gartsap/) so you can review the modules, ui, and server. \n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| eval: true \n#| echo: false \n#| include: false\nsource(\"../_common.R\")\noptions(scipen = 999)\n# remotes::install_github(\"mjfrigaard/tsap\",\n#   force = TRUE, quiet = TRUE)\nlibrary(mstsap)\n```\n\n\n```{r}\n#| label: co_box_dev\n#| echo: false\n#| results: asis\n#| eval: true\nco_box(color = \"r\", \n  header = \"ALERT!\", \n  contents = \"This post is currently under development--thank you for your patience.\")\n```\n\n```{r}\n#| label: pkgs\n#| code-summary: 'show/hide packages'\n#| eval: false \n#| message: false \n#| warning: false\nlibrary(debugApp) # app package \nlibrary(palmerpenguins) # data\nlibrary(NHANES) # data\nlibrary(rlang) # traceback/stack trace\nlibrary(gt) # tables\n```\n\n\n::: {.column-margin}\n![](shiny-test-bugs.png){width=70%}\n:::\n\n## Bugs!\n\nIn [a previous post](https://mjfrigaard.github.io/series.html), I covered writing tests for module server functions with Shiny's `testServer()` function. The application in that post displays an error similar to the one below:\n\n::: {#fig-graph_error_gif_intro}\n\n![UI error](01-debugApp-error.gif){#fig-graph_error_gif_intro width=100% fig-align=\"center\"}\n\nShiny app displaying `Error: Column 'species' not found in '.data'`\n:::\n\n\nThe warning resolves itself without causing the application to crash, but it's displayed in the UI, so leaving it is not an option. In this post, I'll cover reading the call stack (or stack trace) and using `browse()` to debug errors in a Shiny app-package.\n\n## `debugApp` app-package\n\nThe `debugApp` app-package allows users to select a dataset from an R package and visualize a scatter-plot of\n\nIf you'd like to follow along, you can download `debugApp` [here](https://github.com/mjfrigaard/debugApp/archive/refs/heads/main.zip) or install it using the following: \n\n```{r}\n#| code-fold: false\n#| eval: false\n#| results: hide\nremotes::install_github(\"mjfrigaard/debugApp\", force = TRUE)\nlibrary(debugApp)\n```\n\nI'll quickly review the contents of `debugApp`. The [`R/` folder](https://github.com/mjfrigaard/debugApp/tree/main/R) contains files for the modules: \n\n```{verbatim}\n#| code-fold: false\n#| eval: false\n#| echo: true\nR/\n├── mod_cols.R\n├── mod_ds.R\n├── mod_pkg.R\n└── mod_plot.R\n```\n\n-   Each module file has it's own utility function file: \n\n    ```{verbatim}\n    #| code-fold: false\n    #| eval: false\n    #| echo: true\n    R/\n    ├── utils_vars.R\n    ├── utils_datasets.R\n    ├── utils_pkg.R\n    └── utils_scatter.R\n    ```\n\n\nThe module functions are split between the `appUI()` and `appServer()` functions.  \n\n```{verbatim}\n#| code-fold: false\n#| eval: false\n#| echo: true\nR/\n├── appServer.R # <- _server() module functions\n├── appUI.R # <- _ui() module functions\n└── pkgDataApp.R # <- standalone app function\n```\n\n-   `pkgDataApp()` is a stand-alone app function, which calls `appUI()` and `appServer()`:\n\n    ```{verbatim}\n    #| code-fold: false\n    #| eval: false\n    #| echo: true\n    pkgDataApp <- function() {\n        shiny::shinyApp(\n          ui = appUI,\n          server = appServer)\n    \n    }\n    pkgDataApp()\n    ```\n    \nEach of the modules have tests in the `tests/testthat/` folder: \n\n```{verbatim}\n#| code-fold: false\n#| eval: false\n#| echo: true\ntests/testthat/\n├── test-mod_cols_server.R\n├── test-mod_ds_server.R\n├── test-mod_pkg_server.R\n└── test-mod_plot_server.R\n```\n\n-   As do the module utility functions: \n\n    ```{verbatim}\n    #| code-fold: false\n    #| eval: false\n    #| echo: true\n    tests/testthat\n    ├── test-check_binary_vec.R\n    ├── test-check_facet_vec.R\n    ├── test-get_col_types.R\n    ├── test-make_binary_vec.R\n    ├── test-make_facet_vec.R\n    ├── test-pull_binary_cols.R\n    ├── test-pull_cat_cols.R\n    ├── test-pull_facet_cols.R\n    └── test-pull_numeric_cols.R\n    ```\n\n\n## Modules \n\nI've created the figure below to illustrate how the modules in `pkgDataApp()` work together: \n\n:::: {.column-page-inset-right}\n\n::: {#fig-module_flow}\n\n![`tsap` modules](module_flow.png){#fig-module_flow width=100%}\n\nModules in `tsap::pkgDataApp()`\n:::\n\n::::\n\nAs you can see, the modules are connected by a chain of reactive values, and each module returns a slightly more complicated reactive value (`character` -> `data.frame`/`tibble` -> `list` ). \n\n### `mod_pkg`\n\n1. The `mod_pkg` module displays the packages with `data.frame`s or `tibble`s (and returns the package as a reactive character string, `pkg()`)\n\n::: {#fig-mod_pkg_schema}\n\n![`mod_pkg`](mod_pkg_schema.png){#fig-mod_pkg_schema width=70%}\n\n\n`mod_pkg` in `pkgDataApp()`\n:::\n\n### `mod_ds`\n\n2. `mod_ds` renames `pkg()` as `pkg_input()` and uses it to update the `selectInput()` options for the selected package datasets (the selected dataset is returned as a reactive `dataset()`) \n\n::: {#fig-mod_ds_schema}\n\n![`mod_ds`](mod_ds_schema.png){#fig-mod_ds_schema width=70%}\n\n`mod_pkg` and `mod_ds` in `pkgDataApp()`\n:::\n\n### `mod_cols`\n\n3. `mod_cols` receives `dataset()` as `ds_input()` and updates the `selectInput()`s with the columns in the `ds_input()`. Columns are displayed by 'type' (i.e., two numeric columns (`x` and `y`), binary columns (`color`), and a  `facet` column. Then `ds_input()`, the selected columns (`x`, `y`, `color` and `facet`) and graph aesthetics (`size` and `alpha`) are combined and returned as the reactive list `plot_values()`\n\n::: {#fig-mod_cols_schema}\n\n![`mod_cols`](mod_cols_schema.png){#fig-mod_cols_schema width=100%}\n\n`mod_pkg`, `mod_ds`, and `mod_cols` in `pkgDataApp()`\n:::\n\n\n### `mod_plot`\n\n4. `mod_plot` uses `plot_values()` as `plot_inputs()` and a custom `ggplot2` utility function (`gg_color_scatter_facet()`) to render the plot\n\n:::: {.column-body-outset-right}\n\n::: {#fig-mod_plot_schema}\n\n![`mod_plot` in `tsap::pkgDataApp()`](mod_plot_schema.png){#fig-mod_plot_schema width=100%}\n\n`mod_pkg`,`mod_ds`, `mod_cols`, and `mod_plot` modules in `pkgDataApp()`\n:::\n\n::::\n\nThe `ggplot2` function used to generate the plot (`gg_color_scatter_facet()`) is below:\n\n```{r}\n#| code-fold: true\n#| code-summary: 'gg_color_scatter_facet()'\n#| eval: false\ngg_color_scatter_facet <- function(df, x_var, y_var,\n                                col_var = NULL, facet_var = NULL,\n                                ...) {\n  # missing both color and facet vars\n  if (is.null(col_var) & is.null(facet_var)) {\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]], \n          y = .data[[y_var]])\n      ) +\n        ggplot2::geom_point(...) +\n        # add labels\n        ggplot2::labs(\n          title = make_x_y_title(\n            x = x_var, y = y_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n\n    # no facet, but has color\n  } else if (!is.null(col_var) & is.null(facet_var)) {\n\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]], \n          y = .data[[y_var]])\n      ) +\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(\n          ggplot2::aes(\n            colour = .data[[col_var]], \n            group = .data[[col_var]]),\n            ...\n        ) +\n        # add labels\n        ggplot2::labs(\n          title = make_x_y_color_title(\n            x = x_var, y = y_var, color = col_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          ),\n          color = stringr::str_replace_all(\n            snakecase::to_title_case(col_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n    # no color, but has facet\n  } else if (is.null(col_var) & !is.null(facet_var)) {\n\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]], \n          y = .data[[y_var]])\n      ) +\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(...) +\n        # add facet layer\n        ggplot2::facet_wrap(ggplot2::vars(.data[[facet_var]])) +\n        # add labels\n        ggplot2::labs(\n          title = make_x_y_title(\n            x = x_var, y = y_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n  } else {\n\n      # has both color and facet vars\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]],\n          y = .data[[y_var]])\n      ) +\n        # points layer\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(\n          ggplot2::aes(\n            colour = .data[[col_var]],\n            group = .data[[col_var]]), ...\n        ) +\n        # add facet layer\n        ggplot2::facet_wrap(ggplot2::vars(.data[[facet_var]])) +\n        # add labels\n        ggplot2::labs(title =\n            make_x_y_col_facet_title(x = x_var,\n                                     y = y_var,\n                                     color = col_var,\n                                     facets = facet_var),\n          x = stringr::str_replace_all(\n            snakecase::to_title_case(x_var), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            snakecase::to_title_case(y_var), \"_\", \" \"\n          ),\n          color = stringr::str_replace_all(\n            snakecase::to_title_case(col_var), \"_\", \" \"\n          ),\n          group = stringr::str_replace_all(\n            snakecase::to_title_case(facet_var), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n\n  }\n}\n\n```\n\n\n## Stack trace\n\nDuring development, the warning below is printed to the **Console** when I change the package input of `tsap::pkgDataApp()`:\n\n::: {style='font-size: 1.10em; font-weight: bold;'}\n\n`# Warning: Error in [[: Column 'race1' not found in '.data'.`\n\n:::\n\nBelow the warning, the **Console** also prints the following abbreviated numbered list of items: \n\n::: {style='font-size: 0.90em;'}\n\n```{verbatim}\n#| eval: false\n#| code-fold: show\n#| code-summary: 'show/hide stack trace from console'\nWarning: Error in [[: Column `race1` not found in `.data`.\n  202: <Anonymous>\n  201: signalCondition\n  200: signal_abort\n  199: abort\n  198: abort_data_pronoun\n  197: data_pronoun_get\n  196: [[.rlang_data_pronoun\n  195: [[\n  194: eval_tidy\n  189: FUN\n  188: lapply\n  185: FUN\n  184: lapply\n  181: combine_vars\n  180: compute_layout\n  179: self$facet$compute_layout\n  178: setup\n  177: layout$setup\n  176: ggplot_build.ggplot\n  174: print.ggplot\n  169: func\n  167: f\n  166: Reduce\n  157: do\n  156: hybrid_chain\n  128: drawPlot\n  114: <reactive:plotObj>\n   98: drawReactive\n   85: renderFunc\n   84: output$plot-graph\n    3: runApp\n    2: print.shiny.appobj\n    1: <Anonymous>\n```\n\n:::\n\nThe output above is referred to as a [stack trace (or traceback)](https://en.wikipedia.org/wiki/Stack_trace?oldformat=true), which is a report that provides information about a function call (or sequence of calls) at a certain point. The numbered items are 'frames', and collectively they're referred to as the ['call stack' or 'stack frame'](https://en.wikipedia.org/wiki/Call_stack).\n\n::: {.callout-note icon=false collapse='true'}\n\n## Stack traces in shiny\n\nBelieve it or not, the output shown above actually isn't the *full* stack trace for the error--`shiny` performs some post-processing to trim it down. If you'd like to view the full stack trace for the warning, try setting `options(shiny.fullstacktrace = TRUE)` before running your application.\n\n:::\n\nA stack trace is usually generated when an error occurs, and it gives developers a snapshot of the function calls preceding the error.\n\n### Stack traces in R\n\nThe output above is automatically returned to the **Console** while if you're developing a shiny app in RStudio, but I'll cover two methods for manually creating a stack trace from an error. \n\n#### `traceback()`\n\nIn base R, you can generate a stack trace by calling the `traceback()` function directly following the error. \n\nI'll use `gg_color_scatter_facet()` in the code chunk below, but I've written it to reproduce the error I'm seeing above (i.e., the variable arguments are from the `NHANES::NHANES` data, but the `df` argument has been changed to `palmerpenguins::penguins`). \n\nI'll pass the `gg_color_scatter_facet()` call in to the **Console:**\n\n```{r}\n#| error: true\n#| code-fold: show\n#| code-summary: 'ggplot2 error with traceback()'\n#| eval: true\ntsap::gg_color_scatter_facet(\n  df = janitor::clean_names(palmerpenguins::penguins),\n  x_var = \"poverty\",\n  y_var = \"weight\",\n  col_var = \"survey_yr\",\n  facet_var = \"race1\",\n  alpha = 1 / 3,\n  size = 2)\n```\n\nAfter the error, I call `traceback()`:\n\n```{r}\n#| eval: false\n#| code-fold: false\ntraceback()\n```\n\nThe output from `traceback()` is below: \n\n::: {style=\"font-size: 0.90em;\"}\n\n```{bash}\n#| eval: false\n#| code-fold: show \n#| code-summary: 'show/hide traceback() output'\n29: stop(fallback)\n28: signal_abort(cnd, .file)\n27: abort(msg, \"rlang_error_data_pronoun_not_found\", call = call)\n26: abort_data_pronoun(x, call = y)\n25: data_pronoun_get(x, i, call = I(call(\"[[\", quote(.data), substitute(i))))\n24: `[[.rlang_data_pronoun`(.data, \"race1\")\n23: .data[[\"race1\"]]\n22: eval_tidy(facet, mask)\n21: doTryCatch(return(expr), name, parentenv, handler)\n20: tryCatchOne(expr, names, parentenv, handlers[[1L]])\n19: tryCatchList(expr, classes, parentenv, handlers)\n18: tryCatch(eval_tidy(facet, mask), ggplot2_missing_facet_var = function(e) NULL)\n17: FUN(X[[i]], ...)\n16: lapply(facets, eval_facet, data, possible_columns = possible_columns)\n15: vapply(x, is.null, logical(1))\n14: compact(lapply(facets, eval_facet, data, possible_columns = possible_columns))\n13: FUN(X[[i]], ...)\n12: lapply(data, eval_facets, facets = vars, possible_columns = possible_columns)\n11: vapply(x, is.null, logical(1))\n10: compact(lapply(data, eval_facets, facets = vars, possible_columns = possible_columns))\n9: combine_vars(data, params$plot_env, vars, drop = params$drop)\n8: compute_layout(..., self = self)\n7: self$facet$compute_layout(data, self$facet_params)\n6: setup(..., self = self)\n5: layout$setup(data, plot$data, plot$plot_env)\n4: ggplot_build.ggplot(x)\n3: ggplot_build(x)\n2: print.ggplot(x)\n1: (function (x, ...) \n   UseMethod(\"print\"))(x)\n```\n\n:::\n\nThe output from `traceback()` is a [pairlist](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Pairlist-objects), and it contains the \"[stack of the last uncaught errors](https://stat.ethz.ch/R-manual/R-devel/library/base/html/traceback.html).\" \n\n::: {.callout-tip icon=false collapse='true'}\n\n## Adding `traceback()` to `.Rprofile`\n\nIf you'd like to view the `traceback()` output whenever an error occurs, you can add the following to your `.Rprofile`:\n\n```{r}\n#| eval: false\n#| echo: true\n#| code-fold: false\noptions(error = traceback)\n```\n\nRead more debugging tips in the [Posit support documentation](https://support.posit.co/hc/en-us/articles/200713843#using-the-debugger). \n\n:::\n\nIf the output from `traceback()` is too large to read in the **Console**, I'll store it and use `grep()` or [`stringr::str_view_all()`](https://stringr.tidyverse.org/) to explore its contents: \n\n```{r}\n#| label: bug\n#| eval: true \n#| echo: false\nbug <- pairlist(\"stop(fallback)\", \"signal_abort(cnd, .file)\", \"abort(msg, \\\"rlang_error_data_pronoun_not_found\\\", call = call)\", \"abort_data_pronoun(x, call = y)\", \"data_pronoun_get(x, i, call = I(call(\\\"[[\\\", quote(.data), substitute(i))))\", \"`[[.rlang_data_pronoun`(.data, \\\"race1\\\")\", \".data[[\\\"race1\\\"]]\", \"eval_tidy(facet, mask)\", \"doTryCatch(return(expr), name, parentenv, handler)\", \"tryCatchOne(expr, names, parentenv, handlers[[1L]])\", \"tryCatchList(expr, classes, parentenv, handlers)\", \"tryCatch(eval_tidy(facet, mask), ggplot2_missing_facet_var = function(e) NULL)\", \"FUN(X[[i]], ...)\", \"lapply(facets, eval_facet, data, possible_columns = possible_columns)\", \"vapply(x, is.null, logical(1))\", \"compact(lapply(facets, eval_facet, data, possible_columns = possible_columns))\", \"FUN(X[[i]], ...)\", \"lapply(data, eval_facets, facets = vars, possible_columns = possible_columns)\", \"vapply(x, is.null, logical(1))\", \"compact(lapply(data, eval_facets, facets = vars, possible_columns = possible_columns))\", \"combine_vars(data, params$plot_env, vars, drop = params$drop)\", \"compute_layout(..., self = self)\", \"self$facet$compute_layout(data, self$facet_params)\", \"setup(..., self = self)\", \"layout$setup(data, plot$data, plot$plot_env)\", \"ggplot_build.ggplot(x)\", \"ggplot_build(x)\", \"print.ggplot(x)\", c(\"(function (x, ...) \", \n\"UseMethod(\\\"print\\\"))(x)\"))\n```\n\n\n```{r}\n#| eval: false \n#| echo: true\n#| code-fold: false\nbug <- traceback()\n```\n\nBelow I'll narrow the stack trace down to the terms I see in the UI (like `.data` and `race1`): \n\n```{r}\n#| eval: true \n#| echo: true\n#| code-fold: false \nlibrary(stringr) \nstringr::str_view_all(\n  string = unlist(bug), \n  pattern = \"\\\\.data|race1\", \n  match = TRUE)\n```\n\n#### `rlang::last_trace()`\n\nWhen I entered the previous call to `gg_color_scatter_facet()` in the **Console**, there was a suggestion to run `rlang::last_trace()`: \n\n```{verbatim}\n#| eval: false\n#| code-fold: false\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\n`last_trace()` is similar to `traceback()`, but prints the stack trace in a hierarchical tree structure: \n\n```{r}\n#| eval: false\n#| code-fold: false\nrlang::last_trace()\n```\n\n::: {style=\"font-size: 0.90em;\"}\n\n```{bash}\n#| eval: false\n#| code-fold: show\n#| code-summary: 'show/hide rlang::last_trace() output'\n<error/rlang_error_data_pronoun_not_found>\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\n---\nBacktrace:\n     ▆\n  1. ├─base (local) `<fn>`(x)\n  2. ├─ggplot2:::print.ggplot(x)\n  3. │ ├─ggplot2::ggplot_build(x)\n  4. │ └─ggplot2:::ggplot_build.ggplot(x)\n  5. │   └─layout$setup(data, plot$data, plot$plot_env)\n  6. │     └─ggplot2 (local) setup(..., self = self)\n  7. │       └─self$facet$compute_layout(data, self$facet_params)\n  8. │         └─ggplot2 (local) compute_layout(..., self = self)\n  9. │           └─ggplot2::combine_vars(data, params$plot_env, vars, drop = params$drop)\n 10. │             ├─ggplot2:::compact(lapply(data, eval_facets, facets = vars, possible_columns = possible_columns))\n 11. │             │ └─base::vapply(x, is.null, logical(1))\n 12. │             └─base::lapply(data, eval_facets, facets = vars, possible_columns = possible_columns)\n 13. │               └─ggplot2 (local) FUN(X[[i]], ...)\n 14. │                 ├─ggplot2:::compact(lapply(facets, eval_facet, data, possible_columns = possible_columns))\n 15. │                 │ └─base::vapply(x, is.null, logical(1))\n 16. │                 └─base::lapply(facets, eval_facet, data, possible_columns = possible_columns)\n 17. │                   └─ggplot2 (local) FUN(X[[i]], ...)\n 18. │                     ├─base::tryCatch(eval_tidy(facet, mask), ggplot2_missing_facet_var = function(e) NULL)\n 19. │                     │ └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 20. │                     │   └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 21. │                     │     └─base (local) doTryCatch(return(expr), name, parentenv, handler)\n 22. │                     └─rlang::eval_tidy(facet, mask)\n 23. ├─race1\n 24. ├─rlang:::`[[.rlang_data_pronoun`(.data, \"race1\")\n 25. │ └─rlang:::data_pronoun_get(...)\n 26. └─rlang:::abort_data_pronoun(x, call = y)\n\n```\n\n:::\n\nBoth `traceback()` and `last_trace()` print each preceding function call before the error. I prefer using `rlang::last_trace()` because I find the tree output to be easier to read. However, I usually follow the second piece of advice from the **Console** output and set `drop` to `FALSE`:\n\n```{verbatim}\n#| eval: false\n#| code-fold: true \nRun rlang::last_trace(drop = FALSE) to see 1 hidden frame.\n```\n\nBy default, `last_trace()` will `drop` technical function calls, but I like to see *all* of the calls in a stack trace, so I usually change `drop` to `FALSE`. \n\n```{r}\n#| eval: false\n#| code-fold: false\nrlang::last_trace(drop = FALSE)\n```\n\nAfter changing `drop` to `FALSE` I can see one additional frame in the stack (I've omitted frames `1.` through `22.`, but you can see frame `27.` has been added below).\n\n::: {style=\"font-size: 0.90em;\"}\n\n```{bash}\n#| eval: false\n#| code-fold: false \n<error/rlang_error_data_pronoun_not_found>\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\n---\nBacktrace:\n     ▆\n 23. ├─race1\n 24. ├─rlang:::`[[.rlang_data_pronoun`(.data, \"race1\")\n 25. │ └─rlang:::data_pronoun_get(...)\n 26. └─rlang:::abort_data_pronoun(x, call = y)\n 27.   └─rlang::abort(msg, \"rlang_error_data_pronoun_not_found\", call = call)\n```\n\n:::\n\n### What did I expect?\n\nI generally try to write code that executes without errors, so the output from `traceback()` or `last_trace()` is always a little bewildering. I never know *exactly* what I'm looking for in the stack trace (if so, I would've written the code to avoid encountering it), but I like to start with a clear understanding of the behavior I'm expecting the function to perform. \n\nIn this case, I'm expecting the data (in `mod_ds`) and columns (in `mod_cols`) to update in `plot_values()` when I change the package input to `palmerpenguins`:\n\n::: {#fig-mods_pkg_ds_cols}\n\n![Changes to package, data and columns](mods_pkg_ds_cols.png){#fig-mods_pkg_ds_cols width=100%}\n\nUpdating package input, data, and columns\n:::\n\nThe updated `plot_values()` reactive list is passed to the `plot_inputs` argument `mod_plot` (where the graph is rendered). \n\nI've included the call to `renderPlot()` with `gg_color_scatter_facet()` in the code block below for reference: \n\n```{r}\n#| eval: false\n#| code-fold: false \n output$graph <- shiny::renderPlot({\n    gg_color_scatter_facet(\n        df = plot_inputs()$df,\n        x_var = plot_inputs()$x_var,\n        y_var = plot_inputs()$y_var,\n        col_var = plot_inputs()$col_var,\n        facet_var = plot_inputs()$facet_var,\n        alpha = plot_inputs()$alpha,\n        size = plot_inputs()$size)\n   })\n```\n\n\n### What happened instead? \n\nThe error I'm seeing is telling me there is something wrong with the facet variable in `mod_plot`:\n\n``` r\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\n```\n\n`race1` is the facet variable from the `NHANES` data, so I am assuming the `plot_inputs()` list isn't updating when I change `input$pkg` in `mod_pkg` to `palmerpenguins`. \n\n::: {#fig-default_nhanes_vars}\n\n![Default `NHANES::NHANES` data and columns](default_nhanes_vars.png){#fig-default_nhanes_vars width=100%}\n\n`pkgDataApp()` automatically loads with `NHANES::NHANES`\n:::\n\n\nthe `plot_values()` list would contain the updated `penguins` data (from `mod_ds`), and the `penguins` columns (from `mod_cols`). \n\nIf the `penguins` data is updated in `plot_values()` *before* the columns and graph aesthetics, then why is the facet variable causing the error? \n\n::: {#fig-mods_pkg_ds_cols_warn_plot}\n\n![Possible location of bug in `pkgDataApp()`](mods_pkg_ds_cols_warn_plot.png){#fig-mods_pkg_ds_cols_warn_plot width=100%}\n\n\nLocation of bug in `pkgDataApp()`?\n:::\n\nThere are hints to what is causing the warning/error in the call stack. Frame `1.` through `.6` of show the initialization of the `ggplot2` graph, but frame `.7` references the facet layout: \n\n```{bash}\n#| eval: false\n#| code-fold: false \nBacktrace:\n     ▆\n  1. ├─base (local) `<fn>`(x)\n  2. ├─ggplot2:::print.ggplot(x)\n  3. │ ├─ggplot2::ggplot_build(x)\n  4. │ └─ggplot2:::ggplot_build.ggplot(x)\n  5. │   └─layout$setup(data, plot$data, plot$plot_env)\n  6. │     └─ggplot2 (local) setup(..., self = self)\n  7. │       └─self$facet$compute_layout(data, self$facet_params)\n```\n\n\nFrame `.7` is a hint because it tells me where/when the facet layer is referenced in the call stack.\n\nIf I look down to frame `23.`, I see `race1` (the facet variable) and the data masking method used to find the facet variable in the custom `ggplot2` function (`.data[[facet_var]]`):\n\n```{bash}\n#| eval: false\n#| code-fold: false \nBacktrace:\n     ▆\n 22. │                     └─rlang::eval_tidy(facet, mask)\n 23. ├─race1\n 24. ├─rlang:::`[[.rlang_data_pronoun`(.data, \"race1\")\n 25. │ └─rlang:::data_pronoun_get(...)\n 26. └─rlang:::abort_data_pronoun(x, call = y)\n```\n\nThe stack ends in a call to `rlang::abort_data_pronoun()` (because `race1` isn't in `.data`).\n\n#### Check (and re-check) function \n\nThe order of the frames in the stack trace is counter-intuitive, because the facet variable (`.data[[facet_var]]`) is added to the `ggplot2` graph *after* the x, y, and color variables (*I've included this portion of `gg_color_scatter_facet()` below*):\n\n```{r}\n#| eval: false\n#| code-fold: false \n# has both color and facet vars\n      ggplot2::ggplot(\n        data = df,\n        mapping = ggplot2::aes(\n          x = .data[[x_var]],\n          y = .data[[y_var]])\n      ) +\n        # points layer\n        # add ... for alpha and size passed to points\n        ggplot2::geom_point(\n          ggplot2::aes(\n            colour = .data[[col_var]],\n            group = .data[[col_var]]), ...\n        ) +\n        # add facet layer\n        ggplot2::facet_wrap(ggplot2::vars(.data[[facet_var]])) +\n        # add labels \n        # ...\n```\n\n1. The `x` and `y` are in the initial `aes()` layer    \n2. The `colour` layer is added with the `geom_point()`    \n3. Finally, the facet variable is added in the `facet_wrap()` layer\n\n\nWhen I change the package input in `mod_pkg`, I'm assuming the `plot_values()` list is updated with the `penguins` data, followed by the column arguments from `mod_cols`.\n\nBut the column values are still from the `NHANES` data, which is triggering the warning. The warning/error is eventually resolved when the `penguins` column inputs make their way from `mod_cols` to `mod_plot` (where the plot is rendered).\n\n## Using the debugger \n\nNow I'm ready to experiment with `plot_values` and `gg_color_scatter_facet()` in the debugger: \n\n1.  Below I've create `plot_values_test`, with `penguins` assigned to `df`, and the `NHANES` columns assigned to the column arguments: \n\n    ```{r}\n    #| eval: true\n    #| code-fold: false \n    plot_values_test <- list(\n      # data from palmerpenguins::penguins\n      df = janitor::clean_names(palmerpenguins::penguins),\n      # columns from NHANES::NHANES\n      x_var = \"poverty\",\n      y_var = \"weight\",\n      col_var = \"survey_yr\",\n      facet_var = \"race1\",\n      size = 2L,\n      alpha = 0.75\n    )\n    ```\n\n2.  I'll pass the `plot_values_test` list to the `gg_color_scatter_facet()` function, but with a call to `browser()`: \n\n    ```{.r}\n    source(\"~/tsap/R/utils_scatter.R\")\n    Called from: gg_color_scatter_facet(\n      df = plot_values_test$df, \n      x_var = plot_values_test$x_var, \n      y_var = plot_values_test$y_var, \n      col_var = plot_values_test$col_var, \n      facet_var = plot_values_test$facet_var, \n      alpha = plot_values_test$alpha, \n      size = plot_values_test$size)\n    ```\n\n### Inside the function\n\n\nThe first few steps take me through the control flow in `gg_color_scatter_facet()`. \n\n```{.r}\n# are both col_var and facet_var NULL?\nBrowse[1]> n\ndebug at ~/tsap/R/utils_scatter.R#452: if (is.null(col_var) & is.null(facet_var)) {\n```\n\n```{.r}\n# facet_var NULL? \nBrowse[2]> n\ndebug at ~/tsap/R/utils_scatter.R#452: if (!is.null(col_var) & is.null(facet_var)) {\n```\n\nAt this step, I can see the values for `col_var` and `facet_var` are present in the function **Environment**: \n\n::: {#fig-env_vars_col_facet}\n\n![Function variables in `gg_color_scatter_facet()`](env_vars_col_facet.png){#fig-env_vars_col_facet width=100%}\n\nColor and facet variables in `gg_color_scatter_facet()`\n:::\n\nI continue stepping through the control flow until I arrive at the `ggplot2` function: \n\n```{.r}\n# col_var NULL?\nBrowse[2]> n\ndebug at ~/tsap/R/utils_scatter.R#452: if (is.null(col_var) & !is.null(facet_var)) {\n```\n\nWhen I arrive at the `ggplot2` functions, I'll see this code highlighted in the **Source** pane, \n\n::: {#fig-debugger_ggplot2}\n\n![Function variables in `gg_color_scatter_facet()`](debugger_ggplot2.png){#fig-debugger_ggplot2 width=75%}\n\n`ggplot2` code in `gg_color_scatter_facet()`\n:::\n\nWhen I attempt to execute this step, I see the error: \n\n### Confirmation!\n\n```{.r}\nBrowse[2]> n\nError in `.data[[\"race1\"]]`:\n! Column `race1` not found in `.data`.\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\nThe error in the debugger tells me that when I update the package in `mod_pkg`, the dataset (from `mod_ds`) is updated in `plot_values()` *before* the column values (from `mod_cols`). \n\nThis explains why the error I'm seeing is referring to data masking (`.data[[\"race1\"]]`), because in `gg_color_scatter_facet()`, when `.data` changes to `penguins`, the `facet_var` is still `race1`. \n\n## Solution 1\n\nI have a few options for dealing with this warning. I can rewrite the custom `ggplot2` function to only execute if all of the column arguments are present in `.data`. This can be implemented using something like `graph_check()` below:\n\n```{r graph_check}\n#| eval: true\n#| code-fold: false\ngraph_check <- function(df, x_var, y_var, col_var = NULL, facet_var = NULL, ...)\nif (sum(c(x_var, y_var, col_var, facet_var) %in% names(df)) == 4) {\n  cli::cli_alert_success(\"Plot renders\") \n} else {\n  cli::cli_alert_warning(\"Columns not in .data\") \n}\n```\n\n`graph_check()` will search the names of `df` to confirm the values provided in the column arguments are present. \n\nI can confirm this with `plot_values_test` (the list with `penguins` data and `NHANES` columns) and `plot_values` (a list with `NHANES` data and columns).\n\n-   Check mismatched data and columns: \n\n    ```{r}\n    #| eval: true\n    #| code-fold: false\n    graph_check(\n      df = plot_values_test$df,\n      x_var = plot_values_test$x_var,\n      y_var = plot_values_test$y_var,\n      col_var = plot_values_test$col_var,\n      facet_var = plot_values_test$facet_var,\n      alpha = plot_values_test$alpha,\n      size = plot_values_test$size\n    )\n    ```\n    ```\n    ! Columns not in .data\n    ```\n    \n    -   Create correct `plot_values` list: \n\n    ```{r}\n    #| eval: true\n    #| code-fold: false\n    plot_values <- list(\n      df = janitor::clean_names(NHANES::NHANES),\n      x_var = \"poverty\",\n      y_var = \"weight\",\n      col_var = \"survey_yr\",\n      facet_var = \"race1\",\n      size = 2L,\n      alpha = 0.75\n    )\n    ```\n    \n    -   Confirm `graph_check()`:\n\n    ```{r}\n    #| eval: true\n    #| code-fold: false\n    graph_check(\n      df = plot_values$df,\n      x_var = plot_values$x_var,\n      y_var = plot_values$y_var,\n      col_var = plot_values$col_var,\n      facet_var = plot_values$facet_var,\n      alpha = plot_values$alpha,\n      size = plot_values$size\n    )\n    ```\n    ```\n    ✔ Plot renders\n    ```\n\nI can also separate the graph aesthetic *variables* (`x_var`, `y_var`, `col_var`, and `facet_var`) from the two graph aesthetic *values* (`alpha` and `size`). I've implemented this solution in the `mod_vars` and `mod_graph` modules, which you can view below: \n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_vars'\nmod_vars_ui <- function(id) {\n  ns <- shiny::NS(id)\n  shiny::tagList(\n    shiny::fluidRow(\n      column(\n        width = 6,\n        shiny::selectInput(\n          inputId = ns(\"x\"),\n          label = \"X variable:\",\n          choices = NULL\n        ),\n        shiny::selectInput(\n          inputId = ns(\"y\"),\n          label = \"Y variable:\",\n          choices = NULL\n        )\n      ),\n      column(\n        6,\n        shiny::selectInput(\n          inputId = ns(\"col\"),\n          label = \"Color variable:\",\n          choices = NULL\n        ),\n        shiny::selectInput(\n          inputId = ns(\"facet\"),\n          label = \"Facet variable:\",\n          choices = NULL\n        )\n      )\n    )\n  )\n}\nmod_vars_server <- function(id, ds_input) {\n  shiny::moduleServer(id, function(input, output, session) {\n    pkg_data <- shiny::reactive({\n      janitor::clean_names(ds_input())\n    }) |>\n      shiny::bindEvent(ds_input(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      num_vars <- pull_numeric_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"x\",\n        choices = num_vars,\n        selected = num_vars[1]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      num_vars <- pull_numeric_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"y\",\n        choices = num_vars,\n        selected = num_vars[2]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      col_vars <- pull_binary_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"col\",\n        choices = col_vars,\n        selected = col_vars[1]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    shiny::observe({\n      facet_vars <- pull_facet_cols(df = pkg_data())\n      shiny::updateSelectInput(session,\n        inputId = \"facet\",\n        choices = facet_vars,\n        selected = facet_vars[1]\n      )\n    }) |>\n      shiny::bindEvent(pkg_data(),\n        ignoreNULL = TRUE\n      )\n\n    df_vars <- shiny::reactive({\n      cols <- c(input$x, input$y, input$col, input$facet)\n      if (sum(cols %in% names(pkg_data())) == 4) {\n        dplyr::select(\n          .data = pkg_data(),\n          dplyr::all_of(c(\n            input$x, input$y,\n            input$col, input$facet\n          ))\n        )\n      }\n    }) |>\n      shiny::bindEvent(\n        c(\n          pkg_data(),\n          input$x, input$y,\n          input$col, input$facet\n        ),\n        ignoreNULL = TRUE\n      )\n    return(\n      shiny::reactive({\n        cols <- c(input$x, input$y, input$col, input$facet)\n        if (sum(cols %in% names(pkg_data())) == 4) {\n          dplyr::select(\n            .data = pkg_data(),\n            dplyr::all_of(c(\n              input$x, input$y,\n              input$col, input$facet\n            ))\n          )\n        }\n      }) |>\n        shiny::bindEvent(\n          c(\n            pkg_data(),\n            input$x, input$y,\n            input$col, input$facet\n          ),\n          ignoreNULL = TRUE\n        )\n    )\n  })\n}\n```\n\n\n```{r}\n#| eval: false\n#| code-fold: true \n#| code-summary: 'show/hide mod_graph'\nmod_graph_ui <- function(id) {\n  ns <- shiny::NS(id)\n  shiny::tagList(\n    shiny::fluidRow(\n      shiny::column(\n        width = 6,\n        shiny::sliderInput(\n          inputId = ns(\"alpha\"),\n          label = \"Point opacity:\",\n          min = 0, max = 1, step = 0.1,\n          value = 0.7)\n        ),\n      shiny::column(\n        width = 6,\n        shiny::sliderInput(\n          inputId = ns(\"size\"),\n          label = \"Point size:\",\n          min = 0, max = 5,\n          step = 0.2,\n          value = 3)\n        )\n    ),\n    shiny::fluidRow(\n      shiny::column(\n        width = 12,\n        shiny::plotOutput(outputId = ns(\"graph\"))\n      )\n    )\n  )\n}\nmod_graph_server <- function(id, graph_inputs) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n        output$vals <- shiny::renderPrint({\n            c(input$alpha, input$size)\n           }) |>\n          shiny::bindEvent(graph_inputs(),\n                           ignoreNULL = TRUE)\n\n          shiny::observe({\n              output$graph <- shiny::renderPlot({\n                 gg_scatter_color_facet(\n                     df = graph_inputs(),\n                     x_var = names(graph_inputs())[1],\n                     y_var = names(graph_inputs())[2],\n                     col_var = names(graph_inputs())[3],\n                     facet_var = names(graph_inputs())[4],\n                     alpha = input$alpha,\n                     size = input$size)\n                })\n              }) |>\n             shiny::bindEvent(graph_inputs(),\n                              input$alpha, input$size,\n                              ignoreNULL = TRUE)\n\n  })\n}\n```\n\nThese are added to `appUI()` and `appServer()` the same way I used the `mod_cols` and `mod_plot` modules, and results in the following:\n\n::: {#fig-mod_vars_graph}\n\n![`mod_vars` and `mod_graph` in `pkgDataApp()` error](mod_vars_graph.gif){#fig-mod_vars_graph width=100%}\n\nShiny app displaying `mod_vars` and `mod_graph`\n:::\n\nI can see the warning/error is no longer displayed in UI or the **Console.**\n\n## Solution 2\n\nA second option is using the [`gargoyle` package](https://github.com/ColinFay/gargoyle) from Colin Fay. This package is designed to provide 'Event-Based Structures for Shiny', and it works like so: \n\nIn `appServer()`, I use `gargoyle::init()` to initiate a series of 'trigger flags' and a environment (`env_vars`) to store the function values: \n\n```{r}\n#| eval: false \n#| code-fold: false \n#| echo: true\ngargoyle::init(\"tf_ds\", \"tf_cols\", \"tf_plot\")\nenv_vars <- new.env()\n```\n\nThen I use `gargoyle::trigger()` and `gargoyle::watch()` to link the modules together in a 'reactive daisy-chain':\n\n```{r}\n# pkg module ----\nshiny::observe({\n  env_vars$pkg <- mod_pkg_server(\"pkg\")\n  return(env_vars$pkg)\n  gargoyle::trigger(\"tf_ds\")\n}) |>\n  shiny::bindEvent(env_vars)\n\n# dataset module ----\nshiny::observe({\n  env_vars$dataset <- mod_ds_server(\"ds\",\n    pkg_input = env_vars$pkg\n  )\n  return(env_vars$dataset)\n  gargoyle::trigger(\"tf_cols\")\n}) |>\n  shiny::bindEvent(\n    gargoyle::watch(\"tf_ds\")\n  )\n\n# column select module ----\nshiny::observe({\n  env_vars$plot_values <- mod_cols_server(\n    id = \"cols\",\n    ds_input = env_vars$dataset\n  )\n  return(env_vars$plot_values)\n  gargoyle::trigger(\"tf_plot\")\n}) |>\n  shiny::bindEvent(\n    gargoyle::watch(\"tf_cols\")\n  )\n\n# plot module ----\nshiny::observe({\n  mod_plot_server(\"plot\",\n    ds_input = env_vars$dataset,\n    col_inputs = env_vars$plot_values\n  )\n}) |>\n  shiny::bindEvent(\n    gargoyle::watch(\"tf_plot\")\n  )\n```\n\nI've deployed a version of this application [here in showcase mode](https://mjfrigaard.shinyapps.io/gartsap/) so you can review the modules, ui, and server. \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"fig-asp":0.618,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr","message":false},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","dpi":320,"toc":true,"toc-depth":5,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.28","knitr":{"opts_chunk":{"collapse":true,"comment":"#"}},"editor":{"mode":"source","render-on-save":true},"theme":{"light":["cosmo","../../custom.scss"]},"fontsize":"1.015em","linestretch":1.15,"code-annotations":"hover","title-block-banner":true,"title":"Debugging Shiny apps","subtitle":"call stacks, browser(), and tests","author":"Martin Frigaard","date":"2023-06-23","categories":["code","debugging","shiny","testing"],"image":"image.png","toc-title":"Contents","toc-location":"left","code-block-bg":"#f8f8f8","code-block-border-left":"#e8e8e8","code-summary":"show/hide","callout-icon":false,"draft":true},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}