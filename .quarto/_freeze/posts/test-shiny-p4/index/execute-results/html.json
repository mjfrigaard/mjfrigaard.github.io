{
  "hash": "b192afb75b7ec9a7a016e07dc48a45d4",
  "result": {
    "markdown": "---\ntitle: \"Testing shiny apps with `shinytest2`\" \nsubtitle: \"Part 4: recording tests and snapshots\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-06-30\"\ncategories: [shiny, testing]\nimage: \"image.svg\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n\ndraft: true\n\ncode-fold: show\ncode-summary: 'show/hide'\ncode-link: false\n\nfig-align: center\n\nfontsize: '10.5'\n\ncallout-icon: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"packages\"}\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(vdiffr)\nlibrary(shinytest2)\n```\n:::\n\n\n\n\n\n\nThis is the fourth post in a [series on testing](https://mjfrigaard.github.io/series.html#testing-shiny-applications) shiny applications. My previous posts have covered [unit testing utility functions](https://mjfrigaard.github.io/posts/test-shiny-p1/) and [testing module server functions with `testServer()`](https://mjfrigaard.github.io/posts/test-shiny-p3/). In this post, I'll be covering testing shiny applications using `testthat` and `shinytest2`.\n\n::: {.column-margin}\n![](image.svg){width=70%}\n:::\n\n\n\n\n:::: {.callout-note collapse='true'}\n\n## Why `shinytest2`?\n\n::: {style='font-size: 1.10em; color: #696969;'}\n\n\n  **What happened to `shinytest`?**\n  \n  `shinytest2` replaced `shinytest` on 2022-04-27. If you've previously written tests with `shinytest`--or are curious how `shinytest2` if different--I recommend going through the [Migrating from `shinytest`](https://cran.r-project.org/web/packages/shinytest2/vignettes/z-migration.html#:~:text) vignette.\n  \n\n::: \n\n::::\n\n\n## Set up\n\n[`shinytest2`](https://rstudio.github.io/shinytest2/index.html) requires a few steps to get up and running, so I've included my start up steps below (in hopes that someone might find them useful).\n\n## Chromium\n\nFirst make sure you have [Chromium headless browser](https://www.chromium.org/chromium-projects/) installed. Chromium is the browser used to test and debug shiny apps with `shinytest2`.\n\nIf you're using macOS, you can install Chromium using [homebrew](https://formulae.brew.sh/cask/chromium): \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nbrew install --cask chromium\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"true\" code-summary=\"show/hide output\"}\n==> Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==> Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==> Installing Cask chromium\n==> Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==> Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nüç∫  chromium was successfully installed!\n```\n:::\n\n\n\n## [`chromote`]{style=\"font-size: 1.20em\"}\n\nThe [`chromote` package](https://rstudio.github.io/chromote/index.html) allows R to open Chromium. I had to make sure R knew where to find the Chromium application ([this section helps](https://rstudio.github.io/chromote/#specifying-which-browser-to-use)) by passing the path to the app to `Sys.setenv()` (*you can locate the path to Chromium using by holding <kbd>command (‚åò)</kbd> and clicking on the application icon*)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nremotes::install_github(\"rstudio/chromote\")\nlibrary(chromote)\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n```\n:::\n\n\nFind your chrome app: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nchromote::find_chrome()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[1] \"/Applications/Chromium.app/Contents/MacOS/Chromium\"\n```\n:::\n\n\nI also verified the Chromium app opened with `ChromoteSession$new()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\" code-summary=\"verify ChromoteSession$new()\"}\nb <- ChromoteSession$new()\nb$view()\n```\n:::\n\n\n\n:::: {.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![Chromium](chromium.png){#fig-chromium width=100% fig-align=\"center\"}\n\nChromium headless browser\n:::\n\n::::\n\nGreat! Going through this step means `shinytest2`'s test recorder will (*should*) deploy when I'm recording tests. \n\n## A shiny app-package\n\nI've created [`msst2ap`](https://github.com/mjfrigaard/msst2ap) (i.e., **M**astering **S**hiny **s**hiny**t**est**2** **a**pp-**p**ackage), which you can download [here](https://github.com/mjfrigaard/msst2ap/archive/refs/heads/main.zip) or install it using the following: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n```\n:::\n\n\nThe applications in `msst2ap` can be run with the their standalone app functions.\n\n---\ntitle-meta: \"Modules & apps\"\n\ncallout-icon: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n## Modules & apps \n\nThe modules in `msst2ap` are from the [Modules chapter of Mastering Shiny](https://mastering-shiny.org/scaling-modules.html), with a few minor adjustments. \n\nEach standalone app includes the output from `shiny::reactiveValuesToList()`:\n\n-   In the `ui`: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n    ```\n    :::\n    \n-   In the `server`: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # for printing reactive values in application modules\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n    ```\n    :::\n\n\n### [`dataset`]{style=\"font-size: 1.15em\"} module\n\nThe `dataset` module displays the objects in the `datasets` package in a `selectInput()` according to a filter argument (i.e., `is.data.frame`, `is.matrix`, etc.).\n\n`datasetServer()` returns the selected object as a reactive value. Read more [here](https://mastering-shiny.org/scaling-modules.html#getting-started-ui-input-server-output).\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"datasetInput() & datasetServer()\"}\ndatasetInput <- function(id, filter = NULL) {\n  names <- ls(\"package:datasets\")\n\n  if (!is.null(filter)) {\n    data <- lapply(names, get, \"package:datasets\")\n    names <- names[vapply(data, filter, logical(1))]\n  }\n\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n}\ndatasetServer <- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    shiny::reactive(get(input$dataset, \"package:datasets\"))\n  })\n}\n```\n:::\n\n#### [`datasetApp()`]{style=\"font-size: 1.10em\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"datasetApp()\"}\ndatasetApp <- function(filter = NULL) {\n  ui <- shiny::fluidPage(\n    datasetInput(\"dataset\", filter = is.data.frame),\n    shiny::tableOutput(\"data\"),\n    \n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n  )\n  server <- function(input, output, session) {\n    data <- datasetServer(\"dataset\")\n    output$data <- shiny::renderTable(head(data()))\n    \n    # for printing reactive values in application modules\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n\n  }\n  shiny::shinyApp(ui, server)\n}\n```\n:::\n\nBelow the table output in `datasetApp()`, the reactive values displays the `inputId` from `datasetInput()` and the namespace value from the shared `id` argument with `datasetServer()`: ```` $`dataset-dataset` ````\n\n\n\n:::: {.column-body-outset-right}\n\n::: {#fig-datasetApp}\n\n![`datasetApp()`](datasetApp.png){#fig-datasetApp fig-align=\"center\" width=100%}\n\n`datasetApp()` in `msst2ap`\n:::\n\n::::\n\n\n\n### [`selectVar`]{style=\"font-size: 1.15em\"} module\n\nThe `selectVar` module [selects a numeric variable](https://mastering-shiny.org/scaling-modules.html#case-study-selecting-a-numeric-variable) the `data()` object returned from `datasetServer()`.\n\nIt has a single utility function (`find_vars()`) which is used to filter the columns (variables):\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide selectVarInput() & selectVarServer()\"}\nselectVarInput <- function(id) {\n  shiny::selectInput(\n    shiny::NS(id, \"var\"),\n    label = \"Variable\",\n    choices = NULL\n  )\n}\nselectVarServer <- function(id, data, filter = is.numeric) {\n  \n  stopifnot(shiny::is.reactive(data))\n  stopifnot(!shiny::is.reactive(filter))\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n    shiny::observe({\n      shiny::updateSelectInput(\n        session, \"var\",\n        choices = find_vars(data(), filter))\n    }) |>\n      shiny::bindEvent(data())\n\n    return(\n      shiny::reactive({\n        if (input$var %in% names(data())) {\n          data()[input$var]\n        } else {\n          NULL\n        }\n      }) |>\n      shiny::bindEvent(input$var)\n    )\n\n  })\n}\n```\n:::\n\nI've made a few small changes to `selectVarServer()`: \n\n-   In the original version, `input$var` is returned as a vector: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    reactive(data()[[input$var]])\n    ```\n    :::\n    \n-   I've added some validation and return `input$var` as a single column from `data()`: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    shiny::reactive({\n        if (input$var %in% names(data())) {\n            data()[input$var]\n        } else {\n            NULL\n        }\n      }) \n    ```\n    :::\n\n-   The `find_vars()` function is also below:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide find_vars()\"}\n    find_vars <- function(data, filter = is.vector) {\n      stopifnot(is.data.frame(data))\n      stopifnot(is.function(filter))\n      names(data)[vapply(data, filter, logical(1))]\n    }\n    ```\n    :::\n\n#### [`selectVarApp()`]{style=\"font-size: 1.10em\"}\n\nThe `selectVarApp()` extends the `dataset` module by collecting the returned reactive value, passing it to `find_vars()`, and returning a single column.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide selectVarApp()\"}\nselectVarApp <- function(filter = is.numeric) {\n  ui <- shiny::fluidPage(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n            shiny::tableOutput(\"out\"),\n            shiny::verbatimTextOutput(\"vals\")\n  )\n  server <- function(input, output, session) {\n\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n  }\n\n  shiny::shinyApp(ui, server)\n}\n```\n:::\n\n:::: {.column-body-outset-right}\n\n::: {#fig-selectVarApp}\n\n![`selectVarApp()`](selectVarApp.png){#fig-selectVarApp fig-align=\"center\" width=100%}\n\n`selectVarApp()` in `msst2ap`\n:::\n\n::::\n\nThe reactive values in `selectVarApp()` are displayed below the table: \n\n:::: {layout-ncol=2}\n\n#### Variables \n\n::: {style=\"font-size: 0.80em\"}\n\n-   the 1st `var` is from the `inputId` in `selectVarInput()`\n\n    ```\n    $`-var` \n    ```\n\n-   the 2nd `var` is the shared namespace `id` from the `selectVar` module \n\n    ```\n    $`var-var` \n    ```\n\n:::\n\n#### Data\n\n::: {style=\"font-size: 0.80em\"}\n    \n-   `dataset` is from the `inputId` in `datasetInput()`\n\n    ```\n    $`-dataset`\n    ```\n    \n-   `data` is the shared namespace `id` from the `dataset` module\n\n    ```\n    $`data-dataset`\n    ```\n    \n:::\n\n::::\n\n### [`selectDataVar`]{style=\"font-size: 1.10em\"} module\n\n`selectDataVar` is from the [Modules inside of modules](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules) section, so true to form, both the `dataset` and `selectVar` modules are called inside of the UI and Server modules: \n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"selectDataVarUI() & selectDataVarServer()\"}\nselectDataVarUI <- function(id) {\n  shiny::tagList(\n    datasetInput(\n      shiny::NS(id, \"data\"), \n        filter = is.data.frame),\n    selectVarInput(\n      shiny::NS(id, \"var\"))\n  )\n}\nselectDataVarServer <- function(id, filter = is.numeric) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n    var\n\n  })\n}\n```\n:::\n\n#### [`selectDataVarApp()`]{style=\"font-size: 1.15em\"}\n\nThe `selectDataVarApp()` places the inputs in the `sidebarPanel()` and the outputs in the `mainPanel()`.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"selectDataVarApp()\"}\nselectDataVarApp <- function(filter = is.numeric) {\n  ui <- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        selectDataVarUI(\"var\")\n        ),\n      shiny::mainPanel(\n        shiny::tableOutput(\"out\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n        )\n    )\n  )\n  server <- function(input, output, session) {\n    var <- selectDataVarServer(\"var\", filter)\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n```\n:::\n\n:::: {.column-body-outset-right}\n\n::: {#fig-selectDataVarApp}\n\n![`selectDataVarApp()`](selectDataVarApp.png){#fig-selectDataVarApp fig-align=\"center\" width=100%}\n\n`selectDataVarApp()` in `msst2ap`\n:::\n\n::::\n\nThe reactive values from `selectDataVarApp()` reflect the nested module structure:\n\n:::: {layout-ncol=2}\n\n#### Variables \n\n::: {style=\"font-size: 0.80em\"}\n\n-   The first `var` belongs to the `inputId` in `selectVarInput()`, \n\n    ```\n    $`-var` \n    ```\n\n-   the 2nd `var` is the shared namespace `id` from the `selectVar` module,\n\n    ```\n    $`-var-var`\n    ```\n    \n-   the 3rd `var` is the call to the `selectVar` module *inside* `selectDataVar`\n\n    ```\n    $`var-var-var` \n    [1] \"Ozone\"\n    ```\n    \n:::\n\n#### Data\n\n::: {style=\"font-size: 0.80em\"}\n\n-   `dataset` belongs to the `inputId` in `datasetInput()`, \n\n    ```\n    $`-dataset` \n    ```\n\n-   `data` is the shared namespace `id` from the `dataset` module, \n\n    ```\n    $`-data-dataset` \n    ```\n\n-   `var` is the call to the `dataset` module *inside* `selectDataVar`\n        \n    ```\n    $`var-data-dataset` \n    [1] \"airquality\"\n    ```\n    \n:::\n\n::::\n\n\n\n### [`histogram`]{style=\"font-size: 1.10em\"} module\n\nThe final modules and application I'll use from Mastering Shiny are from the [Case study: histogram](https://mastering-shiny.org/scaling-modules.html#case-study-histogram) section. This application uses the existing `dataset` and `selectVar` modules to pass a single variable to the render a histogram:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide histogramOutput() & histogramServer()\"}\nhistogramOutput <- function(id) {\n  shiny::tagList(\n    shiny::numericInput(\n      shiny::NS(id, \"bins\"),\n      label = \"bins\",\n      value = 10,\n      min = 1,\n      step = 1\n    ),\n    shiny::plotOutput(\n      shiny::NS(id, \"hist\"))\n  )\n}\nhistogramServer <- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(shiny::is.reactive(x))\n  stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    output$hist <- shiny::renderPlot({\n        shiny::req(x())\n        main <- paste0(title(), \" [\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main\n        )\n      }, res = 96)\n\n    output$data <- shiny::renderPrint({\n      shiny::req(x())\n      print(head(x()))\n    })\n  })\n}\n```\n:::\n\nI've made some changes to the `histogramServer()` function (to accomodate the changes to the `selectVar` module). \n\n-   The original `renderPlot()` call in `histogramServer()`:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      output$hist <- renderPlot({\n        req(is.numeric(x()))\n        main <- paste0(title(), \" [\", input$bins, \"]\")\n        hist(x(), breaks = input$bins, main = main)\n      }, res = 96)\n    ```\n    :::\n\n-   The updated `renderPlot()` call in `histogramServer()`:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      output$hist <- shiny::renderPlot({\n        shiny::req(x())\n        main <- paste0(title(), \" [bins =\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main)\n      }, res = 96)\n    ```\n    :::\n    \n    -   As you can see, `req()` is verifying `x()` exists, but doesn't check it's class with `is.numeric()`. \n    \n    -   `x()` is also passed to `purrr::as_vector()` before it's plotted with `hist()`\n\n\n#### [`histogramApp()`]{style=\"font-size: 1.15em\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"histogramApp()\"}\nhistogramApp <- function() {\n  ui <- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server <- function(input, output, session) {\n    data <- datasetServer(\"data\")\n    x <- selectVarServer(\"var\", data)\n    histogramServer(\"hist\", x)\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n```\n:::\n\n:::: {.column-body-outset-right}\n\n::: {#fig-histogramApp}\n\n![`histogramApp()`](histogramApp.png){#fig-dataStrApp fig-align=\"center\" width=100%}\n\n`histogramApp()` in `msst2ap`\n:::\n\n::::\n\nThe displayed reactive values in `histogramApp()` are described below:\n\n:::: {layout-ncol=3}\n\n#### Plot\n\n::: {style=\"font-size: 0.80em\"}\n\n-   The `inputId` from `histogramOutput()` and the shared namespace `id`\n\n    ```\n    $`hist-bins`\n    [1] 10\n    ```\n    \n:::\n\n#### Variables \n\n::: {style=\"font-size: 0.80em\"}\n\n-   The `inputId` from `selectVarInput()` and the shared namespace `id`\n\n    ```\n    $`var-var`\n    [1] \"Ozone\"\n    ```\n    \n:::\n    \n#### Data\n\n::: {style=\"font-size: 0.80em\"}\n\n-   The `inputId` from `datasetInput()` and the shared namespace `id`\n\n    ```\n    $`data-dataset` \n    [1] \"airquality\"\n    ```\n    \n:::\n\n::::\n\n\n\n\n\n\n## Using [`shinytest2`]{style=\"font-size: 1.15em\"}\n\n`shinytest2` is extremely [well documentation](https://rstudio.github.io/shinytest2/index.html). I highly recommended the [Get Started vignette](https://rstudio.github.io/shinytest2/articles/shinytest2.html). In the next sections, I'll cover some examples for what I've included in the `msst2ap`.\n\nRun `shinytest2::use_shinytest2()` to create the initial files for `shinytest2`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nshinytest2::use_shinytest2()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"true\" code-summary=\"show/hide output from use_shinytest2()\"}\n! Runner already found: tests/testthat.R\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚úî Adding '*_.new.png' to '.gitignore'\n‚úî Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\n‚úî Setting active project to '/projects/apps/msst2ap'\n‚úî Adding 'shinytest2' to Suggests field in DESCRIPTION\n‚Ä¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\n‚Ä¢ Then directly refer to functions with `shinytest2::fun()`\n‚úî Setting active project to '<no active project>'\n```\n:::\n\n\n-   `use_shinytest2()` adds the `setup-shinytest2.R` script to my `tests/testthat/` folder:\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    tests/testthat/\n    ‚îú‚îÄ‚îÄ _snaps/\n    ‚îî‚îÄ‚îÄ setup-shinytest2.R\n    ```\n    :::\n\n\nThe `setup-shinytest2.R` file contains a single call to `shinytest2::load_app_env()`, which \"*Executes all `./R` files and `global.R` into the current environment*\"\n\n### Recording tests\n\nNew tests with [`shinytest2`](https://rstudio.github.io/shinytest2/index.html) can be created by launching the test event recorder, which allows us interact with our application, observe it's behavior, and record inputs, reactive values, and outputs. To record a test, run `shinytest2::record_test()`.\n\nThe first argument in `record_test()` is the path to application. If you've stored your application in an `app.R` file, `record_test()` will automatically load that application. In `msst2ap`, the application in `app.R` is the `histogramApp()`, so the test recorder will automatically open with this application if I run `record_test()` (without providing the path to a `shiny` app).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nshinytest2::record_test()\n```\n:::\n\n\n::::{.column-page-inset-right}\n\n::: {#fig-record_test_histogramApp layout-ncol=1}\n![shinytest2::record_test()](record_test_histogramApp.png){#fig-record_test_histogramApp width=100% fig-align=\"center\"}\n\n`record_test()` with application in `app.R`\n:::\n\n::::\n\nIf you have an application is stored in another location (like the `inst/dev/` folder), the you can pass the path to `record_test()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nshinytest2::record_test(app = \"\")\n```\n:::\n\n\nThis opens Chromium with our shiny app: \n\n::::{.column-page-inset-right}\n\n::: {#fig-record_test_datasetApp layout-ncol=1}\n\n![record_test(\"inst/dev/datasetApp/\") ](record_test_datasetApp.png){#fig-record_test_datasetApp width=100% fig-align=\"center\"}\n\n`record_test()` for `datasetApp()`\n:::\n\n::::\n\nThe test event recorder displays the `shiny` app, but also includes a window for recording each application 'event.' \n\n#### Expectations\n\nI'll start by recording a test for `datasetApp()`. On the right-hand side of the Chromium headless browser, you'll see the **`shinytest2` expectations** window:\n\n::::{.column-page-inset-right}\n\n::: {#fig-shinytest2-expectations layout-ncol=1}\n![`shinytest2` expectations](shinytest2-expectations.png){#fig-expectations}\n\n`shinytest2` expectations in `record_test()`\n:::\n\n::::\n\nThe initial value in the **Code** window displays the dimensions of the application in Chromium (`app$set_window_size(width = , height = )`).\n\n#### Events\n\nWhen I interact with the application (i.e., make changes to the inputs), each change is an 'event' that is recorded in the test:\n\n::::{.column-page-inset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![change inputs](shinytest2-change-inputs.png){#fig-change-values-shinytest2 width=100% fig-align=\"center\"}\n\nChanging app inputs \n:::\n\n::::\n\n#### Code \n\nAll events are recorded as code in the **Code** section of **`shinytest2` expectations**:\n\n::::{.column-page-inset-right}\n\n::: {#fig-shinytest2-code-expectations layout-ncol=1}\n\n![shinytest2 code expectations](shinytest2-expectations-code.png){#fig-shinytest2-expectations-code width=100% fig-align=\"center\"}\n\nRecorded code for each event\n:::\n\n::::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}