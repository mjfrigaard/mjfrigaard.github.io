{
  "hash": "cf7165881a6ee10d6ffd9da0acd59ed5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shiny, R packages, and R6\"\nsubtitle: \"A deep dive into using R6 in Shiny apps\"\nauthor: \"Martin Frigaard\"\ndate: \"2025-07-22\"\ncategories: [R6, Shiny]\n# image: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n# code-block-border-left: true\ncode-block-bg: \"#f8f8f8\"\ncode-block-border-left: \"#e8e8e8\"\ncode-fold: show\ncode-summary: 'show/hide'\ncallout-icon: false\n\ndraft: true\n\nfreeze: true\n\nknitr:\n  opts_chunk: \n    fig-dpi: 320\n    fig-width: 6\n    out-width: '85%'\n    fig-format: png\n    fig-align: 'center'\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [ALERT!]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.10em; color: #282b2d;'}\n\n\nThis post is currently under development--thank you for your patience.\n\n::: \n\n::::\n:::\n\n\n\nAs your Shiny application grows in complexity, organizing code in a modular and object-oriented way becomes crucial. While Shiny is inherently reactive and functional, **R6 classes** provide a powerful tool for encapsulating state, behavior, and logic — particularly useful in large-scale apps or when designing reusable components inside an R package.\n\nIn this post, we’ll explore:\n\n* What R6 is and why it's useful in Shiny\n* How to define and use R6 classes in a Shiny app-package\n* Best practices for integrating R6 with reactivity\n* A practical example within a package structure\n\n## What is R6?\n\nR6 is an object-oriented system in R that enables the creation of **reference-based** objects. Unlike S3 or S4 objects, R6 objects maintain state and support encapsulation, inheritance, and private/public members — much like objects in other OOP languages (e.g., Python, Java).\n\nThis makes R6 especially useful for:\n\n* Managing mutable state (e.g., counters, user sessions)\n* Bundling business logic with data\n* Reusing logic across modules or apps\n\nIn an app packaged as an R package, R6 classes help you separate concerns and avoid global state.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages('R6')\nlibrary(R6)\n```\n:::\n\n\n### Defining an R6 Class\n\nYou define R6 classes using the `R6` package. Here's a simple example of an R6 class for a counter:\n\n```r\n# In R/counter.R\nCounter <- R6::R6Class(\n  \"Counter\",\n  public = list(\n    value = 0,\n    initialize = function(start = 0) {\n      self$value <- start\n    },\n    increment = function() {\n      self$value <- self$value + 1\n    },\n    reset = function() {\n      self$value <- 0\n    },\n    get = function() {\n      self$value\n    }\n  )\n)\n```\n\nPlace this class definition inside your `R/` directory so it is loaded with the rest of your package code.\n\n### Using R6 in the Shiny Server Function\n\nTo use the class in your app, instantiate it inside the `server` function and wrap its methods in `reactive` or `observe` blocks where needed:\n\n```r\n# In inst/app/server.R\n\nserver <- function(input, output, session) {\n  counter <- Counter$new()\n\n  observeEvent(input$increment_btn, {\n    counter$increment()\n  })\n\n  observeEvent(input$reset_btn, {\n    counter$reset()\n  })\n\n  output$counter_text <- renderText({\n    paste(\"Current count:\", counter$get())\n  })\n}\n```\n\nAnd in the UI:\n\n```r\n# In inst/app/ui.R\n\nui <- fluidPage(\n  actionButton(\"increment_btn\", \"Increment\"),\n  actionButton(\"reset_btn\", \"Reset\"),\n  textOutput(\"counter_text\")\n)\n```\n\n---\n\n## Reactivity and R6\n\nR6 objects aren't inherently reactive. If you want your app to respond to changes in an R6 object's state, you need to wrap getters in reactive expressions or use `reactiveVal`/`reactiveValues` internally.\n\n## Strategy 1: Wrap method calls in `render*` functions\n\nThis is the simplest method, shown above with `renderText()`.\n\n## Strategy 2: Use reactive triggers\n\nYou can also use `reactiveVal` to track state and trigger UI updates:\n\n```r\nserver <- function(input, output, session) {\n  counter <- Counter$new()\n  trigger <- reactiveVal(0)\n\n  observeEvent(input$increment_btn, {\n    counter$increment()\n    trigger(trigger() + 1)\n  })\n\n  output$counter_text <- renderText({\n    trigger()\n    paste(\"Current count:\", counter$get())\n  })\n}\n```\n\n## Organizing R6 Classes in a Package\n\nTo integrate smoothly with your app-package:\n\n* Place class definitions in `R/` with clear, modular file names (e.g., `R/counter.R`)\n* Use `@export` roxygen tags if you want to make classes available to users\n* Test classes with `testthat` as you would with functions\n* Avoid instantiating R6 objects at the package level (e.g., outside of functions); do so inside `server()` or module server functions\n\n\n## Example: Session-Aware Logger\n\nSuppose we want an R6 class that logs user actions with session tracking:\n\n```r\n# In R/logger.R\nLogger <- R6::R6Class(\"Logger\",\n  public = list(\n    session_id = NULL,\n    logs = character(),\n    \n    initialize = function(session_id) {\n      self$session_id <- session_id\n    },\n    \n    log = function(message) {\n      timestamp <- format(Sys.time(), \"%Y-%m-%d %H:%M:%S\")\n      entry <- paste0(\"[\", self$session_id, \" @ \", timestamp, \"] \", message)\n      self$logs <- c(self$logs, entry)\n    },\n    \n    get_logs = function() {\n      self$logs\n    }\n  )\n)\n```\n\nIn the server:\n\n```r\nserver <- function(input, output, session) {\n  logger <- Logger$new(session$token)\n\n  observeEvent(input$do_something, {\n    logger$log(\"Button clicked\")\n  })\n\n  output$log_output <- renderPrint({\n    logger$get_logs()\n  })\n}\n```\n\n\n\n## Recap\n\nUsing R6 in Shiny app-packages gives you a scalable, maintainable approach to organizing business logic and managing state. It shines when:\n\n* You want object-oriented abstractions\n* You need mutable objects tied to user sessions\n* You're building reusable modules within or across apps\n\nWhile not every Shiny app needs R6, mastering this tool adds a robust pattern to your Shiny developer toolkit — particularly when packaging your app for production or distribution.\n\n\n\nIn the next chapter, we'll explore how to use **Shiny modules** in combination with R6 objects to further encapsulate functionality within your package structure.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}