{
  "hash": "27f1ac5127fea6f0d38f523764e296b3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Python Apps\" \nsubtitle: \"Launching Python Applications from VS Code\"\nauthor: \"Martin Frigaard\"\ndate: \"2024-07-13\"\ncategories: [python, vscode]\nimage: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n# code-block-border-left: true\ncode-block-bg: \"#f8f8f8\"\ncode-block-border-left: \"#e8e8e8\"\ncode-fold: show\ncode-summary: 'show/hide'\ncallout-icon: false\ndraft: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n\n---\n\n\n\n\n:::: {.callout-note collapse='false' appearance='simple' icon=false}\n\n## [Note]{style='font-weight: bold; font-size: 1.10em;'}\n\n::: {style='font-size: 1.05em; color: #282b2d;'}\n\n\nThis is the second post on working in VS Code with Python. I'll cover developing and publishing Python applications using Bokeh, Streamlit, and Dash.\n\n::: \n\n::::\n\n\n\nI've been demoing quite a few Python applications with VS Code lately and thought I'd write some notes and observations on running and deploying the three popular libraries: [Bokeh](https://docs.bokeh.org/en/latest/), [Streamlit](https://docs.streamlit.io/), and [Dash](https://dash.plotly.com/).\n\n## Virtual environments \n\nPython virtual environments are designed to manage project-specific dependencies and ensure that the correct versions of packages are used in a given project. Similar to the renv package in R, Python comes with a a `venv` command for creating a virtual environment.[^venv] It's common practice to name the virtual environment something like `myenv` or `.venv`. \n\n``` sh\npython -m venv .venv\n```\n\n`venv` works by creating a directory with a copy of the Python interpreter and the necessary executables to use it. After creating the virtual environment folder, we can activate it using the following command: \n\n``` sh\nsource .venv/bin/activate\n# windows\n# myenv\\Scripts\\activate\n```\n\n[^venv]: `venv` is a module that comes built-in with [Python 3.3 and later versions](https://docs.python.org/3/library/venv.html), so we do not need to install it separately.\n\nIf you're using VS Code, this activate the following prompt to set your workspace folder: \n\n![Workspace folder](img/venv_vs_code.png){fig-align='center' width='90%'}\n\nClick **Yes**, then make sure all the dependencies listed in the requirements.txt file are installed in the virtual environment using [`pip`](https://pypi.org/project/pip/), the package installer for Python.\n\n``` sh\npip install -r requirements.txt\n```\n\nAs you're developing, new dependencies can be recorded in `requirements.txt` using `pip freeze`:\n\n``` sh\npip freeze > requirements.txt\n```\n\n### Git history\n\nThe virtual environment will store all the dependencies for a project, so it's a good practice to remove it from any Git repositories. You can do this with the following commands in the terminal: \n\n``` sh\necho \".venv/\" >> .gitignore\ngit add .gitignore\ngit commit -m \"Add .venv to .gitignore\"\n```\n\nYou can also remove the `.venv` directory from the latest commit:\n\n``` sh\ngit rm -r --cached .venv\ngit commit -m \"Remove .venv directory\"\n```\n\n\n\n\n\n\n\n:::: {.callout-tip collapse='true' appearance='simple' icon=false}\n\n## [Using `venv`]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.10em; color: #282b2d;'}\n\n\n\n`venv` allows us to manage dependencies more effectively, ensuring a clean and isolated environment for each Python app project.\n\n```sh\n# create a virtual environment\npython -m venv .venv\n\n# activate the virtual environment on macOS/Linux\nsource .venv/bin/activate  \n\n# install necessary packages\npip install dash streamlit bokeh\n\n# save your current environment's packages\npip freeze > requirements.txt\n\n# install the packages in a new environment\npip install -r requirements.txt\n\n# deactivate the virtual environment when done\ndeactivate\n```\n\n\n\n::: \n\n::::\n\n\n\n\n\n[Bokeh](https://docs.bokeh.org/en/latest/), [Streamlit](https://docs.streamlit.io/), and [Dash](https://dash.plotly.com/) are three popular libraries for creating interactive Python applications, particularly for visualizations and dashboards. Below we'll explore building an application in each framework using the [`palmerpenuins` data](https://allisonhorst.github.io/palmerpenguins/). For uniformity, each app will include a scatter plot comparing the numeric variables and a table output.\n\n## Bokeh\n\n::: {.column-margin}\n![](img/bokeh.png){width=40%}\n:::\n\n[Bokeh](https://docs.bokeh.org/en/latest/) is a library in Python specifically designed for creating interactive and visually appealing interactive graphs and charts. Bokeh can also create static HTML files without a server, similar to RMarkdown's HTML output.\n\n### Importing Libraries\n\nCreate a main.py script and install the following libraries using `pip`. `pandas` is for data manipulation, `bokeh` will be used for the interactive visualizations, and the `palmerpenguins` package will load the `penguins` dataset.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nimport pandas as pd\nfrom bokeh.layouts import column, row\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn, NumberFormatter, Select\nfrom bokeh.plotting import figure, curdoc\nfrom palmerpenguins import load_penguins\n```\n:::\n\n\n\nSimilar to R, where you might use `library(dplyr)` for data manipulation and `library(ggplot2)` for visualizations. For interactive visualizations, you might use `library(shiny)`.\n\n\n\n\n:::: {.callout-tip collapse='true' appearance='simple' icon=false}\n\n## [**Python vs. R**: Key Differences When Importing Libraries]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.10em; color: #282b2d;'}\n\n\n\n<br>\n\n**Library Import Syntax**\n\n\nPython emphasizes explicit control over imports and namespaces:\n\n- Python uses the `import` statement  \n  - `import package_name`\n- Aliases are often used to shorten package names  \n  - `import package_name as alias`\n- Python uses `from` to import specific functions or classes\n  - `from package_name import specific_function`\n\nR uses the `library()` or `require()` function to import packages. R loads the entire package into the namespace by default. If you have functions with the same name in different packages, you can specify the package explicitly with `package::function()`.\n\n\n\n::: \n\n::::\n\n\n\n### Loading Data\n\nThe `penguins` dataset is loaded into a `pandas` `DataFrame` using the `load_penguins()` function and the missing data is removed.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\ndf = load_penguins()\ndf = df.dropna()\n```\n:::\n\n\n\nA `ColumnDataSource` is created from the `DataFrame`, which is used by Bokeh for efficient data handling. This intermediate step doesn't really have an R equivalent.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nsource = ColumnDataSource(df)\n```\n:::\n\n\n\nA list of numeric columns is defined for use in the scatter plot. To define columns of interest in R we could use `colnames()` or `dplyr::select()`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nnumeric_columns = ['bill_length_mm', 'bill_depth_mm', 'flipper_length_mm', 'body_mass_g']\n```\n:::\n\n\n\n### App Inputs\n\nTwo dropdown widgets are created for selecting x and y axes variables. If this was a Shiny app, we would use `selectInput()`.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nx_select = Select(title=\"X Axis\", value=\"bill_length_mm\", options=numeric_columns)\ny_select = Select(title=\"Y Axis\", value=\"bill_depth_mm\", options=numeric_columns)\n```\n:::\n\n\n\n### Scatter Plot \n\nThe scatter plot is created initialized with default axis labels and data.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nscatter_plot = figure(title=\"Scatter Plot\",\n                      x_axis_label='Bill Length (mm)',\n                      y_axis_label='Bill Depth (mm)')\nscatter_plot.scatter(x='bill_length_mm', y='bill_depth_mm', source=source, size=10)\n```\n:::\n\n\n\nIn `ggplot2`, this would look like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide ggplot2 equivalent code\"}\nggplot(df, \n  aes(x = bill_length_mm, y = bill_depth_mm)) + \n  geom_point()\n```\n:::\n\n\n\n### Interactivity\n\nBelow we define a function that updates the scatter plot when a new variable is selected for the x or y axis. It changes axis labels and re-renders the plot with new data. In `shiny`, you would use `observeEvent()` or `reactive()` to update plots dynamically.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\ndef update_plot(attr, old, new):\n    x = x_select.value\n    y = y_select.value\n    scatter_plot.xaxis.axis_label = x.replace('_', ' ').title()\n    scatter_plot.yaxis.axis_label = y.replace('_', ' ').title()\n    scatter_plot.renderers = []  # clear existing renderers\n    scatter_plot.scatter(x=x, y=y, source=source, size=10)\n\nx_select.on_change(\"value\", update_plot)\ny_select.on_change(\"value\", update_plot)\n```\n:::\n\n\n\n### Table Display\n\nThe code below defines columns and their formatters for the data table to be displayed. `DataTable()` creates `data_table` a DataTable widget that displays the data. This is similar to using `DT::datatable(df)` in R.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\ncolumns = [\n    TableColumn(field=\"species\", title=\"Species\"),\n    TableColumn(field=\"island\", title=\"Island\"),\n    TableColumn(field=\"bill_length_mm\", title=\"Bill Length (mm)\", formatter=NumberFormatter(format=\"0.0\")),\n    TableColumn(field=\"bill_depth_mm\", title=\"Bill Depth (mm)\", formatter=NumberFormatter(format=\"0.0\")),\n    TableColumn(field=\"flipper_length_mm\", title=\"Flipper Length (mm)\", formatter=NumberFormatter(format=\"0\")),\n    TableColumn(field=\"body_mass_g\", title=\"Body Mass (g)\", formatter=NumberFormatter(format=\"0\")),\n    TableColumn(field=\"sex\", title=\"Sex\"),\n    TableColumn(field=\"year\", title=\"Year\", formatter=NumberFormatter(format=\"0\"))\n]\n\ndata_table = DataTable(source=source, columns=columns, width=800)\n```\n:::\n\n\n\n### Layout \n\nThe layout is defined and added to the current document for rendering. In `shiny`, you would use `fluidPage()`, `sidebarLayout()`, `mainPanel()`, etc., to arrange UI components.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nlayout = column(row(x_select, y_select), scatter_plot, data_table)\ncurdoc().add_root(layout)\n```\n:::\n\n\n\n### Run the App\n\nTo run this code, save `main.py` and use the `bokeh serve` command:\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nbokeh serve --show main.py\n```\n:::\n\n\n\nIn R, you would run a `shiny` app using `shinyApp(ui, server)` and the `runApp()` function.\n\nThe full code in `main.py` is available below: \n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show/hide main.py\" code-line-numbers=\"true\"}\nimport pandas as pd\nfrom bokeh.layouts import column, row\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn, NumberFormatter, Select\nfrom bokeh.plotting import figure, curdoc\nfrom palmerpenguins import load_penguins\n\n# load the penguins dataset\ndf = load_penguins()\n\n# drop missing data \ndf = df.dropna()\n\n# create ColumnDataSource\nsource = ColumnDataSource(df)\n\n# numeric columns\nnumeric_columns = ['bill_length_mm', 'bill_depth_mm', 'flipper_length_mm', 'body_mass_g']\n\n# create select widgets for x and y axis\nx_select = Select(title=\"X Axis\", value=\"bill_length_mm\", options=numeric_columns)\ny_select = Select(title=\"Y Axis\", value=\"bill_depth_mm\", options=numeric_columns)\n\n# scatter plot comparing selected variables\nscatter_plot = figure(title=\"Scatter Plot\",\n                      x_axis_label='Bill Length (mm)',\n                      y_axis_label='Bill Depth (mm)')\n\nscatter_plot.scatter(x='bill_length_mm', y='bill_depth_mm', source=source, size=10)\n\ndef update_plot(attr, old, new):\n    x = x_select.value\n    y = y_select.value\n    scatter_plot.xaxis.axis_label = x.replace('_', ' ').title()\n    scatter_plot.yaxis.axis_label = y.replace('_', ' ').title()\n    scatter_plot.renderers = []  # Clear existing renderers\n    scatter_plot.scatter(x=x, y=y, source=source, size=10)\n\nx_select.on_change(\"value\", update_plot)\ny_select.on_change(\"value\", update_plot)\n\n# define columns \ncolumns = [\n    TableColumn(field=\"species\", title=\"Species\"),\n    TableColumn(field=\"island\", title=\"Island\"),\n    TableColumn(field=\"bill_length_mm\", title=\"Bill Length (mm)\", formatter=NumberFormatter(format=\"0.0\")),\n    TableColumn(field=\"bill_depth_mm\", title=\"Bill Depth (mm)\", formatter=NumberFormatter(format=\"0.0\")),\n    TableColumn(field=\"flipper_length_mm\", title=\"Flipper Length (mm)\", formatter=NumberFormatter(format=\"0\")),\n    TableColumn(field=\"body_mass_g\", title=\"Body Mass (g)\", formatter=NumberFormatter(format=\"0\")),\n    TableColumn(field=\"sex\", title=\"Sex\"),\n    TableColumn(field=\"year\", title=\"Year\", formatter=NumberFormatter(format=\"0\"))\n]\n\n# create DataTable\ndata_table = DataTable(source=source, columns=columns, width=800)\n\n# Layout\nlayout = column(row(x_select, y_select), scatter_plot, data_table)\n\n# add layout to curdoc\ncurdoc().add_root(layout)\n```\n:::\n\n\n\n</details>\n\nAfter running the `bokeh serve` command, the terminal will display the local URL we can use to view our app: \n\n```sh\nStarting Bokeh server version 3.4.2 (running on Tornado 6.4)\nUser authentication hooks NOT provided (default user enabled)\nBokeh app running at: http://localhost:5006/main\nStarting Bokeh server with process id: 88167\nWebSocket connection opened\nServerConnection created\n```\n\n![Bokeh Python App](img/bokeh_penguins_app.png){width=100% fig-align='center'}\n\n\nAs we can see, the layout is simple, and it gets the job done quickly with a modest amount of code. Bokeh is not really designed for full-fledged applications, but it *is* capable of creating detailed and interactive plots and tables.\n\n## Streamlit\n\n::: {.column-margin}\n![](img/streamlit.png){width=40%}\n:::\n\n\n[Streamlit](https://docs.streamlit.io/) is another library for creating web applications for data analysis and visualization. It’s known for its simplicity and generally requires less code to build functional applications.\n\n### Importing Libraries \n\nAfter creating and activating a Python virtual environment with `venv`, ensure you have `streamlit`, `palmerpenguins`, and the other necessary libraries installed using `pip`. Create an `app.py` file and import the following libraries:\n \n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nimport streamlit as st\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n```\n:::\n\n\n\n### Loading Data\n\nLoad the `penguins` data as a `pandas` `DataFrame` using the `load_penguins()` function from the `palmerpenguins`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\n# load the dataset\npenguins = load_penguins()\n```\n:::\n\n\n\n### App Inputs\n\nThe code below creates a streamlit application that includes a scatter plot with a dropdown menu for selecting the X-axis and Y-axis variables among the numeric columns (minus `year`). The scatter plot differentiates the species by color. \n\n  - `st.title` sets the title of the app.\n  \n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n    st.title('Palmer Penguins Dashboard')\n    ```\n    :::\n\n\n  \n  - `st.write` displays text and the datase.t[^st-write]\n  \n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n    st.write(\"### Scatter Plot\")\n    ```\n    :::\n\n\n  \n  - `st.selectbox` creates dropdown menus for selecting variables for the scatter plot.\n  \n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n    x_axis = st.selectbox('X-axis variable', numeric_columns)\n    ```\n    :::\n\n\n  \n[^st-write]: [`st.write()`](https://docs.streamlit.io/develop/api-reference/write-magic/st.write) is incredibly versatile. We're passing it Markdown-formatted text in this example, but it can be used to display DataFrames, models, and more.\n\n### Scatter Plot\n\nThe scatter plot is created using `seaborn`, a visualization library built on top of `matplotlib`.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nif x_axis and y_axis:\n    fig, ax = plt.subplots()\n    sns.scatterplot(data=penguins, x=x_axis, y=y_axis, hue='species', ax=ax)\n    st.pyplot(fig)\n```\n:::\n\n\n\n### Table Display\n\nThe `st.dataframe` method displays the dataset in a table format within the `streamlit` app.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nst.dataframe(penguins)\n```\n:::\n\n\n:::: {.callout-tip collapse='true' appearance='simple' icon=false}\n\n## [**Python vs. R**: Key Syntax Differences]{style='font-weight: bold; font-size: 1.15em;'}\n\n::: {style='font-size: 1.10em; color: #282b2d;'}\n\n\n\n\n<br>\n\n**Assignment Operators**\n\n- Python uses `=` for assignment.  \n- R typically uses `<-` for assignment, although `=` can also be used.\n\n**Function Calls**\n\n- Python calls `st.selectbox()` where `st` is an alias for `streamlit`.  \n- R can call `selectInput()` after loading the `shiny` library, although `shiny::selectInput()` can be used (if `shiny` is installed).\n\n**Data Structures**\n\n   - In Python, the data is read into a `pandas DataFrame`.  \n   - In R, the data is read into a `tibble`, which is part of the `tidyverse` and is a modern reimagining of the traditional data frame.\n\n\n::: \n\n::::\n\n\n\nThe full application code is available below: \n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show/hide app.py\" code-line-numbers=\"true\"}\n# app title\nst.title('Palmer Penguins Dashboard')\n\n# numeric columns for scatter plot\nnumeric_columns = penguins.select_dtypes(include=['float64', 'int64']).columns\n# drop year\nnumeric_columns = numeric_columns.drop('year')\n\n# scatter plot\nst.write(\"### Scatter Plot\")\nx_axis = st.selectbox('X-axis variable', numeric_columns)\ny_axis = st.selectbox('Y-axis variable', numeric_columns, index=1)\n\nif x_axis and y_axis:\n    fig, ax = plt.subplots()\n    sns.scatterplot(data=penguins, x=x_axis, y=y_axis, hue='species', ax=ax)\n    st.pyplot(fig)\n\n# display the dataframe as a table\nst.write(\"### Dataset\")\nst.dataframe(penguins)\n\n# footer\nst.write(\"Data Source: [palmerpenguins](https://github.com/allisonhorst/palmerpenguins)\")\n```\n:::\n\n\n\n\n### Run the App\n\n Open your terminal, navigate to the directory containing `app.py`, and run:\n \n ```sh\n streamlit run app.py\n ```\n \n![Streamlit Python App](img/streamlit_penguins_app.png){fig-align='center' width='100%'}\n\nWith streamlit we're able to create an interactive graph and table display with about 1/3 the code we used in Bokeh, which is why they are ideal for quickly building and sharing simpler web apps (similar to flexdashboard in R). However, Streamlit apps have limited customization and may not handle very complex apps or large datasets efficiently.\n\n## Dash\n\n::: {.column-margin}\n![](img/dash.png){width=40%}\n:::\n\n[Dash](https://dash.plotly.com/) is a framework developed by Plotly for building analytical web applications using Python. It’s especially well-suited for interactive visualizations and dashboards.\n\n### Importing Libraries \n\nIn an `app.py` file, we'll start by importing the following necessary libraries. `dash` and `dash.dependencies` [^dash-depends] are used for building web applications (similar to `shiny`), `pandas` is imported for data manipulation, `plotly.express` is used for creating plots (akin to `ggplot2`), and `dash_bootstrap_components` allows us to use Bootstrap themes for styling the app.\n\n[^dash-depends]: Watch [The Dash Callback - Input, Output, State, and more](https://youtu.be/mTsZL-VmRVE?si=C6mkTzQYAI0FlCRJ) on the [Charming Data YouTube channel](https://www.youtube.com/@CharmingData).\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nimport dash\nfrom dash import dcc, html, dash_table\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nimport plotly.express as px\nimport dash_bootstrap_components as dbc\n```\n:::\n\n\n\n\n### Loading Data\n\nNow that we've identified and imported the dependencies, we can read the data into the application using `pandas`. We can assign the URL to the raw `.csv` file to `url`, then have `pd.read_csv()` read the CSV file into a `pandas` DataFrame.[^pd_read_csv]\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nurl = \"https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv\"\ndf = pd.read_csv(url)\n```\n:::\n\n\n\n[^pd_read_csv]: `pd.read_csv` is analogous to `read.csv` or `readr::read_csv` in R.\n\n### Utility Function\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\ndef format_label(label):\n    return label.replace('_', ' ').title()\n```\n:::\n\n\n\nThis function replaces underscores with spaces and capitalizes words. In R, you would define a similar function using `gsub()` and `tools::toTitleCase()`.\n\n### Define Columns\n\nWe want to omit the `year` column from the drop-dowwns, so we'll define `numerical_columns` outside of the app so we don't have to repeat this code later. Type `float64` or `int64` are numeric columns.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nnumerical_columns = [col for col in df.select_dtypes(include=['float64', 'int64']).columns if col != 'year']\n```\n:::\n\n\n\n### Initialize App\n\n`dash.Dash` creates a Dash app instance with Bootstrap styling by supplying `dbc.themes.BOOTSTRAP` to the `external_stylesheets` argument.[^dash-dash] This is somewhat similar to initializing a Shiny app with `shiny::shinyApp()`.\n\n[^dash-dash]: Read all the arguments for dash.Dash in the [documentation.](https://dash.plotly.com/reference#dash.dash)\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\napp = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n```\n:::\n\n\n\nIn the case of initializing a Dash app, `__name__` is passed as an argument to the `dash.Dash()` constructor to specify the `name` of the application. We'll encounter this again when we launch the application below.\n\n### Layout\n\nThe majority of the code is contributed to defining the app layout using Bootstrap components.\n\n-   `dbc.Container`, `dbc.Row`, and `dbc.Col` arrange components in a grid, similar to layout functions in Shiny like `fluidPage()`, `sidebarLayout()`, etc.\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n    app.layout = dbc.Container([\n        dbc.Row([\n            dbc.Col([\n            \n            ])\n        ])\n    ])\n    ```\n    :::\n\n\n   \n-   `html.H1` creates a header, like `tags$h1()` in Shiny.\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n      html.H1(\"Palmer Penguins Dashboard\")\n    ```\n    :::\n\n\n\n-   `dcc.Dropdown` creates dropdown menus for user input, similar to `selectInput()` in Shiny.\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n      dcc.Dropdown(\n          id='x-axis',\n          options=[{'label': col, 'value': col} for col in numerical_columns],\n          value='bill_length_mm',\n          clearable=False\n      )\n    ```\n    :::\n\n\n\n-   `dcc.Graph` places a plot in the app, analogous to `plotOutput()` in Shiny.\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n      dcc.Graph(id='scatter-plot')\n    ```\n    :::\n\n\n\n-   `dash_table.DataTable` displays data in a table, similar to `DT::dataTableOutput()` in R.\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n      dash_table.DataTable(\n          id='table',\n          columns=[{\"name\": i, \"id\": i} for i in df.columns],\n          data=df.to_dict('records'),\n          page_size=10,\n          style_table={'overflowX': 'auto'},\n          style_cell={\n              'height': 'auto',\n              'minWidth': '140px', 'width': '140px', 'maxWidth': '140px',\n              'whiteSpace': 'normal'\n          }\n      )\n    ```\n    :::\n\n\n\n### Callback \n\nThe **callback function** updates the scatter plot based on dropdown inputs.\n   \n-   The `@app.callback` decorator defines reactive behavior, similar to `observeEvent()` or `reactive()` in Shiny.[^dash-callbacks]\n\n[^dash-callbacks]: Read more about Dash callback definitions in the [documentation](https://dash.plotly.com/basic-callbacks).\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n      @app.callback(\n          Output('scatter-plot', 'figure'),\n          [Input('x-axis', 'value'),\n           Input('y-axis', 'value')]\n      )\n    ```\n    :::\n\n\n\n-   The function `update_scatter_plot` takes inputs from dropdowns and updates the plot, using `plotly.express` and our `format_label()` utility function to create the scatter plot, similar to using `ggplot2` in R.\n\n\n\n    ::: {.cell}\n    \n    ```{.python .cell-code  code-fold=\"false\"}\n      def update_scatter_plot(x_axis, y_axis):\n          fig = px.scatter(\n              df, x=x_axis, y=y_axis, color='species',\n              labels={x_axis: format_label(x_axis), y_axis: format_label(y_axis)},\n              title=f'Scatter Plot of {format_label(x_axis)} vs {format_label(y_axis)}'\n          )\n          return fig\n    ```\n    :::\n\n\n\n\nThe full callback code is below: \n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show/hide app callback in app.py\"}\n@app.callback(\n    Output('scatter-plot', 'figure'),\n    [Input('x-axis', 'value'),\n     Input('y-axis', 'value')]\n)\ndef update_scatter_plot(x_axis, y_axis):\n    fig = px.scatter(\n        df, x=x_axis, y=y_axis, color='species',\n        labels={x_axis: format_label(x_axis), y_axis: format_label(y_axis)},\n        title=f'Scatter Plot of {format_label(x_axis)} vs {format_label(y_axis)}'\n    )\n    return fig\n```\n:::\n\n\n\n### For loops\n\nPython often relies on explicit iteration using for loops, which means Python code tends to use for loops more frequently than R code. The reason for this goes beyond the scope of this blog post, but it's rooted in the distinct practices and strengths of each language. \n\nComing from R (and `purrr` or the `apply` family of functions), writing `for` loops can take some getting used to, so I've broken down the `numerical_columns` and `dcc.Dropdown()` examples from our Dash app. \n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nnumerical_columns = [col for col in df.select_dtypes(include=['float64', 'int64']).columns if col != 'year']\n```\n:::\n\n\n\n1. `[col for col in ...]` is a list comprehension--it iterates over each column name (`col`) in the filtered list of column names.\n\n2. `df` is a DataFrame, and `select_dtypes` is a method that filters the DataFrame columns based on their data types. It includes columns with data types `float64` and `int64` (similar to numeric types in R).\n\n3. `.columns` retrieves the names of the columns that have been filtered by `select_dtypes`.\n\n4. `if col != 'year'` is the condition to ensure that the column `year` is excluded from the resulting list, even if it has a numeric type.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\noptions=[{'label': col, 'value': col} for col in numerical_columns]\n```\n:::\n\n\n\nThis `for` loop iterates over each column name (`col`) in the `numerical_columns` list.\n\n1. For each column name, it creates a dictionary (`{'label': col, 'value': col}`). \n\n2. `label` is the text displayed in the Dropdown, and `value` is the actual value assigned to this option.\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\ncolumns=[{\"name\": i, \"id\": i} for i in df.columns]\n```\n:::\n\n\n\nThis `for` loop iterates over all columns of the DataFrame `df`. \n\n1. For each column, it creates a dictionary with `name` and `id` both set to the column name. \n\n2. These dictionaries are used to define the columns of the `dash_table.DataTable()`.\n\nThe entire app layout code is below:\n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"show/hide full Dash app in app.py\" code-line-numbers=\"true\"}\nimport dash\nfrom dash import dcc, html, dash_table\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nimport plotly.express as px\nimport dash_bootstrap_components as dbc\n\n# load the dataset\nurl = \"https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv\"\ndf = pd.read_csv(url)\n\n# remove the 'year' column \nnumerical_columns = [col for col in df.select_dtypes(include=['float64', 'int64']).columns if col != 'year']\n\n# initialize the Dash app\napp = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n\n# function to replace underscores with spaces\ndef format_label(label):\n    return label.replace('_', ' ').title()\n\n# app layout\napp.layout = dbc.Container([\n    dbc.Row(\n        dbc.Col(\n            html.H1(\"Palmer Penguins Dashboard\"), \n        width=12)\n    ),\n    dbc.Row(\n        html.H3(\"Inputs\")\n    ),\n    dbc.Row([\n        dbc.Col(\n            dcc.Dropdown(\n                id='x-axis',\n                options=[{'label': col, 'value': col} for col in numerical_columns],\n                value='bill_length_mm',\n                clearable=False\n            ), width=3\n        ),\n        dbc.Col(\n            dcc.Dropdown(\n                id='y-axis',\n                options=[{'label': col, 'value': col} for col in numerical_columns],\n                value='bill_depth_mm',\n                clearable=False\n            ), width=3\n        )\n    ]),\n    dbc.Row([\n        dbc.Col([\n            html.H3(\"Scatter Plot\"),\n            dcc.Graph(id='scatter-plot')\n        ], width=6),\n        dbc.Col([\n            html.H3(\"Table\"),\n            dash_table.DataTable(\n                id='table',\n                columns=[{\"name\": i, \"id\": i} for i in df.columns],\n                data=df.to_dict('records'),\n                page_size=10,\n                style_table={'overflowX': 'auto'},\n                style_cell={\n                    'height': 'auto',\n                    'minWidth': '140px', 'width': '140px', 'maxWidth': '140px',\n                    'whiteSpace': 'normal'\n                }\n            )\n        ], width=6)\n    ])\n])\n\n# callback to update the scatter plot\n@app.callback(\n    Output('scatter-plot', 'figure'),\n    [Input('x-axis', 'value'),\n     Input('y-axis', 'value')]\n)\ndef update_scatter_plot(x_axis, y_axis):\n    fig = px.scatter(\n        df, x=x_axis, y=y_axis, color='species',\n        labels={x_axis: format_label(x_axis), y_axis: format_label(y_axis)},\n        title=f'Scatter Plot of {format_label(x_axis)} vs {format_label(y_axis)}'\n    )\n    return fig\n\n# run the app\nif __name__ == '__main__':\n    app.run_server(debug=True)\n```\n:::\n\n\n\n### Run the App\n\nThe code below runs the application. Note that the `__name__ == '__main__'` condition corresponds to the `dash.Dash(__name__, ...)` we used to initialize the application above. \n\n\n\n::: {.cell}\n\n```{.python .cell-code  code-fold=\"false\"}\nif __name__ == '__main__':\n    app.run_server(debug=True)\n```\n:::\n\n\n\nRun the application by running the following commands in the terminal: \n\n``` sh\npython app.py\n```\n\n``` sh\nDash is running on http://127.0.0.1:8050/\n\n * Serving Flask app 'app'\n * Debug mode: on\n```\n\nUse <kbd>Cmd</kbd>/<kbd>Ctrl</kbd> + click on the URL to open the web browser with our application:\n\n![Penguins Dash App](img/dash_penguins_app.png){fig-align='center' width='100%'}\n\nThe Dash application has an interactive scatter plot (with hover features) with a side-by-side table display. The layout functions in Dash give us more control over output placement in the UI, and the additional HTML functions give us the ability to build our application up like a standard webpage (or Shiny app).\n\n## Recap \n\nIn summary, [Bokeh]() is excellent for creating detailed and interactive visualizations, comparable to `ggplot2` and `plotly` for interactive plots, but it's not focused on developing complete applications. [Streamlit]() is very user-friendly and ideal for quickly building and sharing simpler web apps, but with fewer options for customization. [Dash]() is capable of developing highly customizable and complex web applications (similar to Shiny), but has a steeper learning curve than Streamlit.\n\nYou can view the code used to create the apps in this [repo.](https://github.com/mjfrigaard/py-apps/tree/main)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}