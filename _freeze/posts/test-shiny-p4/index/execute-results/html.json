{
  "hash": "52cf846697c0dbad3da8109d12d9f459",
  "result": {
    "markdown": "---\ntitle: \"Testing shiny apps with `shinytest2`\" \nsubtitle: \"Part 4: recording tests and snapshots\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-07-04\"\ncategories: [shiny, testing]\nimage: \"image.svg\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n# code-block-border-left: true\ncode-block-bg: \"#f8f8f8\"\ncode-block-border-left: \"#e8e8e8\"\ncode-fold: show\ncode-summary: 'show/hide'\ncallout-icon: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"packages\"}\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\n```\n:::\n\n\n\n\n\nThis is the fourth post in a [series on testing](https://mjfrigaard.github.io/series.html#testing-shiny-applications) shiny applications. My previous posts have covered [unit testing utility functions](https://mjfrigaard.github.io/posts/test-shiny-p1/) and [testing module server functions with `testServer()`](https://mjfrigaard.github.io/posts/test-shiny-p3/). In this post, I'll be covering testing shiny applications using `testthat` and `shinytest2`.\n\n::: {.column-margin}\n![](image.svg){width=70%}\n:::\n\n\n\n:::: {.callout-important collapse='false'}\n\n## ALERT!\n\n::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\n\nThis post is currently under development. Thank you for your patience.\n\n::: \n\n::::\n\n\n## Set up\n\n[`shinytest2`](https://rstudio.github.io/shinytest2/index.html) requires a few steps to get up and running, so I've included my start up steps below (in hopes that someone might find them useful).\n\n### Chromium\n\nFirst make sure you have [Chromium headless browser](https://www.chromium.org/chromium-projects/) installed. Chromium is the browser used to test and debug shiny apps with `shinytest2`.\n\nIf you're using macOS, you can install Chromium using [homebrew](https://formulae.brew.sh/cask/chromium): \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nbrew install --cask chromium\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"true\" code-summary=\"show/hide output\"}\n==> Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==> Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==> Installing Cask chromium\n==> Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==> Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nüç∫  chromium was successfully installed!\n```\n:::\n\n\n\n### [`chromote`]{style=\"font-size: 1.20em\"}\n\nThe [`chromote` package](https://rstudio.github.io/chromote/index.html) allows R to open Chromium. I had to make sure R knew where to find the Chromium application ([this section helps](https://rstudio.github.io/chromote/#specifying-which-browser-to-use)) by passing the path to the app to `Sys.setenv()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n```\n:::\n\n\nYou can use `find_chrome()` to find your chrome app: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nchromote::find_chrome()\n```\n:::\n\n\n*You can also locate the path to Chromium using by holding command <kbd>‚åò</kbd> and clicking on the application icon*\n\nThen set the `CHROMOTE_CHROME` environment variable to the `Chromium` path (**make sure it's not the path to `Chrome.app`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n```\n:::\n\n\nVerify the Chromium app/`chromote` install with `ChromoteSession$new()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\" code-summary=\"verify ChromoteSession$new()\"}\nb <- ChromoteSession$new()\nb$view()\n```\n:::\n\n\n\n:::: {.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![Chromium](chromium.png){#fig-chromium width=100% fig-align=\"center\"}\n\nChromium headless browser\n:::\n\n::::\n\nGreat! Going through this step means `shinytest2`'s test recorder will (*should*) deploy when I'm recording tests. \n\n## App-package contents\n\nI've created [`msst2ap`](https://github.com/mjfrigaard/msst2ap) (i.e., **M**astering **S**hiny **s**hiny**t**est**2** **a**pp-**p**ackage) with [`devtools` and `usethis`](https://r-pkgs.org/). It somewhat resembles an application using the [`golem` framework](https://engineering-shiny.org/), but with fewer opinions. You can download `msst2ap` [here](https://github.com/mjfrigaard/msst2ap/archive/refs/heads/main.zip) or install it using the following: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n```\n:::\n\n\nThe applications in `msst2ap` can be run with the their standalone app functions.\n\n---\ntitle-meta: \"Modules & apps\"\n\ncallout-icon: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n### Modules & apps \n\nThe modules in `msst2ap` are from the [Modules chapter of Mastering Shiny](https://mastering-shiny.org/scaling-modules.html), with a few minor adjustments. These modules create namespaces for their inputs and outputs with the `shiny::NS()` function, which appends a second `id` string to each `inputId`/`outputId`.\n\nEach standalone app also includes the output from `shiny::reactiveValuesToList()`:\n\n-   In the `ui`: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n    ```\n    :::\n    \n-   In the `server`: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # for printing reactive values in application modules\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n    ```\n    :::\n\n\n#### [`dataset`]{style=\"font-size: 1.15em\"} module\n\nThe `dataset` module displays the objects in the `datasets` package in a `selectInput()` according to a filter argument (i.e., `is.data.frame`, `is.matrix`, etc.).\n\n`datasetServer()` returns the selected object as a reactive value. Read more [here](https://mastering-shiny.org/scaling-modules.html#getting-started-ui-input-server-output).\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"datasetInput() & datasetServer()\"}\ndatasetInput <- function(id, filter = NULL) {\n  names <- ls(\"package:datasets\")\n\n  if (!is.null(filter)) {\n    data <- lapply(names, get, \"package:datasets\")\n    names <- names[vapply(data, filter, logical(1))]\n  }\n\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n}\ndatasetServer <- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    shiny::reactive(get(input$dataset, \"package:datasets\"))\n  })\n}\n```\n:::\n\n##### [`datasetApp()`]{style=\"font-size: 1.10em\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"datasetApp()\"}\ndatasetApp <- function(filter = NULL) {\n  ui <- shiny::fluidPage(\n    datasetInput(\"dataset\", filter = is.data.frame),\n    shiny::tableOutput(\"data\"),\n    \n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n  )\n  server <- function(input, output, session) {\n    data <- datasetServer(\"dataset\")\n    output$data <- shiny::renderTable(head(data()))\n    \n    # for printing reactive values in application modules\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n\n  }\n  shiny::shinyApp(ui, server)\n}\n```\n:::\n\n\n:::: {.column-body-outset-right}\n\n::: {#fig-datasetApp}\n\n![`datasetApp()`](datasetApp.png){#fig-datasetApp fig-align=\"center\" width=100%}\n\n`datasetApp()` in `msst2ap`\n:::\n\n::::\n\n##### Reactive values ([`vals`]{style=\"font-size: 1.15em\"})\n\nBelow the table output in `datasetApp()`, the reactive values displays the `inputId` from `datasetInput()` and the namespace value from the shared `id` argument with `datasetServer()`:\n\n```r\n$`dataset-dataset`\n```\n\n#### [`selectVar`]{style=\"font-size: 1.15em\"} module\n\nThe `selectVar` module [selects a numeric variable](https://mastering-shiny.org/scaling-modules.html#case-study-selecting-a-numeric-variable) the `data()` object returned from `datasetServer()`.\n\nIt has a single utility function (`find_vars()`) which is used to filter the columns (variables):\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide selectVarInput() & selectVarServer()\"}\nselectVarInput <- function(id) {\n  shiny::selectInput(\n    shiny::NS(id, \"var\"),\n    label = \"Variable\",\n    choices = NULL\n  )\n}\nselectVarServer <- function(id, data, filter = is.numeric) {\n  \n  stopifnot(shiny::is.reactive(data))\n  stopifnot(!shiny::is.reactive(filter))\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n    shiny::observe({\n      shiny::updateSelectInput(\n        session, \"var\",\n        choices = find_vars(data(), filter))\n    }) |>\n      shiny::bindEvent(data())\n\n    return(\n      shiny::reactive({\n        if (input$var %in% names(data())) {\n          data()[input$var]\n        } else {\n          NULL\n        }\n      }) |>\n      shiny::bindEvent(input$var)\n    )\n\n  })\n}\n```\n:::\n\nI've made a few small changes to `selectVarServer()`: \n\n-   In the original version, `input$var` is returned as a vector: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    reactive(data()[[input$var]])\n    ```\n    :::\n    \n-   I've added some validation and return `input$var` as a single column from `data()`: \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    shiny::reactive({\n        if (input$var %in% names(data())) {\n            data()[input$var]\n        } else {\n            NULL\n        }\n      }) \n    ```\n    :::\n\n-   The `find_vars()` function is also below:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide find_vars()\"}\n    find_vars <- function(data, filter = is.vector) {\n      stopifnot(is.data.frame(data))\n      stopifnot(is.function(filter))\n      names(data)[vapply(data, filter, logical(1))]\n    }\n    ```\n    :::\n\n##### [`selectVarApp()`]{style=\"font-size: 1.10em\"}\n\nThe `selectVarApp()` extends the `dataset` module by collecting the returned reactive value, passing it to `find_vars()`, and returning a single column.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide selectVarApp()\"}\nselectVarApp <- function(filter = is.numeric) {\n  ui <- shiny::fluidPage(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n            shiny::tableOutput(\"out\"),\n            shiny::verbatimTextOutput(\"vals\")\n  )\n  server <- function(input, output, session) {\n\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n  }\n\n  shiny::shinyApp(ui, server)\n}\n```\n:::\n\n:::: {.column-body-outset-right}\n\n::: {#fig-selectVarApp}\n\n![`selectVarApp()`](selectVarApp.png){#fig-selectVarApp fig-align=\"center\" width=100%}\n\n`selectVarApp()` in `msst2ap`\n:::\n\n::::\n\n##### Reactive values ([`vals`]{style=\"font-size: 1.15em\"})\n\nThe reactive values in `selectVarApp()` are displayed below the table: \n\n:::: {layout-ncol=2}\n\n##### Variables \n\n::: {style=\"font-size: 0.80em\"}\n\n-   the 1st `var` is from the `inputId` in `selectVarInput()`\n\n    ```\n    $`-var` \n    ```\n\n-   the 2nd `var` is the shared namespace `id` from the `selectVar` module \n\n    ```\n    $`var-var` \n    ```\n\n:::\n\n##### Data\n\n::: {style=\"font-size: 0.80em\"}\n    \n-   `dataset` is from the `inputId` in `datasetInput()`\n\n    ```r\n    $`-dataset`\n    ```\n    \n-   `data` is the shared namespace `id` from the `dataset` module\n\n    ```r\n    $`data-dataset`\n    ```\n    \n:::\n\n::::\n\n#### [`selectDataVar`]{style=\"font-size: 1.10em\"} module\n\n`selectDataVar` is from the [Modules inside of modules](https://mastering-shiny.org/scaling-modules.html#modules-inside-of-modules) section, so true to form, both the `dataset` and `selectVar` modules are called inside of the UI and Server modules: \n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"selectDataVarUI() & selectDataVarServer()\"}\nselectDataVarUI <- function(id) {\n  shiny::tagList(\n    datasetInput(\n      shiny::NS(id, \"data\"), \n        filter = is.data.frame),\n    selectVarInput(\n      shiny::NS(id, \"var\"))\n  )\n}\nselectDataVarServer <- function(id, filter = is.numeric) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n    var\n\n  })\n}\n```\n:::\n\n##### [`selectDataVarApp()`]{style=\"font-size: 1.15em\"}\n\nThe `selectDataVarApp()` places the inputs in the `sidebarPanel()` and the outputs in the `mainPanel()`.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"selectDataVarApp()\"}\nselectDataVarApp <- function(filter = is.numeric) {\n  ui <- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        selectDataVarUI(\"var\")\n        ),\n      shiny::mainPanel(\n        shiny::tableOutput(\"out\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n        )\n    )\n  )\n  server <- function(input, output, session) {\n    var <- selectDataVarServer(\"var\", filter)\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n```\n:::\n\n:::: {.column-body-outset-right}\n\n::: {#fig-selectDataVarApp}\n\n![`selectDataVarApp()`](selectDataVarApp.png){#fig-selectDataVarApp fig-align=\"center\" width=100%}\n\n`selectDataVarApp()` in `msst2ap`\n:::\n\n::::\n\nThe reactive values from `selectDataVarApp()` reflect the nested module structure:\n\n:::: {layout-ncol=2}\n\n##### Variables \n\n::: {style=\"font-size: 0.80em\"}\n\n-   The first `var` belongs to the `inputId` in `selectVarInput()`, \n\n    ```r\n    $`-var` \n    ```\n\n-   the 2nd `var` is the shared namespace `id` from the `selectVar` module,\n\n    ```r\n    $`-var-var`\n    ```\n    \n-   the 3rd `var` is the call to the `selectVar` module *inside* `selectDataVar`\n\n    ```r\n    $`var-var-var` \n    [1] \"Ozone\"\n    ```\n    \n:::\n\n##### Data\n\n::: {style=\"font-size: 0.80em\"}\n\n-   `dataset` belongs to the `inputId` in `datasetInput()`, \n\n    ```r\n    $`-dataset` \n    ```\n\n-   `data` is the shared namespace `id` from the `dataset` module, \n\n    ```r\n    $`-data-dataset` \n    ```\n\n-   `var` is the call to the `dataset` module *inside* `selectDataVar`\n        \n    ```r\n    $`var-data-dataset` \n    [1] \"airquality\"\n    ```\n    \n:::\n\n::::\n\n\n\n#### [`histogram`]{style=\"font-size: 1.10em\"} module\n\nThe final modules and application I'll use from Mastering Shiny are from the [Case study: histogram](https://mastering-shiny.org/scaling-modules.html#case-study-histogram) section. This application uses the existing `dataset` and `selectVar` modules to pass a single variable to the render a histogram:\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide histogramOutput() & histogramServer()\"}\nhistogramOutput <- function(id) {\n  shiny::tagList(\n    shiny::numericInput(\n      shiny::NS(id, \"bins\"),\n      label = \"bins\",\n      value = 10,\n      min = 1,\n      step = 1\n    ),\n    shiny::plotOutput(\n      shiny::NS(id, \"hist\"))\n  )\n}\nhistogramServer <- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(shiny::is.reactive(x))\n  stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    output$hist <- shiny::renderPlot({\n        shiny::req(x())\n        main <- paste0(title(), \" [\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main\n        )\n      }, res = 96)\n\n    output$data <- shiny::renderPrint({\n      shiny::req(x())\n      print(head(x()))\n    })\n  })\n}\n```\n:::\n\nI've made some changes to the `histogramServer()` function (to accomodate the changes to the `selectVar` module). \n\n-   The original `renderPlot()` call in `histogramServer()`:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      output$hist <- renderPlot({\n        req(is.numeric(x()))\n        main <- paste0(title(), \" [\", input$bins, \"]\")\n        hist(x(), breaks = input$bins, main = main)\n      }, res = 96)\n    ```\n    :::\n\n-   The updated `renderPlot()` call in `histogramServer()`:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      output$hist <- shiny::renderPlot({\n        shiny::req(x())\n        main <- paste0(title(), \" [bins =\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main)\n      }, res = 96)\n    ```\n    :::\n    \n    -   As you can see, `req()` is verifying `x()` exists, but doesn't check it's class with `is.numeric()`. \n    \n    -   `x()` is also passed to `purrr::as_vector()` before it's plotted with `hist()`\n\n\n##### [`histogramApp()`]{style=\"font-size: 1.15em\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"histogramApp()\"}\nhistogramApp <- function() {\n  ui <- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server <- function(input, output, session) {\n    data <- datasetServer(\"data\")\n    x <- selectVarServer(\"var\", data)\n    histogramServer(\"hist\", x)\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n```\n:::\n\n:::: {.column-body-outset-right}\n\n::: {#fig-histogramApp}\n\n![`histogramApp()`](histogramApp.png){#fig-dataStrApp fig-align=\"center\" width=100%}\n\n`histogramApp()` in `msst2ap`\n:::\n\n::::\n\n##### Reactive values ([`vals`]{style=\"font-size: 1.15em\"})\n\nThe displayed reactive values in `histogramApp()` are described below:\n\n:::: {layout-ncol=3}\n\n##### Plot\n\n::: {style=\"font-size: 0.80em\"}\n\n-   The `inputId` from `histogramOutput()` and the shared namespace `id`\n\n    ```r\n    $`hist-bins`\n    [1] 10\n    ```\n    \n:::\n\n##### Variables \n\n::: {style=\"font-size: 0.80em\"}\n\n-   The `inputId` from `selectVarInput()` and the shared namespace `id`\n\n    ```r\n    $`var-var`\n    [1] \"Ozone\"\n    ```\n    \n:::\n    \n##### Data\n\n::: {style=\"font-size: 0.80em\"}\n\n-   The `inputId` from `datasetInput()` and the shared namespace `id`\n\n    ```r\n    $`data-dataset` \n    [1] \"airquality\"\n    ```\n    \n:::\n\n::::\n\n\n\n## Using [`shinytest2`]{style=\"font-size: 1.20em\"}\n\n`shinytest2` is extremely [well documentation](https://rstudio.github.io/shinytest2/index.html). I highly recommended the [Get Started vignette](https://rstudio.github.io/shinytest2/articles/shinytest2.html). In the next sections, I'll cover some examples for what I've included in the `msst2ap`.\n\n\n\n:::: {.callout-note collapse='false'}\n\n## Why `shinytest2`?\n\n::: {style='font-size: 1.10em; color: #696969;'}\n\n\n  **What happened to `shinytest`?**\n  \n  `shinytest2` replaced `shinytest` on 2022-04-27. If you've previously written tests with `shinytest`--or are curious how `shinytest2` if different--I recommend going through the [Migrating from `shinytest`](https://cran.r-project.org/web/packages/shinytest2/vignettes/z-migration.html#:~:text) vignette.\n  \n\n::: \n\n::::\n\n\nRun `shinytest2::use_shinytest2()` to create the initial files for `shinytest2`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nshinytest2::use_shinytest2()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"true\" code-summary=\"show/hide output from use_shinytest2()\"}\n! Runner already found: tests/testthat.R\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚úî Adding '*_.new.png' to '.gitignore'\n‚úî Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\n‚úî Setting active project to '/projects/msst2ap'\n‚úî Adding 'shinytest2' to Suggests field in DESCRIPTION\n‚Ä¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\n‚Ä¢ Then directly refer to functions with `shinytest2::fun()`\n‚úî Setting active project to '<no active project>'\n```\n:::\n\n\n-   `use_shinytest2()` adds the `setup-shinytest2.R` script to my `tests/testthat/` folder:\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    tests/testthat/\n    ‚îú‚îÄ‚îÄ _snaps/\n    ‚îî‚îÄ‚îÄ setup-shinytest2.R\n    ```\n    :::\n\n\nThe `setup-shinytest2.R` file contains a single call to `shinytest2::load_app_env()`, which \"*Executes all `./R` files and `global.R` into the current environment*\"\n\n## Recording tests\n\nNew tests with [`shinytest2`](https://rstudio.github.io/shinytest2/index.html) can be created by launching the test event recorder, which allows us interact with our application, observe it's behavior, and record inputs, reactive values, and outputs. To record a test, run `shinytest2::record_test()`.\n\nThe first argument in `record_test()` is the path to application. If you've stored your application in an `app.R` file, `record_test()` will automatically load that application. \n\n-   If you encounter a message telling you [Chromium is disconnected](https://github.com/rstudio/shinytest2/issues/331), try installing the development version of `chromote`: \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # run this in the console to make sure you have dev version of chromote\n    remotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\n    library(chromote)\n    ```\n    :::\n\n\nIn `msst2ap`, the application in `app.R` is the `histogramApp()`, so the test recorder will automatically open with this application if I run `record_test()` (without providing the path to a `shiny` app).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nshinytest2::record_test()\n```\n:::\n\n\n### In Chromium \n\n::::{.column-body-outset-right}\n\n::: {#fig-record_test_histogramApp layout-ncol=1}\n![shinytest2::record_test()](record_test_histogramApp.png){#fig-record_test_histogramApp width=100% fig-align=\"center\"}\n\n`record_test()` with application in `app.R`\n:::\n\n::::\n\nThe `app` argument can also be a \"*path to a Shiny application*\". For example, I have 'development' versions of each application in `msst2ap` in [`inst/dev/`](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev):\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"true\" code-summary=\"show/hide contents of msst2ap/inst/dev\"}\ninst/dev\n‚îú‚îÄ‚îÄ datasetApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ histogramApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ selectDataVarApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îî‚îÄ‚îÄ selectVarApp\n    ‚îú‚îÄ‚îÄ DESCRIPTION\n    ‚îú‚îÄ‚îÄ R\n    ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n    ‚îú‚îÄ‚îÄ README.md\n    ‚îî‚îÄ‚îÄ app.R\n\n9 directories, 16 files\n```\n:::\n\n\nI can pass the path to each application to the `app` argument in `record_test()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n```\n:::\n\n\nThis opens Chromium with our shiny app: \n\n::::{.column-body-outset-right}\n\n::: {#fig-record_test_datasetApp layout-ncol=1}\n\n![record_test(\"inst/dev/histogramApp/\")](record_test_histogramApp.png){#fig-record_test_datasetApp width=100% fig-align=\"center\"}\n\n`record_test()` with app in `inst/dev/histogramApp/` folder\n:::\n\n::::\n\nThe test event recorder displays the `shiny` app, but also includes a window for recording each application 'event.' \n\n#### Expectations\n\nI'll start by recording a test for `histogramApp()`. On the right-hand side of the Chromium headless browser, you'll see the **`shinytest2` expectations** window:\n\n::::{.column-body-outset-right}\n\n::: {#fig-shinytest2-expectations layout-ncol=1}\n![`shinytest2` expectations](shinytest2-expectations.png){#fig-expectations}\n\n`shinytest2` expectations in `record_test()`\n:::\n\n::::\n\nThe initial value in the **Code** window displays the dimensions of the application in Chromium (`app$set_window_size(width = , height = )`).\n\n#### Events\n\nWhen I interact with the application (i.e., make changes to the inputs), each change is an 'event' that is recorded in the test:\n\n::::{.column-body-outset-right}\n\n::: {#fig-chromium layout-ncol=1}\n![change inputs](shinytest2-change-inputs.png){#fig-change-values-shinytest2 width=100% fig-align=\"center\"}\n\nChanging app inputs \n:::\n\n::::\n\n#### Code \n\nAll events are recorded as code in the **Code** section of **`shinytest2` expectations**:\n\n::::{.column-body-outset-right}\n\n::: {#fig-shinytest2-code-expectations layout-ncol=1}\n\n![shinytest2 code expectations](shinytest2-expectations-code.png){#fig-shinytest2-expectations-code width=100% fig-align=\"center\"}\n\nRecorded code for each event\n:::\n\n::::\n\n#### Expect Shiny values \n\nWhen I've finished interacting with the application, I click on the **Expect Shiny values** button at the top of **`shinytest2` expectations**. This will add `app$expect_values()` to the **Code** section:\n\n::::{.column-body-outset-right}\n\n::: {#fig-expect-shiny-values layout-ncol=1}\n\n\n![expect-shiny-values](shinytest2-expect-shiny-values.png){#fig-expect-shiny-values width=100% fig-align=\"center\"}\n\n**Expect Shiny values** in `shinytest2` expectations\n:::\n\n::::\n\n#### Save test and exit\n\nFinally, to save the test, enter a **Test name** and click **Save test and exit**\n\n::::{.column-body-outset-right}\n\n::: {#fig-name-save-exit layout-ncol=1}\n\n![name-save-exit](shinytest2-name-save.png){#fig-shinytest2-name-save width=100% fig-align=\"center\"}\n\nName, save and exit `record_test()`\n:::\n\n::::\n\n### In Console\n\nBack in the **Console**, the `shinytest2` test recorder is performing the following actions behind the scenes:\n\n-   The Chromium headless browser opens with the `histogramApp()` and `shiny` is loaded \n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    Listening on http://127.0.0.1:7418\n    {shiny} R stderr ----------- Loading required package: shiny\n    ```\n    :::\n\n\n\n-   [**`Warning`**]{style=\"font-size: 1.20em\"}: The first warning is a caused by the call to `shiny::loadSupport()`. It's a [known issue](https://github.com/rstudio/shinytest2/issues/264#issuecomment-1251422788), so we can assume the developers are working on it!\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    Warning message:\n    In shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n      Loading R/ subdirectory for Shiny application, but this directory appears to\n      contain an R package. Sourcing files in R/ may cause unexpected behavior.\n    ```\n    :::\n\n\n-   We are told the application is being run in [`test mode`](https://rstudio.github.io/shinytest2/reference/AppDriver.html#test-mode), which '*lets the `AppDriver` retrieve values*' from the app \n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    {shiny} R stderr ----------- Running application in test mode.\n    {shiny} R stdout ----------- ‚Ñπ Loading msst2ap\n    ```\n    :::\n\n\n-   [**`Warning`**]{style=\"font-size: 1.20em\"}: The `tests/testthat.R` file (i.e., the 'test runner') was overwritten and tests are now run with `shinytest2::test_app()`\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    Warning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\n    call to ensure proper a testing environment.\n    ```\n    :::\n\n\n-   When I clicked \"**Save test and exit**\", the changes made to `tests/testthat.R` and `tests/testthat/test-shinytest2.R` are saved: \n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    ‚Ä¢ Saving test runner: tests/testthat.R\n    ‚Ä¢ Saving test file: tests/testthat/test-shinytest2.R\n    ```\n    :::\n\n\n-   A call to `shinytest2::load_app_env()` is added to `setup-shinytest2.R` and the test file (`tests/testthat/test-shinytest2.R`) is opened: \n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    ‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n    ‚Ä¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n    ```\n    :::\n\n\n-   The new test is saved in the `tests/testthat/test-shinytest2.R` file and automatically run. \n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    ‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n    ```\n    :::\n\n    \n## Test contents\n\nThe contents of the test file generated from the test recorder are below: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app <- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n```\n:::\n\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on **Run Test** or by using `test_file()` from `testthat`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n```\n:::\n\n\n\n:::: {.callout-important collapse='false' title='WARNING'}\n\n::: {style='font-size: 1.10em; color: #000000;'}\n\nBecause `msst2ap` is a package, running tests with `shinytest2` will produce the warning below:\n  \n![`shiny::loadSupport()` warning](run_tests_out.png){width=100%}\n\nAs noted above, this warning is [known by the `shinytest2` package authors](https://github.com/rstudio/shinytest2/issues/264#issuecomment-1251422788) and is being addressed in a future release. \n\n:::\n\n::::\n\nNow that I know the first `shinytest2` test is passing, I'll dive into each line in the test. \n\n### [`AppDriver`]{style=\"font-size: 1.15em\"}\n\n`shinytest2` uses the [`AppDriver`](https://rstudio.github.io/shinytest2/reference/AppDriver.html) to create \"*a full simulation of a Shiny app*\". When recording tests, this will be the first argument (along with the `name` of the `.png` and `.json` snapshot `testthat` files, and the `height` and `width` of the [`ChromoteSession`](https://rstudio.github.io/chromote/reference/ChromoteSession.html)).\n\n-   The example from the test above is below: \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n     app <- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n    ```\n    :::\n\n\n\n### [`set_inputs()`]{style=\"font-size: 1.15em\"}\n\nWhen recording `shinytest2` tests, every change to the applications inputs will result in a call to `app$set_inputs()`. This function is similar to the `testServer()` call to `session$setInputs()` (i.e., the inputs are provided as \"*name-value pairs*\", i.e., `inputId` = `\"value\"`). \n\n-   In the `histogramApp()`, these are provided with the appended namespaces:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      app$set_inputs(`data-dataset` = \"attitude\")\n      app$set_inputs(`var-var` = \"privileges\")\n      app$set_inputs(`hist-bins` = 11)\n      app$set_inputs(`hist-bins` = 12)\n      app$set_inputs(`hist-bins` = 13)\n      app$set_inputs(`hist-bins` = 14)\n      app$set_inputs(`hist-bins` = 15)\n    ```\n    :::\n\n\n### [`expect_values()`]{style=\"font-size: 1.15em\"}\n\n[The documentation](https://rstudio.github.io/shinytest2/articles/in-depth.html#making-expectations) on `expect_values()` is definitely worth reading. `expect_values()` is added to the test file when **Expect Shiny values** is clicked in the test recorder and \"*creates a list of values and compares them to the current values of the application*.\"\n\n-   `expect_values()` = \"*Expect all `input`, `output`, and `export` values are consistent*\"\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      app$expect_values()\n    ```\n    :::\n\n\n\n## Test results\n\nThe results from running the new test file (`test-shinytest2.R`) are below: \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n‚úî | F W S  OK | Context\n‚úî |   2     1 | shinytest2 [6.3s]                                             \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n```\n:::\n\n\nTwo warnings are displayed because the test adds two new files to the `tests/testthat/_snaps/` folder: \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\ntests/testthat/_snaps/\n‚îî‚îÄ‚îÄ shinytest2\n    ‚îú‚îÄ‚îÄ histogramApp-001.json\n    ‚îî‚îÄ‚îÄ histogramApp-001_.png\n\n2 directories, 2 files\n```\n:::\n\n\nThese are the files new test runs will be compared against (i.e., our 'baseline' snapshots). I'll briefly cover their contents below: \n\n### [`_snaps`]{style=\"font-size: 1.15em\"}\n\n`expect_values()` generates two snapshot files in the `tests/testthat/_snaps/` folder: one `.png` and one `.json` file:\n\n#### [`.png`]{style=\"font-size: 1.20em\"}\n\nThe image saved in `tests/testthat/_snaps/histogramApp-001_.png` is below:\n\n![](histogramApp-001_.png){fig-align='center'}\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (**`attitude`** and **`privileges`**).\n\n#### [`.json`]{style=\"font-size: 1.20em\"}\n\nThe `.json` file saved in `tests/testthat/_snaps/histogramApp-001.json` contains the snapshot `input`s, `output`s, and `export`s:\n\n-   The inputs show the three changed values (`\"data-dataset\"`, `\"var-var\"`, and `\"hist-bins\"`).\n \n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"show\" code-summary=\"show/hide snapshot inputs\"}\n    {\n      \"input\": {\n        \"data-dataset\": \"attitude\",\n        \"hist-bins\": 15,\n        \"var-var\": \"privileges\"\n      },\n    ```\n    :::\n\n    \nThe two outputs are stored in `\"hist-hist\"` and `\"vals\"`:\n\n-   `\"hist-hist\"` holds the updated image (stored in the `image data hash`), along with various other characteristics of the plot:\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"true\" code-summary=\"show/hide snapshot outputs\"}\n      \"output\": {\n        \"hist-hist\": {\n          \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n          \"width\": 682.6640625,\n          \"height\": 400,\n          \"alt\": \"Plot object\",\n          \"coordmap\": {\n            \"panels\": [\n              {\n                \"domain\": {\n                  \"left\": 27.8,\n                  \"right\": 87.2,\n                  \"bottom\": -0.24,\n                  \"top\": 6.24\n                },\n                \"range\": {\n                  \"left\": 78.79664956011726,\n                  \"right\": 642.3048029692084,\n                  \"bottom\": 301.08,\n                  \"top\": 77.71999999999998\n                },\n                \"log\": {\n                  \"x\": null,\n                  \"y\": null\n                },\n                \"mapping\": {\n    \n                }\n              }\n            ],\n            \"dims\": {\n              \"width\": 682.6640625,\n              \"height\": 400\n            }\n          }\n        },\n    ```\n    :::\n\n    \n-   `\"vals\"` contains the reactive values from `reactiveValuesToList()`:\n    \n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"show\" code-summary=\"show/hide snapshot outputs\"}\n        \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n      },\n    ```\n    :::\n\n\n-   I didn't export any values in this test, so `\"export\"` is empty:\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"show\" code-summary=\"show/hide snapshot outputs\"}\n      \"export\": {\n    \n      }\n    }\n    ```\n    :::\n\n\n    -   *I'll cover this in a later test.*\n  \n#### Namespaces\n\nThe contents of the `.json` snapshot should look *somewhat* familiar for the three modules contained in  `histogramApp()`:\n\n-   For example, the `inputId` for `\"dataset\"` in the `datasetInput/Server` module communicates between the UI and server using the shared `id` argument `\"data\"`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # in datasetInput()\n      shiny::selectInput(\n        shiny::NS(id, \"dataset\"),\n        \"Pick a dataset\",\n        choices = names)\n    # in histogramApp()\n      shiny::sidebarPanel(\n            datasetInput(\"data\", is.data.frame)\n          )\n    ```\n    :::\n\n    \n-   This creates the ```` $`data-dataset` ```` output we see the `verbatimTextOutput()` at the bottom of the application: \n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    $`data-dataset`\n    [1] \"attitude\"\n    ```\n    :::\n\n    \n-   In the `.json` snapshot, this `inputId` is represented in the following `\"input\"`:\n\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    {\n      \"input\": {\n        \"data-dataset\": \"attitude\",\n      },\n    ```\n    :::\n\n    \nNamespaces and `inputId`s will come up again if you start writing your own tests, which I'll cover below. \n\n## Writing tests\n\nThe great thing about testing with `shinytest2` is the ability to interact with the `AppDriver` as you write tests. I'll demo writing a test for the `datasetApp()` by adapting the contents of `test-shinytest2.R` into a new `test-shinytest2-datasetApp.R` file.\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îÇ   ‚îî‚îÄ‚îÄ shinytest2/\n‚îÇ       ‚îú‚îÄ‚îÄ histogramApp-001.json\n‚îÇ       ‚îî‚îÄ‚îÄ histogramApp-001_.png\n‚îú‚îÄ‚îÄ setup-shinytest2.R\n‚îú‚îÄ‚îÄ test-shinytest2-datasetApp.R <- new test file!\n‚îî‚îÄ‚îÄ test-shinytest2.R\n\n3 directories, 5 files\n```\n:::\n\n\n\nIn the new test `test-shinytest2-datasetApp.R` file, I'll start with a call to `testthat::test_that(),` then create a new `app` object with the Chromium headless browser. \n\nThe namespaced standalone app function can be used to create a `ds_app` object, then `ds_app` is passed to the first argument of `AppDriver$new()` (I've adjusted the `height` and `weight` to fit the `datasetApp()`).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n})\n```\n:::\n\n\nIn the **Console**, I can use `app$view()` to open the Chromium browser: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napp$view()\n```\n:::\n\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view layout-ncol=1}\n\n![`app$view()`](app_view.png){#fig-app_view}\n\nView application with `app$view()`\n:::\n\n::::\n\nChromium displays the same app I see when I run `msst2ap::datasetApp()` in the console, but the headless browser has some additional developer tools ([read more](https://www.browserstack.com/guide/difference-between-chrome-and-chromium)).  \n\n### Setting inputs \n\nIf I continue to adapt each line in `test-shinytest2.R` to the `datasetApp()`, I see that next lines set the `inputId`s for `dataset-dataset` to the `attitude` dataset with `app$set_input()` (*Note that this uses the module notation above (i.e., `\"id-inputId\"`*):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n```\n:::\n\n\nIf you can see both windows, you'll see the application values change in the Chromium browser: \n\n::::{.column-page-right}\n\n::: {#fig-set_inputs layout-ncol=1}\n\n![`app$set_inputs()`](app_set_inputs.png){#fig-app_set_inputs}\n\nSet application inputs with `app$set_inputs()`\n:::\n\n::::\n\n### Checking inputs\n\nIn the previous test, I used the `expect_values()` to capture a list of all the app values (`input`, `output`, `export`). I can also capture these values in a list *inside* the test by including a call to `app$get_values()` and assigning the output to `app_values`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n})\n```\n:::\n\n\n`app_values` has a similar structure to the `.json` snapshot covered above (i.e., with `input`, `output`, and `export`): \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nstr(app_values)\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"<table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n```\n:::\n\n\nI can narrow the scope of the test by using `app_values` to verify only the `input` that was changed with `app$set_inputs()`::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n```\n:::\n\n\nAt the end of the test, I'll add a call [`app$stop()`](https://rstudio.github.io/shinytest2/articles/zzz-faq.html#should-i-manually-shut-down-my-appdriver) to close the Chromium app.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app <- msst2ap::datasetApp()\n  app <- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n```\n:::\n\n\n### Running tests\n\nI'll save the `test-shinytest2-datasetApp.R` file and run the test with `testthat::test_file()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n```\n:::\n\n\n:::: {.callout-important collapse='false' title='WARNING'}\n\n::: {style='font-size: 1.10em; color: #000000;'}\n\nIf you encounter the error message below: \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\n‚îÄ‚îÄ Skipped tests (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚Ä¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n```\n:::\n\n\nTry installing and loading `chromote` and `shinytest2` again (this seemed to work for me).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n```\n:::\n\n\n:::\n\n::::\n\nIn the initial run of the test for `datasetApp()`, no snapshot files are generated because the test didn't include a call to `app$export_values()`. \n\nI see this initial test passes:  \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n```\n:::\n\n\n## Exporting test values \n\nThe `shinytest2` documentation [repeatedly](https://rstudio.github.io/shinytest2/articles/in-depth.html#exported-values) [recommends](https://rstudio.github.io/shinytest2/articles/robust.html#exported-values) exporting test values from shiny applications with `shiny::exportTestValues()`. \n\n### [`exportTestValues()`]{style=\"font-size: 1.20em\"}\n\nI'll demonstrate exporting test values from `selectVarApp()` by adding the following to the `server` function in `inst/dev/app.R`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  server <- function(input, output, session) {\n\n    data <- datasetServer(\"data\")\n    var <- selectVarServer(\"var\", data, filter = filter)\n\n    output$out <- shiny::renderTable(head(var()))\n\n    output$vals <- shiny::renderPrint({\n      x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n```\n:::\n\n\n### Using [`system.file()`]{style=\"font-size: 1.20em\"}\n\nAfter loading, documenting and installing the package, I'll create a `test-shinytest2-selectVarApp.R` test file and add the initial contents to create the `AppDriver` object:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n```\n:::\n\n\nNote that to test the development version of `selectVarApp()`, I pass a call to `system.file()` to the `app_dir` argument (this is a similar folder structure to apps built with [`golem`](https://thinkr-open.github.io/golem/articles/a_start.html) and [`leprechaun`](https://leprechaun.opifex.org/#/guide/build) frameworks) \n\n\nAfter entering `app$view()` in the **Console**, the application opens in the Chromium headless browser again:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napp$view()\n```\n:::\n\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_selectVarApp layout-ncol=1}\n\n![`app$view()`](app_view_selectVarApp.png){#fig-app_view_selectVarApp}\n\nView `selectVarApp()` application with `app$view()`\n:::\n\n::::\n\nIn the test file, I'll use `app$set_values()` to change the ```` $`data-dataset` ```` and ```` $`var-var` ```` inputs:\n\n-   Change ```` $`data-dataset` ```` to `mtcars`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    testthat::test_that(\"{shinytest2}: selectVarApp\", {\n      app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                                 package = \"msst2ap\"),\n                           height = 600, width = 600)\n      \n        app$set_inputs(`data-dataset` = \"mtcars\")\n        \n    })\n    ```\n    :::\n\n\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_set_data_selectVarApp layout-ncol=1}\n\n![Set `data-dataset`](app_view_set_data_selectVarApp.png){#fig-app_view_set_data_selectVarApp}\n\nView `selectVarApp()` after setting `data-dataset` with `app$set_inputs()`\n:::\n\n::::\n\n-   Change ```` $`var-var` ```` to `wt`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    testthat::test_that(\"{shinytest2}: selectVarApp\", {\n      app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                                 package = \"msst2ap\"),\n                           height = 600, width = 600)\n      \n        app$set_inputs(`data-dataset` = \"mtcars\")\n        app$set_inputs(`var-var` = \"wt\")\n        \n    })\n    ```\n    :::\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_set_var_selectVarApp layout-ncol=1}\n\n![Set `var-var`](app_view_set_var_selectVarApp.png){#fig-app_view_set_var_selectVarApp}\n\nView `selectVarApp()` after setting `var-var` with `app$set_inputs()`\n:::\n\n::::\n\n### [`get_values()`]{style=\"font-size: 1.20em\"} \n\nI'll use `app$get_values()` to store the exported `input`, `output`, and `export` test values in `app_values`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values <- app$get_values()\n    \n})\n```\n:::\n\n\n`app_values` is a list (similar to the `.json` snapshot file), but now we've explicitly `export`ed values from the server in `selectVarApp()`: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnames(app_values$export)\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[1] \"data\" \"var\" \n```\n:::\n\n\n### [`export`]{style=\"font-size: 1.20em\"}ed expectations\n\nI can use `app_values` to verify the structure of each exported object: \n\n-   `data` should be a `data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n```\n:::\n\n\n-   `var` should be a single column `data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n```\n:::\n\n\nOnce again, I end the test with a call to `app$stop()`. The completed test for `selectVarApp()` is below:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values <- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n```\n:::\n\n\nI can run the test with `testthat::test_file()`.  \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n```\n:::\n\n\nThe results are below: \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n```\n:::\n\n\n## Testing complex outputs \n\nI've created an adapted version of the `histogramApp()` in the `inst/dev/gghistApp/` folder (view contents [here](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev/gghistApp#gghistapp)):\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\ninst/dev/gghistApp/\n            ‚îú‚îÄ‚îÄ DESCRIPTION\n            ‚îú‚îÄ‚îÄ R/\n            ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n            ‚îú‚îÄ‚îÄ README.md\n            ‚îî‚îÄ‚îÄ app.R\n\n2 directories, 4 files\n```\n:::\n\n\n`gghistApp()` renders a `ggplot2` graph, which makes it easier to demonstrate [this example of checking a plot](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the `shinytest2` package website. \n\n::::{.column-page-inset-right}\n\n::: {#fig-sbs_histogramApp_gghistApp layout-ncol=2}\n\n![`histogramApp()`](sbs_histogramApp.png){#fig-sbs_histogramApp}\n\n![`gghistApp()`](sbs_gghistApp.png){#fig-sbs_gghistApp}\n\n\n`histogramApp()` vs. `gghistApp()`\n\n:::\n\n::::\n\nThe `gghistApp()` is similar to `histogramApp()`, but instead of using `hist()` to generate the plot, a reactive `plot_obj()` is passed to `shiny::renderPlot()` (like the example above).\n\nDue to the structure of the modules in the application, the `exportTestValues()` function is placed in the `gghistServer()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide gghistServer()\"}\ngghistServer <- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj <- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist <- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |>\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n```\n:::\n\n\n-   `gghistServer()` is replaces `histogramServer()` in the standalone app function (`gghistApp()`): \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide gghistApp()\"}\n    gghistApp <- function() {\n      ui <- shiny::fluidPage(\n        shiny::sidebarLayout(\n          shiny::sidebarPanel(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n          ),\n          shiny::mainPanel(\n            histogramOutput(\"hist\"),\n            shiny::verbatimTextOutput(\"vals\")\n          )\n        )\n      )\n    \n      server <- function(input, output, session) {\n    \n        data <- datasetServer(\"data\")\n    \n        x <- selectVarServer(\"var\", data)\n    \n        gghistServer(\"hist\", x)\n    \n        output$vals <- shiny::renderPrint({\n          x <- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n          print(x, width = 30, max.levels = NULL)\n          }, width = 30)\n    \n      }\n    \n      shiny::shinyApp(ui, server)\n    }\n    ```\n    :::\n\n\nIn the `test-shinytest2-gghistApp.R` test file, I'll verify the [`vdiffr` package](https://vdiffr.r-lib.org/) is installed with `testthat::skip_if_not_installed()`, then create the `AppDriver` object with a call to `system.file()` and set the `height` and `width`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n```\n:::\n\n\nView the application in the Chromium browser by running `app$view()` in the **Console**:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napp$view()\n```\n:::\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_gghistApp layout-ncol=1}\n\n![`app$view()`](app_view_gghistApp.png){#fig-app_view_gghistApp}\n\nView `gghistApp()` application with `app$view()`\n:::\n\n::::\n\nI'll replicate the [example](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the website using the `gghistApp()`:\n\n### Verify initial [`input`]{style=\"font-size: 1.20em\"}\n\n-   The first expectations in the example test the default `input` values with **`app$get_value(input = )`**:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      # Verify initial data\n      app_init_data <- app$get_value(input = \"data-dataset\")\n      testthat::expect_equal(\n        object = app_init_data,\n        expected = \"BOD\")\n    \n      # Verify initial variable\n      app_init_var <- app$get_value(input = \"var-var\")\n      testthat::expect_equal(\n        object = app_init_var,\n        expected = \"Time\")\n    ```\n    :::\n\n    \n### Set and verify [`export`]{style=\"font-size: 1.20em\"}\n    \n-   Next, we check the exported values after changing the inputs with `app$set_values()` and **`app$get_value(export = )`**\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      # Verify exported `x()` data\n      app$set_inputs(`data-dataset` = \"mtcars\")\n      app_exp_x_01 <- app$get_value(export = \"hist-x\")\n      testthat::expect_equal(\n        object = app_exp_x_01, \n        expected = mtcars[1])\n      \n      # Verify exported `plot_obj()` data\n      app$set_inputs(`var-var` = \"wt\")\n      app_exp_plot_obj_01 <- app$get_value(export = \"hist-plot_obj\")\n      testthat::expect_equal(\n        object = app_exp_plot_obj_01,\n        expected = purrr::as_vector(app_exp_plot_obj_01))\n    ```\n    :::\n\n    \n-   The `bins` are also set to a new value with `app$set_inputs()` *after* verifying the exported values:\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      # Verify `hist-bins` changes\n      app$set_inputs(`hist-bins` = 15)\n      app_set_bins_01 <- app$get_value(input = \"hist-bins\")\n      testthat::expect_equal(\n        object = app_set_bins_01,\n        expected = 15)\n    ```\n    :::\n\n    \n::::{.column-page-inset-right}\n\n::: {#fig-app_view_set_inputs_gghistApp layout-ncol=1}\n\n![`set_inputs()` and `get_value()` in `gghistApp()` ](app_view_set_inputs_gghistApp.png){#fig-app_view_set_inputs_gghistApp width=100%}\n\nSet `input`s and get `export`ed values in `gghistApp()`\n:::\n\n::::\n    \n### Verify plot with [`vdiffr`]{style=\"font-size: 1.20em\"}\n\n-   Now we verify the plot with the exported `plot_obj` (in the `hist` module) with `expect_doppelganger()` from the `vdiffr` package. \n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      # Verify `hist-plot_obj` changes\n      plot_obj_15 <- app$get_value(export = \"hist-plot_obj\")\n      vdiffr::expect_doppelganger(\n        title = \"hist-plot_obj-15\",\n        fig = plot_obj_15)\n    ```\n    :::\n\n    \n    -   *I saved the test file and ran the test to confirm the snapshot file was created in `tests/testthat/_snaps/`*:\n    \n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n    ‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\n    Adding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n    ```\n    :::\n\n    \n### [`set_`, `get_`, `expect_`]{style=\"font-size: 1.10em\"}\n\nThe process above is repeated with new values passed to **`app$set_inputs()`** and verified with **`app$get_value(export = )`**:\n    \n-   The `x()`, `plot_obj()` and `hist-bins` are updated again with new values: \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      ## Update `data` to USArrests\n      app$set_inputs(`data-dataset` = \"USArrests\")\n      app_exp_x_02 <- app$get_value(export = \"hist-x\")\n      testthat::expect_equal(\n        object = app_exp_x_02,\n        expected = USArrests[1])\n    \n      ## Update `var` to UrbanPop\n      app$set_inputs(`var-var` = \"UrbanPop\")\n      app_exp_plot_obj_02 <- app$get_value(export = \"hist-plot_obj\")\n      testthat::expect_equal(\n        object = app_exp_plot_obj_02,\n        expected = purrr::as_vector(app_exp_plot_obj_02))\n    \n      ## Update `bins` to 12\n      app$set_inputs(`hist-bins` = 12)\n      app_set_bins_02 <- app$get_value(input = \"hist-bins\")\n      expect_equal(\n        object = app_set_bins_02,\n        expected = 12)\n    ```\n    :::\n\n    \n-   The new plot is verified again with `expect_doppelganger()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n      ## Verify updates to `hist-plot_obj`\n      plot_obj_12 <- app$get_value(export = \"hist-plot_obj\")\n      vdiffr::expect_doppelganger(\n        title = \"hist-plot_obj-12\",\n        fig = plot_obj_12)\n    ```\n    :::\n\n\n    -   *This initial run of this test will show a warning again as the snapshot file is saved to `tests/testthat/_snaps/`*:\n    \n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n    ‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\n    Adding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n    [ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n    ```\n    :::\n\n    \n### Results \n\nThe final results of the `test-shinytest2-gghistApp.R` are below:\n    \n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n```\n:::\n\n\nThe vector in each `plot_obj()` test is printed with `expect_doppelganger()`, but this doesn't interfere with the results. \n\nI can run `devtools::test()` to run all the tests in `msst2ap`: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::test()\n```\n:::\n\n\n\n## Recap\n\nThis post has covered creating tests with `testthat` and `shinytest2` for an app-package containing a shiny application (with modules!). As you can see, the test recorder makes it easier to test specific app behaviors, and the `AppDriver` makes it possible to build a set of test expectations iteratively. Other items to consider when writing `shinytest2` tests include: \n\n1. **Define What to Test**: Since Shiny apps are interactive, so `shinytest2` tests should simulate user interaction as much as possible. The tests should focus on key user interactions and the output they should generate. `shinytest2` provides functions for simulating user clicks, inputs, and other interactions. Not every interaction needs to be tested, but crucial ones and those that handle complex logic should be.\n\n2. **Organize Your Tests & Use Descriptive Test Names**: Organize your tests into separate files based on what they are testing. Each test should have a descriptive name that clarifies what the test is for. Organizing your test files with unambiguous names will make it easier to manage multiple tests, and it will make it easier to understand what's going wrong when a test fails.\n\n3. **Create snapshots for expected outputs**: Use snapshot files to verify that an app's output matches the expected results. `AppDriver$expect_values()` generates `.json` and `.png` snapshot files for the application. The .json file contains `input`, `output`, and `export` values, and the .png file is a *debug* screenshot, which records how the app looked when the values where captured. These files can then be compared to a baseline snapshot.\n\n4. **Export app values**: While snapshot files are great for detecting changes, it's important to remember that \"*differences in the captured screenshot will never cause test failures.*\" Manually inspecting the snapshot .png files during test development can also be time-consuming and tedious. Wherever possible, export app values and compare them against expected reference values.\n\nIn general, `shinytest2` is designed for end-to-end testing of shiny applications. These tests can capture the state of a shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots), which is useful for regression testing. \n\n`shinytest2` tests can also simulate user interaction in a way that `shiny::testServer()` tests can't, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. `shinytest2` can also be resource-intensive, so it's recommended to write these tests after you've completed the standard `testthat` unit tests and `testServer()` tests.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}