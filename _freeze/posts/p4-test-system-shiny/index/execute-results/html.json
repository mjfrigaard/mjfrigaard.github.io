{
  "hash": "efcdff970859d89d9d4e6ba20b5dcf1a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shiny system tests with `shinytest2`\" \nsubtitle: \"Part 4: writing efficient system tests\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-10-15\"\ncategories: [shiny, testing]\nimage: \"image.svg\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n# code-block-border-left: true\ncode-block-bg: \"#f8f8f8\"\ncode-block-border-left: \"#e8e8e8\"\ncode-fold: show\ncode-summary: 'show/hide'\ncallout-icon: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [NOTE]{style='font-weight: bold; font-size: 1.20em;'}\n\n::: {style='font-size: 1.10em; color: #282b2d;'}\n\n\n\n  This post has been shortened from the original version. I felt it was too long and duplicative of other resources written better elsewhere. If you'd like to read the previous version, you can find it in the [series section.](https://mjfrigaard.github.io/series.html)\n  \n\n::: \n\n::::\n\n\n\n\nThis is the fourth post in a [series on testing](https://mjfrigaard.github.io/series.html#testing-shiny-applications) Shiny applications. The previous posts have covered using [BDD in unit tests](https://mjfrigaard.github.io/posts/p1-tests-unit-tests/), testing apps [outside of an R package](https://mjfrigaard.github.io/posts/p2-tests-nonpkg-unit-tests/) structure, and [testing module server functions](https://mjfrigaard.github.io/posts/p3-test-shiny-module-tests/). \nIn this post, we'll be covering testing Shiny applications using `testthat` and `shinytest2`.\n\n::: {.column-margin}\n![](img/image.svg){width=70%}\n:::\n\n## App-Packages\n\nIn the previous post, we stored the modules and applications from the [Shiny modules chapter](https://mastering-shiny.org/scaling-modules.html) of Mastering Shiny in the [`mstsap`](https://mjfrigaard.github.io/mstsap/) package. The [`msst2ap`](https://mjfrigaard.github.io/msst2ap/) package contains `shinytest2` tests for the Shiny apps in Mastering Shiny (hence the name: **M**astering **S**hiny **s**hiny**t**est**2** **a**pp-**p**ackage).\n\nYou can install `msst2ap` using the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages(\"remotes\")\nremotes::install_github(\n  \"https://github.com/mjfrigaard/msst2ap\"\n)\n```\n:::\n\n\n\nI've stored development versions of the applications in the [`inst/dev/` folder](https://github.com/mjfrigaard/msst2ap/tree/main/inst/dev) of `msst2ap`:\n\n\n\n\n```{.default}\ninst\n└── dev\n    ├── datasetApp\n    │   ├── DESCRIPTION\n    │   ├── R\n    │   │   └── modules.R\n    │   ├── README.md\n    │   └── app.R\n    ├── gghistApp\n    │   ├── DESCRIPTION\n    │   ├── R\n    │   │   └── modules.R\n    │   ├── README.md\n    │   └── app.R\n    ├── histogramApp\n    │   ├── DESCRIPTION\n    │   ├── R\n    │   │   └── modules.R\n    │   ├── README.md\n    │   └── app.R\n    ├── selectDataVarApp\n    │   ├── DESCRIPTION\n    │   ├── R\n    │   │   └── modules.R\n    │   ├── README.md\n    │   └── app.R\n    └── selectVarApp\n        ├── DESCRIPTION\n        ├── R\n        │   └── modules.R\n        ├── README.md\n        └── app.R\n\n12 directories, 20 files\n```\n\n\n\n### Using [`system.file()`]{style=\"font-size: 1.10em; font-weight: bold;\"}\n\nThe apps stored in the `inst/dev/` directory of `msst2ap` can be passed to the `app_dir` argument of `AppDriver$new()` with `system.file()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: datasetApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"datasetApp\",\n                                             package = \"msst2ap\"),\n                       height = 600,\n                       width = 800)\n  app$view()\n})\n```\n:::\n\n\n\n![](img/app_view_datasetApp.png){width='100%'}\n\n\n\n### Setting inputs \n\nThe first things we'll check is changing the `dataset-dataset` input from `ability.cov` to `attitude` using `app$set_inputs()` (*Note that this uses the module notation above (i.e., `\"id-inputId\"`*):\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"datasetApp\",\n                                             package = \"msst2ap\"),\n                       height = 600,\n                       width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n```\n:::\n\n\n\nIf you can see both windows, you'll see the application values change in the Chromium browser: \n\n::::{.column-page-right}\n\n::: {#fig-set_inputs layout-ncol=1}\n\n![`app$set_inputs()`](img/app_set_inputs.png){#fig-app_set_inputs}\n\nSet application inputs with `app$set_inputs()`\n:::\n\n::::\n\n### Checking inputs\n\nWe can capture values in a list *inside* the test by including a call to `app$get_values()` and assigning the output to `app_values`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: datasetApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"datasetApp\",\n                                             package = \"msst2ap\"),\n                       height = 600,\n                       width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n})\n```\n:::\n\n\n\n`app_values` has a similar structure to the `.json` snapshot covered above (i.e., with `input`, `output`, and `export`): \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nstr(app_values)\n```\n:::\n\n\n```{.default}\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"<table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'>\\n<thead> <tr\"..\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n```\n\n\n\nWe can use `waldo::compare()` to verify the `input` in `app_values` to verify the value that we changed with `app$set_inputs()` \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nwaldo::compare(\n  x = app_values$input$`dataset-dataset`,\n  y = \"attitude\"\n)\n```\n:::\n\n\n```{.default}\n✔ No differences\n```\n\n\n\n`waldo::compare()` can easily be adapted to a new test expectation: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: datasetApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"datasetApp\",\n                                             package = \"msst2ap\"),\n                       height = 600,\n                       width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  waldo::compare(x = app_values$input$`dataset-dataset`,\n                 y = \"attitude\")\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n```\n:::\n\n\n\nAt the end of the test, I'll add a call [`app$stop()`](https://rstudio.github.io/shinytest2/articles/zzz-faq.html#should-i-manually-shut-down-my-appdriver) to close the Chromium app.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: datasetApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"datasetApp\",\n                                             package = \"msst2ap\"),\n                       height = 600,\n                       width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  waldo::compare(x = app_values$input$`dataset-dataset`,\n                 y = \"attitude\")\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n```\n:::\n\n\n\n## Exporting test values \n\nThe `shinytest2` documentation repeatedly[^export-test-vals-rec-01] recommends[^export-test-vals-rec-02] exporting test values from Shiny applications. We'll use the application stored in `inst/dev/selectVarApp/` to explore exporting test values.\n\n[^export-test-vals-rec-01]: \"*In some cases, it’s useful to snapshot some bits of internal state of an application – state that’s not reflected directly in the inputs or outputs. This can be done by exporting values.*\" - [`shinytest2` documentation](https://rstudio.github.io/shinytest2/articles/in-depth.html#exported-values)\n\n[^export-test-vals-rec-02]: \"*It cannot be recommended enough to use `exportTestValues()` to test your Shiny app’s reactive values.*\" -  [`shinytest2` documentation](https://rstudio.github.io/shinytest2/articles/robust.html#exported-values)\n\nThe application in the `inst/dev/selectVarApp/` folder of `msst2ap` includes a call to `exportTestValues()` and the `test.mode` option set to `TRUE` in the call to `shinyApp()`.[^export-test-values]\n\n[^export-test-values]: Read more about exporting test values [here](https://shiny.posit.co/r/reference/shiny/1.0.2/exporttestvalues).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nserver <- function(input, output, session) {\n  data <- datasetServer(\"data\")\n  var <- selectVarServer(\"var\", data, filter = filter)\n\n  output$out <- renderTable(head(var()))\n\n  output$vals <- renderPrint({\n    x <- reactiveValuesToList(input,\n      all.names = TRUE\n    )\n    print(x)\n  })\n\n  exportTestValues(\n    var = var(),\n    data = data()\n  )\n}\n```\n:::\n\n\n\n\nThe test for this application contains the same `system.file()` call to create the `AppDriver` object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 1200, width = 1000)\n})\n```\n:::\n\n\n\nAfter entering `app$view()` in the **Console**, the application opens in the Chromium headless browser again:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napp$view()\n```\n:::\n\n\n\nWe can see `selectVarApp` has been launched in showcase mode, so the `README` and code files are displayed in the UI.\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_selectVarApp layout-ncol=1}\n\n![`app$view()`](img/app_view_selectVarApp.png){#fig-app_view_selectVarApp}\n\nView `selectVarApp()` application with `app$view()`\n:::\n\n::::\n\nIn our test file, we'll use `app$set_values()` to change the ```` $`data-dataset` ```` and ```` $`var-var` ```` inputs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 1200, width = 1000)\n  \n  app$set_inputs(`data-dataset` = \"mtcars\") # <1>\n})\n```\n:::\n\n\n1. Change ```` $`data-dataset` ```` to `mtcars`\n\nWe'll also change the variable input from `mpg` to `wt` and verify the output in the UI:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 1200, width = 1000)\n  \n  app$set_inputs(`data-dataset` = \"mtcars\") # <1>\n  app$set_inputs(`var-var` = \"wt\") # <2>\n})\n```\n:::\n\n\n1. Change ```` $`data-dataset` ```` to `mtcars`\n2. Change ```` $`var-var` ```` to `wt`\n\n\nThe printed `reactiveValuesToList()` is updated UI when the `selectInput()` changes:\n\n::::{.column-body-outset-right}\n\n::: {#fig-selectVarApp_changes layout-ncol=1}\n\n![Set `data-dataset`](img/selectVarApp_changes.gif){#fig-selectVarApp_changes}\n\nView `selectVarApp()` after setting `data-dataset` and `var-var` with `app$set_inputs()`\n:::\n\n::::\n\n### Getting values\n\nWe'll use `app$get_values()` to store the exported `input`, `output`, and `export` test values in `app_values`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 1200, width = 1000)\n\n  app$set_inputs(`data-dataset` = \"mtcars\") # <1>\n  app$set_inputs(`var-var` = \"wt\") # <2>\n\n  app_values <- app$get_values() # <3>\n})\n```\n:::\n\n\n1. Change ```` $`data-dataset` ```` to `mtcars`\n2. Change ```` $`var-var` ```` to `wt`\n3. Assign to `app_values` list\n\n`app_values` is a list (similar to the `.json` snapshot file), but now we've explicitly exported values from the server in `selectVarApp()`: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnames(app_values$export)\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[1] \"data\" \"var\" \n```\n:::\n\n\n\n### Expectations\n\nWe can use `app_values` to verify the structure of each exported object: \n\n-   `data` should be a `data.frame()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::expect_true(\n  object = is.data.frame(app_values$export$data)\n)\n```\n:::\n\n\n\n-   `var` should be have one column:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::expect_true(\n  object = ncol(app_values$export$var) == 1)\n```\n:::\n\n\n\nOnce again, we end the test with a call to `app$stop()`. The completed test for `selectVarApp()` is below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide mstsap::selectVarApp test\"}\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 1200, width = 1000)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values <- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n```\n:::\n\n\n\n## Testing complex outputs \n\n`msst2ap` has the [`histogramApp()` from Mastering Shiny](https://mastering-shiny.org/scaling-modules.html#case-study-histogram) in `inst/dev/histogramApp/`, and a `ggplot2` version of the `histogramApp()` in the `inst/dev/ggHistApp/` folder:\n\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\ninst\n└── dev\n    ├── ggHistApp\n    │   ├── DESCRIPTION\n    │   ├── R\n    │   │   └── modules.R\n    │   ├── README.md\n    │   └── app.R\n    └── histogramApp\n        ├── DESCRIPTION\n        ├── R\n        │   └── modules.R\n        ├── README.md\n        └── app.R\n\n6 directories, 8 files\n```\n:::\n\n\n\n:::: {layout=\"[49,-2,49]\" layout-valign=\"top\"}\n\n::: {#fig-sbs_histogramApp_ggHistApp layout-ncol=2}\n\n![`histogramApp()`](img/sbs_histogramApp.png){#fig-sbs_histogramApp}\n\n![`ggHistApp()`](img/sbs_ggHistApp.png){#fig-sbs_ggHistApp}\n\n\n`histogramApp()` vs. `ggHistApp()`\n\n:::\n\n::::\n\n### Testing reactive values\n\nThe module server functions in `histogramApp()` return two values: `data` and `x`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nserver <- function(input, output, session) {\n  \n  data <- datasetServer(\"data\")\n  x <- selectVarServer(\"var\", data)\n  \n  histogramServer(\"hist\", x)\n\n  output$vals <- shiny::renderPrint({\n    x <- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n\n}\n```\n:::\n\n\n\n`data` is returned reactive from `datasetServer()` and becomes an input parameter for `selectVarServer()`, and `x` is the returned reactive. \n\nBoth of these are reactive values, but they aren't treated like returned values from the `reactive()` function (i.e., they don't have parentheses). These are passed in the server as reactive *expressions*, which we can confirm using `exportTestValues()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide msst2ap::histogramApp() server\"}\nserver <- function(input, output, session) {\n  data <- datasetServer(\"data\")\n  x <- selectVarServer(\"var\", data)\n  histogramServer(\"hist\", x)\n\n  # remaining code omitted\n  \n  exportTestValues( # <1>\n      data = data,\n      x = x\n    ) # <1>\n}\n```\n:::\n\n\n1. We've also added `options(shiny.testmode = TRUE)` to the top of the `app.R` file.\n\nIn the test for `histogramApp()`, we'll create the app with `AppDriver$new()` and change the three inputs using `app$set_inputs()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: histogramApp\", {\n  app <- AppDriver$new(system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\"),\n                       height = 750,\n                       width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_values <- app$get_values()\n  names(app_values)\n})\n```\n:::\n\n\n```{.default}\n[1] \"data\" \"x\"  \n```\n\n\n\nWe'll test is these are reactive functions by combining `rlang::is_function()` and `shiny::is.reactive()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: histogramApp\", {\n  app <- AppDriver$new(system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\"),\n                       height = 750,\n                       width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_values <- app$get_values()\n  names(app_values)\n  expect_equal(\n    rlang::is_function(app_values$export$data),\n    shiny::is.reactive(app_values$export$data))\n  expect_equal(\n    rlang::is_function(app_values$export$x),\n    shiny::is.reactive(app_values$export$x))\n})\n```\n:::\n\n\n\n### Using app logs \n\n`shinytest2` also has the handy `get_logs()` that allows us to check the logs for specific functionality. Below is the output from `get_logs()` from `histogramApp()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: histogramApp\", {\n  app <- AppDriver$new(system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\"),\n                       height = 750,\n                       width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_logs <- app$get_logs() # <1>\n  str(app_logs) # <2>\n})\n```\n:::\n\n\n1. Create app logs \n2. View log structure\n\n\n\n\n```{.default}\nClasses ‘shinytest2_log’ and 'data.frame':\t56 obs. of  5 variables:\n $ workerid : chr  NA NA NA NA ...\n $ timestamp: POSIXct, format: \"2024-03-31 04:47:41\" \"2024-03-31 04:47:41\" ...\n $ location : chr  \"shinytest2\" \"shinytest2\" \"shinytest2\" \"shinytest2\" ...\n $ level    : chr  \"info\" \"info\" \"info\" \"info\" ...\n $ message  : chr  \"Start AppDriver initialization\" \"Starting Shiny app\" \"Creating \"..\n```\n\n\n\nAfter changing the three inputs with `set_inputs()`, we can check the output to see these actions were included in the logs:\n \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: histogramApp\", {\n  app <- AppDriver$new(system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\"),\n                       height = 750,\n                       width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_values <- app$get_values()\n  names(app_values)\n  expect_equal(\n    rlang::is_function(app_values$export$data),\n    shiny::is.reactive(app_values$export$data))\n  expect_equal(\n    rlang::is_function(app_values$export$x),\n    shiny::is.reactive(app_values$export$x))\n  app$set_inputs(`hist-bins` = 15)\n  app_logs <- app$get_logs() # <1>\n  ds_msg <- subset(app_logs,  # <2>\n                   message == \"Setting inputs: 'data-dataset'\")  # <2>\n  expect_equal(nrow(ds_msg), 1L) # <2>\n  var_msg <- subset(app_logs,  # <3>\n                    message == \"Setting inputs: 'var-var'\")\n  expect_equal(nrow(var_msg), 1L) # <3>\n  hist_msg <- subset(app_logs,  # <4>\n                     message == \"Setting inputs: 'hist-bins'\")\n  expect_equal(nrow(hist_msg), 1L) # <4>\n})\n```\n:::\n\n\n1. Create app logs  \n2. Create and test dataset  \n3. Create and test variable  \n4. Create and test bins  \n\nLogs can also be passed from the test to the application using [`log_message()`](https://rstudio.github.io/shinytest2/reference/AppDriver.html#method-log-message-).\n\n### Verify initial [`input`]{style=\"font-size: 1.10em; font-weight: bold;\"}s\n\nThe `ggHistApp()` app is similar to `histogramApp()`, but instead of passing a reactive vector to `hist()`, `ggHistServer()` passes a reactive one-column `data.frame` (`x()`) to the `ggplot2` functions. We'll add `exportTestValues()` to a development version of `ggHistServer()` in `inst/dev/`: [^replicate-robust-testing]\n\n[^replicate-robust-testing]: This section replicates these [test examples from `shinytest2` ](https://rstudio.github.io/shinytest2/articles/robust.html#example) using the `ggHistApp()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide ggHistServer()\"}\nggHistServer <- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(is.reactive(x))\n  stopifnot(is.reactive(title))\n\n  moduleServer(id, function(input, output, session) {\n    \n    gg2_plot <- reactive({ # <1>\n      ggplot2::ggplot(\n          mapping =\n            ggplot2::aes(purrr::as_vector(x()))\n        ) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())\n          ) +\n          ggplot2::theme_minimal()\n    }) # <1>\n\n    observe({ # <2>\n      output$hist <- renderPlot({gg2_plot()}, res = 124)\n    }) |> \n      bindEvent(c(x(), title(), input$bins)) # <2>\n\n    exportTestValues( # <3>\n      bins = input$bins,\n      x = x(),\n      title = title()\n    ) # <3>\n\n    # remaining code omitted\n    \n  })\n}\n```\n:::\n\n\n1. Build `ggplot2` graph \n2. Render plot  \n3. Export bins, `x()` and `title()`\n\nThe version of `ggHistServer()` above replaces the `ggHistServer()` used in the standalone app function).[^load-modules-from-inst] The remaining modules from `mstsap` are explicitly namespaced. The code below identifies the location of each module in `ggHistApp()`: [^load-app-from-inst]\n\n[^load-modules-from-inst]: This version is loaded from a `inst/dev/histogramApp/R/modules.R` file.\n\n[^load-app-from-inst]: This version is loaded from a `inst/dev/histogramApp/R/app.R` file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide ggHistApp()\"}\nggHistApp <- function() {\n  ui <- fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        mstsap::datasetInput(\"data\", is.data.frame),\n        mstsap::selectVarInput(\"var\"),\n      ),\n      mainPanel(\n        histogramOutput(\"hist\"), # <1>\n        code(\"app vals\"),\n        verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server <- function(input, output, session) {\n    data <- mstsap::datasetServer(\"data\")\n    x <- ggSelectVarServer(\"var\", data) # <2>\n    ggHistServer(\"hist\", x) # <3>\n\n    output$vals <- renderPrint({\n        x <- reactiveValuesToList(input,\n          all.names = TRUE)\n        print(x, width = 30, max.levels = NULL)},\n      width = 30)\n  }\n  \n    exportTestValues( # <4>\n      x = x(),\n      data = data(),\n      react_x = x,\n      react_data = data\n    ) # <4>\n\n  shinyApp(ui, server)\n}\nggHistApp()\n```\n:::\n\n\n1. From `R/histogramOutput.R`  \n2. From `R/ggSelectVarServer.R`  \n3. From `inst/dev/ggHistApp/R/modules.R`\n4. Exported test values \n\nIn the `test-shinytest2-ggHistApp.R` test file, I'll verify the [`vdiffr` package](https://vdiffr.r-lib.org/) is installed, then create the `AppDriver` object with a call to `system.file()` and set the `height` and `width`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: ggHistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n  app_pth <- system.file(\"dev\", \"ggHistApp\",\n                                  package = \"msst2ap\")\n  app <- AppDriver$new(app_pth,\n                       height = 750, width = 1200)\n})\n```\n:::\n\n\n\nView the application in the Chromium browser by running `app$view()` in the **Console**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napp$view()\n```\n:::\n\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_ggHistApp layout-ncol=1}\n\n![`app$view()`](img/app_view_ggHistApp.png){#fig-app_view_ggHistApp}\n\nView `ggHistApp()` application with `app$view()`\n:::\n\n::::\n\nThe first expectations in the example test the default `input` values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  testthat::skip_if_not_installed(\"vdiffr\")\n\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n\n  app_init_data <- app$get_value(input = \"data-dataset\") # <1>\n  waldo::compare(app_init_data, \"BOD\")\n  expect_equal(\n    object = app_init_data,\n    expected = \"BOD\") # <1>\n\n  app_init_var <- app$get_value(input = \"var-var\") # <2>\n  waldo::compare(app_init_var, \"Time\")\n  expect_equal(\n    object = app_init_var,\n    expected = \"Time\") # <2>\n})\n```\n:::\n\n\n1. Verify initial data\n2. Verify initial variable\n    \n### Set and verify [`export`]{style=\"font-size: 1.10em; font-weight: bold;\"}\n    \nNext, we check changing the input values with **`app$set_values(id-inputId)`**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  testthat::skip_if_not_installed(\"vdiffr\")\n\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n\n  app_init_data <- app$get_value(input = \"data-dataset\") # <1>\n  waldo::compare(app_init_data, \"BOD\")\n  expect_equal(\n    object = app_init_data,\n    expected = \"BOD\") # <1>\n\n  app_init_var <- app$get_value(input = \"var-var\") # <2>\n  waldo::compare(app_init_var, \"Time\")\n  expect_equal(\n    object = app_init_var,\n    expected = \"Time\") # <2>\n  \n  app$set_inputs(`data-dataset` = \"mtcars\") # <3>\n  app_exp_x_01 <- app$get_value(export = \"hist-x\")\n  waldo::compare(\n    x = app_exp_x_01,\n    y = mtcars[1])\n  expect_equal(\n    object = app_exp_x_01,\n    expected = mtcars[1]) # <3>\n\n  app$set_inputs(`var-var` = \"disp\") # <4>\n  app_exp_plot_obj_01 <- app$get_value(export = \"hist-plot_obj\")\n  waldo::compare(\n    x = app_exp_plot_obj_01,\n    y = purrr::as_vector(mtcars['disp']))\n  expect_equal(\n    object = app_exp_plot_obj_01,\n    expected = purrr::as_vector(mtcars['disp'])) # <4>\n\n  app$set_inputs(`hist-bins` = 15) # <5>\n  app_set_bins_01 <- app$get_value(input = \"hist-bins\")\n  waldo::compare(app_set_bins_01, 15L)\n  expect_equal(\n    object = app_set_bins_01,\n    expected = 15) # <5>\n})\n```\n:::\n\n\n1. Verify initial data\n2. Verify initial variable \n3. Verify exported data \n4. Verify exported var \n5. Verify histogram changes \n\n### Verify [`export`]{style=\"font-size: 1.10em; font-weight: bold;\"}s\n\nFinally, we'll test the exported values by creating **`app$get_values()$export`** and checking it's contents:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  testthat::skip_if_not_installed(\"vdiffr\")\n\n  app <- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n\n  app_init_data <- app$get_value(input = \"data-dataset\") # <1>\n  waldo::compare(app_init_data, \"BOD\")\n  expect_equal(\n    object = app_init_data,\n    expected = \"BOD\") # <1>\n\n  app_init_var <- app$get_value(input = \"var-var\") # <2>\n  waldo::compare(app_init_var, \"Time\")\n  expect_equal(\n    object = app_init_var,\n    expected = \"Time\") # <2>\n  \n  app$set_inputs(`data-dataset` = \"mtcars\") # <3>\n  app_exp_x_01 <- app$get_value(export = \"hist-x\")\n  waldo::compare(\n    x = app_exp_x_01,\n    y = mtcars[1])\n  expect_equal(\n    object = app_exp_x_01,\n    expected = mtcars[1]) # <3>\n\n  app$set_inputs(`var-var` = \"disp\") # <4>\n  app_exp_plot_obj_01 <- app$get_value(export = \"hist-plot_obj\")\n  waldo::compare(\n    x = app_exp_plot_obj_01,\n    y = purrr::as_vector(mtcars['disp']))\n  expect_equal(\n    object = app_exp_plot_obj_01,\n    expected = purrr::as_vector(mtcars['disp'])) # <4>\n\n  app$set_inputs(`hist-bins` = 15) # <5>\n  app_set_bins_01 <- app$get_value(input = \"hist-bins\")\n  waldo::compare(app_set_bins_01, 15L)\n  expect_equal(\n    object = app_set_bins_01,\n    expected = 15) # <5>\n\n  \n  exp_values <- app$get_values()$export # <6>\n\n  expect_true(is.data.frame(exp_values$`hist-x`)) # <7>\n  expect_equal(exp_values$`hist-x`, mtcars['disp']) # <8>\n\n  expect_true(is.numeric(exp_values$`hist-plot_obj`)) # <9>\n  expect_equal( # <10>\n    object = exp_values$`hist-plot_obj`,\n    expected = purrr::as_vector(mtcars['disp'])) # <10>\n})\n```\n:::\n\n\n1. Verify initial data\n2. Verify initial variable \n3. Verify exported data \n4. Verify exported var \n5. Verify histogram changes\n6. Export expected values \n7. Verify hist-x is data.frame \n8. Verify hist-x is correct column \n9. Verify hist-plot_obj is numeric \n10. Verify hist-plot_obj is vector  \n\n### Verify plot with [`vdiffr`]{style=\"font-size: 1.10em; font-weight: bold;\"}\n\nNow we verify the plot with the exported `plot_obj` (in the `hist` module) with `expect_doppelganger()` from the `vdiffr` package. \n    \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ngg2_plot <- app$get_value(output = \"hist-hist\")\n  expect_equal(gg2_plot$alt, \"Plot object\") # <1>\n  vdiffr::expect_doppelganger( # <2>\n      title = \"mtcars_disp_plot\",\n      fig = ggplot2::ggplot(data = exp_values$`hist-x`,\n              mapping =\n              ggplot2::aes(x = disp)\n          ) +\n            ggplot2::geom_histogram(bins = exp_values$`hist-bins`) +\n            ggplot2::labs(\n              title = paste0(exp_values$`hist-title`,\n                             \" [bins = \",\n                             exp_values$`hist-bins`, \"]\"),\n              y = \"Count\",\n              x = names(exp_values$`hist-x`)\n            ) +\n            ggplot2::theme_minimal()\n      ) # <2>\n```\n:::\n\n\n1. Check the rendered plot object  \n2. `ggHistApp()` renders a `ggplot2` graph, which makes it easier to demonstrate [this example of checking a plot](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the `shinytest2` package website. \n    \n*I saved the test file and ran the test to confirm the snapshot file was created in `tests/testthat/_snaps/`*:\n    \n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n── Warning (test-shinytest2-gghistApp.R:72:3): {shinytest2}: gghistApp ─────────\nAdding new file snapshot: 'tests/testthat/_snaps/mtcars-disp-plot.svg'\n```\n:::\n\n\n\n### Set, get, expect\n\nThe process above is repeated with new values passed to **`app$set_inputs()`** and verified with **`app$get_values()`**:\n    \n-   The `data-dataset`, `var-var`, and `hist-bins` are updated again with new values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# verify usaarrests_plot ---- \napp$set_inputs(`data-dataset` = \"USArrests\")\napp$set_inputs(`var-var` = 'UrbanPop')\napp$set_inputs(`hist-bins` = 15)\n```\n:::\n\n\n    \n-   The updated values are exported automatically with `exportTestValues()` and stored in `exp_values`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# export values \nexp_values <- app$get_values()$export\n```\n:::\n\n\n\n-   The new plot is verified again with `expect_doppelganger()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nvdiffr::expect_doppelganger(\n  title = \"usaarrests_plot\",\n  fig = ggplot2::ggplot(data = exp_values$`hist-x`,\n          mapping =\n          ggplot2::aes(x = UrbanPop)\n      ) + \n        ggplot2::geom_histogram(bins = exp_values$`hist-bins`) +\n        ggplot2::labs(\n          title = paste0(exp_values$`hist-title`, \n                         \" [bins = \",\n                         exp_values$`hist-bins`, \"]\"),\n          y = \"Count\",\n          x = names(exp_values$`hist-x`)\n        ) +\n        ggplot2::theme_minimal()\n  )\n```\n:::\n\n\n\nNow that we have a template, we can set, get, and expect multiple plot snapshots:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  ## SET -----\n  app$set_inputs(`data-dataset` = \"sleep\")\n  app$set_inputs(`var-var` = 'extra')\n  app$set_inputs(`hist-bins` = 8)\n  # GET ----\n  exp_values <- app$get_values()$export\n  # EXPECT ----\n  vdiffr::expect_doppelganger(\n    title = \"sleep_extra_plot\",\n    fig = ggplot2::ggplot(data = exp_values$data,\n            mapping =\n            ggplot2::aes(x = extra)\n        ) + \n          ggplot2::geom_histogram(bins = exp_values$`hist-bins`) +\n          ggplot2::labs(\n            title = paste0(exp_values$`hist-title`, \n                           \" [bins = \",\n                           exp_values$`hist-bins`, \"]\"),\n            y = \"Count\",\n            x = names(exp_values$x)\n          ) +\n          ggplot2::theme_minimal()\n    )\n```\n:::\n\n\n\n\nThe initial run of this test will save the snapshot file to `tests/testthat/_snaps/`:\n\n\n\n\n```{.default}\ntests/testthat/_snaps/shinytest2-gghistApp\n├── mtcars-disp-plot.svg\n├── sleep-extra-plot.svg\n└── usaarrests-plot.svg\n\n1 directory, 3 files\n```\n\n\n    \n### Results \n\nThe final results of `devtools::test()`  in `msst2ap` are below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::test()\n```\n:::\n\n\n```{.default}\n==> devtools::test()\n\nℹ Testing msst2ap\n✔ | F W  S  OK | Context\n✔ |          1 | shinytest2-datasetApp [4.8s]                                                   \n⠼ |          5 | shinytest2-gghistApp       \n⠋ |         11 | shinytest2-gghistApp                                   \n⠙ |         12 | shinytest2-gghistApp                       \n✔ |         13 | shinytest2-gghistApp [5.1s]                                \n✔ |          5 | shinytest2-histogramApp [3.6s]                                                 \n✔ |          2 | shinytest2-selectVarApp [2.2s]                                                 \n✔ |          1 | shinytest2 [4.2s]                                                              \n\n══ Results ══════════════════════════════════════════════════════════════════\nDuration: 19.9 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 22 ]\n```\n\n\n\n## Recap\n\nThis post has covered creating tests with `testthat` and `shinytest2` for an app-package containing a Shiny application. In general, `shinytest2` is designed for end-to-end testing of Shiny applications. System tests (or regression testing) can capture the state of a Shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots). As we can see, `shinytest2` makes it easier to test specific app behaviors and set expectations iteratively with the `AppDriver`.\n\n`shinytest2` tests can also simulate user interaction in a way that `testServer()` tests can't, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. `shinytest2` can also be resource-intensive, so it's recommended to write these tests after you've completed the standard `testthat` unit tests and `testServer()` tests.\n\nOther things to consider when writing `shinytest2` tests include: \n\n1. **Define What to Test**: Since Shiny apps are interactive, so `shinytest2` tests should simulate user interaction as much as possible. The tests should focus on key user interactions and the output they should generate. `shinytest2` provides functions for simulating user clicks, inputs, and other interactions. Not every interaction needs to be tested, but crucial ones and those that handle complex logic should be.\n\n2. **Organize Your Tests & Use Descriptive Test Names**: Organize your tests into separate files based on the app or feature they test. Each test should have a descriptive name that clarifies what the test is for. Organizing your test files with unambiguous names will make it easier to manage multiple tests, and it will make it easier to understand what's going wrong when a test fails.\n\n3. **Create snapshots for expected outputs**: Use snapshot files to verify that an app's output matches the expected results. `AppDriver$expect_values()` generates `.json` and `.png` snapshot files for the application. The .json file contains `input`, `output`, and `export` values, and the .png file is a *debug* screenshot, which records how the app looked when the values where captured. These files can then be compared to a baseline snapshot.\n\n4. **Export app values**: While snapshot files are great for detecting changes, it's important to remember that \"*differences in the captured screenshot will never cause test failures.*\" Manually inspecting the snapshot .png files during test development can also be time-consuming and tedious. Wherever possible, export app values and compare them against expected reference values.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}