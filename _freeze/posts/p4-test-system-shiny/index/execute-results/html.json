{
  "hash": "c0ad5d14ab1cda8a6f9ebfacdbf8f1f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shiny system tests with `shinytest2`\" \nsubtitle: \"Part 4: writing efficient system tests\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-07-04\"\ncategories: [shiny, testing]\nimage: \"image.svg\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n# code-block-border-left: true\ncode-block-bg: \"#f8f8f8\"\ncode-block-border-left: \"#e8e8e8\"\ncode-fold: show\ncode-summary: 'show/hide'\ncallout-icon: false\n\nfreeze: true\n\nexecute:\n  echo: true\n  message: false\n  warning: false\n  eval: false\n---\n\n\n\n\n:::: {.callout-important collapse='false' appearance='default' icon=false}\n\n## [NOTE]{style='font-weight: bold; font-size: 1.20em;'}\n\n::: {style='font-size: 1.10em; color: #282b2d;'}\n\n\n\n  This post has been shortened from the original version. I felt it was too long and duplicative of other resources written better elsewhere. If you'd like to read the previous version, you can find it in the [series section.](https://mjfrigaard.github.io/series.html)\n  \n\n::: \n\n::::\n\n\n\nThis is the fourth post in a [series on testing](https://mjfrigaard.github.io/series.html#testing-shiny-applications) Shiny applications. The previous posts have covered using [BDD in unit tests](https://mjfrigaard.github.io/posts/p1-tests-unit-tests/), testing apps [outside of an R package](https://mjfrigaard.github.io/posts/p2-tests-nonpkg-unit-tests/) structure, and [testing module server functions](https://mjfrigaard.github.io/posts/p3-test-shiny-module-tests/). \nIn this post, we'll be covering testing Shiny applications using `testthat` and `shinytest2`.\n\n::: {.column-margin}\n![](img/image.svg){width=70%}\n:::\n\n## App-Package Contents\n\nIn the previous post, we stored the modules and applications from the [Shiny modules chapter](https://mastering-shiny.org/scaling-modules.html) of Mastering Shiny in the [`mstsap`](https://github.com/mjfrigaard/sapkgs/tree/mstsap) branch of `sapkgs`, which you can install using the code below: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages(\"remotes\")\nremotes::install_github(\n  \"https://github.com/mjfrigaard/sapkgs\",\n  ref = \"mstsap\"\n)\n```\n:::\n\n\nThe [`msst2ap`](https://github.com/mjfrigaard/sapkgs/tree/msst2ap) branch of `sapkgs` contains `shinytest2` tests for the Shiny apps in `mstsap` (hence the name: **M**astering **S**hiny **s**hiny**t**est**2** **a**pp-**p**ackage).  \n\nYou can install `msst2ap` using the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages(\"remotes\")\nremotes::install_github(\n  \"https://github.com/mjfrigaard/sapkgs\",\n  ref = \"msst2ap\"\n)\n```\n:::\n\n\nThe beauty of R packages is that we can use the modules we developed in the previous `mstsap` branch as a dependency for `msst2ap` by adding this package to the `Depends` field of the `DESCRIPTION` file (this will automatically attach the `mstsap` to the search list when `msst2ap` is loaded). \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::load_all()\n```\n:::\n\n\n```{.default}\nℹ Loading msst2ap\nLoading required package: mstsap\n```\n\n\nI've stored development versions of the applications in the [`inst/dev/` folder](https://github.com/mjfrigaard/sapkgs/tree/mstsap/inst/dev) of `mstsap`:\n\n\n\n```{.default}\ninst/\n  └── dev/\n      ├── datasetApp/\n      │   ├── DESCRIPTION\n      │   ├── app.R\n      │   └── modules.R\n      ├── selectDataVarApp/\n      │   ├── DESCRIPTION\n      │   ├── README.md\n      │   ├── app.R\n      │   └── modules.R\n      └── selectVarApp/\n          ├── DESCRIPTION\n          ├── README.md\n          ├── app.R\n          ├── modules.R\n          └── utils.R\n```\n\n\n### Using [`system.file()`]{style=\"font-size: 1.10em; font-weight: bold;\"}\n\nThe apps stored in the `inst/dev/` directory of `mstsap` can be passed to the `app_dir` argument of `AppDriver$new()` with `system.file()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app_pth <- system.file(\"dev\", \"datasetApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_dir = app_pth, height = 600, width = 800)\n  app$view()\n})\n```\n:::\n\n\n![](img/app_view_datasetApp.png){width='100%'}\n\nThe first things we'll check with our test is the window size we've provided and the `system.file()` path to the `datasetApp` in `mstsap`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app_pth <- system.file(\"dev\", \"datasetApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_dir = app_pth, height = 600, width = 800)\n  expect_equal(\n    object = app$get_window_size(), \n    expected = list(width = 800L, height = 600L))\n  expect_equal(\n    object = app$get_dir(),\n    expected = app_pth)\n})\n```\n:::\n\n\n### Setting inputs \n\nNext we'll change `dataset-dataset` input from `ability.cov` to `attitude` using `app$set_inputs()` (*Note that this uses the module notation above (i.e., `\"id-inputId\"`*):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app_pth <- system.file(\"dev\", \"datasetApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_dir = app_pth, height = 600, width = 800)\n  # previous tests omitted\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n```\n:::\n\n\nIf you can see both windows, you'll see the application values change in the Chromium browser: \n\n::::{.column-page-right}\n\n::: {#fig-set_inputs layout-ncol=1}\n\n![`app$set_inputs()`](img/app_set_inputs.png){#fig-app_set_inputs}\n\nSet application inputs with `app$set_inputs()`\n:::\n\n::::\n\n### Checking inputs\n\nIn the previous test, we used the `expect_values()` to capture a list of all the app values (`input`, `output`, `export`). We can also capture these values in a list *inside* the test by including a call to `app$get_values()` and assigning the output to `app_values`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app_pth <- system.file(\"dev\", \"datasetApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_dir = app_pth, height = 600, width = 800)\n  # previous tests omitted\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n})\n```\n:::\n\n\n`app_values` has a similar structure to the `.json` snapshot covered above (i.e., with `input`, `output`, and `export`): \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nstr(app_values)\n```\n:::\n\n\n```{.default}\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"<table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'>\\n<thead> <tr\"..\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n```\n\n\nWe can use `waldo::compare()` to verify the `input` in `app_values` to verify the value that we changed with `app$set_inputs()` \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nwaldo::compare(\n  x = app_values$input$`dataset-dataset`,\n  y = \"attitude\"\n)\n```\n:::\n\n\n```{.default}\n✔ No differences\n```\n\n\n`waldo::compare()` can easily be adapted to a new test expectation: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app_pth <- system.file(\"dev\", \"datasetApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_dir = app_pth, height = 600, width = 800)\n  # previous tests omitted\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\"\n  )\n})\n```\n:::\n\n\nAt the end of the test, I'll add a call [`app$stop()`](https://rstudio.github.io/shinytest2/articles/zzz-faq.html#should-i-manually-shut-down-my-appdriver) to close the Chromium app.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::datasetApp\", {\n  app_pth <- system.file(\"dev\", \"datasetApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_dir = app_pth, height = 600, width = 800)\n  expect_equal(\n    object = app$get_window_size(), \n    expected = list(width = 800L, height = 600L))\n  expect_equal(\n    object = app$get_dir(),\n    expected = app_pth)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values <- app$get_values()\n  expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n```\n:::\n\n\n## Exporting test values \n\nThe `shinytest2` documentation repeatedly[^export-test-vals-rec-01] recommends[^export-test-vals-rec-02] exporting test values from Shiny applications. We'll use the application stored in `inst/dev/selectVarApp/` to explore exporting test values.\n\n[^export-test-vals-rec-01]: \"*In some cases, it’s useful to snapshot some bits of internal state of an application – state that’s not reflected directly in the inputs or outputs. This can be done by exporting values.*\" - [`shinytest2` documentation](https://rstudio.github.io/shinytest2/articles/in-depth.html#exported-values)\n\n[^export-test-vals-rec-02]: \"*It cannot be recommended enough to use `exportTestValues()` to test your Shiny app’s reactive values.*\" -  [`shinytest2` documentation](https://rstudio.github.io/shinytest2/articles/robust.html#exported-values)\n\nThe application in the `inst/dev/selectVarApp/` folder of `mstsap` includes a call to `exportTestValues()` and the `test.mode` option set to `TRUE` in the call to `shinyApp()`.[^export-test-values]\n\n[^export-test-values]: Read more about exporting test values [here](https://shiny.posit.co/r/reference/shiny/1.0.2/exporttestvalues).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nserver <- function(input, output, session) {\n  data <- datasetServer(\"data\")\n  var <- selectVarServer(\"var\", data, filter = filter)\n\n  output$out <- renderTable(head(var()))\n\n  output$vals <- renderPrint({\n    x <- reactiveValuesToList(input,\n      all.names = TRUE\n    )\n    print(x)\n  })\n\n  exportTestValues(\n    var = var(),\n    data = data()\n  )\n}\n```\n:::\n\n\n\nThe test for this application contains the same `system.file()` call to create the `AppDriver` object:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::selectVarApp\", {\n  app_pth <- system.file(\"dev\", \"selectVarApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_pth, height = 1200, width = 1000)\n})\n```\n:::\n\n\nAfter entering `app$view()` in the **Console**, the application opens in the Chromium headless browser again:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napp$view()\n```\n:::\n\n\nWe can see `selectVarApp` has been launched in showcase mode, so the `README` and code files are displayed in the UI.\n\n\n::::{.column-body-outset-right}\n\n::: {#fig-app_view_selectVarApp layout-ncol=1}\n\n![`app$view()`](img/app_view_selectVarApp.png){#fig-app_view_selectVarApp}\n\nView `selectVarApp()` application with `app$view()`\n:::\n\n::::\n\nIn our test file, we'll use `app$set_values()` to change the ```` $`data-dataset` ```` and ```` $`var-var` ```` inputs:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::selectVarApp\", {\n  app_pth <- system.file(\"dev\", \"selectVarApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_pth, height = 1200, width = 1000)\n  \n  app$set_inputs(`data-dataset` = \"mtcars\") # <1>\n})\n```\n:::\n\n1. Change ```` $`data-dataset` ```` to `mtcars`\n\nWe'll also change the variable input from `mpg` to `wt` and verify the output in the UI:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::selectVarApp\", {\n  app <- AppDriver$new(\n    system.file(\"dev\", \"selectVarApp\",\n      package = \"mstsap\"\n    ),\n    height = 1200,\n    width = 1000\n  )\n  app$set_inputs(`data-dataset` = \"mtcars\") # <1>\n  app$set_inputs(`var-var` = \"wt\") # <2>\n})\n```\n:::\n\n1. Change ```` $`data-dataset` ```` to `mtcars`\n2. Change ```` $`var-var` ```` to `wt`\n\n\nThe printed `reactiveValuesToList()` is updated UI when the `selectInput()` changes:\n\n::::{.column-body-outset-right}\n\n::: {#fig-selectVarApp_changes layout-ncol=1}\n\n![Set `data-dataset`](img/selectVarApp_changes.gif){#fig-selectVarApp_changes}\n\nView `selectVarApp()` after setting `data-dataset` and `var-var` with `app$set_inputs()`\n:::\n\n::::\n\n### Getting values\n\nWe'll use `app$get_values()` to store the exported `input`, `output`, and `export` test values in `app_values`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"mstsap::selectVarApp\", {\n  app <- AppDriver$new(\n    system.file(\"dev\", \"selectVarApp\",\n      package = \"mstsap\"\n    ),\n    height = 1200,\n    width = 1000\n  )\n\n  app$set_inputs(`data-dataset` = \"mtcars\") # <1>\n  app$set_inputs(`var-var` = \"wt\") # <2>\n\n  app_values <- app$get_values() # <3>\n})\n```\n:::\n\n1. Change ```` $`data-dataset` ```` to `mtcars`\n2. Change ```` $`var-var` ```` to `wt`\n3. Assign to `app_values` list\n\n`app_values` is a list (similar to the `.json` snapshot file), but now we've explicitly exported values from the server in `selectVarApp()`: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nnames(app_values$export)\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n[1] \"data\" \"var\" \n```\n:::\n\n\n### Expectations\n\nWe can use `app_values` to verify the structure of each exported object: \n\n-   `data` should be a `data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntestthat::expect_true(\n  object = is.data.frame(app_values$export$data)\n)\n```\n:::\n\n\n-   `var` should be a numeric vector:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nexpect_true(\n  object = is.numeric(app_values$export$var)\n)\n```\n:::\n\n\nOnce again, we end the test with a call to `app$stop()`. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show/hide mstsap::selectVarApp test\"}\ntest_that(\"mstsap::selectVarApp\", {\n  app_pth <- system.file(\"dev\", \"selectVarApp\", package = \"mstsap\")\n  app <- AppDriver$new(app_pth, height = 1200, width = 1000)\n  # app$view()\n  expect_equal(app$get_window_size(), \n                 list(width = 1000L, height = 1200L))\n  expect_equal(app$get_dir(), app_pth)\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n  app_values <- app$get_values()\n  expect_true(\n    object = is.data.frame(app_values$export$data))\n  expect_true(\n    object = is.numeric(app_values$export$var))\n  app$stop()\n})\n```\n:::\n\n\n## Testing complex outputs \n\nThe `msst2ap` branch has the [`histogramApp()` from Mastering Shiny](https://mastering-shiny.org/scaling-modules.html#case-study-histogram) in `inst/dev/histogramApp/`, and a `ggplot2` version of the `histogramApp()` in the `inst/dev/ggHistApp/` folder (view contents [here](https://github.com/mjfrigaard/sapkgs/tree/msst2ap/inst/dev/ggHistApp)):\n\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\ninst\n└── dev\n    ├── ggHistApp\n    │   ├── DESCRIPTION\n    │   ├── R\n    │   │   └── modules.R\n    │   ├── README.md\n    │   └── app.R\n    └── histogramApp\n        ├── DESCRIPTION\n        ├── R\n        │   └── modules.R\n        ├── README.md\n        └── app.R\n\n6 directories, 8 files\n```\n:::\n\n\n:::: {layout=\"[49,-2,49]\" layout-valign=\"top\"}\n\n::: {#fig-sbs_histogramApp_ggHistApp layout-ncol=2}\n\n![`histogramApp()`](img/sbs_histogramApp.png){#fig-sbs_histogramApp}\n\n![`ggHistApp()`](img/sbs_ggHistApp.png){#fig-sbs_ggHistApp}\n\n\n`histogramApp()` vs. `ggHistApp()`\n\n:::\n\n::::\n\n### Testing reactive values\n\nThe module server functions in `histogramApp()` return two values: `data` and `x`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide values in msst2ap::histogramApp() server\"}\nserver <- function(input, output, session) {\n  data <- datasetServer(\"data\")\n  x <- selectVarServer(\"var\", data)\n  histogramServer(\"hist\", x)\n\n  # remaining code omitted\n  \n}\n```\n:::\n\n\n`data` is returned reactive from `datasetServer()` and becomes an input parameter for `selectVarServer()`, and `x` is the returned reactive. \n\nBoth of these are reactive values, but they aren't treated like returned values from the `reactive()` function (i.e., they don't have parentheses). These are passed in the server as reactive *expressions*, which we can confirm using `exportTestValues()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide msst2ap::histogramApp() server\"}\nserver <- function(input, output, session) {\n  data <- datasetServer(\"data\")\n  x <- selectVarServer(\"var\", data)\n  histogramServer(\"hist\", x)\n\n  # remaining code omitted\n  \n  exportTestValues( # <1>\n      data = data,\n      x = x\n    ) # <1>\n}\n```\n:::\n\n1. We've also added `options(shiny.testmode = TRUE)` to the top of the `app.R` file.\n\nIn the test for `histogramApp()`, we'll create the app with `AppDriver$new()` and change the three inputs using `app$set_inputs()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide msst2ap::histogramApp() server\"}\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app_pth <- system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\")\n  app <- AppDriver$new(app_pth, height = 750, width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_values <- app$get_values()\n  names(app_values)\n})\n```\n:::\n\n\n```{.default}\n[1] \"data\" \"x\"  \n```\n\n\nWe'll test is these are reactive functions by combining `rlang::is_function()` and `shiny::is.reactive()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide msst2ap::histogramApp() values\"}\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app_pth <- system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\")\n  app <- AppDriver$new(app_pth, height = 750, width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_values <- app$get_values()\n  # names(app_values)\n  expect_equal(\n    rlang::is_function(app_values$export$data),\n    shiny::is.reactive(app_values$export$data))\n  expect_equal(\n    rlang::is_function(app_values$export$x),\n    shiny::is.reactive(app_values$export$x))\n})\n```\n:::\n\n\n### Using app logs \n\n`shinytest2` also has the handy `get_logs()` that allows us to check the logs for specific functionality. After changing the three inputs with `set_inputs()`, we can check the output to see these actions were included in the logs:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide msst2ap::histogramApp() logs\"}\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app_pth <- system.file(\"dev\", \"histogramApp\",\n                                  package = \"msst2ap\")\n  app <- AppDriver$new(app_pth, height = 750, width = 1200)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 15)\n  app_logs <- app$get_logs() # <1>\n  ds_msg <- subset(app_logs,  # <2>\n                   message == \"Setting inputs: 'data-dataset'\")  # <2>\n  expect_equal(nrow(ds_msg), 1L) # <2>\n  var_msg <- subset(app_logs,  # <3>\n                    message == \"Setting inputs: 'var-var'\")\n  expect_equal(nrow(var_msg), 1L) # <3>\n  hist_msg <- subset(app_logs,  # <4>\n                     message == \"Setting inputs: 'hist-bins'\")\n  expect_equal(nrow(hist_msg), 1L) # <4>\n})\n```\n:::\n\n1. Create app logs \n2. Create and test dataset  \n3. Create and test variable  \n4. Create and test bins  \n\nLogs can also be passed from the test to the application using [`log_message()`](https://rstudio.github.io/shinytest2/reference/AppDriver.html#method-log-message-).\n\n### Verify initial [`input`]{style=\"font-size: 1.10em; font-weight: bold;\"}s\n\nThe `ggHistApp()` app is similar to `histogramApp()`, but instead of passing a reactive vector to `hist()`, `ggHistServer()` passes a reactive one-column `data.frame` (`x()`) to the `ggplot2` functions. We'll add `exportTestValues()` to a development version of `ggHistServer()` in `inst/dev/`: [^replicate-robust-testing]\n\n[^replicate-robust-testing]: This section replicates these [test examples from `shinytest2` ](https://rstudio.github.io/shinytest2/articles/robust.html#example) using the `ggHistApp()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide ggHistServer()\"}\nggHistServer <- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(is.reactive(x))\n  stopifnot(is.reactive(title))\n\n  moduleServer(id, function(input, output, session) {\n    \n    gg2_plot <- reactive({ # <1>\n      ggplot2::ggplot(\n          mapping =\n            ggplot2::aes(purrr::as_vector(x()))\n        ) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())\n          ) +\n          ggplot2::theme_minimal()\n    }) # <1>\n\n    observe({ # <2>\n      output$hist <- renderPlot({gg2_plot()}, res = 124)\n    }) |> \n      bindEvent(c(x(), title(), input$bins)) # <2>\n\n    exportTestValues( # <3>\n      bins = input$bins,\n      x = x(),\n      title = title()\n    ) # <3>\n\n    # remaining code omitted\n    \n  })\n}\n```\n:::\n\n1. Build `ggplot2` graph \n2. Render plot  \n3. Export bins, `x()` and `title()`\n\nThe version of `ggHistServer()` above replaces the `ggHistServer()` used in the standalone app function).[^load-modules-from-inst] The remaining modules from `mstsap` are explicitly namespaced. The code below identifies the location of each module in `ggHistApp()`: [^load-app-from-inst]\n\n[^load-modules-from-inst]: This version is loaded from a `inst/dev/histogramApp/R/modules.R` file.\n\n[^load-app-from-inst]: This version is loaded from a `inst/dev/histogramApp/R/app.R` file.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"show/hide ggHistApp()\"}\nggHistApp <- function() {\n  ui <- fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        mstsap::datasetInput(\"data\", is.data.frame),\n        mstsap::selectVarInput(\"var\"),\n      ),\n      mainPanel(\n        histogramOutput(\"hist\"), # <1>\n        code(\"app vals\"),\n        verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server <- function(input, output, session) {\n    data <- mstsap::datasetServer(\"data\")\n    x <- ggSelectVarServer(\"var\", data) # <2>\n    ggHistServer(\"hist\", x) # <3>\n\n    output$vals <- renderPrint({\n        x <- reactiveValuesToList(input,\n          all.names = TRUE)\n        print(x, width = 30, max.levels = NULL)},\n      width = 30)\n  }\n  \n    exportTestValues( # <4>\n      x = x(),\n      data = data(),\n      react_x = x,\n      react_data = data\n    ) # <4>\n\n  shinyApp(ui, server)\n}\nggHistApp()\n```\n:::\n\n1. From `R/histogramOutput.R`  \n2. From `R/ggSelectVarServer.R`  \n3. From `inst/dev/ggHistApp/R/modules.R`\n4. Exported test values \n\nIn the `test-shinytest2-ggHistApp.R` test file, I'll verify the [`vdiffr` package](https://vdiffr.r-lib.org/) is installed, then create the `AppDriver` object with a call to `system.file()` and set the `height` and `width`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ntest_that(\"{shinytest2}: ggHistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n  app_pth <- system.file(\"dev\", \"ggHistApp\",\n                                  package = \"msst2ap\")\n  app <- AppDriver$new(app_pth,\n                       height = 750, width = 1200)\n})\n```\n:::\n\n\nThe first expectations in the example test the default `input` values with **`app$get_value(input = )`**:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# initial values----\n# verify initial values \ninit_ds <- app$get_value(input = 'data-dataset')\ninit_var <- app$get_value(input = 'var-var')\n# is the variable from the dataset?\nexpect_true(\n  init_var %in% names(get(init_ds, \"package:datasets\"))\n)\ninit_bins <- app$get_value(input = 'hist-bins')\nexpect_true(is.numeric(init_bins))\n```\n:::\n\n    \n### Set and verify [`export`]{style=\"font-size: 1.10em; font-weight: bold;\"}\n    \nNext, we check chamging the input values with **`app$set_values(id-inputId)`**:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# set values ----\n# dataset\napp$set_inputs(`data-dataset` = 'mtcars')\nnew_data <- app$get_value(input = \"data-dataset\")\n# Verify new data\nexpect_equal(object = new_data,\n  expected = \"mtcars\")\napp$set_inputs(`var-var` = 'disp')\nnew_var <- app$get_value(input = \"var-var\")\n# Verify new variable\nexpect_equal(object = new_var,\n  expected = \"disp\")\n```\n:::\n\n\n### Verify [`export`]{style=\"font-size: 1.10em; font-weight: bold;\"}s\n\nFinally, we'll test the exported values by creating **`app$get_values()$export`** and checking it's contents:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Exported objects ----\nexp_values <- app$get_values()$export\n# check reactives/functions\nexpect_true(shiny::is.reactive(exp_values$react_data))\nexpect_true(shiny::is.reactive(exp_values$react_x))\nexpect_true(rlang::is_function(exp_values$react_data))\nexpect_true(rlang::is_function(exp_values$react_x))\n# check data \nexpect_true(is.data.frame(exp_values$data))\nexpect_true(ncol(exp_values$x) == 1)\nexpect_equal(exp_values$data, mtcars)\nexpect_equal(exp_values$x, mtcars['disp'])\n```\n:::\n\n    \n### Verify plot with [`vdiffr`]{style=\"font-size: 1.10em; font-weight: bold;\"}\n\nNow we verify the plot with the exported `plot_obj` (in the `hist` module) with `expect_doppelganger()` from the `vdiffr` package. \n    \n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Verify plot ----\ngg2_plot <- app$get_value(output = \"hist-hist\") # <1>\nexpect_equal(gg2_plot$alt, \"Plot object\") # <1>\nvdiffr::expect_doppelganger(  # <2>\n    title = \"mtcars_disp_plot\",\n    fig = ggplot2::ggplot(data = exp_values$data,\n            mapping =\n            ggplot2::aes(x = disp)\n        ) + \n          ggplot2::geom_histogram(bins = exp_values$`hist-bins`) +\n          ggplot2::labs(\n            title = paste0(exp_values$`hist-title`, \n                           \" [bins = \",\n                           exp_values$`hist-bins`, \"]\"),\n            y = \"Count\",\n            x = names(exp_values$x)\n          ) +\n          ggplot2::theme_minimal()\n    ) # <2>\n```\n:::\n\n1. Check the rendered plot object  \n2. `ggHistApp()` renders a `ggplot2` graph, which makes it easier to demonstrate [this example of checking a plot](https://rstudio.github.io/shinytest2/articles/robust.html#example) from the `shinytest2` package website. \n\n### Set, get, expect\n\nThe process above is repeated with new values passed to **`app$set_inputs()`** and verified with **`app$get_values()`**:\n    \nThe `data-dataset`, `var-var`, and `hist-bins` are updated again with new values, exported with `exportTestValues()` and stored in `exp_values`. The new plot is then verified again with `expect_doppelganger()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# SET ---- \napp$set_inputs(`data-dataset` = \"USArrests\")\napp$set_inputs(`var-var` = 'UrbanPop')\napp$set_inputs(`hist-bins` = 15)\n# GET ----\nexp_values <- app$get_values()$export\n## EXPECT ---- \nvdiffr::expect_doppelganger(\n  title = \"usaarrests_plot\",\n  fig = ggplot2::ggplot(data = exp_values$data,\n          mapping =\n          ggplot2::aes(x = UrbanPop)\n      ) + \n        ggplot2::geom_histogram(bins = exp_values$`hist-bins`) +\n        ggplot2::labs(\n          title = paste0(exp_values$`hist-title`, \n                         \" [bins = \",\n                         exp_values$`hist-bins`, \"]\"),\n          y = \"Count\",\n          x = names(exp_values$x)\n        ) +\n        ggplot2::theme_minimal()\n  )\n```\n:::\n\n\nThe final snapshot files are stroed in `tests/testthat/_snaps/`:\n\n\n\n```{.default}\ntests/testthat/_snaps/\n  └── shinytest2-ggHistApp\n      ├── mtcars-disp-plot.svg\n      ├── sleep-extra-plot.svg\n      └── usaarrests-plot.svg\n\n2 directories, 3 files\n```\n\n    \n### Results \n\nThe final results of `devtools::test()`  in `msst2ap` are below:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::test()\n```\n:::\n\n\n```{.default}\nℹ Testing msst2ap\nLoading required package: shiny\n✔ | F W  S  OK | Context\n✔ |          3 | shinytest2-datasetApp [3.7s]\n✔ |         16 | shinytest2-ggHistApp [11.4s]\n✔ |          5 | shinytest2-histogramApp [3.8s]\n✔ |          4 | shinytest2-selectVarApp [2.4s]\n\n══ Results ═══════════════════\nDuration: 21.3 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 28 ]\n```\n\n\n## Recap\n\nThis post has covered creating tests with `testthat` and `shinytest2` for an app-package containing a Shiny application. In general, `shinytest2` is designed for end-to-end testing of Shiny applications. System tests (or regression testing) can capture the state of a Shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots). As we can see, `shinytest2` makes it easier to test specific app behaviors and set expectations iteratively with the `AppDriver`. \n\n`shinytest2` tests can also simulate user interaction in a way that `testServer()` tests can't, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. `shinytest2` can also be resource-intensive, so it's recommended to write these tests after you've completed the standard `testthat` unit tests and `testServer()` tests.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}