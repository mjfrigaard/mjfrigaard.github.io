{
  "hash": "6d86a53450bd693254e1f822af317e8d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shiny (for R) & APIs\"\nsubtitle: \"Using plumber, vetiver and Shiny\"\nauthor: \"Martin Frigaard\"\ndate: \"2025-04-23\"\ncategories: [APIs, Shiny, Packages]\n# image: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n# code-block-border-left: true\ncode-block-bg: \"#f8f8f8\"\ncode-block-border-left: \"#e8e8e8\"\ncode-fold: show\ncode-summary: 'show/hide'\ncallout-icon: false\n\ndraft: false\n\nfreeze: true\n\nexecute:\n  echo: false\n  message: false\n  warning: false\n  eval: true\n---\n\n\n\n\n\nI've been working my way through [DevOps for Data Science](https://do4ds.com/) by Alex K Gold (highly recommended) and the [chapter on APIs](https://do4ds.com/chapters/sec1/1-3-data-access.html#lab-use-a-database-and-an-api) includes an exercise using `duckdb`, `vetiver`, `pins`, `plumber`, and `shiny`. These packages work so well together I thought I'd write a blog post on the solution I developed.\n\n## Suggested reading\n\nBelow are the packages you'll need to reproduce the solution:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npkgs <- c(\"vetiver\", \"pins\", \"plumber\", \"logger\", \"palmerpenguins\", \n          \"duckdb\",\"DBI\", \"dplyr\", \"bslib\", \"bsicons\", \"httr2\", \n          \"jsonlite\")\ninstall.packages(pkgs)\n```\n:::\n\n\nIf this is your first time encountering APIs, I suggest watching the [Expanding R horizons: Integrating R with Plumber APIs](https://posit.co/resources/videos/expanding-r-horizons-integrating-r-with-plumber-apis/) video and reading the [Creating APIs for data science with plumber](https://posit.co/blog/creating-apis-for-data-science-with-plumber/) and [RStudio and APIs](https://posit.co/blog/rstudio-and-apis/) blog posts. I'll do my best to summarize the information in these resources, but they are excellent references worth reading from the original authors.\n\n### What is an API?\n\nAn API, or [Application Programming Interface](https://en.wikipedia.org/wiki/API), is like a shared language that lets different pieces of software talk to each other and exchange information or commands.\n\nAPIs provide a clear way for software programs to interact, allowing different apps and services to connect without needing to understand their internal workings.\n\nIn R, package APIs handle things like authentication (OAuth tokens, API keys, etc.), creating the correct query parameters, and parsing the JSON/XML responses into data frames or lists, which means we can focus on the higher-level data tasks rather than on the low-level networking details.\n\nThe lab exercise for this chapter involves 1) putting the `palmerpenguins` in a `duckdb` database,[^1] 2) pointing a `vetiver` model to the database and converting it into an API,[^2] and 3) building a Shiny app that calls the model API to display predictions:[^3]\n\n[^1]: [DevOps for Data Science: Step 1: Put the data in DuckDB](https://do4ds.com/chapters/sec1/1-3-data-access.html#step-1-put-the-data-in-duckdb)\n\n[^2]: [DevOps for Data Science: Step 2: Point the EDA and modeling scripts to the database](https://do4ds.com/chapters/sec1/1-3-data-access.html#step-2-point-the-eda-and-modeling-scripts-to-the-database)\n\n[^3]: [DevOps for Data Science: Step 3: Build an app that calls the API](https://do4ds.com/chapters/sec1/1-3-data-access.html#step-3-build-an-app-that-calls-the-api)\n\n> \"*...you’ll want to store input parameters in a reactive and then send a request to the API when the user presses a button.*\"\n\n## The API\n\nThe API code files I created for these lab exercises are displayed in the folder tree below:[^4]\n\n[^4]: These files can also be found in this [GitHub repo.](https://github.com/mjfrigaard/do4ds-labs/tree/main/_labs/lab4/R/api).\n\n\n```{.default}\napi/\n├── api.Rproj\n├── model.R\n├── models/\n│   └── penguin_model/\n├── my-db.duckdb\n├── plumber.R\n├── renv/\n└── renv.lock\n\n6 directories, 7 files\n```\n\n### The model\n\nThe `model.R` file creates our model (found in the `models` folder). After loading the necessary packages, we establish a connection to the `duckdb` database (`con`) and register the `penguins` dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncon <- DBI::dbConnect(duckdb::duckdb(), \"my-db.duckdb\")\n\nduckdb::duckdb_register(con, \"penguins_raw\", palmerpenguins::penguins)\n```\n:::\n\n\nWe use SQL to create a persistent table in the database and extract a subset of columns and rows for the model (`df`).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nDBI::dbExecute(\n  con,\n  \"CREATE OR REPLACE TABLE penguins AS SELECT * FROM penguins_raw\"\n)\ndf <- DBI::dbGetQuery(\n  con,\n  \"SELECT bill_length_mm, species, sex, body_mass_g \n   FROM penguins \n   WHERE body_mass_g IS NOT NULL \n   AND bill_length_mm BETWEEN 30 AND 60\n   AND sex IS NOT NULL\n   AND species IS NOT NULL\"\n)\n```\n:::\n\n\nFinally, we disconnect from the database.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nDBI::dbDisconnect(con)\n```\n:::\n\n\nFor modelling, we start by using the `stats::lm()` function to predict body mass using bill length, species, and sex.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodel <- lm(body_mass_g ~ bill_length_mm + species + sex, data = df)\n```\n:::\n\n\nWe then pass the model object to the `vetiver_model()` and provide a `model_name` and `description`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nv <- vetiver::vetiver_model(\n  model,\n  model_name = \"penguin_model\",\n  description = \"Linear model predicting penguin body mass from bill length, species, and sex\",\n  save_prototype = TRUE  \n)\n```\n:::\n\n\n`vetiver_pin_write()` 'pins' a trained model, an input prototype for new data, and and other model metadata to a model board.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodel_board <- pins::board_folder(\"models/\")\n```\n:::\n\n\nThe `board_folder()` from the `pins` package allows us write model to a board inside a folder (for sharing on network drives like Dropbox).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nvetiver::vetiver_pin_write(model_board, v)\n```\n:::\n\n\nNow we've creates a vetiver model and stored it in the `board_folder` named `models/penguin_model`. The `model.R` file only needs to run once to build the model.\n\n### `plumber` API\n\nIn `plumber.R`, we read the model into our environment using `board_folder()` to connect to the `pins` board:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodel_board <- pins::board_folder(\"models/\")\n```\n:::\n\n\nAnd `vetiver_pin_read()` will return the `vetiver` model object ready for deployment:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nv <- vetiver::vetiver_pin_read(model_board, \"penguin_model\")\n```\n:::\n\n\nWith the model in our environment, we'll print some  attributes to the console when the plumber API is run:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncat(\"\\n=== Model Loaded Successfully ===\\n\")\ncat(\"Model name:\", v$model_name, \"\\n\")\ncat(\"Model class:\", class(v$model), \"\\n\")\ncat(\"Prototype (expected input):\\n\")\nprint(v$prototype)\ncat(\"Factor levels:\\n\")\ncat(\"  species:\", paste(levels(v$prototype$species), collapse = \", \"), \"\\n\")\ncat(\"  sex:\", paste(levels(v$prototype$sex), collapse = \", \"), \"\\n\")\ncat(\"=================================\\n\\n\")\n```\n:::\n\n\n\n```{.default}\n=== Model Loaded Successfully ===\n\nModel name: penguin_model \n\nModel class: butchered_lm lm \n\nPrototype (expected input):\n# A tibble: 0 × 3\n# ℹ 3 variables: bill_length_mm <dbl>, species <fct>, sex <fct>\n\nFactor levels:\n\nspecies: Adelie, Chinstrap, Gentoo \n\nsex: female, male \n\n=================================\n```\n\n#### Helper functions\n\nMost of the challenges I encountered with the Shiny/API lab was due to data formatting. APIs love JSON, and I'm used to working in `data.frame`s/`tibble`s, specifically factors. So I wrote a a helper function for converting incoming JSON data (strings) to the proper R types (factors) that our model expects:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nprep_pred_data <- function(input_data) {\n  species_levels <- levels(v$prototype$species)\n  sex_levels <- levels(v$prototype$sex)\n  \n  data.frame(\n    bill_length_mm = as.numeric(input_data$bill_length_mm),\n    species = factor(input_data$species, levels = species_levels),\n    sex = factor(input_data$sex, levels = sex_levels),\n    stringsAsFactors = FALSE\n  )\n}\n```\n:::\n\n\n`prep_pred_data()` uses the prototype stored in the `vetiver` model to get correct factor levels. If we pass a `data.frame` with character values for `species` and `sex`: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nprep_pred_data(\n  data.frame(\n    bill_length_mm = 45,\n    species = \"Adelie\",\n    sex = \"male\" )\n  )\n```\n:::\n\n\n`prep_pred_data()`  converts the characters to factors with the appropriate levels: \n\n\n```{.default}\n#> 'data.frame':\t1 obs. of  3 variables:\n#>  $ bill_length_mm: num 45\n#>  $ species       : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1\n#>  $ sex           : Factor w/ 2 levels \"female\",\"male\": 2\n```\n\n#### Handlers\n\n`plumber` allows us to create RESTful APIs[^restful-apis] in R by decorating regular R functions with special comments (`#*`) that define API endpoints and their HTTP methods (also called verbs). These methods are listed below:\n\n[^restful-apis]: What is a RESTful API? Appsilon has a [great tutorial](https://www.appsilon.com/post/r-rest-api#introduction) on using `plumber`. [This](https://ploomber.io/blog/restapi-plumber/) is also a great tutorial (but is uses `caret` for modeling).\n\n| HTTP verb | plumber tag | Description |\n|----|----|----|\n| GET | `@get` | Request data from a server without modifying anything |\n| POST | `@post` | Send data to the server to create a new resource |\n| PUT | `@put` | Replace an entire resource with new data |\n| DELETE | `@delete` | Delete a specified resource from the server |\n| HEAD | `@head` | Same as GET but returns only headers (no body content) |\n\n##### Health Check\n\nThe first plumber handler function is a standard health check (or `ping`). This is a `GET`/`@get` endpoint, since it's only returning requested information (without altering anything).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#* Basic health check\n#*\n#* Simple endpoint to verify the API is running. Returns a minimal response\n#* with status and timestamp.\n#*\n#* @get /ping\n#* \n#* @serializer json\n#* \nhandle_ping <- function() {\n  list(\n    status = \"alive\", \n    timestamp = Sys.time()\n  )\n}\n```\n:::\n\n\n`handle_ping()` creates a simple endpoint to verify our API is running without performing any complex operations or database queries. Below is an illustration of how a Client or (Shiny app) would communicate with the API using this endpoint:\n\n```{=html}\n\n<style>\n\n.codeStyle span:not(.nodeLabel) {\n  font-family: monospace;\n  font-size: 1.5em;\n  font-weight: bold;\n  color: #9753b8 !important;\n  background-color: #f6f6f6;\n  padding: 0.2em;\n}\n\n</style>\n```\n\n```{mermaid}\n%%| fig-align: center\n%%| echo: false\n%%| fig-cap: 'health check'\n%%{init: {'theme': 'neutral', 'look': 'handDrawn', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"18px\"}}}%%\n  \nsequenceDiagram\n    participant Client\n    participant API as plumber<br>API\n    participant Handler as handle_ping()\n    \n    Note over Client,Handler: Health Check\n    \n    Client->>API: GET /ping\n    activate API\n    \n    API->>Handler: Execute function\n    activate Handler\n    \n    Handler->>Handler: Get timestamp<br/>Build response list\n    \n    Handler-->>API: {status: \"alive\",<br/>timestamp: Sys.time()}\n    deactivate Handler\n    \n    API->>API: Serialize to JSON\n    \n    API-->>Client: 200 OK<br/>{\"status\": \"alive\",<br/>\"timestamp\": \"...\"}\n    deactivate API\n    \n```\n\nThe health check will be displayed in the application to let us know if the API is running.\n\n##### Predictions \n\nThe primary endpoint for predictions is created with `handle_predict()`. This function uses the `prep_pred_data()` helper and returns a single numeric predicted penguin body mass (g).   \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#* Predict penguin body mass\n#*\n#* Main prediction endpoint that accepts penguin characteristics and returns\n#* predicted body mass in grams. Supports both single predictions and batch\n#* predictions (multiple penguins in one request).\n#*\n#* @post /predict\n#* \n#* @serializer json\nhandle_predict <- function(req, res) {\n  cat(\"\\n=== /predict called ===\\n\")\n  cat(\"Raw body:\", req$postBody, \"\\n\")\n  \n  result <- tryCatch({ \n    body <- jsonlite::fromJSON(req$postBody) #<1>\n    cat(\"Parsed body:\\n\")\n    print(body)\n    \n    if (is.list(body) && !is.data.frame(body)) {\n      body <- as.data.frame(body)\n    }\n    \n    pred_data <- prep_pred_data(body) #<2>\n    cat(\"Prepared data:\\n\")\n    print(pred_data)\n    str(pred_data)\n    \n    cat(\"Calling predict...\\n\")\n    prediction <- predict(v, pred_data) #<3>\n    cat(\"Prediction result:\\n\")\n    print(prediction)\n    cat(\"Prediction class:\", class(prediction), \"\\n\")\n    \n    if (is.data.frame(prediction) && \".pred\" %in% names(prediction)) { #<4>\n      response <- list(.pred = prediction$.pred)\n    } else if (is.numeric(prediction)) {\n      response <- list(.pred = as.numeric(prediction))\n    } else {\n      response <- list(.pred = as.numeric(prediction))\n    } #<4>\n    \n    cat(\"Response:\\n\")\n    print(response)\n    cat(\"=== /predict complete ===\\n\\n\")\n    \n    return(response)\n    \n  }, error = function(e) { #<5>\n    cat(\"\\n!!! ERROR !!!\\n\")\n    cat(\"Error message:\", conditionMessage(e), \"\\n\")\n    print(e)\n    cat(\"!!! END ERROR !!!\\n\\n\")\n    \n    res$status <- 500\n    return(list(\n      error = conditionMessage(e),\n      timestamp = as.character(Sys.time())\n    )) #<5>\n  })\n  \n  return(result)\n}\n```\n:::\n\n1. Parse JSON   \n2. Prep data (convert strings to factors)   \n3. Make prediction with `predict()` using the `vetiver` model and `prep_data`     \n4. Handle different return types from `vetiver`   \n5. Error handling  \n\n\nThe diagram below outlines the sequence from the Client request to the `plumber` API, the `handle_predict()` and `prep_pred_data()` functions, and the response from the `vetiver` API:\n\n```{mermaid}\n%%| fig-align: center\n%%| echo: false\n%%| fig-cap: 'Predictions'\n%%{init: {'theme': 'neutral', 'look': 'handDrawn', 'themeVariables': { 'fontFamily': 'monospace', \"fontSize\":\"18px\"}}}%%\n\nsequenceDiagram\n    \n    participant Client\n    participant API as plumber<br>API\n    participant Handler as handle_predict()\n    participant Helper as prep_pred_data()\n    participant VetiverObj as vetiver<br>model (v)\n    \n    Client->>API: POST /predict<br/>Body: {bill_length_mm, species, sex}\n    activate API\n    \n    API->>Handler: Execute<br>function\n    activate Handler\n    \n    Handler->>Handler: Parse JSON<br>from req$postBody\n    \n    Handler->>Handler: Convert to<br>data.frame<br>(if needed)\n    \n    Handler->>Helper: prep_pred_data(body)\n    activate Helper\n    Helper->>Helper: Convert strings<br>to factors\n    Helper-->>Handler: Return prepared<br>data\n    deactivate Helper\n    \n    Handler->>VetiverObj: predict(v, pred_data)\n    activate VetiverObj\n    VetiverObj->>VetiverObj: Run model<br>prediction\n    VetiverObj-->>Handler: Return<br>prediction\n    deactivate VetiverObj\n    \n    Handler->>Handler: Format response:<br/>{.pred = prediction}\n    \n    Handler-->>API: {.pred: [value]}\n    deactivate Handler\n    \n    API-->>Client: 200 OK + JSON\n    deactivate API\n    \n```\n\nWhen launched, the API lists the endpoints and documentation: \n\n![Click to enlarge](img/api.png){width='100%' fig-align='center'}\n\nThe `shiny` app below will access two of these endpoints (`/health` and `/predict`).\n\n\n## The Shiny App\n\nThis lab also includes a Shiny app, but we will use the application from the following [chapter](https://github.com/mjfrigaard/do4ds-labs/tree/main/_labs//lab4/R) (because it also includes logs and monitoring):\n\n\n```{.default}\nR/\n├── app.R\n├── R.Rproj\n├── README.md\n├── renv/\n├── renv.lock\n└── shiny_app.log\n```\n\nThe UI is built using [`bslib`](https://rstudio.github.io/bslib/) and a few custom HTML functions with basic CSS styling. The application server is going to be making API calls, so we'll be using `httr2` to build the request and `logger` to monitor these requests. \n\n### Logging\n\nLogging is configured with `logger`'s:\n\n1. `log_threshold()` sets the default log level (set to `\"INFO\"`)  \n2. `log_appender()` and `appender_tee()` specify the log file (`shiny_app.log`)   \n3. `log_formatter()` determines the format of the logs.   \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlogger::log_threshold(level = \"INFO\")\nlogger::log_appender(appender = appender_tee(file = \"shiny_app.log\"))\nlogger::log_formatter(logger::formatter_glue_or_sprintf)\n```\n:::\n\n\n### URL \n\nWe set the `api_url` to an internal location with port `8080` and the `/predict` endpoint:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\napi_url <- \"http://127.0.0.1:8080/predict\"\n```\n:::\n\n\n### Session token \n\nWe'll display the session token in the upper-right corner of the UI. This can be used for debugging (or to reference for testing).\n\n#### UI\n\nA `div()` is useful here because we want the token to be visible (but not distracting from the primary functions of the app).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  div(\n    style = \"position: fixed; top: 10px; right: 10px; z-index: 1000; color: #fff;\",\n    strong(\"Session\", \n      textOutput(\"log_status\", inline = TRUE)\n      )\n  )\n```\n:::\n\n\n#### Server\n\nDuring startup, we will log the session and user interactions:\n\n1. The `priority` argument determines when an observer should be executed (higher values have higher priority).   \n2. `throttle` \"*delays invalidation if the throttled reactive recently (within the time window) invalidated*.\"[^throttle]\n\n[^throttle]: Read more in the Shiny documentation on [debounce/throttle](https://shiny.posit.co/r/reference/shiny/latest/debounce.html).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nobserve({ # <1>\n    logger::log_info(\n      \"Shiny app started - Session: {session$token} - Host: {session$clientData$url_hostname}\"\n    )\n  }, priority = 1000) # <1>\n\n  observe({ #<2>\n    logger::log_debug(\n      \"User input changed - Session: {session$token} - bill_length: {input$bill_length} - species: {input$species} - sex: {input$sex}\"\n    )\n  }) |> \n    throttle(2000) #<2>\n\n  output$log_status <- renderText({ #<3>\n    paste(\"Token:\", substr(session$token, 1, 8))\n  }) #<3>\n```\n:::\n\n1. log app startup is set to a high priority        \n2. User interactions are throttled    \n3. Token display    \n\nIn the **Console**, we see: \n\n\n```{.default}\nINFO [2025-12-23 06:43:29] Shiny application initialized - timestamp: 2025-12-23 06:43:29.75396 - r_version: R version 4.5.2 (2025-10-31)\nINFO [2025-12-23 06:43:30] Shiny app started - Session: 8e0d4bd326098f9c2d2d01aeaab6b1db - Host: 127.0.0.1\n```\n\nIn the app, we see: \n\n![Click to enlarge](img/session_token.png){width='100%' fig-align='center'}\n\n### API health check\n\nWhen the application is launched, we want to perform a `GET` request to the `/health` endpoint to make sure the API is available to make predictions. \n\n#### UI\n\nThe response from the `/health` endpoint is displayed under a **System Status** section using a simple `textOutput()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncard_header(\"System Status\"),\n  card_body(\n    h5(\"API Status:\"),\n    textOutput(\"api_health\")\n    # ...\n  )\n```\n:::\n\n\n#### Server\n\nThe initial ping (health check) is sent using a `httr2` pipeline: \n\n1. `request()`: include the API url with the `/ping` endpoint   \n2. `req_timeout()`: set the timeout to `5` (seconds)       \n3. `req_perform()`: perform the request     \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# ping\n  api_health <- reactive({\n    tryCatch({ #<1>\n      logger::log_debug(\"Checking API health - Session: {session$token}\")\n      \n      response <- httr2::request(\"http://127.0.0.1:8080/ping\") |> #<2>\n        httr2::req_timeout(5) |> #<3>\n        httr2::req_perform() #<4>\n      \n      if (httr2::resp_status(response) == 200) {\n        logger::log_info(\"API health check successful - Session: {session$token}\")\n        return(\"✅ API Online\")\n      } else {\n        logger::log_warn(\n          \"API health check returned non-200 status - Session: {session$token} - status: {httr2::resp_status(response)}\"\n        )\n        return(\"⚠️ API Issues\")\n      } #<1>\n    }, error = function(e) { #<5>\n      logger::log_error(\n        \"API health check failed - Session: {session$token} - error: {conditionMessage(e)}\"\n      )\n      return(\"❌ API Offline\")\n    })\n  }) #<5>\n# display\n  output$api_health <- renderText({ #<6>\n    api_health()\n  }) #<6>\n```\n:::\n\n1. Perform request safely     \n2. Include the `base_url` to create the `httr2` request object  \n3. Set time limit (before error is returned)    \n4. Perform the request    \n5. Fall back safely to error messages \n6. Display API health check response  \n\nThe **Console** displays the successful (or failed) health check status:\n\n\n```{.default}\nINFO [2025-12-23 06:43:30] API health check successful - Session: 8e0d4bd326098f9c2d2d01aeaab6b1db\n```\n\nIn the UI, we see: \n\n![Click to enlarge](img/health_check.png){width='100%' fig-align='center'}\n\n### Predictions\n\nThe API has multiple options for making predictions, but we're going to focus on the `/predict` endpoint because it's relatively straighforward to implement in our application. \n\n#### UI\n\nThe model inputs and display in the sidebar (using the values we know are in the subset of `penguins` data we used to build the model).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bill_length\", \n      label = \"Bill Length (mm)\",\n      min = 30, \n      max = 60, \n      value = 45, \n      step = 1\n    ),\n    selectInput(\n      inputId = \"sex\", \n      label = \"Sex\", \n      choices = c(\"Male\", \"Female\"), \n      selected = \"Male\"\n    ),\n    selectInput(\n      inputId = \"species\",\n      label = \"Species\",\n      choices = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n      selected = \"Adelie\"\n    ),\n    actionButton(\n      inputId = \"predict\", \n      label = \"Predict\", \n      class = \"btn-primary\"\n    )\n  )\n```\n:::\n\n\nThe prediction results are returned along with a display of the reactive values in the server. This gives us an idea of the data format in the application before it's sent off to the API. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncard(\n  card_header(\"Penguin Parameters\"),\n  card_body(\n    verbatimTextOutput(outputId = \"vals\")\n  )\n)\n```\n:::\n\n\nThe predicted mass is displayed in a `value_box()` with a `textOutput()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ncard(\n  card_header(\"Predicted Mass\"),\n  card_body(\n    value_box(\n      showcase_layout = \"left center\",\n      title = \"Grams\",\n      value = textOutput(outputId = \"pred\"),\n      showcase = bs_icon(\"graph-up\"),\n      max_height = \"200px\",\n      min_height = \"200px\"\n    )\n  )\n)\n```\n:::\n\n\n#### Server\n\nIn the `server`, the reactive value are collected, converted to a `data.frame`, and displayed in a plain-text format.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# values \nvals <- reactive({ #<1>\n    bill_length <- input$bill_length #<2>\n    species <- input$species\n    sex <- input$sex #<2>\n    \n    if (bill_length < 30 || bill_length > 60) { #<3>\n      logger::log_warn(\n        \"Bill length out of typical range - Session: {session$token} - bill_length: {bill_length}\"\n      )\n    }\n    \n    if (is.null(species) || is.null(sex)) {\n      logger::log_error(\n        \"Missing required inputs - Session: {session$token} - species_null: {is.null(species)} - sex_null: {is.null(sex)}\"\n      )\n      return(NULL)\n    } #<3>\n    \n    data <- data.frame( #<4>\n      bill_length_mm = bill_length,\n      species = species,\n      sex = tolower(sex)\n    ) #<4>\n    \n    logger::log_debug(\n      \"Input data prepared - Session: {session$token} - data: {jsonlite::toJSON(data, auto_unbox = TRUE)}\"\n    )\n    \n    return(data)\n  }) #<1>\n# display\n  output$vals <- renderPrint({ #<5>\n    data <- vals()\n    if (!is.null(data)) {\n      logger::log_debug(\"Displaying input values to user - Session: {session$token}\")\n      return(data)\n    } else {\n      return(\"Invalid inputs\")\n    }\n  }) #<5>\n```\n:::\n\n1. Reactive values from inputs    \n2. Inputs (bill_length, species, and sex) \n3. Input validation   \n4. Prepare data   \n5. Display structure of inputs \n\n\nIn the UI, we can see the default values displayed as a `data.frame`:\n\n![Click to enlarge](img/vals.png){width='100%' fig-align='center'}\n\nIf a user changes the inputs, the reactive values will also update. To make a prediction, we click the **Predict** button with the selected inputs. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# prediction \n  pred <- reactive({ #<1>\n    request_start <- Sys.time() #<2>\n    request_data <- vals() #<3>\n    \n    if (is.null(request_data)) { #<4>\n      logger::log_error(\n        \"Cannot make prediction with invalid inputs - Session: {session$token}\"\n      )\n      return(\"❌ Invalid inputs\")\n    } #<4>\n    \n    logger::log_info(\n      \"Starting prediction request - Session: {session$token} - request_data: {jsonlite::toJSON(request_data, auto_unbox = TRUE)}\"\n    )\n    \n    tryCatch({ #<5>\n      showNotification( #<6>\n        \"Predicting penguin mass...\", \n        type = \"default\", \n        duration = 3\n      ) #<6>\n      \n      response <- httr2::request(api_url) |> #<7>\n        httr2::req_method(\"POST\") |>\n        httr2::req_body_json(request_data, auto_unbox = FALSE) |>\n        httr2::req_timeout(30) |>\n        httr2::req_perform() #<7>\n      \n      response_time <- as.numeric( #<8>\n        difftime(Sys.time(), request_start, units = \"secs\")\n      ) #<8>\n      response_data <- httr2::resp_body_json(response) #<9>\n      \n      \n      prediction_value <- if (is.list(response_data$.pred)) { #<10>\n        # If .pred is a list, get first element\n        as.numeric(response_data$.pred[[1]])\n      } else {\n        # If .pred is already numeric\n        as.numeric(response_data$.pred[1])\n      } #<10>\n      \n      logger::log_info(\n        \"Prediction successful - Session: {session$token} - response_time_sec: {round(response_time, 3)} - prediction: {prediction_value}\"\n      )\n      \n      if (response_time > 5) { #<11>\n        logger::log_warn(\n          \"Slow API response - Session: {session$token} - response_time_sec: {response_time}\"\n        )\n      } #<11>\n      \n      showNotification( #<12>\n        \"✅ Prediction successful!\", \n        type = \"message\", \n        duration = 3\n      ) #<12>\n      \n      return(prediction_value)\n      \n    }, error = function(e) { #<5>\n      \n      error_msg <- conditionMessage(e) #<13>\n      response_time <- as.numeric(\n        difftime(Sys.time(), request_start, units = \"secs\")\n      )\n      \n      logger::log_error(\n        \"Prediction request failed - Session: {session$token} - error: {error_msg} - response_time_sec: {round(response_time, 3)}\"\n      ) #<13>\n      \n      if (grepl(\"Connection refused|couldn't connect\", error_msg, ignore.case = TRUE)) { #<14>\n        user_msg <- \"API not available - is the server running on port 8080?\"\n        logger::log_error(\"API connection refused - Session: {session$token}\")\n      } else if (grepl(\"timeout|timed out\", error_msg, ignore.case = TRUE)) {\n        user_msg <- \"Request timed out - API may be overloaded\"\n        logger::log_warn(\"API timeout occurred - Session: {session$token}\")\n      } else {\n        user_msg <- paste(\"API Error:\", substr(error_msg, 1, 50))\n        logger::log_error(\n          \"Unknown API error - Session: {session$token} - error: {error_msg}\"\n        )\n      } #<14>\n      \n      showNotification( #<15>\n        paste(\"❌\", user_msg), \n        type = \"error\", \n        duration = 5\n      ) #<15>\n      \n      return(paste(\"❌\", user_msg)) #<16>\n    })\n  }) |> \n    bindEvent(input$predict, ignoreInit = TRUE)\n  \n  # outputs ----\n  output$pred <- renderText({\n    prediction <- pred() #<17>\n    \n    if (is.numeric(prediction)) { #<18>\n      result <- paste(round(prediction, 1), \"grams\") \n      logger::log_info(\n        \"Displaying prediction to user - Session: {session$token} - display_value: {result}\"\n      )\n      return(result)\n    } else {\n      logger::log_debug(\n        \"Displaying error message to user - Session: {session$token} - message: {prediction}\"\n      )\n      return(as.character(prediction))\n    } #<18>\n  })\n```\n:::\n\n1. Create reactive for predictions  \n2. Request start time   \n3. Request data converted to `request_data`        \n4. Input validation     \n5. Safely perform request   \n6. Notification for starting prediction   \n7. Perform `POST` request using `request_data`    \n8. Create response time   \n9. Convert data to JSON   \n10. Extract prediction - handle different response formats    \n11. Performance monitoring    \n12. Notification for successful prediction    \n13. Construct and display error message   \n14. Classify error types by API response    \n15. Notification for failed prediction    \n16. Error for failed prediction    \n17. Create prediction from reactive `pred()`  \n18. Format prediction for display   \n\nIn the **Console**, we see the following: \n\n\n```{.default}\nINFO [2025-12-23 08:32:56] Starting prediction request - Session: 8e0d4bd326098f9c2d2d01aeaab6b1db - request_data: [{\"bill_length_mm\":51,\"species\":\"Gentoo\",\"sex\":\"female\"}]\nINFO [2025-12-23 08:32:56] Prediction successful - Session: 8e0d4bd326098f9c2d2d01aeaab6b1db - response_time_sec: 0.293 - prediction: 4923.5183\nINFO [2025-12-23 08:32:56] Displaying prediction to user - Session: 8e0d4bd326098f9c2d2d01aeaab6b1db - display_value: 4923.5 grams\n```\n\nIn the UI, we see the following:\n\n![Click to enlarge](img/predictions.png){width='100%' fig-align='center'}\n\n### Logs \n\nThe **System Status** section includes a reactive display of the log file (`recent_logs`) and a timestamp for the last time the application was run (`log_timestamp`). \n\n#### UI\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nh5(\"Recent Logs:\"),\n  div(\n    style = \"font-family: 'Ubuntu Mono', monospace; font-size: 12px; background-color: #f8f9fa; padding: 10px; border-radius: 5px;\",\n    verbatimTextOutput(\"recent_logs\", placeholder = TRUE)\n  ),\nh6(\"Last updated:\", \n    textOutput(\"log_timestamp\", inline = TRUE)\n  )\n```\n:::\n\n\n\n#### Server\n\nThe logs are created using [`reactiveFileReader()`](https://shiny.posit.co/r/reference/shiny/1.7.0/reactivefilereader.html) and the log file (`shiny_app.log`) to update the display in the UI. This is a handy way of viewing the log outputs in the UI (without having to open the log file). \n\nThe final output is the timestamp. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# log file \nlog_file_content <- reactiveFileReader( #<1>\n  intervalMillis = 1000,\n  session = session,\n  filePath = \"shiny_app.log\", #<2>\n  readFunc = function(filePath) {\n    if (file.exists(filePath)) {\n      lines <- readLines(filePath, warn = FALSE)\n      mod_time <- file.mtime(filePath)\n      list( #<3>\n        lines = lines,\n        last_mod = mod_time,\n        total_lines = length(lines)\n      ) #<3>\n    } else {\n      list(\n        lines = character(0),\n        last_mod = Sys.time(),\n        total_lines = 0\n      )\n    }\n  }\n) #<1>\n# display\n  output$recent_logs <- renderText({\n    log_data <- log_file_content() #<4>\n    \n    if (length(log_data$lines) > 0) { #<5>\n      recent_lines <- if (log_data$total_lines > 5) {\n        tail(log_data$lines, 5)\n      } else {\n        log_data$lines\n      } #<5>\n      \n      logger::log_debug( #<6>\n        \"Updating recent logs display - Session: {session$token} - showing {length(recent_lines)} lines\"\n      )\n      paste(recent_lines, collapse = \"\\n\")\n    } else {\n      \"No logs available\"\n    } #<6>\n  })\n  \n  output$log_timestamp <- renderText({  #<7>\n    log_data <- log_file_content()\n    format(log_data$last_mod, \"%Y-%m-%d %H:%M:%S\")\n  })  #<7>\n```\n:::\n\n1. Reactive file reader for log monitoring  \n2. The `shiny_app.log` file we specified in the log configuration   \n3. Return as list     \n4. Create `log_data` object     \n5. Only return the top five lines of the log file       \n6. Log message for debugging log display      \n7. Log timestamp      \n\n\nIn the UI, we see the top 5 lines of the `shiny_app.log` file and the timestamp.\n\n![Click to enlarge](img/logs.png){width='100%' fig-align='center'}\n\nThe app includes a log for the session ending, too: \n\n\n```{.default}\nINFO [2025-12-23 08:53:16] User session ended - Session: 5f61a8ce042d21d5e6a6702127f24946\n```\n\n## Recap\n\nWe've covered how to create a [`vetiver`](https://rstudio.github.io/vetiver-r/) model (with [`duckdb`](https://duckdb.org/docs/stable/clients/r)) with [`plumber`](https://www.rplumber.io/) and access this API using a [`shiny`](https://shiny.posit.co/r/reference/shiny/) app. The [`httr2` package](https://httr2.r-lib.org/) is used to make API requests and [`logger`](https://daroczig.github.io/logger/) is used throughout the application to log behaviors and actions. \n\n![Click to enlarge](img/app.png){width='100%' fig-align='center'}\n\nAccess the code for the API and app in my [DO4DS: Lab Solutions](https://mjfrigaard.github.io/do4ds-labs/).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}