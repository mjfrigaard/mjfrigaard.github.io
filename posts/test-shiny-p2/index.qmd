---
title: "Unit tests for (non-package) shiny apps"
subtitle: "Part 2: Testing in non-package shiny apps"
author: "Martin Frigaard"
date: "2023-05-07"
categories: [shiny, testing]
image: "image.png"

draft: false

callout-icon: false

freeze: true

execute:
  echo: true
  warning: false
  eval: false
  collapse: true
---

```{r}
#| label: setup
#| eval: true 
#| echo: false 
#| include: false
library(ggplot2)
library(dplyr)
library(shiny)
library(vdiffr)
library(testthat)
library(shinytest2)
options(width = 60)
co_box <- function(color, header, contents = "Your text") {
  class <- switch(color,
    b = "note",
    g = "tip",
    r = "important",
    o = "caution",
    stop("Invalid `type`", call. = FALSE)
  )
  switch(color,
  b = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  g = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  o = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  r = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  stop("Invalid `type`", call. = FALSE)
  )
}
options(scipen = 999)
```


```{r}
#| label: pkgs
#| code-summary: packages
#| eval: false
library(testthat)
library(ggplot2)
library(dplyr)
library(shiny)
library(vdiffr)
library(shinytest2)
```


```{r}
#| label: co_box_test
#| eval: false 
#| results: asis
#| include: false
co_box(color = "r", "RED", "**This is red**
  
  **This is a new line**
  
  **this a another line**")
```

This post is the second in a series on testing shiny applications. I'll cover testing shiny module server functions using the [`testhat` package](https://testthat.r-lib.org/) *outside* an R package. This application is stored in the [`noap`](https://github.com/mjfrigaard/noap) GitHub repo if you'd like to follow along. 


## Testing module server functions

::: {style="font-size: 1.10em;"}
*...the ABCs of testing shiny server modules...*
:::

This post covers how `shiny::testServer()` works using the  [abcApp() shiny app.](https://github.com/mjfrigaard/noap/blob/main/app.R). The code for `abcApp()` is an RStudio project (i.e., there is a `noap.Rproj` file in the parent folder), but it's not part of an R package. Developing shiny applications as R packages is [highly](https://mastering-shiny.org/scaling-packaging.html) [recommended](https://engineering-shiny.org/structuring-project.html#shiny-app-as-a-package), but it's *possible* to begin writing unit tests before your application is a fully developed shiny app-package. 

For more information regarding performing tests outside of the package environment, see [this issue on GitHub](https://github.com/r-lib/testthat/issues/659). 

### abcApp()

The `abcApp()` application has been written using [shiny modules](https://shiny.posit.co/r/articles/improve/modules/) and a single [utility function](https://github.com/mjfrigaard/noap/blob/main/utils.R). 

`testthat` is designed to perform unit tests for R packages, but for the sake of simplicity,`abcApp()` has not been developed as part of a package. This will allow us to focus on the files involved in testing (and not all the other files that accompany R packages).

The standalone application function (`abcApp()`) is stored in `app.R`, the modules are contained in `modules.R`, and the single utility function is stored in `utils.R`: 

```{verbatim}
#| code-fold: show
#| code-summary: "abcApp() files and folder structure"
├── README.md
├── app.R
├── app.Rproj
├── modules.R
├── tests
└── utils.R

2 directories, 5 files
```

-   The `tests` folder contains the following:

    ```{verbatim}
    #| code-fold: show
    #| code-summary: "abcApp() test files"
    tests
    ├── testthat
    │   └── test-mod_abc_server.R
    └── testthat.R
    
    2 directories, 2 files
    ```

    -   `tests/` has a `testthat.R` file   
    -   New test files should be placed in `tests/testthat/` (see example `test-mod_abc_server.R` below):

#### UI module function

In this small example app, both ui and server modules are stored in the `modules.R` file. 

-   UI module: 

    ```{r}
    #| label: mod_abc_ui
    #| code-fold: show 
    #| eval: false
    #| code-summary: mod_abc_ui() (example ui module function)
    # ui module
    mod_abc_ui <- function(id) {
      
      ns <- shiny::NS(id)
      
      shiny::tagList(
        shiny::numericInput(
          inputId = ns("num"),
          label = shiny::h4(
            shiny::code("alphabet number")),
            value = 5, min = 1, max = 26
        ),
        shiny::verbatimTextOutput(
          outputId = ns("txt"))
      )
    }
    ```


#### Server module function

The counterpart to `mod_abc_ui()` is `mod_abc_server()`:

-   Server module:

    ```{r}
    #| label: mod_abc_server
    #| code-fold: show 
    #| eval: false
    #| code-summary: mod_abc_server() (example server module function)
    # server module
    mod_abc_server <- function(id) {
      
      shiny::moduleServer(id, function(input, output, session) {
        # reactive 
        letter <- shiny::reactive({ LETTERS[input$num] })
        # super script
        sup_scrpt <- shiny::reactive({ 
          num_super_script(x = input$num)
        })
        # output
        output$txt <- shiny::renderPrint({
          paste0("The ", input$num, sup_scrpt(), 
                 " letter in the alphabet is: ", letter())
        })
        
      })
    }
    ```

#### Module utility function

The `mod_abc_server()` function uses the `num_super_script()` function stored in `utils.R`:

-   Utility function:

    ```{r}
    #| label: num_super_script
    #| code-fold: show 
    #| eval: false
    #| code-summary: num_super_script() (example utility function)
    # utility function
    num_super_script <- function(x) {
          num <- as.numeric(x)
          if (num == 1) {
            super_script <- "st"
          } else if (num == 2) {
            super_script <- "nd"
          } else if (num == 3) {
            super_script <- "rd"
          } else {
            super_script <- "th"
          }
        return(super_script)
    }
    ```

#### Standalone app function

-   Standalone app functions include a call to `shiny::shinyApp()`:

    ```{r}
    #| code-fold: show 
    #| eval: false
    #| code-summary: abcApp() (example app with modules)
    # standalone shiny app function
    abcApp <- function() {
      shiny::shinyApp(
        ui = shiny::fluidPage(
          mod_abc_ui("x")
        ), 
        server = function(input, output, session) { 
          mod_abc_server("x")
        }
      )
    }
    abcApp()
    ```
    
    -   The call to `shiny::shinyApp()` is placed inside the `abcApp()` function 
    
    - The `ui` argument is wrapped in `shiny::fluidPage()` and the ui module function (`mod_abc_ui()`) is placed inside
    
    -   The `server` argument includes the standard `function(input, output, session)` and the module server companion function--`mod_abc_server()`--with a matching `id` arguments
    
    -   The `abcApp()` function is stored in the `app.R` file
    
Because `abcApp()` is not part of a package, `shiny` and `testthat` are loaded and the modules and utility function are sourced in the top of the `app.R` file.

```{r}
#| code-fold: show 
#| eval: false
#| code-summary: 'source utils.R and modules.R in app.R'
# packages --------------------------------------------------------
library(shiny)
library(testthat)

# utils ------------------------------------------------------------------
source("utils.R")

# modules ------------------------------------------------------------------
source("modules.R")
```


### Using `testServer()`

In the `test-mod_abc_server.R` file, I'll add `testServer()` and include the module server function as the first argument:   

-   `app` is the module server function (`mod_abc_server`) or any [`shiny.appobj`](https://shiny.posit.co/r/reference/shiny/1.7.0/shiny.appobj.html) 

    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: 'app = shiny.appobj'
    shiny::testServer(app = mod_abc_server, {

    })
    ```
    
#### Testing `input$`s

-   The first test I'll add will check the initial value of `input$num`
    
    -   I'll also include a custom message with `cat()`

    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: test initial value with custom message
    shiny::testServer(mod_abc_server, {
      # Test 1: check initial value
      testthat::expect_equal(input$num, NULL)
      cat("\n Test 1 initial input$num = NULL: ", is.null(input$num), "\n")
    })
    ```
    
    ```{verbatim}
    #| eval: false
    #| echo: true
    #| code-fold: false
    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
    Test 1 initial input$num = NULL:  TRUE 
    ```
    
    -   `testServer()` allows me to set new `input` values with `session$setInputs()`
    
        -   Use `session$setInputs()` to set `input$num` to `3`
        
        -   Test 2 confirms `input$num` has changed  
        
        -   Add another custom message with `cat()`
    
    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: setInputs() and test inputs
    shiny::testServer(mod_abc_server, {
      # set inputs
      session$setInputs(num = 3)
      # Test 2: check set inputs
      testthat::expect_equal(input$num, 3)
      cat("\n Test 2 setInputs(num = 3):", input$num, "\n")
    })
    ```
    
    ```{verbatim}
    #| eval: false
    #| echo: true
    #| code-fold: false
    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
     Test 2 setInputs(num = 3): 3 
    ```
    
#### Testing reactive values

-   The module's reactive values are also available to in `testServer()`

    -   Test 3 adds a test for `sup_scrpt()` (given the changed value of `input$num`)   
    
        -   The `expected` value is what I'm expecting `num_super_script()` to return.
    
    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: Check sup_scrpt() reactive value with expect_equal()
    shiny::testServer(mod_abc_server, {
      # Test 3: check super script
      testthat::expect_equal(object = sup_scrpt(), expected = "rd")
      cat("\n Test 3 sup_scrpt(): = 'rd':", sup_scrpt(), "\n")
    })
    ```
    
    ```{verbatim}
    #| eval: false
    #| echo: true
    #| code-fold: false
    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
     Test 3 sup_scrpt(): = 'rd': rd  
    ```
    
    -   For completeness I'll add a test for `letter()`
    
    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: Check letter() reactive value with expect_equal()
    shiny::testServer(mod_abc_server, {
      # Test 4: check letter
      testthat::expect_equal(object = letter(), expected = "C")
      cat("\n Test 4 letter() = C:", letter(), "\n")
    })
    ```
    
    ```{verbatim}
    #| eval: false
    #| echo: true
    #| code-fold: false
    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
     Test 4 letter() = C: C 
    ```
    
#### Testing `output$`s

-   The module output values are also available as `output$<value>`

    -   Test 5 will verify the `output$txt` (given the updated `input$num`)
    
    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: Check module output values
    shiny::testServer(mod_abc_server, {
      # Test 5: check output
    testthat::expect_equal(object = output$txt,
      expected =  "The 3rd letter in the alphabet is: C")
    cat("\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n",
      output$txt, "\n")
    })
    ```
    
    ```{verbatim}
     FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]
     Test 5 output$ = 'The 3rd letter in the alphabet is: C': 
     [1] "The 3rd letter in the alphabet is: C" 
    
    ─- Failure (test-mod_abc_server.R:1:1): (code run outside of `test_that()`) ──
    output$txt (`actual`) not equal to "The 3rd letter in the alphabet is: C" (`expected`).
    
    `actual`:   "[1] \"The 3rd letter in the alphabet is: C\""
    `expected`: "The 3rd letter in the alphabet is: C"        
    Backtrace:
      1. shiny::testServer(...)
           at test-mod_abc_server.R:1:0
     22. testthat::expect_equal(object = output$txt, 
       expected = "The 3rd letter in the alphabet is: C")
           at test-mod_abc_server.R:17:4
    
    [ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]
    ```
    
    -   **What happened?** I forgot to add the escape characters (`\"`) and line number (`[1]`) for the output
        -   I'll change the `expected` value and re-run the test: 
        
    ```{r}
    #| eval: false
    #| echo: true
    #| code-summary: 'Check module output values (again)'
    shiny::testServer(mod_abc_server, {
      # Test 5: check output
    testthat::expect_equal(object = output$txt,
      expected =  "The 3rd letter in the alphabet is: C")
    cat("\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n",
      output$txt, "\n")
    })
    ```
    
    ```{verbatim}
    [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
     Test 5 output$ = 'The 3rd letter in the alphabet is: C': 
     [1] "The 3rd letter in the alphabet is: C" 
    ```
    
    -   Finally, I'll run the tests with `test_dir()`      
    
    ```{r}
    #| eval: false
    #| code-fold: false
    #| echo: true
    #| code-summary: test_dir()
    test_dir(path = "/path/to/app/tests/testthat/")
    ```

    ```{verbatim}
    ✔ | F W S  OK | Context
    ⠏ |         0 | mod_abc_server         
    
     Test 1 initial input$num = NULL:  TRUE 
    
     Test 2 setInputs(num = 3): 3 
    
     Test 3 sup_scrpt(): = 'rd': rd 
    
     Test 4 letter() = C: C 
    
     Test 5 output$ = 'The 3rd letter in the alphabet is: C': 
     [1] "The 3rd letter in the alphabet is: C" 
    ✔ |         5 | mod_abc_server
    ══ Results ════════════════════════════════════════════════════
    Duration: 0.2 s
     [ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]
    🌈 Your tests are over the rainbow 🌈
    ```
    
The results show the tests passed! Now I am confident inputs, reactive values (`sup_scrpt()` & `letter()`), outputs behave as expected.
    
### Recap

The example above provides a workflow for using `testServer()` with `testthat` *outside* a package environment. The checklist below summarizes the steps required to test your application's module server functions:

1. Create test files (in `tests/testthat/`)  

    - [x]  All test files should have the `test-` prefix
  
2. Verify inputs with `session$setInputs(inputId = <value>)`

    - [x]   All `input$` values should initially be `NULL`

3. Test reactive values by referring to them as you would in the module server 

    - [x]   Compare expected values after changing inputs with `session$setInputs()`
  
4. Test outputs using `output$<value>` to check changes to the inputs and reactives

    - [x]   Check output values with `output$txt`

This concludes running tests on `abcApp()`. Ideally, shiny applications are developed as an R package (which I'll cover in a future post), but now you know how to perform tests if this isn't the case. The files for this demonstration are located [here.](https://github.com/mjfrigaard/noap) 

For a more comprehensive review of testing, check out the chapters on testing in [R packages](https://r-pkgs.org/testing-basics.html) and [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html).