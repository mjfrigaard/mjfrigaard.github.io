[
  {
    "objectID": "series/testing/series-testing-p4/index.html",
    "href": "series/testing/series-testing-p4/index.html",
    "title": "Testing shiny apps with shinytest2",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\nThis is the fourth post in a series on testing shiny applications. My previous posts have covered unit testing utility functions and testing module server functions with testServer(). In this post, I‚Äôll be covering testing shiny applications using testthat and shinytest2."
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#set-up",
    "href": "series/testing/series-testing-p4/index.html#set-up",
    "title": "Testing shiny apps with shinytest2",
    "section": "Set up",
    "text": "Set up\nshinytest2 requires a few steps to get up and running, so I‚Äôve included my start up steps below (in hopes that someone might find them useful).\n\nChromium\nFirst make sure you have Chromium headless browser installed. Chromium is the browser used to test and debug shiny apps with shinytest2.\nIf you‚Äôre using macOS, you can install Chromium using homebrew:\n\nbrew install --cask chromium\n\n\n\nshow/hide output\n==&gt; Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==&gt; Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==&gt; Installing Cask chromium\n==&gt; Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==&gt; Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nüç∫  chromium was successfully installed!\n\n\n\n\nchromote\nThe chromote package allows R to open Chromium. I had to make sure R knew where to find the Chromium application (this section helps) by passing the path to the app to Sys.setenv()\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\nYou can use find_chrome() to find your chrome app:\n\nchromote::find_chrome()\n\nYou can also locate the path to Chromium using by holding command ‚åò and clicking on the application icon\nThen set the CHROMOTE_CHROME environment variable to the Chromium path (make sure it‚Äôs not the path to Chrome.app:\n\n\nshow/hide\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n\n\nVerify the Chromium app/chromote install with ChromoteSession$new()\n\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n\n\n\n(a) Chromium\n\n\n\n\nFigure¬†1: Chromium headless browser\n\n\n\nGreat! Going through this step means shinytest2‚Äôs test recorder will (should) deploy when I‚Äôm recording tests."
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#app-package-contents",
    "href": "series/testing/series-testing-p4/index.html#app-package-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "App-package contents",
    "text": "App-package contents\nI‚Äôve created msst2ap (i.e., Mastering Shiny shinytest2 app-package) with devtools and usethis. It somewhat resembles an application using the golem framework, but with fewer opinions. You can download msst2ap here or install it using the following:\n\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n\nThe applications in msst2ap can be run with the their standalone app functions.\n\nModules & apps\nThe modules in msst2ap are from the Modules chapter of Mastering Shiny, with a few minor adjustments. These modules create namespaces for their inputs and outputs with the shiny::NS() function, which appends a second id string to each inputId/outputId.\nEach standalone app also includes the output from shiny::reactiveValuesToList():\n\nIn the ui:\n\n# for printing reactive values in application modules\nshiny::verbatimTextOutput(\"vals\")\n\nIn the server:\n\n# for printing reactive values in application modules\noutput$vals &lt;- shiny::renderPrint({\n  x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n  print(x, width = 30, max.levels = NULL)\n}, width = 30)\n\n\n\ndataset module\nThe dataset module displays the objects in the datasets package in a selectInput() according to a filter argument (i.e., is.data.frame, is.matrix, etc.).\ndatasetServer() returns the selected object as a reactive value. Read more here.\n\n\ndatasetInput() & datasetServer()\ndatasetInput &lt;- function(id, filter = NULL) {\n  names &lt;- ls(\"package:datasets\")\n\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n}\ndatasetServer &lt;- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    shiny::reactive(get(input$dataset, \"package:datasets\"))\n  })\n}\n\n\n\ndatasetApp()\n\n\ndatasetApp()\ndatasetApp &lt;- function(filter = NULL) {\n  ui &lt;- shiny::fluidPage(\n    datasetInput(\"dataset\", filter = is.data.frame),\n    shiny::tableOutput(\"data\"),\n    \n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"dataset\")\n    output$data &lt;- shiny::renderTable(head(data()))\n    \n    # for printing reactive values in application modules\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) datasetApp()\n\n\nFigure¬†2: datasetApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nBelow the table output in datasetApp(), the reactive values displays the inputId from datasetInput() and the namespace value from the shared id argument with datasetServer():\n$`dataset-dataset`\n\n\n\nselectVar module\nThe selectVar module selects a numeric variable the data() object returned from datasetServer().\nIt has a single utility function (find_vars()) which is used to filter the columns (variables):\n\n\nshow/hide selectVarInput() & selectVarServer()\nselectVarInput &lt;- function(id) {\n  shiny::selectInput(\n    shiny::NS(id, \"var\"),\n    label = \"Variable\",\n    choices = NULL\n  )\n}\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  \n  stopifnot(shiny::is.reactive(data))\n  stopifnot(!shiny::is.reactive(filter))\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n    shiny::observe({\n      shiny::updateSelectInput(\n        session, \"var\",\n        choices = find_vars(data(), filter))\n    }) |&gt;\n      shiny::bindEvent(data())\n\n    return(\n      shiny::reactive({\n        if (input$var %in% names(data())) {\n          data()[input$var]\n        } else {\n          NULL\n        }\n      }) |&gt;\n      shiny::bindEvent(input$var)\n    )\n\n  })\n}\n\n\nI‚Äôve made a few small changes to selectVarServer():\n\nIn the original version, input$var is returned as a vector:\n\nreactive(data()[[input$var]])\n\nI‚Äôve added some validation and return input$var as a single column from data():\n\nshiny::reactive({\n    if (input$var %in% names(data())) {\n        data()[input$var]\n    } else {\n        NULL\n    }\n  }) \n\nThe find_vars() function is also below:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter = is.vector) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\nselectVarApp()\nThe selectVarApp() extends the dataset module by collecting the returned reactive value, passing it to find_vars(), and returning a single column.\n\n\nshow/hide selectVarApp()\nselectVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n            shiny::tableOutput(\"out\"),\n            shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectVarApp()\n\n\nFigure¬†3: selectVarApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe reactive values in selectVarApp() are displayed below the table:\n\n\n\n\nVariables\n\nthe 1st var is from the inputId in selectVarInput()\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module\n$`var-var` \n\n\n\nData\n\ndataset is from the inputId in datasetInput()\n$`-dataset`\ndata is the shared namespace id from the dataset module\n$`data-dataset`\n\n\n\n\n\n\nselectDataVar module\nselectDataVar is from the Modules inside of modules section, so true to form, both the dataset and selectVar modules are called inside of the UI and Server modules:\n\n\nselectDataVarUI() & selectDataVarServer()\nselectDataVarUI &lt;- function(id) {\n  shiny::tagList(\n    datasetInput(\n      shiny::NS(id, \"data\"), \n        filter = is.data.frame),\n    selectVarInput(\n      shiny::NS(id, \"var\"))\n  )\n}\nselectDataVarServer &lt;- function(id, filter = is.numeric) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n    var\n\n  })\n}\n\n\n\nselectDataVarApp()\nThe selectDataVarApp() places the inputs in the sidebarPanel() and the outputs in the mainPanel().\n\n\nselectDataVarApp()\nselectDataVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        selectDataVarUI(\"var\")\n        ),\n      shiny::mainPanel(\n        shiny::tableOutput(\"out\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n        )\n    )\n  )\n  server &lt;- function(input, output, session) {\n    var &lt;- selectDataVarServer(\"var\", filter)\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectDataVarApp()\n\n\nFigure¬†4: selectDataVarApp() in msst2ap\n\n\n\nThe reactive values from selectDataVarApp() reflect the nested module structure:\n\n\n\n\nVariables\n\nThe first var belongs to the inputId in selectVarInput(),\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module,\n$`-var-var`\nthe 3rd var is the call to the selectVar module inside selectDataVar\n$`var-var-var` \n[1] \"Ozone\"\n\n\n\nData\n\ndataset belongs to the inputId in datasetInput(),\n$`-dataset` \ndata is the shared namespace id from the dataset module,\n$`-data-dataset` \nvar is the call to the dataset module inside selectDataVar\n$`var-data-dataset` \n[1] \"airquality\"\n\n\n\n\n\n\nhistogram module\nThe final modules and application I‚Äôll use from Mastering Shiny are from the Case study: histogram section. This application uses the existing dataset and selectVar modules to pass a single variable to the render a histogram:\n\n\nshow/hide histogramOutput() & histogramServer()\nhistogramOutput &lt;- function(id) {\n  shiny::tagList(\n    shiny::numericInput(\n      shiny::NS(id, \"bins\"),\n      label = \"bins\",\n      value = 10,\n      min = 1,\n      step = 1\n    ),\n    shiny::plotOutput(\n      shiny::NS(id, \"hist\"))\n  )\n}\nhistogramServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(shiny::is.reactive(x))\n  stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    output$hist &lt;- shiny::renderPlot({\n        shiny::req(x())\n        main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main\n        )\n      }, res = 96)\n\n    output$data &lt;- shiny::renderPrint({\n      shiny::req(x())\n      print(head(x()))\n    })\n  })\n}\n\n\nI‚Äôve made some changes to the histogramServer() function (to accomodate the changes to the selectVar module).\n\nThe original renderPlot() call in histogramServer():\n\n  output$hist &lt;- renderPlot({\n    req(is.numeric(x()))\n    main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n    hist(x(), breaks = input$bins, main = main)\n  }, res = 96)\n\nThe updated renderPlot() call in histogramServer():\n\n  output$hist &lt;- shiny::renderPlot({\n    shiny::req(x())\n    main &lt;- paste0(title(), \" [bins =\", input$bins, \"]\")\n    hist(purrr::as_vector(x()),\n      breaks = input$bins,\n      main = main)\n  }, res = 96)\n\n\nAs you can see, req() is verifying x() exists, but doesn‚Äôt check it‚Äôs class with is.numeric().\nx() is also passed to purrr::as_vector() before it‚Äôs plotted with hist()\n\n\n\nhistogramApp()\n\n\nhistogramApp()\nhistogramApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    x &lt;- selectVarServer(\"var\", data)\n    histogramServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\nFigure¬†5: histogramApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe displayed reactive values in histogramApp() are described below:\n\n\n\n\nPlot\n\nThe inputId from histogramOutput() and the shared namespace id\n$`hist-bins`\n[1] 10\n\n\n\nVariables\n\nThe inputId from selectVarInput() and the shared namespace id\n$`var-var`\n[1] \"Ozone\"\n\n\n\nData\n\nThe inputId from datasetInput() and the shared namespace id\n$`data-dataset` \n[1] \"airquality\"\n\n\n\n\n## Using shinytest2\nshinytest2 is extremely well documentation. I highly recommended the Get Started vignette. In the next sections, I‚Äôll cover some examples for what I‚Äôve included in the msst2ap.\n\n\n\n\n\n\nWhy shinytest2?\n\n\n\n\n\n\nWhat happened to shinytest?\nshinytest2 replaced shinytest on 2022-04-27. If you‚Äôve previously written tests with shinytest‚Äìor are curious how shinytest2 if different‚ÄìI recommend going through the Migrating from shinytest vignette.\n\n\n\n\nRun shinytest2::use_shinytest2() to create the initial files for shinytest2:\n\nshinytest2::use_shinytest2()\n\n\n\nshow/hide output from use_shinytest2()\n! Runner already found: tests/testthat.R\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚úî Adding '*_.new.png' to '.gitignore'\n‚úî Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\n‚úî Setting active project to '/projects/msst2ap'\n‚úî Adding 'shinytest2' to Suggests field in DESCRIPTION\n‚Ä¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\n‚Ä¢ Then directly refer to functions with `shinytest2::fun()`\n‚úî Setting active project to '&lt;no active project&gt;'\n\n\n\nuse_shinytest2() adds the setup-shinytest2.R script to my tests/testthat/ folder:\n\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îî‚îÄ‚îÄ setup-shinytest2.R\n\n\nThe setup-shinytest2.R file contains a single call to shinytest2::load_app_env(), which ‚ÄúExecutes all ./R files and global.R into the current environment‚Äù"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#recording-tests",
    "href": "series/testing/series-testing-p4/index.html#recording-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recording tests",
    "text": "Recording tests\nNew tests with shinytest2 can be created by launching the test event recorder, which allows us interact with our application, observe it‚Äôs behavior, and record inputs, reactive values, and outputs. To record a test, run shinytest2::record_test().\nThe first argument in record_test() is the path to application. If you‚Äôve stored your application in an app.R file, record_test() will automatically load that application.\n\nIf you encounter a message telling you Chromium is disconnected, try installing the development version of chromote:\n\n# run this in the console to make sure you have dev version of chromote\nremotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\n\nIn msst2ap, the application in app.R is the histogramApp(), so the test recorder will automatically open with this application if I run record_test() (without providing the path to a shiny app).\n\nshinytest2::record_test()\n\n\nIn Chromium\n\n\n\n\n\n\n\n\n(a) shinytest2::record_test()\n\n\n\n\nFigure¬†6: record_test() with application in app.R\n\n\n\nThe app argument can also be a ‚Äúpath to a Shiny application‚Äù. For example, I have ‚Äòdevelopment‚Äô versions of each application in msst2ap in inst/dev/:\n\n\nshow/hide contents of msst2ap/inst/dev\ninst/dev\n‚îú‚îÄ‚îÄ datasetApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ histogramApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ selectDataVarApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îî‚îÄ‚îÄ selectVarApp\n    ‚îú‚îÄ‚îÄ DESCRIPTION\n    ‚îú‚îÄ‚îÄ R\n    ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n    ‚îú‚îÄ‚îÄ README.md\n    ‚îî‚îÄ‚îÄ app.R\n\n9 directories, 16 files\n\n\nI can pass the path to each application to the app argument in record_test():\n\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n\nThis opens Chromium with our shiny app:\n\n\n\n\n\n\n\n\n(a) record_test(‚Äúinst/dev/histogramApp/‚Äù)\n\n\n\n\nFigure¬†7: record_test() with app in inst/dev/histogramApp/ folder\n\n\n\nThe test event recorder displays the shiny app, but also includes a window for recording each application ‚Äòevent.‚Äô\n\nExpectations\nI‚Äôll start by recording a test for histogramApp(). On the right-hand side of the Chromium headless browser, you‚Äôll see the shinytest2 expectations window:\n\n\n\n\n\n\n\n\n(a) shinytest2 expectations\n\n\n\n\nFigure¬†8: shinytest2 expectations in record_test()\n\n\n\nThe initial value in the Code window displays the dimensions of the application in Chromium (app$set_window_size(width = , height = )).\n\n\nEvents\nWhen I interact with the application (i.e., make changes to the inputs), each change is an ‚Äòevent‚Äô that is recorded in the test:\n\n\n\n\n\n\n\n\n(a) change inputs\n\n\n\n\nFigure¬†9: Changing app inputs\n\n\n\n\n\nCode\nAll events are recorded as code in the Code section of shinytest2 expectations:\n\n\n\n\n\n\n\n\n(a) shinytest2 code expectations\n\n\n\n\nFigure¬†10: Recorded code for each event\n\n\n\n\n\nExpect Shiny values\nWhen I‚Äôve finished interacting with the application, I click on the Expect Shiny values button at the top of shinytest2 expectations. This will add app$expect_values() to the Code section:\n\n\n\n\n\n\n\n\n(a) expect-shiny-values\n\n\n\n\nFigure¬†11: Expect Shiny values in shinytest2 expectations\n\n\n\n\n\nSave test and exit\nFinally, to save the test, enter a Test name and click Save test and exit\n\n\n\n\n\n\n\n\n(a) name-save-exit\n\n\n\n\nFigure¬†12: Name, save and exit record_test()\n\n\n\n\n\n\nIn Console\nBack in the Console, the shinytest2 test recorder is performing the following actions behind the scenes:\n\nThe Chromium headless browser opens with the histogramApp() and shiny is loaded\n\nListening on http://127.0.0.1:7418\n{shiny} R stderr ----------- Loading required package: shiny\n\nWarning: The first warning is a caused by the call to shiny::loadSupport(). It‚Äôs a known issue, so we can assume the developers are working on it!\n\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\n  contain an R package. Sourcing files in R/ may cause unexpected behavior.\n\nWe are told the application is being run in test mode, which ‚Äòlets the AppDriver retrieve values‚Äô from the app\n\n{shiny} R stderr ----------- Running application in test mode.\n{shiny} R stdout ----------- ‚Ñπ Loading msst2ap\n\nWarning: The tests/testthat.R file (i.e., the ‚Äòtest runner‚Äô) was overwritten and tests are now run with shinytest2::test_app()\n\nWarning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\ncall to ensure proper a testing environment.\n\nWhen I clicked ‚ÄúSave test and exit‚Äù, the changes made to tests/testthat.R and tests/testthat/test-shinytest2.R are saved:\n\n‚Ä¢ Saving test runner: tests/testthat.R\n‚Ä¢ Saving test file: tests/testthat/test-shinytest2.R\n\nA call to shinytest2::load_app_env() is added to setup-shinytest2.R and the test file (tests/testthat/test-shinytest2.R) is opened:\n\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚Ä¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n\nThe new test is saved in the tests/testthat/test-shinytest2.R file and automatically run.\n\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#test-contents",
    "href": "series/testing/series-testing-p4/index.html#test-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test contents",
    "text": "Test contents\nThe contents of the test file generated from the test recorder are below:\n\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on Run Test or by using test_file() from testthat:\n\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nBecause msst2ap is a package, running tests with shinytest2 will produce the warning below:\n\n\n\nshiny::loadSupport() warning\n\n\nAs noted above, this warning is known by the shinytest2 package authors and is being addressed in a future release.\n\n\n\n\nNow that I know the first shinytest2 test is passing, I‚Äôll dive into each line in the test.\n\nAppDriver\nshinytest2 uses the AppDriver to create ‚Äúa full simulation of a Shiny app‚Äù. When recording tests, this will be the first argument (along with the name of the .png and .json snapshot testthat files, and the height and width of the ChromoteSession).\n\nThe example from the test above is below:\n\n app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n\n\n\n\nset_inputs()\nWhen recording shinytest2 tests, every change to the applications inputs will result in a call to app$set_inputs(). This function is similar to the testServer() call to session$setInputs() (i.e., the inputs are provided as ‚Äúname-value pairs‚Äù, i.e., inputId = \"value\").\n\nIn the histogramApp(), these are provided with the appended namespaces:\n\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n\n\n\n\nexpect_values()\nThe documentation on expect_values() is definitely worth reading. expect_values() is added to the test file when Expect Shiny values is clicked in the test recorder and ‚Äúcreates a list of values and compares them to the current values of the application.‚Äù\n\nexpect_values() = ‚ÄúExpect all input, output, and export values are consistent‚Äù\n\n  app$expect_values()"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#test-results",
    "href": "series/testing/series-testing-p4/index.html#test-results",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test results",
    "text": "Test results\nThe results from running the new test file (test-shinytest2.R) are below:\n\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n‚úî | F W S  OK | Context\n‚úî |   2     1 | shinytest2 [6.3s]                                             \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\nTwo warnings are displayed because the test adds two new files to the tests/testthat/_snaps/ folder:\n\ntests/testthat/_snaps/\n‚îî‚îÄ‚îÄ shinytest2\n    ‚îú‚îÄ‚îÄ histogramApp-001.json\n    ‚îî‚îÄ‚îÄ histogramApp-001_.png\n\n2 directories, 2 files\n\nThese are the files new test runs will be compared against (i.e., our ‚Äòbaseline‚Äô snapshots). I‚Äôll briefly cover their contents below:\n\n_snaps\nexpect_values() generates two snapshot files in the tests/testthat/_snaps/ folder: one .png and one .json file:\n\n.png\nThe image saved in tests/testthat/_snaps/histogramApp-001_.png is below:\n\n\n\n\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (attitude and privileges).\n\n\n.json\nThe .json file saved in tests/testthat/_snaps/histogramApp-001.json contains the snapshot inputs, outputs, and exports:\n\nThe inputs show the three changed values (\"data-dataset\", \"var-var\", and \"hist-bins\").\n\n\nshow/hide snapshot inputs\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n    \"hist-bins\": 15,\n    \"var-var\": \"privileges\"\n  },\n\n\n\nThe two outputs are stored in \"hist-hist\" and \"vals\":\n\n\"hist-hist\" holds the updated image (stored in the image data hash), along with various other characteristics of the plot:\n\n\nshow/hide snapshot outputs\n  \"output\": {\n    \"hist-hist\": {\n      \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n      \"width\": 682.6640625,\n      \"height\": 400,\n      \"alt\": \"Plot object\",\n      \"coordmap\": {\n        \"panels\": [\n          {\n            \"domain\": {\n              \"left\": 27.8,\n              \"right\": 87.2,\n              \"bottom\": -0.24,\n              \"top\": 6.24\n            },\n            \"range\": {\n              \"left\": 78.79664956011726,\n              \"right\": 642.3048029692084,\n              \"bottom\": 301.08,\n              \"top\": 77.71999999999998\n            },\n            \"log\": {\n              \"x\": null,\n              \"y\": null\n            },\n            \"mapping\": {\n\n            }\n          }\n        ],\n        \"dims\": {\n          \"width\": 682.6640625,\n          \"height\": 400\n        }\n      }\n    },\n\n\n\"vals\" contains the reactive values from reactiveValuesToList():\n\n\nshow/hide snapshot outputs\n    \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n  },\n\n\nI didn‚Äôt export any values in this test, so \"export\" is empty:\n\n\nshow/hide snapshot outputs\n  \"export\": {\n\n  }\n}\n\n\n\nI‚Äôll cover this in a later test.\n\n\n\n\nNamespaces\nThe contents of the .json snapshot should look somewhat familiar for the three modules contained in histogramApp():\n\nFor example, the inputId for \"dataset\" in the datasetInput/Server module communicates between the UI and server using the shared id argument \"data\"\n\n# in datasetInput()\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n# in histogramApp()\n  shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame)\n      )\n\nThis creates the $`data-dataset` output we see the verbatimTextOutput() at the bottom of the application:\n\n$`data-dataset`\n[1] \"attitude\"\n\nIn the .json snapshot, this inputId is represented in the following \"input\":\n\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n  },\n\n\nNamespaces and inputIds will come up again if you start writing your own tests, which I‚Äôll cover below."
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#writing-tests",
    "href": "series/testing/series-testing-p4/index.html#writing-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Writing tests",
    "text": "Writing tests\nThe great thing about testing with shinytest2 is the ability to interact with the AppDriver as you write tests. I‚Äôll demo writing a test for the datasetApp() by adapting the contents of test-shinytest2.R into a new test-shinytest2-datasetApp.R file.\n\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îÇ   ‚îî‚îÄ‚îÄ shinytest2/\n‚îÇ       ‚îú‚îÄ‚îÄ histogramApp-001.json\n‚îÇ       ‚îî‚îÄ‚îÄ histogramApp-001_.png\n‚îú‚îÄ‚îÄ setup-shinytest2.R\n‚îú‚îÄ‚îÄ test-shinytest2-datasetApp.R &lt;- new test file!\n‚îî‚îÄ‚îÄ test-shinytest2.R\n\n3 directories, 5 files\n\nIn the new test test-shinytest2-datasetApp.R file, I‚Äôll start with a call to testthat::test_that(), then create a new app object with the Chromium headless browser. The namespaced standalone app function can be passed to the first argument of AppDriver$new(), followed by the height and weight (which I‚Äôve adjusted to fit the datasetApp()).\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n})\n\nIn the Console, I can use app$view() to open the Chromium browser:\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigure¬†13: View application with app$view()\n\n\n\nChromium displays the same app I see when I run msst2ap::datasetApp() in the console, but the headless browser has some additional developer tools (read more).\n\nSetting inputs\nIf I continue to adapt each line in test-shinytest2.R to the datasetApp(), I see that next lines set the inputIds for dataset-dataset to the attitude dataset with app$set_input() (Note that this uses the module notation above (i.e., \"id-inputId\"):\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n\nIf you can see both windows, you‚Äôll see the application values change in the Chromium browser:\n\n\n\n\n\n\n\n\n(a) app$set_inputs()\n\n\n\n\nFigure¬†14: Set application inputs with app$set_inputs()\n\n\n\n\n\nChecking inputs\nIn the previous test, I used the expect_values() to capture a list of all the app values (input, output, export). I can also capture these values in a list inside the test by including a call to app$get_values() and assigning the output to app_values.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n})\n\napp_values has a similar structure to the .json snapshot covered above (i.e., with input, output, and export):\n\nstr(app_values)\n\n\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"&lt;table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n\nI can narrow the scope of the test by using app_values to verify only the input that was changed with app$set_inputs()::\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n\nAt the end of the test, I‚Äôll add a call app$stop() to close the Chromium app.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n\n\n\nRunning tests\nI‚Äôll save the test-shinytest2-datasetApp.R file and run the test with testthat::test_file():\n\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nIf you encounter the error message below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\n‚îÄ‚îÄ Skipped tests (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚Ä¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n\nTry installing and loading chromote and shinytest2 again (this seemed to work for me).\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n\n\n\n\n\nIn the initial run of the test for datasetApp(), no snapshot files are generated because the test didn‚Äôt include a call to app$export_values().\nI see the tests passes:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#exporting-test-values",
    "href": "series/testing/series-testing-p4/index.html#exporting-test-values",
    "title": "Testing shiny apps with shinytest2",
    "section": "Exporting test values",
    "text": "Exporting test values\nThe shinytest2 documentation repeatedly recommends exporting test values from shiny applications with shiny::exportTestValues().\nI‚Äôll demonstrate exporting test values from selectVarApp() by adding the following to the server function in inst/dev/app.R:\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n\nAfter saving, loading and building the package, I‚Äôll create the test-shinytest2-selectVarApp.R test file and add the initial contents to create the AppDriver object:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n\nNote that in this test, I can load the development version of selectVarApp() with system.file() (this is a similar folder structure to apps built with golem and leprechaun frameworks)\nAfter entering app$view() in the Console, the application opens in the Chromium headless browser again:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigure¬†15: View selectVarApp() application with app$view()\n\n\n\nIn the test file, I‚Äôll use app$set_values() to change the $`data-dataset` and $`var-var` inputs:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n})\n\nI‚Äôll use app$get_values() to store the exported input/output/export test values in app_values:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values &lt;- app$get_values()\n    \n})\n\napp_values is a list (similar to the .json snapshot file), but now we‚Äôve explicitly exported values from the server in selectVarApp():\n\nnames(app_values$export)\n\n\n[1] \"data\" \"var\" \n\nI can use app_values to verify the structure of each exported object:\n\ndata should be a data.frame()\n\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n\nvar should be a single column data.frame()\n\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\nOnce again, I end the test with a call to app$stop(). The completed test for selectVarApp() is below:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values &lt;- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n\nI can run the test with testthat::test_file().\n\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n\nThe results are below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#testing-complex-outputs",
    "href": "series/testing/series-testing-p4/index.html#testing-complex-outputs",
    "title": "Testing shiny apps with shinytest2",
    "section": "Testing complex outputs",
    "text": "Testing complex outputs\nI‚Äôve created an adapted version of the histogramApp() in the inst/dev/gghistApp/ folder (view contents here):\n\ninst/dev/gghistApp/\n            ‚îú‚îÄ‚îÄ DESCRIPTION\n            ‚îú‚îÄ‚îÄ R/\n            ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n            ‚îú‚îÄ‚îÄ README.md\n            ‚îî‚îÄ‚îÄ app.R\n\n2 directories, 4 files\n\ngghistApp() renders a ggplot2 graph, which makes it easier to demonstrate this example of checking a plot from the shinytest2 package website.\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\n\n\n\n\n\n(b) gghistApp()\n\n\n\n\nFigure¬†16: histogramApp() vs.¬†gghistApp()\n\n\n\nThe gghistApp() is similar to histogramApp(), but instead of using hist() to generate the plot, a reactive plot_obj() is passed to shiny::renderPlot() (like the example above).\nDue to the structure of the modules in the application, the exportTestValues() function is placed in the gghistServer() function:\n\n\nshow/hide gghistServer()\ngghistServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj &lt;- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist &lt;- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |&gt;\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n\n\n\ngghistServer() is replaces histogramServer() in the standalone app function (gghistApp()):\n\n\nshow/hide gghistApp()\ngghistApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n\n    x &lt;- selectVarServer(\"var\", data)\n\n    gghistServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n      }, width = 30)\n\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\nIn the test-shinytest2-gghistApp.R test file, I‚Äôll verify the vdiffr package is installed with testthat::skip_if_not_installed(), then create the AppDriver object with a call to system.file() and set the height and width:\n\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n\nView the application in the Chromium browser by running app$view() in the Console:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigure¬†17: View gghistApp() application with app$view()\n\n\n\n\nExpectations\nI‚Äôll replicate the example from the website using the gghistApp():\n\nThe first expectations in the example test the default input values with app$get_value(input = ):\n\n  # Verify initial data\n  app_init_data &lt;- app$get_value(input = \"data-dataset\")\n  testthat::expect_equal(\n    object = app_init_data, \n    expected = \"BOD\")\n\n  # Verify initial variable\n  app_init_var &lt;- app$get_value(input = \"var-var\")\n  testthat::expect_equal(\n    object = app_init_var, \n    expected = \"Time\")\n\nNext, the expectations check the exported values after changing inputs with app$set_values() and app$get_value(export = )\n\n  # Verify exported `x()` data\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app_exp_x_01 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_01, \n    expected = mtcars[1])\n\n  # Verify exported `plot_obj()` data\n  app$set_inputs(`var-var` = \"wt\")\n  app_exp_plot_obj_01 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_01,\n    expected = purrr::as_vector(app_exp_plot_obj_01))\n\nThe bins are set to a new value after verifying the exported values with app$set_values() and app$get_value(input = )\n\n  # Verify `hist-bins` changes\n  app$set_inputs(`hist-bins` = 15)\n  app_set_bins_01 &lt;- app$get_value(input = \"hist-bins\")\n  testthat::expect_equal(\n    object = app_set_bins_01,\n    expected = 15)\n\nThe plot is verified with the exported hist-plot_obj and expect_doppelganger() from the vdiffr package.\n\n# Verify `hist-plot_obj` changes\nplot_obj_15 &lt;- app$get_value(export = \"hist-plot_obj\")\nvdiffr::expect_doppelganger(\n  title = \"hist-plot_obj-15\",\n  fig = plot_obj_15)\n\n\nI saved the test file and ran the test to confirm the snapshot file was created in tests/testthat/_snaps/:\n\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n\nThe x(), plot_obj() and hist-bins are updated again with new values:\n\n  ## Update `data` to USArrests\n  app$set_inputs(`data-dataset` = \"USArrests\")\n  app_exp_x_02 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_02,\n    expected = USArrests[1])\n\n  ## Update `var` to UrbanPop\n  app$set_inputs(`var-var` = \"UrbanPop\")\n  app_exp_plot_obj_02 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_02,\n    expected = purrr::as_vector(app_exp_plot_obj_02))\n\n  ## Update `bins` to 12\n  app$set_inputs(`hist-bins` = 12)\n  app_set_bins_02 &lt;- app$get_value(input = \"hist-bins\")\n  expect_equal(\n    object = app_set_bins_02,\n    expected = 12)\n\nThe new plot is verified again with expect_doppelganger()\n\n  # Verify `hist-plot_obj` changes\n  plot_obj_12 &lt;- app$get_value(export = \"hist-plot_obj\")\n  vdiffr::expect_doppelganger(\n    title = \"hist-plot_obj-12\",\n    fig = plot_obj_12)\n\nThis initial run of this test will show a warning again as the snapshot file is saved to tests/testthat/_snaps/:\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n\n\n\n\nResults\nThe final results of the test-shinytest2-gghistApp.R are below:\n\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#recap",
    "href": "series/testing/series-testing-p4/index.html#recap",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recap",
    "text": "Recap\nThis post has covered tests with shinytest2 for an app-package containing a shiny application with modules. The test recorder simplifies testing specific behaviors, and the AppDriver makes it possible to build a set of test expectations iteratively."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html",
    "href": "series/testing/series-testing-p3/index.html",
    "title": "How do I test shiny modules?",
    "section": "",
    "text": "This is the third post in a series on testing shiny applications. I‚Äôll cover testing shiny module server functions using the testhat package and shiny‚Äôs testServer() function."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#testing-shiny-modules",
    "href": "series/testing/series-testing-p3/index.html#testing-shiny-modules",
    "title": "How do I test shiny modules?",
    "section": "Testing shiny modules",
    "text": "Testing shiny modules\n\n\n\nShiny functions pose a couple of unique challenges for testing. First, we can‚Äôt execute shiny server functions in the console. Second, as shiny apps become more complex, it‚Äôs highly recommended to break up the code base into modules. Modules have additional challenges due to their reactivity being split between interconnected UI and server functions.\nshiny doesn‚Äôt provide a direct, built-in way to test modules, but the testServer() function addresses these challenges by testing ‚Äúreactive interactions‚Äù in module server functions. testServer() also works with testthat, which means we can structure these ‚Äòreactive interaction‚Äô tests just like other unit tests (for non-application functions)."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#shiny-app-package",
    "href": "series/testing/series-testing-p3/index.html#shiny-app-package",
    "title": "How do I test shiny modules?",
    "section": "Shiny app-package",
    "text": "Shiny app-package\ntestthat is designed to work within an R package, so I‚Äôve put together the mstsap, (i.e., a Mastering Shiny testServer app-package) to demonstrate writing tests with testServer(). The functions, modules, and applications in mstsap come from the Shiny Modules chapter of Mastering Shiny. Specifically, sections 19.3 through 19.3.4. If you haven‚Äôt read this chapter‚Äìstart there.\n\n# to get the mstsap package used in this post:\nrenv::install(\"mjfrigaard/mstsap\", prompt = FALSE)\nlibrary(mstsap)\n\n\n\n\n\n\n\nWhy create an app-package?\n\n\n\n\n\n\nA shiny app-package is a shiny application that‚Äôs been developed as (or converted to) an R package. The benefits of storing shiny apps in R packages have been well documented, but I‚Äôll summarize just a few that are specific to testing:\n\nStandardized folder structure:\n\nIf unit tests are performed with testthat, minimal setup is required to perform tests.\nusethis::use_testthat() sets up test files in the tests/testthat/ folder (to test the code in the R/ folder)\n\nRead more about using testthat with R packages here.\n\nTest extras:\n\nTest data can be placed in tests/testthat/&lt;test dir&gt;/&lt;test_data.rds&gt;\n\nThe code used to create the test data should be placed in make_&lt;test_data.rds&gt;\n\nAdditional testing functions can be stored in tests/testthat/helpers.R\n\nRead more about test helpers here.\n\nDevelopment tools:\n\nIf you‚Äôre using RStudio, tests can be run individually (testthat::test_file()) or collectively (devtools::test()), and code helpers and data are loaded using devtools::load_all()\n\nTests created with testthat remain isolated during development\n\nRead more about developing packages with RStudio in the R Packages text."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#modules",
    "href": "series/testing/series-testing-p3/index.html#modules",
    "title": "How do I test shiny modules?",
    "section": "Modules",
    "text": "Modules\nShiny modules are ‚Äòa pair of UI and server functions‚Äô designed to compartmentalize input and output IDs into distinct namespaces (‚Äúa namespace is to an ID as a directory is to a file‚Äù).\n\n‚ñà‚îÄshinyApp \n‚îú‚îÄui = ‚ñà‚îÄfluidPage \n‚îÇ      ‚îî‚îÄ‚ñà‚îÄmod_ui \n‚îÇ        ‚îî‚îÄid = \"X\" \n‚îú‚îÄserver = `function(input, output, session)` \n‚îî‚îÄ‚ñà‚îÄmod_server \n  ‚îî‚îÄid = \"X\" \n\nIn a previous post, I used the following definition for unit tests,\n\n‚ÄúA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work.‚Äù - The Art of Unit Testing, 2nd edition\n\nModules can also be broken into discrete ‚Äòunits of work‚Äô with expected ‚Äòend results.‚Äô However, the ‚Äòunit of work‚Äô for a shiny module is usually accomplished using a combination of three functions: a module UI function, a module server function, and any helper/utility functions.\n\n\n\n\n\n\nShiny module refresher\n\n\n\n\n\nModule UI functions typically wrap the layout, input, and output functions in tagList(). Module server functions contain the ‚Äòbackend‚Äô code that typically goes in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using NS() (namespace) in the UI function, and called in the server function with moduleServer().\n\nModule UI functions\nBelow is an example module UI function:\n\nmod_fun_ui &lt;- function(id) {\n  tagList(\n    numericInput(inputId = NS(namespace = id, id = \"num_input\")),\n    uiOutput(outputId = NS(namespace = id, id = \"num_out\"))\n  )\n}\n\n\nmod_fun_ui creates a dedicated namespace for one inputId and one outputId with shiny::NS():\n\n‚ñà‚îÄmod_fun_ui \n‚îú‚îÄid \n‚îî‚îÄ‚ñà‚îÄtagList \n  ‚îú‚îÄ‚ñà‚îÄnumericInput \n  ‚îÇ ‚îî‚îÄinputId = ‚ñà‚îÄNS \n  ‚îÇ             ‚îú‚îÄnamespace = id \n  ‚îÇ             ‚îî‚îÄid = \"num_input\" \n  ‚îî‚îÄ‚ñà‚îÄuiOutput \n    ‚îî‚îÄoutputId = ‚ñà‚îÄNS \n                 ‚îú‚îÄnamespace = id \n                 ‚îî‚îÄid = \"num_out\" \n\n\n\n\nModule server functions\nThe corresponding module server function is below:\n\nmod_fun_server &lt;- function(id) {\n        moduleServer(id, function(input, output, session) {\n            ns &lt;- session\n          output$num_out &lt;- uiOutput(outputId = input$num_input)\n      })\n}\n\n\nThe code to render the reactive input$num_input with output$num_out is contained in the nested call to moduleServer()\n\n‚ñà‚îÄmod_fun_server \n‚îú‚îÄid \n‚îî‚îÄ‚ñà‚îÄmoduleServer \n  ‚îú‚îÄid = id \n  ‚îú‚îÄserver = ‚ñà‚îÄ`function(input, output, session)` \n  ‚îÇ          ‚îú‚îÄ`ns &lt;- session` \n  ‚îÇ          ‚îú‚îÄ`output$num_out &lt;-` \n  ‚îÇ          ‚îî‚îÄ‚ñà‚îÄrenderUI \n  ‚îÇ            ‚îî‚îÄ`input$num_input` \n  ‚îî‚îÄsession = session \n\n\n\n\nUsing modules\nBoth module functions are combined in the ui and server arguments of shinyApp():\n\nshinyApp(\n    ui = fluidPage(\n          mod_fun_ui(id = \"mod\")\n        ),\n   server = function(input, output, session) \n          mod_fun_server(\"mod\")\n  )\n\n\nThe id arguments connect the UI and server functions to communicate between the UI and backend of the app:\n\n‚ñà‚îÄshinyApp \n‚îú‚îÄui = ‚ñà‚îÄfluidPage \n‚îÇ      ‚îî‚îÄ‚ñà‚îÄmod_fun_ui \n‚îÇ        ‚îî‚îÄid = \"mod namespace\" \n‚îî‚îÄserver = ‚ñà‚îÄ`function(input, output, session)` \n           ‚îî‚îÄ‚ñà‚îÄmod_fun_server \n             ‚îî‚îÄid = \"mod namespace\" \n\n\nI recommend creating test files when you create module files (i.e., with usethis::use_r() & usethis::use_test()).\n\n\n\n\n\nModules in mstsap\nmstsap contains three modules: dataset, selectVar, and selectDataVar. If you‚Äôre like more information on a module, click on the links in the numbered list.\n\nDataset module\n\ndatasetInput/datasetServer: loads and returns data object from the datasets package (filtered by data frames or matrices)\n\n\n\n\n\n\n(a) dataset module\n\n\nFigure¬†1: dataset module\n\n\n\nThe objects from datasets are filtered in the UI module function with a filter argument that can be used to ‚Äúlimit the options to built-in datasets that are either data frames (filter = is.data.frame) or matrices (filter = is.matrix)‚Äù. The names are passed to the choices in the selectInput():\n\n\nshow/hide choices in datasetInput()\nnames &lt;- ls(\"package:datasets\")\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n\nThe datasets object is returned with get() (wrapped in reactive()). See below:\n\n\nshow/hide returned data from datasetServer()\nshiny::reactive(\n      get(input$dataset, \"package:datasets\")\n    )\n\n\n\n\n\nselectVar module\n\nselectVarInput/selectVarServer: displays a selectInput() that ‚Äúallows the user to select variables of specified type from a given reactive dataset.‚Äù\n\n\n\n\n\n\n(a) selectVar module\n\n\nFigure¬†2: selectVar module\n\n\nThe data argument in selectVarServer() is the returned value from datasetServer():\n\ndata() is used with the filter argument in the find_vars() function:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter) {\n # I've included the updated version with the 'stopifnot()' checks!\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\nThe filter argument can be used to return variables by class/type (using is.* functions like is.numeric() or is.character())\n\nWhen data() changes, the output from find_vars() updates the choices in the variable selectInput() (i.e., input$var) (see below)\n\n\n\n\n\n\n(a) selectVar and find_vars()\n\n\nFigure¬†3: selectVar module and find_vars() function\n\n\n\nselectVarServer() also returns the selected variable (input$var) as a reactive value (var())\n\n\n\nselectDataVar module\n\nselectDataVarUI/selectDataVarServer: The selectDataVar module is from the section titled, ‚ÄúModules inside of modules‚Äù, so here we see the dataset and selectVar modules placed inside the selectDataVar module (each with a new namespace (NS())).\n\n\n\n\n\n\n(a) selectDataVar module\n\n\nFigure¬†4: selectDataVar module\n\n\n\n\n\n\n\n\nNaming modules\n\n\n\n\n\n\nWhen creating an app-packages, modules are stored in the R/ folder as a single file, typically following a naming convention that differentiates modules from the other package functions. The modules in this post use camelCase, with suffix variations (i.e., Input/Server and UI/Server) for each functions. Other options come from the golem and leprechaun packages.\ngolem modules are created with golem::add_module()\n\n\n\nexpand to see golem::add_module(‚Äúinputs‚Äù)\nmod_inputs_ui &lt;- function(id){\n  ns &lt;- NS(id)\n  tagList(\n  )\n}\nmod_inputs_server &lt;- function(id){\n  moduleServer( id, function(input, output, session){\n    ns &lt;- session$ns\n \n  })\n}\n## To be copied in the UI\n# mod_inputs_ui(\"inputs_1\")\n    \n## To be copied in the server\n# mod_inputs_server(\"inputs_1\")\n\n\n\ngolem modules the following naming convention:\n\nAll new module functions have a mod_ prefix\ngolem module functions are differentiated with either a _ui or _server suffix\nNew golem module files are named R/mod_&lt;name&gt;.R\n\nleprechaun modules are also created with a leprechaun::add_module() function.\n\n\n\nexpand to see leprechaun::add_module(‚Äúinputs‚Äù)\ninputsUI &lt;- function(id){\n    ns &lt;- NS(id)\n    tagList(\n        h2(\"inputs\")\n    )\n}\ninputs_server &lt;- function(id){\n  moduleServer(id, function(input, output, session) {\n                ns &lt;- session$ns\n                send_message &lt;- make_send_message(session)\n                # your code here\n        }\n    )\n}\n# UI\n# inputsUI('id')\n\n# server\n# inputs_server('id')\n\n\n\nleprechaun modules have a slightly different naming convention:\n\nAll new UI module functions have a UI suffix\nAll new module server functions have a _server suffix\nleprechaun module functions do not have a prefix\nNew leprechaun modules named module_&lt;name&gt;.R\n\nShiny app-packages often require multiple modules and utility functions, so uniform names will make it easier to manage (and test!) your code.\n\n\n\n\n\n\n\nStandalone app functions\nmstsap contains three standalone functions for running each set of module functions.\nI‚Äôve made a small change to each standalone app function‚Äìeach app has a call to reactiveValuesToList() that displays in the UI.\n\n\nprint reactive values\n  shiny::verbatimTextOutput(\"vals\")\n\n  output$vals &lt;- shiny::renderPrint({\n    x &lt;- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n\n\n\ndatasetApp\ndatasetApp() contains a call to the dataset module, and includes a tableOutput() to render the selected data object:\n\n\n\n\n\n(a) datasetApp\n\n\nFigure¬†5: datasetApp\n\n\nWhen datasetApp() is run, the app displays the dataset object in the tableOutput(), and the verbatimTextOutput() renders the reactive values as a text:\n\n\n\n\n\n(a) datasetApp with reactive values\n\n\nFigure¬†6: datasetApp with reactiveValuesToList()\n\n\nThe output above shows what NS() does in the dataset module‚Äìit appends the module id argument to the inputId (which is why we see dataset-dataset).\n\ndataset-: the module id\ndataset-dataset the inputId from the selectInput()\n\n\n\nselectVarApp\nselectVarApp() includes both dataset and selectVar modules, but instead of rendering the output in a table, the UI renders the variable output in a verbatimTextOutput().\n\n\n\n\n\n(a) selectVarApp\n\n\nFigure¬†7: selectVarApp\n\n\nNote that selectVarApp() contains namespaces for two modules:\n\n\"data\": the namespace for the datasetnput() and datasetServer() modules, inheriting the filter argument and creating the data object\n\"var\": the selectVar modules are linked with the \"var\" id. selectVarServer() uses the data object created by datasetServer() (and also inherits the filter argument).\n\nThese namespaced IDs are rendered below with reactiveValuesToList():\n\n\n\n\n\n(a) selectVarApp with reactive values\n\n\nFigure¬†8: selectVarApp with reactiveValuesToList()\n\n\nThere‚Äôs a lot happening in selectVarApp(), so I‚Äôve created the figure below to display the code for the modules with their displayed outputs:\n\n\n\n\n\n\n(a) selectVarApp schema\n\n\nFigure¬†9: dataset and selectVar modules with rendered outputs\n\n\n\nAs we can see, the data output from the dataset module is used to generate the vars() reactive for the verbatimTextOutput() in selectVarApp(). Note that both dataset and selectVar modules don‚Äôt contain any output functions‚Äìthese have been provided in the UI for both datasetApp() and selectVarApp().\n\n\nselectDataVarApp\nThe final app in mstsap is selectDataVarApp(). Here the inputs from dataset and selectVar have been moved into the sidebarPanel(), and the output is rendered in the mainPanel().\n\n\n\n\n\n(a) selectDataVarApp\n\n\nFigure¬†10: selectDataVarApp\n\n\nThe reactive values here show how the ‚ÄòModules inside of modules‚Äô work‚Äìby adding the additional call to NS() in the datasetInput() and selectVarInput() functions within selectDataVarUI() and selectDataVarServer(), an additional namespace is appended to the reactive values (input$dataset and input$var):\n\n\n\n\n\n(a) selectDataVarApp with reactive values\n\n\nFigure¬†11: selectDataVarApp with reactiveValuesToList()\n\n\nBelow is a figure that displays the contents of the selectDataVar modules (I‚Äôve removed the tagList() and moduleServer() for simplicity), the selectDataVarApp(), and the rendered outputs:\n\n\n\n\n\n\n(a) selectDataVarApp schema\n\n\nFigure¬†12: dataset and selectVar modules inside selectDataVar module with rendered outputs"
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#testserver",
    "href": "series/testing/series-testing-p3/index.html#testserver",
    "title": "How do I test shiny modules?",
    "section": "testServer()",
    "text": "testServer()\nModule server functions can be tested the same way as a traditional shiny server function, as long as you provide the inputs and verify the correct outputs. Below I‚Äôll cover some general advice on module server tests (and the arguments in testServer()).\n\nTesting module server functions\nBefore writing tests, make sure you can answer the following:\n\nWhat is the overall purpose of the application?\n\nThis information is typically referred to as the ‚Äòbusiness logic‚Äô of the application, and should be stored in a specifications or requirements document. If I can‚Äôt answer this question, I‚Äôm probably better off not writing test for code that is likely to undergo major changes.\n\nHow does this module fit within that overall purpose?\n\nSpecifically, how does this module help the application achieve the specifications or requirements? This could also be considered the ‚Äòunit of work‚Äô and ‚Äòend result‚Äô for the module.\n\nWhat dependencies (i.e., utility functions, data, add-on packages) are required for the module to execute?\n\nIf the module depends on other functions, data, or packages to perform it‚Äôs expected behavior, those functions should either be included in the testServer() test, or have their own tests (or both).\n\n\n\nWhat should I test?\nThe items below have been compiled from Mastering Shiny, R Packages, and Engineering Production-Grade Shiny Apps:\n\nDo the inputs/outputs behave as expected?\n\nThese tests verify the module server function inputIds and outputIds are properly namespaced and accessible\n\nDoes the module contain the expected reactive values/objects?\n\nTests should verify it‚Äôs reactivity‚Äìmodule server functions will automatically recompute the outputs when it‚Äôs inputs change, so tests should verify changes to inputs produce the expected behaviors and outputs. This includes any returned values from the module (and any additional function arguments).\n\nAre the calculations correct?\n\nIf the module server function performs calculations or data manipulations, the tests should verify the module produces the correct result (ideally for a variety of inputs and edge cases).\n\nHow are errors handled in the module?\n\nWhat errors are displayed from the module? Tests should simulate scenarios that can test if the module: 1) returns errors that are informative, 2) fails silently (when appropriate), or 3) falls back to the correct default behavior.\n\n\nThe last piece of advice I‚Äôve found helpful when writing tests comes from R Packages,\n\n‚Äúfocus your time on code that you‚Äôre not sure about, is fragile, or has complicated interdependencies‚Äù\n\nThe quote isn‚Äôt in reference to testing modules or shiny application functions, but I‚Äôve found it‚Äôs easy to fall into the trap of trying to test everything when a targeted approach is more efficient (and equally valid).\nThe first test I‚Äôll perform is for datasetServer(), the module used to return a data object from the datasets package.\n\n\n\ntestServer() arguments\n\napp can be a module server function (i.e., datasetServer), or any shiny.appobj\nexpr is where I‚Äôll add the testthat expectations and other test code\nargs is a list() I can use to include any module server function arguments\n\n\n\nInputs\nI created the test file with usethis::use_test(\"datasetServer\") and the module server function is the first argument in testServer().\nI‚Äôll start by testing if the initial input value (input$dataset) in datasetServer() is set to NULL:\n\nshiny::testServer(app = datasetServer, expr = {\n  testthat::expect_equal(input$dataset, NULL)\n  cat(\"\\ndatasetServer: dataset$input is NULL\", \"\\n\")\n})\n\n\nI‚Äôll add a custom message with cat() and the inputId I‚Äôm testing, load, document, and install the package, then run the test with testthat::test_file():\ndevtools::load_all()\n‚Ñπ Loading mstsap\ndevtools::document()\n‚Ñπ Updating mstsap documentation\n‚Ñπ Loading mstsap\n\nRestarting R session...\n\nlibrary(mstsap)\n\nAnd run the test with testthat::test_file():\n\n\ntest_file(\"tests/testthat/test-datasetServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\ndatasetServer: dataset$input is NULL \n\n\n\n\n\n\n\nCreating test messages with testServer()\n\n\n\n\n\n\nThe testServer() documentation has examples of using cat() to create custom messages. I put a function for creating testServer() messages (test_cmt()) in the helper.R file (read more about test helpers here).\nIt has two arguments (test and msg), and makes it easy to print messages to the console while I‚Äôm developing tests.\n\ntest_cmt(test = \"mod_server_function\", msg = \"test contents\")\n\n       mod_server_function: test contents \n\n\n\n\n\n\nSetting test inputs\ntestServer() allows us to mimic changing application (or module) inputIds with session$setInputs() like so:\n\nsession$setInputs(inputId = \"value\")\n\nI‚Äôll demonstrate with a test for input$dataset in datasetServer():\n\n  session$setInputs(dataset = \"faithful\")\n  testthat::expect_equal(\n    object = input$dataset,\n    expected = \"faithful\")\n  test_cmt(\"datasetServer\", \"dataset$input\")\n\nThe results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetServer: dataset$input\n\n\n\nReturned values\nAny returned values from module server functions can be accessed in testServer() with session$returned(). I‚Äôll verify input$dataset returns an object from datasetServer() by testing the class of session$returned():\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"airquality\")\n  testthat::expect_equal(\n    object = class(session$returned()),\n    expected = \"data.frame\")\n  test_cmt(\"datasetServer\", \"class(session$returned())\")\n\n  session$setInputs(dataset = \"WorldPhones\")\n  testthat::expect_true(\n    object = is.matrix(session$returned()))\n  test_cmt(\"datasetServer\", \"is.matrix(session$returned())\")\n\n\nNote that both methods above can be used to check the class of the returned object.\nThe updated results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetServer: class(session$returned()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetServer: is.matrix(session$returned()) \n\nI can also use the typeof(datasets::mtcars) for a direct comparison:\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"mtcars\")\n  expect_equal(\n    # app value...\n    object = typeof(session$returned()), \n    # ...compared to actual output\n    expected = typeof(datasets::mtcars)) \n  test_cmt(\"datasetServer\", \"typeof(session$returned())\")\n\n\n\n\n\nModule server arguments\nIf the module server function has additional arguments beyond id, then it has additional functionality to verify with unit tests. To test additional module server arguments, pass these to testServer(args = list()). The args list should include named arguments from the module server function, i.e., list(arg1 = \"param1\", arg2 = \"param2\").\nFor example, selectVarServer() has data and filter arguments:\n\ndata is the returned reactive object from datasetServer()\nfilter is the function passed to the find_vars() utility function\n\n\n\n\n\n\n\n(a) dataset() -&gt; selectVar()\n\n\nFigure¬†13: Object returned from datasetServer() and passed to selectVarServer()\n\n\n\nBelow is a test for selectVarServer() using args to verify the reactive data() is datasets::mtcars:\n\nshiny::testServer(selectVarServer,\n  args = list(data = datasets::mtcars,\n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\nBut this fails with the following error:\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n‚îÄ‚îÄ Error (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ‚îÄ‚îÄ‚îÄ\nError in `(function (id, data, filter = is.numeric) \n{\n    stopifnot(shiny::is.reactive(data))\n    stopifnot(!shiny::is.reactive(filter))\n\nWhat happened?\n\nI‚Äôve included this example because it‚Äôs not in the testServer() documentation, and it‚Äôs common to pass values between modules (see here in Engineering Production-Grade Shiny Apps and here in Mastering Shiny)\n\nTesting module communication\nThe error message above tells me the issue is originating from the stopifnot() calls in selectVarServer().\n\n\n\n\n\n\nUpdating selectVarServer() and find_vars()\n\n\n\n\n\n\nBoth selectVarServer() and find_vars() are updated from their original versions to include stopifnot() checks for is.reactive(), is.data.frame() and is.function():\n\nOriginal versions:\n\nfind_vars &lt;- function(data, filter) {\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session, \"var\", choices = find_vars(data(), filter))\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\nUpdated versions:\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n\n  stopifnot(is.reactive(data))\n  stopifnot(!is.reactive(filter))\n\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session = session, \n        inputId = \"var\", \n        choices = find_vars(data(), filter)\n        )\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\n\nfind_vars &lt;- function(data, filter) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\n\n\nI‚Äôll stop a moment here to address what‚Äôs happening in each module:\n\nThe datasetServer() returns the results of input$dataset as a reactive (data())\ndata() enters selectVarServer() in the data argument\nInside selectVarServer(), two stopifnot() functions evaluate the reactivity of data and filter with shiny::is.reactive()\n\nIn datasetServer(), the return object is wrapped in the reactive() function, so the items args = list() also need to be wrapped in reactive().\nI‚Äôll re-write the test above to a more basic test using is.reactive():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data()))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n       selectVarServer: is.reactive(data()) \n‚îÄ‚îÄ Failure (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ‚îÄ‚îÄ‚îÄ\nis.reactive(data()) is not TRUE\n\n`actual`:   FALSE\n`expected`: TRUE \n\nAnother failure???\n\nThe results of this test might seem confusing given my advice to wrap the args list in reactive(), but some reading of the x argument in is.reactive() will clear up the error:\n\nFor is.reactive(), an object to test. For reactive(), an expression.\n\nRemoving the parentheses from data() will result in the proper test results:\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectVarServer: is.reactive(data()) \n\n\n\nUtility functions\nNow that I have a reactive data() input, I can explore how this value is used inside selectVarServer(). To update input$var, the data() input is passed to find_vars() (a function that uses a filter argument ‚Äúused to select which variables to list‚Äù). See the example below:\n\nmstsap::find_vars(\n  data = datasets::chickwts, \n  filter = is.factor)\n## [1] \"feed\"\n\nI‚Äôll write an expectation that captures the behavior of find_vars() in selectVarServer():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::chickwts),\n              filter = is.numeric), expr = {\n  testthat::expect_equal(\n    object = find_vars(data(), is.factor),\n    expected = \"feed\")\n  test_cmt(\"selectVarServer\", \"find_vars()\")\n})\n\nThe results are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectVarServer: find_vars()\nTo verify that the returned object from selectVarServer() is the selected column, I‚Äôll need to simulate the application behavior in the tests:\n\nCreate a reactive data() input in selectVarServer():\n\n\nsetting args = list()\n  shiny::testServer(selectVarServer,\n    args = list(data = reactive(datasets::chickwts),\n                filter = is.numeric), expr = {\n\n    # include expectations below...\n\n  })\n\n\nSet the input$var and verify the input$var:\n\n\nverify input$var\n  session$setInputs(var = \"weight\")\n  testthat::expect_equal(object = input$var,\n      expected = \"weight\")\n  test_cmt(\"selectVarServer\", \"input$var\")\n\n\nSet the input$var and verify the session$returned()\n\n\nverify session$returned()\n  session$setInputs(var = \"feed\")\n  testthat::expect_equal(object = session$returned(),\n    expected = datasets::chickwts[[\"feed\"]])\n  test_cmt(\"selectVarServer\", \"session$returned()\")\n\n\n\nThe results from these tests are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectVarServer: input$var \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       selectVarServer: session$returned() \n\n\nModule outputs\nRendered outputs can be accessed in testServer() just like inputs (i.e., with output$outputId). But the modules in mstsap don‚Äôt have outputs‚Äìthese are included in the standalone app functions (datasetApp(), selectVarApp(), and selectDaraVarApp()).\nFortunately, app functions can also be passed to the app argument of testServer(). I‚Äôll use datasetApp() to demonstrate.\n\n\n\n\n\nTesting a standalone app function is similar to testing a module server function, but with a few minor differences. First, the output from the standalone app function is assigned to an object (ds_app), then placed in the app argument:\n\nds_app &lt;- datasetApp()\n  shiny::testServer(ds_app, expr = {\n\n  })\n\nTo use session$setInputs() need to include the namespace for the inputId:\n\n\n\n\n\nThe output from reactiveValuesToList() in datasetApp() shows me how to access the inputId in the datasetServer() module (i.e., input$`dataset-dataset`):\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n\n})\n\n\nOutput testing strategy\nTesting outputs with testServer() is different than testing outputs in regular unit tests, because shiny outputs are executed in the server, but then rendered in the UI. The testServer() documentation outlines a testing strategy for complex outputs:\n\n*The goal for your tests should be to ask ‚Äúis the code that I wrote producing the plot I want?‚Äù There are two components to that question:\n\nDoes the plot generate without producing an error?\nIs the plot visually correct?\n\ntestServer is great for assessing the first component here. By merely referencing output$plot in your test, you‚Äôll confirm that the plot was generated without an error.\n\nIf we replace plot with table in the advice above, the tests for datasetApp() should confirm output$data is generated without producing an error.\nInstead of writing an expectation, I‚Äôll use cat() to display the contents of output$data after setting the `dataset-dataset` input:\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n  cat(\"\\n\\toutput$data:\\n\", output$data, \"\\n\")\n})\n\nThe results from the test is below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$data:\n &lt;table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'&gt;\n  &lt;thead&gt; \n      &lt;tr&gt; \n        &lt;th style='text-align: right;'&gt; weight &lt;/th&gt; \n        &lt;th style='text-align: left;'&gt; feed &lt;/th&gt;  \n     &lt;/tr&gt; \n    &lt;/thead&gt; \n      &lt;tbody&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 179.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 160.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 136.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 227.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 217.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 168.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n   &lt;/tbody&gt; \n &lt;/table&gt; \nThe output is the HTML used to render the table in the UI. This doesn‚Äôt add a passing test, but it confirms that the table is being generated from the data() reactive.\nThe tests for datasetApp() will confirm the inputId, and verify the class and names of the data() reactive (which will be passed to the renderTable() function):\n\n  testthat::expect_equal(\n    object = input$`dataset-dataset`,\n    expected = \"chickwts\")\n  test_cmt(\"datasetApp\", \"input$`dataset-dataset`\")\n\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  test_cmt(\"datasetApp\", \"is.data.frame(data())\")\n\n  testthat::expect_equal(\n    object = names(data()),\n    expected = names(datasets::chickwts))\n  test_cmt(\"datasetApp\", \"names(data())\")\n\nI can include a test for the class of output$data, but note that this is a character output:\n\n  testthat::expect_equal(\n    object = class(output$data),\n    expected = \"character\")\n  test_cmt(\"datasetApp\", \"class(output$data)\")\n\nThe results from test_file() are below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       datasetApp: input$`dataset-dataset` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetApp: is.data.frame(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetApp: names(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetApp: class(output$data) \nThe same method can be used to test the selectVarApp(), but note this app requires passing both inputIds to session$setInputs():\n\n\nshow/hide selectVarApp() tests\nsv_app &lt;- selectVarApp()\nshiny::testServer(app = sv_app, expr = {\n  session$setInputs(`var-var` = \"Ozone\",\n                    `data-dataset` = \"airquality\")\n  # confirm contents of output$out\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n  \n  # confirm var is reactive \n  testthat::expect_true(object = is.reactive(var))\n  # confirm var input\n  testthat::expect_equal(\n    object = input$`var-var`,\n    expected = \"Ozone\")\n  # confirm data is reactive\n  testthat::expect_true(object = is.reactive(data))\n  # confirm data() is a data.frame\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  # confirm 'data' can be subsetted with 'var'\n  testthat::expect_equal(\n    object = data()[[input$`var-var`]],\n    expected = airquality[[\"Ozone\"]])\n})\n\n\n\n\nTesting nested modules\nI highly recommend viewing the output of reactiveValuesToList() if your application has nested modules. It‚Äôs easy to lose track of ids if they span multiple layers.\nWe know selectDataVarApp() contains ‚Äòmodules inside other modules‚Äô, and these layers are reflected in the namespaces:\n\n\n\n\n\nTo access the inputIds in the nested modules, we need to pass the full ‚Äòappended‚Äô namespace:\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n})\n\nAfter setting the inputs, I can confirm the contents of output$out\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$out:\n   [1]  41  36  12  18  NA  28  23  19   8  NA   7  16  11  14  18\n [16]  14  34   6  30  11   1  11   4  32  NA  NA  NA  23  45 115\n [31]  37  NA  NA  NA  NA  NA  NA  29  NA  71  39  NA  NA  23  NA\n [46]  NA  21  37  20  12  13  NA  NA  NA  NA  NA  NA  NA  NA  NA\n [61]  NA 135  49  32  NA  64  40  77  97  97  85  NA  10  27  NA\n [76]   7  48  35  61  79  63  16  NA  NA  80 108  20  52  82  50\n [91]  64  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28\n[106]  65  NA  22  59  23  31  44  21   9  NA  45 168  73  NA  76\n[121] 118  84  85  96  78  73  91  47  32  20  23  21  24  44  21\n[136]  28   9  13  46  18  13  24  16  13  23  36   7  14  30  NA\n[151]  14  18  20 \nAfter confirming output$out, I‚Äôll test the inputs:\n\n  testthat::expect_equal(\n    object = input$`var-var-var`,\n    expected = \"Ozone\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-var-var`\")\n\n  testthat::expect_equal(\n    object = input$`var-data-dataset`,\n    expected = \"airquality\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-data-dataset`\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectDataVarApp: input$`var-var-var` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectDataVarApp: input$`var-data-dataset`\nI can also verify the contents of the reactive var() inside the test:\n\n  testthat::expect_true(object = is.reactive(var))\n  test_cmt(\"selectDataVarApp\", \"is.reactive(var)\")\n  cat(\"\\n\\tvar:\\n\", var(), \"\\n\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectDataVarApp: is.reactive(var) \n\n    var:\n 41 36 12 18 NA 28 23 19 8 NA 7 16 11 14 18 14 34 6 30 11 1 11 4 32 NA NA NA 23 \n    45 115 37 NA NA NA NA NA NA 29 NA 71 39 NA NA 23 NA NA 21 37 20 12 13 NA NA NA\n    NA NA NA NA NA NA NA 135 49 32 NA 64 40 77 97 97 85 NA 10 27 NA 7 48 35 61 79 \n    63 16 NA NA 80 108 20 52 82 50 64 59 39 9 16 78 35 66 122 89 110 NA NA 44 28 \n    65 NA 22 59 23 31 44 21 9 NA 45 168 73 NA 76 118 84 85 96 78 73 91 47 32 20 23\n    21 24 44 21 28 9 13 46 18 13 24 16 13 23 36 7 14 30 NA 14 18 20"
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#recap",
    "href": "series/testing/series-testing-p3/index.html#recap",
    "title": "How do I test shiny modules?",
    "section": "Recap",
    "text": "Recap\nThis post has shown how shiny‚Äôs testServer() function allows you to isolate and test module server functions, which makes it easier to ensure that your server function behaves as expected (and locate and fix bugs).\nI hope you have a better understanding of how you can use testServer() to test a modules inputs/outputs, reactivity, calculations, and errors.\nIn the next post I‚Äôll cover performing integration tests with shinytest2!"
  },
  {
    "objectID": "series/testing/series-testing-p2/index.html",
    "href": "series/testing/series-testing-p2/index.html",
    "title": "How do I test my (non-package) shiny application?",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(vdiffr)\nlibrary(shinytest2)\nThis post is the second in a series on testing shiny applications. I‚Äôll cover testing shiny module server functions using the testhat package outside an R package. This application is stored in the noap GitHub repo if you‚Äôd like to follow along."
  },
  {
    "objectID": "series/testing/series-testing-p2/index.html#testing-module-server-functions",
    "href": "series/testing/series-testing-p2/index.html#testing-module-server-functions",
    "title": "How do I test my (non-package) shiny application?",
    "section": "Testing module server functions",
    "text": "Testing module server functions\n\n‚Ä¶the ABCs of testing shiny server modules‚Ä¶\n\nThis post covers how shiny::testServer() works using the abcApp() shiny app.. The code for abcApp() is an RStudio project (i.e., there is a noap.Rproj file in the parent folder), but it‚Äôs not part of an R package. Developing shiny applications as R packages is highly recommended, but it‚Äôs possible to begin writing unit tests before your application is a fully developed shiny app-package.\nFor more information regarding performing tests outside of the package environment, see this issue on GitHub.\n\nabcApp()\nThe abcApp() application has been written using shiny modules and a single utility function.\ntestthat is designed to perform unit tests for R packages, but for the sake of simplicity,abcApp() has not been developed as part of a package. This will allow us to focus on the files involved in testing (and not all the other files that accompany R packages).\nThe standalone application function (abcApp()) is stored in app.R, the modules are contained in modules.R, and the single utility function is stored in utils.R:\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ app.Rproj\n‚îú‚îÄ‚îÄ modules.R\n‚îú‚îÄ‚îÄ tests\n‚îî‚îÄ‚îÄ utils.R\n\n2 directories, 5 files\n\nThe tests folder contains the following:\ntests\n‚îú‚îÄ‚îÄ testthat\n‚îÇ   ‚îî‚îÄ‚îÄ test-mod_abc_server.R\n‚îî‚îÄ‚îÄ testthat.R\n\n2 directories, 2 files\n\ntests/ has a testthat.R file\n\nNew test files should be placed in tests/testthat/ (see example test-mod_abc_server.R below):\n\n\n\nUI module function\nIn this small example app, both ui and server modules are stored in the modules.R file.\n\nUI module:\n\n\nmod_abc_ui() (example ui module function)\n# ui module\nmod_abc_ui &lt;- function(id) {\n\n  ns &lt;- shiny::NS(id)\n\n  shiny::tagList(\n    shiny::numericInput(\n      inputId = ns(\"num\"),\n      label = shiny::h4(\n        shiny::code(\"alphabet number\")),\n        value = 5, min = 1, max = 26\n    ),\n    shiny::verbatimTextOutput(\n      outputId = ns(\"txt\"))\n  )\n}\n\n\n\n\n\nServer module function\nThe counterpart to mod_abc_ui() is mod_abc_server():\n\nServer module:\n\n\nmod_abc_server() (example server module function)\n# server module\nmod_abc_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    # reactive \n    letter &lt;- shiny::reactive({ LETTERS[input$num] })\n    # super script\n    sup_scrpt &lt;- shiny::reactive({ \n      num_super_script(x = input$num)\n    })\n    # output\n    output$txt &lt;- shiny::renderPrint({\n      paste0(\"The \", input$num, sup_scrpt(), \n             \" letter in the alphabet is: \", letter())\n    })\n\n  })\n}\n\n\n\n\n\nModule utility function\nThe mod_abc_server() function uses the num_super_script() function stored in utils.R:\n\nUtility function:\n\n\nnum_super_script() (example utility function)\n# utility function\nnum_super_script &lt;- function(x) {\n      num &lt;- as.numeric(x)\n      if (num == 1) {\n        super_script &lt;- \"st\"\n      } else if (num == 2) {\n        super_script &lt;- \"nd\"\n      } else if (num == 3) {\n        super_script &lt;- \"rd\"\n      } else {\n        super_script &lt;- \"th\"\n      }\n    return(super_script)\n}\n\n\n\n\n\nStandalone app function\n\nStandalone app functions include a call to shiny::shinyApp():\n\n\nabcApp() (example app with modules)\n# standalone shiny app function\nabcApp &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      mod_abc_ui(\"x\")\n    ), \n    server = function(input, output, session) { \n      mod_abc_server(\"x\")\n    }\n  )\n}\nabcApp()\n\n\n\nThe call to shiny::shinyApp() is placed inside the abcApp() function\nThe ui argument is wrapped in shiny::fluidPage() and the ui module function (mod_abc_ui()) is placed inside\nThe server argument includes the standard function(input, output, session) and the module server companion function‚Äìmod_abc_server()‚Äìwith a matching id arguments\nThe abcApp() function is stored in the app.R file\n\n\nBecause abcApp() is not part of a package, shiny and testthat are loaded and the modules and utility function are sourced in the top of the app.R file.\n\n\nsource utils.R and modules.R in app.R\n# packages --------------------------------------------------------\nlibrary(shiny)\nlibrary(testthat)\n\n# utils ------------------------------------------------------------------\nsource(\"utils.R\")\n\n# modules ------------------------------------------------------------------\nsource(\"modules.R\")\n\n\n\n\n\nUsing testServer()\nIn the test-mod_abc_server.R file, I‚Äôll add testServer() and include the module server function as the first argument:\n\napp is the module server function (mod_abc_server) or any shiny.appobj\n\n\napp = shiny.appobj\nshiny::testServer(app = mod_abc_server, {\n\n})\n\n\n\n\nTesting input$s\n\nThe first test I‚Äôll add will check the initial value of input$num\n\nI‚Äôll also include a custom message with cat()\n\n\n\ntest initial value with custom message\nshiny::testServer(mod_abc_server, {\n  # Test 1: check initial value\n  testthat::expect_equal(input$num, NULL)\n  cat(\"\\n Test 1 initial input$num = NULL: \", is.null(input$num), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTest 1 initial input$num = NULL:  TRUE \n\ntestServer() allows me to set new input values with session$setInputs()\n\nUse session$setInputs() to set input$num to 3\nTest 2 confirms input$num has changed\nAdd another custom message with cat()\n\n\n\n\nsetInputs() and test inputs\nshiny::testServer(mod_abc_server, {\n  # set inputs\n  session$setInputs(num = 3)\n  # Test 2: check set inputs\n  testthat::expect_equal(input$num, 3)\n  cat(\"\\n Test 2 setInputs(num = 3):\", input$num, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 2 setInputs(num = 3): 3 \n\n\n\nTesting reactive values\n\nThe module‚Äôs reactive values are also available to in testServer()\n\nTest 3 adds a test for sup_scrpt() (given the changed value of input$num)\n\nThe expected value is what I‚Äôm expecting num_super_script() to return.\n\n\n\n\nCheck sup_scrpt() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 3: check super script\n  testthat::expect_equal(object = sup_scrpt(), expected = \"rd\")\n  cat(\"\\n Test 3 sup_scrpt(): = 'rd':\", sup_scrpt(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 3 sup_scrpt(): = 'rd': rd  \n\nFor completeness I‚Äôll add a test for letter()\n\n\n\nCheck letter() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 4: check letter\n  testthat::expect_equal(object = letter(), expected = \"C\")\n  cat(\"\\n Test 4 letter() = C:\", letter(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 4 letter() = C: C \n\n\n\nTesting output$s\n\nThe module output values are also available as output$&lt;value&gt;\n\nTest 5 will verify the output$txt (given the updated input$num)\n\n\n\nCheck module output values\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\n‚îÄ- Failure (test-mod_abc_server.R:1:1): (code run outside of `test_that()`) ‚îÄ‚îÄ\noutput$txt (`actual`) not equal to \"The 3rd letter in the alphabet is: C\" (`expected`).\n\n`actual`:   \"[1] \\\"The 3rd letter in the alphabet is: C\\\"\"\n`expected`: \"The 3rd letter in the alphabet is: C\"        \nBacktrace:\n  1. shiny::testServer(...)\n       at test-mod_abc_server.R:1:0\n 22. testthat::expect_equal(object = output$txt, \n   expected = \"The 3rd letter in the alphabet is: C\")\n       at test-mod_abc_server.R:17:4\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\nWhat happened? I forgot to add the escape characters (\\\") and line number ([1]) for the output\n\nI‚Äôll change the expected value and re-run the test:\n\n\n\n\nCheck module output values (again)\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\nFinally, I‚Äôll run the tests with test_dir()\n\n\ntest_dir(path = \"/path/to/app/tests/testthat/\")\n\n‚úî | F W S  OK | Context\n‚†è |         0 | mod_abc_server         \n\n Test 1 initial input$num = NULL:  TRUE \n\n Test 2 setInputs(num = 3): 3 \n\n Test 3 sup_scrpt(): = 'rd': rd \n\n Test 4 letter() = C: C \n\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n‚úî |         5 | mod_abc_server\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 0.2 s\n [ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\nüåà Your tests are over the rainbow üåà\n\nThe results show the tests passed! Now I am confident inputs, reactive values (sup_scrpt() & letter()), outputs behave as expected.\n\n\n\nRecap\nThe example above provides a workflow for using testServer() with testthat outside a package environment. The checklist below summarizes the steps required to test your application‚Äôs module server functions:\n\nCreate test files (in tests/testthat/)\n\nAll test files should have the test- prefix\n\nVerify inputs with session$setInputs(inputId = &lt;value&gt;)\n\nAll input$ values should initially be NULL\n\nTest reactive values by referring to them as you would in the module server\n\nCompare expected values after changing inputs with session$setInputs()\n\nTest outputs using output$&lt;value&gt; to check changes to the inputs and reactives\n\nCheck output values with output$txt\n\n\nThis concludes running tests on abcApp(). Ideally, shiny applications are developed as an R package (which I‚Äôll cover in a future post), but now you know how to perform tests if this isn‚Äôt the case. The files for this demonstration are located here.\nFor a more comprehensive review of testing, check out the chapters on testing in R packages and Mastering Shiny."
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html",
    "href": "series/testing/series-testing-p1/index.html",
    "title": "How do I test shiny utility functions?",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(covr)\nThis post is the first in a series on testing shiny applications. I‚Äôll cover developing and testing a set of utility functions for a shiny app-package using testhat. If you‚Äôd like to follow along, all the code I‚Äôll be using is contained in the utap R package on GitHub.\n# renv::install(\"mjfrigaard/utap\")\nlibrary(utap)"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#shiny-app-packages",
    "href": "series/testing/series-testing-p1/index.html#shiny-app-packages",
    "title": "How do I test shiny utility functions?",
    "section": "Shiny app-packages",
    "text": "Shiny app-packages\nTesting the code in shiny app-packages can be more complicated than testing the code in a typical R package, because app-packages contain two types of code:\n\nApplication code: functions designed to run the application (i.e., the ui and server functions, modules, standalone app functions will a call to shinyApp(), etc.)\nEverything else: functions or code used for connecting to databases, uploading, importing, or manipulating data, building visualizations and/or tables, generating custom HTML layouts, etc. The non-application code and functions in app-packages are typically referred to as ‚Äòutility‚Äô or ‚Äòhelper‚Äô functions\n\nThese two types of code require different types of tests. Utility functions are usually accompanied by unit tests similar to the tests you‚Äôd find in a standard R package, while application code is tested using the shiny::testServer() function, or with the shinytest2 package.\nThis post will cover writing unit tests for a set of utility functions using testthat and covr. Any tips or time-savers I‚Äôve found will be in green callout boxes:\n\n\n\n\n\n\nTIP!\n\n\n\n\n\n\nThis is a tip!"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#what-are-unit-tests",
    "href": "series/testing/series-testing-p1/index.html#what-are-unit-tests",
    "title": "How do I test shiny utility functions?",
    "section": "What are unit tests?",
    "text": "What are unit tests?\n\n\n\n\n‚ÄúA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed. A unit test‚Äôs scope can span as little as a method or as much as multiple classes.‚Äù - The Art of Unit Testing, 2nd edition\n\nI‚Äôve found thinking of functions as ‚Äòunits of work‚Äô and their desired behavior as an ‚Äòend results‚Äô provides a useful mental model during TDD. These terms also align nicely with the testing advice offered by testthat:\n\nStrive to test each behaviour in one and only one test. Then if that behaviour later changes you only need to update a single test.\n\nIn app-packages, the testthat package provides a comprehensive and flexible framework for performing unit tests.\n\ntestthat\nGet started with testthat in your app-package by running usethis::use_testthat(). This function will create following files and folders:\ntests/\n  ‚îú‚îÄ‚îÄ testthat/\n  ‚îî‚îÄ‚îÄ testthat.R\nTo create new tests, run usethis::use_test(\"utils_fun\") (with \"utils_fun\" being the name of the function you‚Äôd like to test).\n\nusethis::use_test(\"utils_fun\")\n\n‚úî Setting active project to '/projects/apps/utap'\n‚úî Writing 'tests/testthat/test-utils_fun.R'\n‚Ä¢ Modify 'tests/testthat/test-utils_fun.R'\n\nTest files\nNew test files are be created and opened from the tests/testthat/ folder (with a test- prefix).\n\nThe initial contents of a new test file contains the boilerplate code below:\n\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n\n\n\n\n\n\n\nFigure¬†1: testthat test file\n\n\nTest files\n\n\nTest structure\ntest_that() sets the test ‚Äúscope‚Äù or ‚Äúexecution environment‚Äù, and encapsulates the expectations.\n\nNote the use of curly brackets after the code argument:\n\ntestthat::test_that(desc = \"description\", code = {\n\n})\n\n\n\n\n\n\n\nFigure¬†2: tests\n\n\ntestthat test\n\n\nExpectations\nTest expectations are the code that comes into direct contact with the unit of work and end result for each function. There are usually multiple expectations for any given function, so these are stored in tests (and the desc describes the test context for the set of expectations).\n\nAll testthat expectations have an expect_* prefix:\n\ntestthat::expect_equal(object = 2 * 2, expected = 4)\n\n\n\n\n\n\n\nFigure¬†3: expectations\n\n\ntestthat expectation\n\n\nUnit test development workflow\nI develop unit tests using the following workflow:\n\nCreate the test file and R script: I‚Äôll start by creating these files with usethis::use_r() and usethis::use_test(), even if I know the names of these files will likely change as I develop (see more below).\nDefine test context: I use the test context (entered as a character string in the first argument of testthat::test_that()) to capture each ‚Äúunit of work‚Äù for each function. I like to keep the test context short and sweet‚Äìthe ‚Äúunit of work‚Äù followed by ‚Äúworks‚Äù will suffice in most circumstances, unless there‚Äôs a need for more specific details.\nWrite expectations: These are the third item in the workflow, but conceptually these comes first‚Äìthese are the ‚Äúend results‚Äù I want from each function (i.e., compute a value, download a file, create a column, etc.).\n\nTests and expectations are grouped into test files based on their related objectives or goals, and should correspond to a similar .R file in the R/ folder.\nWhile this workflow is probably not technically considered test-driven development, I do set up the tests before I start writing any code in the R/ folder. This comes in handy if you‚Äôre having to remind yourself where you stopped developing on a given project‚ÄìI‚Äôll just run devtools::test() and the first failing test reminds me where to look.\n\n\n\n\n\n\nTIPS: Unit tests\n\n\n\n\n\n\nThe advice on unit tests below (in bold) comes from Effective Software Testing, 2022. I‚Äôve included descriptions of how testthat satisfies each recommendation:\n\nUnit tests should be fast: the text recommends unit tests take a ‚Äòcouple of milliseconds‚Äô to execute. testthat tests typically fall within this threshold (and provide time measurements to identify bottlenecks).\nUnit tests are easy to control: i.e., ‚Äòinput values and the expected result value are easy to adapt or modify in the test.‚Äô testthat expectations give us ample access to 1) the expected result and 2) the observed result.\nUnit tests are easy to write: i.e., ‚Äòdo not require a complicated setup or additional work‚Äô. When used combination with usethis, testthat unit tests can be set up, created, written, and run with a few lines of code:\n\nusethis::use_testthat()\n\nusethis::use_test()\n\n&lt; write test &gt;\n\ntestthat::test_file(), testthat::test_dir(), or devtools::test()"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#app-utility-functions",
    "href": "series/testing/series-testing-p1/index.html#app-utility-functions",
    "title": "How do I test shiny utility functions?",
    "section": "App utility functions",
    "text": "App utility functions\nThe utility functions I‚Äôll be developing are designed to populate the choices argument for shiny::selectInput(). For example, the pull_numeric_cols() function would ‚Äòpull‚Äô the column names from an input data.frame or tibble (the example below uses palmerpenguins::penguins):\n\npull_numeric_cols(palmerpenguins::penguins)\n\n\n##      bill_length_mm       bill_depth_mm   flipper_length_mm \n##    \"bill_length_mm\"     \"bill_depth_mm\" \"flipper_length_mm\" \n##         body_mass_g                year \n##       \"body_mass_g\"              \"year\"\n\nThe return values would be passed to an updateSelectInput() in the server to provide column names by type (i.e., numeric, binary, or categorical). These functions can be used to quickly group variables into groups for data visualizations. For example, binary variables can be mapped the color aesthetic (if using ggplot2), and custom functions can be created for other graph layers (i.e., facets).\nThe unit of work for each hypothetical pull_[type]_cols() function would be, ‚Äúingest a data.frame or tibble and identify columns by type,‚Äù and their end result might be ‚Äúreturn a (named) vector of column names by type.‚Äù In this case, [type] refers to the variable type (i.e., numeric, categorical, binary, etc.). See the hypothetical UI output example below:\n\n# UI code\nshiny::selectInput(\n  inputId = ns(\"x\"),\n  label = \"X variable:\",\n  choices = NULL\n)\n\n\n# server code\nshiny::observe({\n  num_vars &lt;- pull_numeric_cols(df = data())\n  shiny::updateSelectInput(session,\n    inputId = \"x\",\n    choices = num_vars,\n    selected = num_vars[1])\n  }) |&gt;\n  shiny::bindEvent(data(),\n    ignoreNULL = TRUE)\n\nIn the example above, pull_numeric_cols() is passed a reactive dataset (data()), and the output is used to update the selectInput().\n\n\n\nX variable:\n\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nyear"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#micro-iteration",
    "href": "series/testing/series-testing-p1/index.html#micro-iteration",
    "title": "How do I test shiny utility functions?",
    "section": "Micro-iteration",
    "text": "Micro-iteration\nIn R packages, micro-iteration is defined as, ‚Äúthe interactive phase where you initiate and refine a function and its tests in tandem.‚Äù If you‚Äôre using TDD, you‚Äôll write the test first, then write the function to pass the test.\nThe first unit test I‚Äôll create is for select_column_class(), a function designed to return columns according to their class().\n\nFunction names\nComing up with names for functions can be challenging. I like to follow the tidyverse style guide and use short verbs as a prefix (make_, get_, check_ etc.). I also like to use names that give ‚Äòfuture‚Äô me hints as to their behavior (i.e., select_column_class() imports and has similar behavior to dplyr::select(), while pull_[type]_cols() is more like dplyr::pull())\n\n\nCreate test file\nI create the test file and function file in the Console\n\nusethis::use_test(\"select_column_class\")\n\n‚úî Setting active project to '/projects/apps/utap'\n‚úî Writing 'tests/testthat/test-select_column_class.R'\n‚Ä¢ Modify 'tests/testthat/test-select_column_class.R'\n\nusethis::use_r(\"select_column_class\")\n\n‚Ä¢ Modify 'R/select_column_class.R'\n\n\nTest context\nThe test context (entered as a character string in the first argument of testthat::test_that()) includes the ‚Äúunit of work‚Äù for the function, followed by ‚Äúworks‚Äù:\n\ntestthat::test_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  \n})\n\nBefore I can start developing the select_column_class() function and it‚Äôs tests, I‚Äôll need data. R comes with example data objects in the datasets package, but it‚Äôs nice to have control over the data being used in your unit tests. I‚Äôll cover how to add test data available in your app-package.\n\n\nTest data\nCreating test data is covered in R packages, but I‚Äôll summarize the key points:\n\nTest data (and other objects) can either be created within a test, or as a persistent test fixture\n\nTest data fixtures should be stored in tests/testthat/fixtures/&lt;test_data.rds&gt;\nThe code used to create any test data fixtures should be stored in the same folder with a make_ prefix (i.e., tests/testthat/fixtures/&lt;make_test_data.R&gt;)\n\nThis is easier to picture with a demonstration: In the tests/testthat/ folder, I‚Äôll create a new fixtures folder, and add a make_testdata_col_class.R file.\ntests/testthat/\n        ‚îî‚îÄ‚îÄ fixtures/\n                ‚îî‚îÄ‚îÄ make_testdata_col_class.R\nIn make_testdata_col_class.R, I‚Äôll create testdata_col_class using the code below:\n\n\ntest_data for test-select_column_class.R\ntestdata_col_class &lt;- tibble::tibble(\n log_var = c(TRUE, FALSE, TRUE),\n int_var = c(1L, 2L, 3L),\n dbl_var = c(1.1, 2.2, 3.3),\n chr_var = c(\"item:1\", \"item:2\", \"item:3\"),\n fct_var = factor(\n   c(\"group 1\", \"group 2\", \"group 3\"),\n   levels = c(\n     \"group 1\", \"group 2\", \"group 3\")),\n ord_var = factor(\n   c(\"level 1\", \"level 2\", \"level 3\"),\n   levels = c(\"level 1\", \"level 2\", \"level 3\"),\n   ordered = TRUE),\n list_var = list(\n   log_vec = c(TRUE, FALSE),\n   dbl_vec = c(1.1, 2.2),\n   chr_var = c(\"item:1\", \"item:2\")))\n\n\n\ntestdata_col_class\n## # A tibble: 3 √ó 7\n##   log_var int_var dbl_var chr_var fct_var ord_var list_var  \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;   &lt;named li&gt;\n## 1 TRUE          1     1.1 item:1  group 1 level 1 &lt;lgl [2]&gt; \n## 2 FALSE         2     2.2 item:2  group 2 level 2 &lt;dbl [2]&gt; \n## 3 TRUE          3     3.3 item:3  group 3 level 3 &lt;chr [2]&gt;\n\nI‚Äôll save testdata_col_class in tests/testthat/fixtures/ as testdata_col_class.rds:\ntests/testthat/\n        ‚îî‚îÄ‚îÄ fixtures/\n                ‚îú‚îÄ‚îÄ make_testdata_col_class.R\n                ‚îî‚îÄ‚îÄ testdata_col_class.rds\nTo load the data into my test, I‚Äôll add the following to the top of the test context:\n\ntest_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  \n})\n\ntestthat::test_path() will load the data from the testing directory when I‚Äôm ready to run my test.\n\n\nExpectations\nIn expect_equal(), I‚Äôll verify the structure of the returned object is a data.frame/tibble.\n\ntest_that(\"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # check tibble\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"???\") |&gt;\n          tibble::is_tibble(),\n    expected = TRUE)\n})\n\nWriting my expectations first forces me to make some decisions about what the arguments will be for the select_column_class() function (i.e., df and class).\nselect_column_class() should return the columns according to their class, so I‚Äôll tests to verify the class of the return columns.\n\n  # check logical\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"log\") |&gt;\n          lapply(is.logical) |&gt; unlist() |&gt; unique(),\n    expected = TRUE)\n\nI try to write these in a way that‚Äôs flexible (should the test data change in the future).\n\n\n\n\n\n\nExpectation-Driven Development\n\n\n\n\n\nWhether or not you decide to adopt Test-Driven Development, I strongly recommend writing test expectations while you‚Äôre developing functions. It‚Äôs a great opportunity to clarify a function‚Äôs intended behaviors, arguments, and error/warning messages.\n\n\n\nAfter including tests for each class, I‚Äôll include a test for the error message from select_column_class() with testthat::expect_error():\n\n# test error type\ntestthat::test_that(\"select_column_class() type error\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # test type error\n  testthat::expect_error(\n    object = select_column_class(\n      df = testdata_col_class, \n      class = \"array\")\n  )\n})\n\nWhen I‚Äôve covered my intended ‚Äòend results‚Äô for select_column_class() (i.e., when it works and what happens when it doesn‚Äôt), I‚Äôll write the function:\n\n\nselect_column_class()\nselect_column_class &lt;- function(df, class) {\n\n  col_class &lt;- function(df, class) {\n    switch(class,\n      log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),\n      int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),\n      dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),\n      chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),\n      fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),\n      ord = dplyr::select(tibble::as_tibble(df), dplyr::where(is.ordered)),\n      list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list))\n    )\n  }\n\n  cl &lt;- unique(class)\n  cl_check &lt;- cl %nin% c(\"log\", \"int\", \"dbl\", \"chr\", \"fct\", \"ord\", \"list\")\n  if (any(cl_check)) {\n    cli::cli_abort(\"Invalid `class` argument. Must be one of:\\n\n          'log', 'int', 'dbl', 'chr', 'fct', 'ord', 'list'\")\n  }\n\n  col_list &lt;- purrr::map(.x = class, .f = col_class, df = df)\n\n  df_cols &lt;- purrr::list_cbind(col_list, size = nrow(df))\n\n  if (ncol(df_cols) &lt; 1 || nrow(df_cols) &lt; 1) {\n    df_cols &lt;- structure(list(),\n      class = c(\"tbl_df\", \"tbl\", \"data.frame\"),\n      row.names = integer(0),\n      names = character(0)\n    )\n    return(df_cols)\n  } else {\n    return(df_cols)\n  }\n}\n\n\n\nRecap: test data\nBelow is a summary of tips for adding data your tests.\n\n\n\n\n\n(a) Unit test fixtures\n\n\nFigure¬†4: Unit test fixtures"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#mezzo-iteration",
    "href": "series/testing/series-testing-p1/index.html#mezzo-iteration",
    "title": "How do I test shiny utility functions?",
    "section": "Mezzo-iteration",
    "text": "Mezzo-iteration\nThe select_column_class() will return a tibble() with the columns matching the class argument, but I‚Äôll also need an argument that allows me to adjust the returned object to a named character vector.\nThat‚Äôs the job of get_column_class()‚Äìthis is a wrapper around select_column_class() with an additional return_tbl argument that, if FALSE, returns the column names as a named vector.\n\nAbstract syntax trees\nWhile developing R functions, I‚Äôve found the ast() function from the lobstr package can be great for keeping track of nested function calls.\nFor example, select_column_class() has a nested col_class() function that isn‚Äôt tested directly. So how do I make sure I‚Äôm keeping track of these nested functions in case they throw an error? I‚Äôll build an abstract function tree for the function in the documentation.\nBelow is the abstract syntax tree for select_column_class():\n\n\n‚ñà‚îÄselect_column_class \n‚îî‚îÄ‚ñà‚îÄcol_class \n\n\nThe tree above is simple‚Äìit only has two functions so far‚Äìbut as packages grow these abstract displays become more important for tracking function calls (and tests!).\n\n\nCombining tests\nget_column_class() calls select_column_class(), so I‚Äôll place both unit tests in the tests/testthat/test-column_classes.R file, and create the corresponding R/column_classes.R file\nTo capture these nested functions visually, I‚Äôll include a function tree in a vignette or other source documentation.\n\n\n‚ñà‚îÄget_column_class \n‚îî‚îÄ‚ñà‚îÄselect_column_class \n  ‚îî‚îÄ‚ñà‚îÄcol_class \n\n\nI‚Äôve combined select_column_class() and get_column_class() into a single file because I know every pull_[type]_cols() function would use get_column_class(). The following function tree captures this relationship.\n\n\n‚ñà‚îÄget_column_class \n‚îú‚îÄ‚ñà‚îÄselect_column_class \n‚îÇ ‚îî‚îÄ‚ñà‚îÄcol_class \n‚îú‚îÄ‚ñà‚îÄpull_binary_cols \n‚îú‚îÄ‚ñà‚îÄpull_facet_cols \n‚îú‚îÄ‚ñà‚îÄpull_cat_cols \n‚îî‚îÄ‚ñà‚îÄpull_numeric_cols \n\n\n\n\n\n\n\n\nFunction file names\n\n\n\n\n\nIn shiny app-packages, it‚Äôs common to combine related functions (i.e., function families) into a single .R file with a prefix.\nFor example, a standalone app function combines the code that would otherwise sit in ui.R and server.R.\n\nmyApp &lt;- function() {\n  shiny::shinyApp(ui = \n      shiny::tagList(\n        # code from ui.R\n      ),\n      server = # code from server.R\n    )\n}\n\nOther files that are automatically run with a standard shiny app (i.e., global.R or helpers.R files that used to load data, set themes/colors, etc.,) can be converted into functions and/or package files based on their purpose. For more information on organizing your R/ folder, read this section in R Packages.\nAlso check out golem::add_utils() and golem::add_fct() for creating function files specific to shiny modules.\n\n\n\nIn the test-column_classes.R test file, I‚Äôll need more data for testing, but rather than create test data files for each test, I‚Äôll use test helpers to create the test data.\n\n\nTest helpers\nTest helpers are stored in tests/testthat/helper.R and usually contain functions or code that 1) is too long to repeat with each test, and 2) doesn‚Äôt take too much time or memory to run. Read more about test helpers here.\nI‚Äôve created a set of test helpers in utap for creating different kinds of test data (because I‚Äôll be repeatedly defining columns with slightly different attributes).\nFor example, col_maker() can be used to create a tibble with columns based on the col_type, size, and missing:\n\ncol_maker(col_type = c(\"log\", \"int\", \"dbl\", \n                       \"chr\", \"fct\", \"ord\"),\n          size = 6,\n          missing = TRUE)\n## # A tibble: 6 √ó 6\n##   log_var int_var dbl_var chr_var fct_var ord_var\n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;  \n## 1 TRUE          1     0.1 item:1  group 1 level 1\n## 2 FALSE       135     3   item:2  group 2 level 2\n## 3 NA          269    NA   item:3  group 3 level 3\n## 4 TRUE        403     0.1 &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n## 5 FALSE        NA     3   item:1  group 1 level 1\n## 6 NA            1    NA   item:1  group 2 level 2\n\nI can also create tibbles with custom columns using individual helper _maker() functions:\n\ntibble::tibble(\n    log_var = log_maker(size = 2),\n    int_var = int_maker(size = 2),\n    dbl_var = dbl_maker(size = 2),\n    chr_var = chr_maker(size = 2),\n    list_var = list(fct_var = fct_maker(size = 3), \n                    ord_var = ord_maker(size = 3)),\n)\n## # A tibble: 2 √ó 5\n##   log_var int_var dbl_var chr_var list_var    \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;named list&gt;\n## 1 TRUE          1     0.1 item: 1 &lt;fct [3]&gt;   \n## 2 FALSE         7     1   item: 2 &lt;ord [3]&gt;\n\nThese helpers make it easier to iterate through the test expectations and function development, because tibbles like the one above can be developed inside each test.\n\nBelow is an example for testing if get_column_class() will correctly identify the logical columns (for both return objects):\n\n\nusing test helpers\ntestthat::test_that(\"get_column_class() logical\", {\n  # test logical class\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n      class = \"log\") |&gt;\n      unlist() |&gt;\n      is.logical(),\n    expected = TRUE\n  )\n  # test logical names\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n     class = \"log\",\n      return_tbl = FALSE\n    ),\n    expected = c(log_var = \"log_var\")\n  )\n})\n\n\n\nWhen I‚Äôm confident with the get_column_class() function and it‚Äôs tests, I‚Äôll save the test file and run testthat::test_file().\n\n\nshow/hide get_column_class()\nget_column_class &lt;- function(df, class, return_tbl = TRUE) {\n  if (isFALSE(return_tbl)) {\n    col_types_df &lt;- select_column_class(df, class = class)\n    nms &lt;- names(col_types_df)\n    col_types &lt;- purrr::set_names(nms)\n  } else {\n    col_types &lt;- select_column_class(df, class = class)\n  }\n  return(col_types)\n}\n\n\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 23 ]\n\n\nTest coverage\nHow many tests should I write?\nAs function behavior grows in complexity, so does the number of expectations. In testthat, expectations are captured in tests, and code coverage measures the extent to which the tests in the tests/testthat/ folder cover the possible execution paths of the functions in the R/ folder (i.e.¬†the package codebase).\nCode test coverage is a way to confirm that the unit tests are robust enough to verify that your code behaves as expected. In R packages, code coverage is discussed in the testing chapter using the covr package.\n\n\nCheck coverage interactively\nDuring development, check the code coverage of a test file with devtools::test_coverage_active_file(), or, if this function is being temperamental, use the combination of functions below from covr:\n\ncovr::file_coverage(\n  source_files = \"R/column_classes.R\", \n  test_files = \"tests/testthat/test-column_classes.R\") |&gt;\n  covr::report()\n\nBelow is the output in the Viewer when devtools::test_coverage_active_file() is entered in the Console:\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigure¬†5: Unit test coverage interactively\n\n\n\nI can see from the output I don‚Äôt have test coverage for the select_column_class() behavior when the class argument doesn‚Äôt return any columns from df. The function is designed to return an empty tibble if this occurs:\n\n\n\n\n\n(a) Behavior not tested in select_column_class()\n\n\nFigure¬†6: The area in red is the untested portion of select_column_class()\n\n\nTo test this behavior, I‚Äôll write two expectations:\n\nThe first expectation (expect_s3_class()) checks the class of the return object from select_column_class():\n\n  # test class of empty tibble\n  testthat::expect_s3_class(\n    object = select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\"),\n    class = c(\"tbl_df\", \"tbl\", \"data.frame\"))\n\nThe second expectation verifies there are zero columns in this return tibble:\n\n  # test rows of empty tibble\n  testthat::expect_equal(\n    object = ncol(select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\")),\n    expected = 0L)\n\n\nAfter adding these tests to the test-column_classes.R test file, I‚Äôll run testthat::test_file() and devtools::test_coverage_active_file() again:\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 25 ]\n\ndevtools::test_coverage_active_file()\n\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigure¬†7: Complete code coverage for column_classes.R\n\n\n\n100% is great, but uncommon. Striving for a high percentage of coverage is a good practice, it doesn‚Äôt guarantee that the function always behaves as expected. Unit tests might execute a line of code, but still not catch a bug due to the design of the test (it‚Äôs easy to have high coverage if the unit tests are shallow and don‚Äôt check for any potential edge cases).\nI‚Äôll address code coverage again in the next section, but checking coverage regularly will help ensure function behaviors don‚Äôt go overlooked."
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#macro-iteration",
    "href": "series/testing/series-testing-p1/index.html#macro-iteration",
    "title": "How do I test shiny utility functions?",
    "section": "Macro-iteration",
    "text": "Macro-iteration\nAfter developing the functions in utap, the files in the R/ folder are organized into names based on the ‚Äòmain function and its supporting helpers‚Äô:\nR/\n‚îú‚îÄ‚îÄ column_classes.R\n‚îú‚îÄ‚îÄ pull_binary_cols.R\n‚îú‚îÄ‚îÄ pull_cat_cols.R\n‚îú‚îÄ‚îÄ pull_facet_cols.R\n‚îú‚îÄ‚îÄ pull_numeric_cols.R\n‚îî‚îÄ‚îÄ utils.R\n\nTest file organization\nThe tests/testthat/ folder file names have identical names as the files in the R/ folder.\ntests/testthat/\n        ‚îú‚îÄ‚îÄ test-column_classes.R\n        ‚îú‚îÄ‚îÄ test-pull_binary_cols.R\n        ‚îú‚îÄ‚îÄ test-pull_cat_cols.R\n        ‚îú‚îÄ‚îÄ test-pull_facet_cols.R\n        ‚îú‚îÄ‚îÄ test-pull_numeric_cols.R\n        ‚îî‚îÄ‚îÄ test-utils.R\n\nR/utils.R\nIt‚Äôs common for R packages to have a general R/utils.R file that defines the ‚Äòutility‚Äô functions. This practice isn‚Äôt discouraged in R Packages, but these files can become a catch-all for any functions that don‚Äôt have a clear home (read more here).\nI‚Äôve only stored the %nin% operator in R/utils.R, and it‚Äôs test is shown below:\n\ntestthat::test_that(\"%nin% works\", {\n  testthat::expect_false(\n    object = \"A\" %nin% LETTERS)\n  testthat::expect_false(\n    object = 1 %nin% 1:10)\n  testthat::expect_true(\n    object = 1 %nin% 2:10)\n})\n\n\n\n\nTest package\nWhen I‚Äôve completed a set of test files, I can use devtools::test() to check if they‚Äôre passing.\n\ndevtools::test()\n\n‚Ñπ Testing utap\n‚úî | F W S  OK | Context\n‚úî |        25 | column_classes                                                     \n‚úî |        29 | pull_binary_cols                                                   \n‚úî |         4 | pull_cat_cols                                                      \n‚úî |        20 | pull_facet_cols                                                    \n‚úî |         5 | pull_numeric_cols                                                  \n‚úî |         3 | utils                                                              \n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 2.1 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 86 ]\n\nüéØ Your tests hit the mark üéØ\nThe output above shows all tests are passing (and some helpful words of encouragement). As you can see, the number of tests correspond to the number of functions in each test file.\nFor example, pull_binary_cols() and pull_facet_cols() required additional internal functions to define their use:\n\n\n‚ñà‚îÄpull_binary_cols \n‚îú‚îÄ‚ñà‚îÄcheck_binary_vec \n‚îÇ ‚îú‚îÄ‚ñà‚îÄcheck_log_binary \n‚îÇ ‚îú‚îÄ‚ñà‚îÄcheck_int_binary \n‚îÇ ‚îî‚îÄ‚ñà‚îÄcheck_fct_binary \n‚îî‚îÄ‚ñà‚îÄmake_binary_vec \n\n\n‚ñà‚îÄpull_facet_cols \n‚îú‚îÄ‚ñà‚îÄcheck_facet_vec \n‚îÇ ‚îú‚îÄ‚ñà‚îÄcheck_chr_facet \n‚îÇ ‚îî‚îÄ‚ñà‚îÄcheck_fct_facet \n‚îî‚îÄ‚ñà‚îÄmake_facet_vec \n\n\nWheras pull_cat_cols() and pull_numeric_cols() map onto existing classes:\n\n\n‚ñà‚îÄpull_cat_cols \n‚îú‚îÄ‚ñà‚îÄis.factor \n‚îî‚îÄ‚ñà‚îÄis.character \n\n\n‚ñà‚îÄpull_numeric_cols \n‚îú‚îÄ‚ñà‚îÄis.integer \n‚îî‚îÄ‚ñà‚îÄis.double \n\n\n\n\nCheck coverage on build/install\nTo check the code coverage for the utap package, I can run devtools::test_coverage() to view the output in the Viewer.\n\ndevtools::test_coverage()\n\n‚Ñπ Computing test coverage for utap\n\n\n\n\n\n\n(a) Final test coverage for utap package\n\n\nFigure¬†8: devtools::test_coverage()\n\n\n\nClicking on any of the Files will open the Source tab and give a summary like the one above from devtools::test_coverage_active_file(). I can also use covr::package_coverage() in the Console for simpler output:\nutap Coverage: 100.00%\nR/column_classes.R: 100.00%\nR/pull_binary_cols.R: 100.00%\nR/pull_cat_cols.R: 100.00%\nR/pull_facet_cols.R: 100.00%\nR/pull_numeric_cols.R: 100.00%\nR/utils.R: 100.00%\n\nOther metrics\nSometimes it‚Äôs interesting to view the relationship between function size and number of tests using the cloc package..\n\nlibrary(cloc)\n\ncloc stands for Count Lines of Code, and it‚Äôs a rough metric used to gauge code complexity. It‚Äôs simple, but apparently provides ‚Äújust as much predictive power as more elaborate constructs like cyclomatic complexity.‚Äùsource\nBelow is a count of the lines of code in each file in the R folder:\n\ncloc::cloc_by_file(\"R\")\n\n# A tibble: 8 √ó 6\n  source filename                language   loc blank_lines comment_lines\n  &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;    &lt;int&gt;       &lt;int&gt;         &lt;int&gt;\n1 R      \"R/pull_binary_cols.R\"  R           53           2            57\n2 R      \"R/pull_facet_cols.R\"   R           42           2            73\n3 R      \"R/column_classes.R\"    R           41           6            65\n4 R      \"R/pull_numeric_cols.R\" R           19           1            24\n5 R      \"R/pull_cat_cols.R\"     R           13           0            19\n6 R      \"R/utils.R\"             R            3           0             7\n7 R      \"R/utap-package.R\"      R            2           0             7\n8 R      \"\"                      SUM        173          11           252\nThis output also confirms the relationship between lines of code and tests."
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#recap",
    "href": "series/testing/series-testing-p1/index.html#recap",
    "title": "How do I test shiny utility functions?",
    "section": "Recap",
    "text": "Recap\nThis post has been an introduction to unit testing utility functions in a shiny app-package. When I‚Äôm confident the utility functions are working, I‚Äôll start adding them into modules (and testing with testServer() or shinytest2). Files names can change a lot throughout the course of developing a shiny app-package, so it‚Äôs helpful to adopt (or create) a naming convention.\nIf you‚Äôre using the golem framework to develop your shiny app-package, the utils_ and fct_ prefixes are used to define two different types of utility/helper functions:\n\nutils_ files contain ‚Äòsmall helper functions and‚Äôtop-level functions defining your user interface and your server function‚Äô\nfct_ files contain ‚Äòthe business logic, which are potentially large functions‚Ä¶the backbone of the application and may not be specific to a given module‚Äô.\n\nThis particular file naming convention isn‚Äôt required, but as with most conventions, it‚Äôs better when someone else comes up with the standard (and I just have to adopt and implement it). And having and sticking to a naming convention is typically more important than the convention itself."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html",
    "href": "series/shiny-frameworks/golem/index.html",
    "title": "Creating shiny app-packages (golem)",
    "section": "",
    "text": "This post walks through building a shiny application using the golem framework. golem is a ‚Äôan opinionated framework for building production-grade shiny applications‚Äô‚Äìwe‚Äôll explore some of the opinions in-depth (and offer my opinion on adopting these opinions).\ninstall.packages(\"devtools\")\ndevtools::install_github(\"mjfrigaard/gap\")\nFor consistency, I‚Äôll be using the application from the RStudio‚Äôs Building Web Applications with Shiny course. These materials are a great resource if you‚Äôre new to shiny‚Äìeven if you‚Äôre aren‚Äôt, it‚Äôs still worth checking out‚Äìplus it‚Äôs free!\nThe golem text is also a fantastic resource, but I found myself using the golem website as a great ‚Äòquick reference.‚Äô If you‚Äôre unfamiliar with R package development, I recommend bookmarking R packages‚Äìthis is a great resource you‚Äôll return to often."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#outline",
    "href": "series/shiny-frameworks/golem/index.html#outline",
    "title": "Creating shiny app-packages (golem)",
    "section": "Outline",
    "text": "Outline\nI‚Äôve organized the app-package development process into three areas: Start, Build, and Use.\n\nStart covers the required steps launch your golem project in the console and IDE, some standard R package files, and any additional setup considerations.\nBuild covers the app-package development process, which includes writing and storing code, data, external resources (like CSS or JavaScript), testing, etc.\nUse shows how to launch a golem application locally (i.e., within the RStudio (Posit) IDE), common workflow tips, and anything I found confusing while building the application."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#start",
    "href": "series/shiny-frameworks/golem/index.html#start",
    "title": "Creating shiny app-packages (golem)",
    "section": "Start",
    "text": "Start\n\nTo create a new golem app from the console, enter the following:\n\ninstall.packages(\"golem\")\nlibrary(golem)\ngolem::create_golem(path = \"gap\")\n\nIf you‚Äôre creating a golem app using the New Project Wizard, the following defaults are available:\n\n\n\n\n\nIDE wizard golem setup\n\n\nFigure¬†1: Creating a new golem shiny app\n\n\nI recommend using golem comments (they‚Äôre helpful and don‚Äôt change how the application code runs). When the new project opens, the initial folder structure for your new golem application is below:\n\n\nshow/hide golem folder structure\napp-name/\n  ‚îú‚îÄ‚îÄ DESCRIPTION\n  ‚îú‚îÄ‚îÄ NAMESPACE\n  ‚îú‚îÄ‚îÄ R\n  ‚îÇ   ‚îú‚îÄ‚îÄ app_config.R\n  ‚îÇ   ‚îú‚îÄ‚îÄ app_server.R\n  ‚îÇ   ‚îú‚îÄ‚îÄ app_ui.R\n  ‚îÇ   ‚îî‚îÄ‚îÄ run_app.R\n  ‚îú‚îÄ‚îÄ dev\n  ‚îÇ   ‚îú‚îÄ‚îÄ 01_start.R\n  ‚îÇ   ‚îú‚îÄ‚îÄ 02_dev.R\n  ‚îÇ   ‚îú‚îÄ‚îÄ 03_deploy.R\n  ‚îÇ   ‚îî‚îÄ‚îÄ run_dev.R\n  ‚îú‚îÄ‚îÄ [app-name].Rproj\n  ‚îú‚îÄ‚îÄ inst\n  ‚îÇ   ‚îú‚îÄ‚îÄ app\n  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ www\n  ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ favicon.ico\n  ‚îÇ   ‚îî‚îÄ‚îÄ golem-config.yml\n  ‚îî‚îÄ‚îÄ man\n      ‚îî‚îÄ‚îÄ run_app.Rd\n  \n  7 directories, 14 files\n\n\n\ndev/ scripts\nNew golem apps automatically open the 01_start.R script. This is the first of three developments scripts in the dev/ folder:\n\n\n\ngolem dev/ scripts\n\n\nThe dev/ folder initially contains three .R scripts which serve as a ‚Äòguided tour‚Äô of golem framework (01_start.R, 02_dev.R, and 03_deploy.R). The run_dev.R is for running a development version of your app (more on this later).\n\n\n\n\n\n\ngolem development scripts\n\n\n\n\n\n\nIf you‚Äôre familiar with R application development, you should recognize most of the items in the dev/ scripts. I recommend going through these scripts even if you‚Äôre an experienced R package developer‚Äìyou can think of these as a ‚Äòshiny app-package development checklist.‚Äô\n\n\n\n\n\n\nFill the DESCRIPTION\nThere are three files in a new golem app-package‚ÄìNAMESPACE, DESCRIPTION, and [app name].Rproj. dev/01_start.R starts by building the DESCRIPTION file with golem::fill_desc()\n\n\n\n\n\ngolem DESCRIPTION\n\n\nfill_desc() is from the desc package, and the sections are entered in a key = \"value\" format\n\nExample DESCRIPTION file contents:\n\ngolem::fill_desc(\n  pkg_name = \"gap\",\n  pkg_title = \"An example goelm app\",\n  pkg_description = \"A working example of the golem package.\",\n  author_first_name = \"Martin\",\n  author_last_name = \"Frigaard\",\n  author_email = \"mjfrigaard@pm.me\",\n  repo_url = NULL # The URL of the GitHub Repo (optional)\n)\n\n\n\nshow/hide output from golem::fill_desc()\n‚úî Setting `golem_version` to 0.0.0.9000\n‚úî Setting `golem_name` to gap\n‚úî DESCRIPTION file modified\n\n\n\n\n\n\n\n\n\n*Amending the DESCRIPTION\n\n\n\n\n\n\nIn dev/02_dev.R, the attachment::att_amend_desc() will ‚ÄòAmend DESCRIPTION with dependencies read from package code parsing‚Äô. If attachment is not installed, use install.package('attachment')\n\n\n\n\n\n\nSet {golem} options\n\n\n\n\n\ngolem config file\n\n\nThe golem::set_golem_options() wraps a collection of golem‚Äòs ‚Äôopinionated‚Äô application development and configuration options.\n\ngolem::set_golem_options()\n\n\n\nshow/hide output from golem::set_golem_optionss()\n‚îÄ‚îÄ Setting {golem} options in `golem-config.yml` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚úî Setting `golem_name` to gap\n‚úî Setting `golem_wd` to golem::pkg_path()\nYou can change golem working directory with set_golem_wd('path/to/wd')\n‚úî Setting `golem_version` to 0.0.0.9000\n‚úî Setting `app_prod` to FALSE\n‚îÄ‚îÄ Setting {usethis} project as `golem_wd` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚úî Setting active project to '/projects/dev/gap'\n\n\nset_golem_options() is a wrapper for a collection of golem option functions (I‚Äôve included each function and a brief description of their behavior below):\n\n\nshow/hide golem options\ngolem::set_golem_options(\n  golem_name = golem::pkg_name(), # name of the app-package in DESCRIPTION\n  golem_version = golem::pkg_version(), # version in DESCRIPTION\n  golem_wd = golem::pkg_path(), # package root when starting a golem\n  app_prod = FALSE, # production mode?\n  talkative = TRUE, # Should the messages be printed to the console?\n  config_file = golem::get_current_config(golem_wd) # golem-config.yml location\n)\n\n\nThe new config file is located in the inst/ folder.\n\n\n\n\n\n\n\ngolem options\n\n\n\n\n\n\nTo fully understand the golem framework, I recommended running this function. The great thing about golem‚Äôs options is you don‚Äôt have to adopt all of them to have a production-quality app!\n\n\n\n\n\n\nInstall required dev dependencies\nThe golem::install_dev_deps() function makes sure the following packages are installed (I‚Äôve grouped them into categories):\n\n\n\nDevelopment\n\ndevtools (loading, documenting, installing package)\n\npkgload (i.e., devtools::load_all())\n\nusethis (create package files)\nroxygen2 (document package functions and objects)\npkgbuild (create a .tar.gz file)\n\n\n\nDocumentation & testing\n\nattachment (deal with package dependencies)\ndesc (Parse DESCRIPTION files)\ntestthat (unit testing your code)\n\n\n\n\n\n\n\nInternals\n\nrstudioapi (interacting with RStudio IDE)\nprocessx (execute and control subprocesses from R)\n\n\n\nFiles & paths\n\nhere (file/folder path management)\nfs (file/folder path management)\n\n\n\nDeploy\n\ndockerfiler (deploying apps with docker)\nrsconnect (deploy shiny apps with RSConnect)\n\n\n\n\n\ngolem::install_dev_deps()\n\nBelow is an example with dockerfiler:\n\n\nshow/hide output from golem::install_dev_deps()\n‚Ñπ The package \"dockerfiler\" is required.\n‚úñ Would you like to install it?\n\n1: Yes\n2: No\n\nSelection: 1\n‚úî Updated metadata database: 5.32 MB in 12 files.                         \n‚úî Updating metadata database ... done                                     \n                                                                            \n‚Üí Will install 1 package.\n‚Üí Will download 1 CRAN package (104.29 kB).\n+ dockerfiler   0.2.1  ‚¨á (104.29 kB)\n‚Ñπ Getting 1 pkg (104.29 kB)\n‚úî Got dockerfiler 0.2.1 (x86_64-apple-darwin17.0) (104.29 kB)             \n‚úî Downloaded 1 package (104.29 kB)in 1.1s                                 \n‚úî Installed dockerfiler 0.2.1  (54ms)                                    \n‚úî 1 pkg + 40 deps: kept 40, added 1, dld 1 (104.29 kB) [20.2s]  \n\n\n\n\n\n\n\n\nUsing golem devops\n\n\n\n\n\n\nI recommend using golem‚Äôs options here‚Äìit‚Äôs efficient and let‚Äôs you know if a particular package isn‚Äôt installed:\n\n\n\n\n\n\nCreate Common Files\nThe ‚ÄòCreate Common Files‚Äô section of dev/01_start.R contains many of the functions and files covered in the ‚ÄòWhole Game‚Äô section of R packages:\n\nLICENSE\n\nusethis::use_mit_license(\"Golem User\")\n\n\n‚úî Adding 'MIT + file LICENSE' to License\n‚úî Writing 'LICENSE'\n‚úî Writing 'LICENSE.md'\n‚úî Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n\n\n\n\n\n\n\n\ngolem LICENSE file\n\n\n\nREADME.Rmd\n\nusethis::use_readme_rmd()\n\n\n‚úî Writing 'README.Rmd'\n‚úî Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n‚Ä¢ Update 'README.Rmd' to include installation instructions.\n\n\nThe README.md is built with devtools::build_readme()\ndevtools::build_readme()\n‚Ñπ Installing gap in temporary library\n‚Ñπ Building /projects/dev/gap/README.Rmd\n\n\n\n\n\n\n\ngolem README.Rmd file\n\n\n\nCODE_OF_CONDUCT.md\n\nusethis::use_code_of_conduct()\n\n\n‚úî Writing 'CODE_OF_CONDUCT.md'\n‚úî Adding '^CODE_OF_CONDUCT\\\\.md$' to '.Rbuildignore'\n‚Ä¢ You may also want to describe the code of conduct in your README:\n  ## Code of Conduct\n\nPlease note that the gap project is released with a [Contributor Code of\n    Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html).\nBy contributing to this project, you agree to abide by its terms.\n  [Copied to clipboard]\n\n\nPaste of the code of conduct in the README.md is rebuild with devtools::build_readme()\ndevtools::build_readme()\n‚Ñπ Installing gap in temporary library\n‚Ñπ Building /projects/dev/gap/README.Rmd\n\n\n\n\n\n\n\ngolem code of conduct file\n\n\n\nLifecycle badge\n\nusethis::use_lifecycle_badge(\"Experimental\")\n\n\n‚úî Adding Lifecycle: experimental badge to 'README.Rmd'\n‚Ä¢ Re-knit 'README.Rmd' with `devtools::build_readme()`\n\n\nRebuild the README.md with devtools::build_readme()\nusethis::use_lifecycle_badge(\"Experimental\")\n‚Ñπ Installing gap in temporary library\n‚Ñπ Building /projects/dev/gap/README.Rmd\n\n\n\n\n\n\n\ngolem lifecycle badge\n\n\n\nNEWS.md\n\nusethis::use_news_md(open = FALSE)\n\n\n‚úî Writing 'NEWS.md'\n\n\n\n\n\n\n\ngolem NEWS.md file\n\n\n\nGit: usethis::use_git() will ask if you‚Äôd like to commit the files in your golem app to a repo of the same name:\n\nusethis::use_git()\n\n\n‚úî Setting active project to '/projects/dev/gap'\n‚úî Initialising Git repo\n‚úî Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth',\n  '.DS_Store', '.quarto' to '.gitignore'\nThere are 16 uncommitted files:\n* '.gitignore'\n* '.here'\n* '.Rbuildignore'\n* 'CODE_OF_CONDUCT.md'\n* 'DESCRIPTION'\n* 'dev/'\n* 'gap.Rproj'\n* 'inst/'\n* 'LICENSE'\n* 'LICENSE.md'\n* ...\nIs it ok to commit them?\n\n1: Definitely\n2: Negative\n3: Not now\n\nSelection: 1\n\n\nTo initialize the Git pane, you‚Äôll need to restart RStudio (in the next dialogue)\n‚úî Adding files\n‚úî Making a commit with message 'Initial commit'\n‚Ä¢ A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Absolutely\n2: Negative\n3: No\nSelection: 1\n\n\n\n\n\n\n\n\ngolems common files\n\n\n\n\n\n\nEach of these files are important for an R package, so having them consolidated in 01_start.R makes it easier to get up and running quickly. However, if you‚Äôd like to edit their contents before moving onto the next step (or you‚Äôd like information on a particular function/file), I recommend consulting R packages for this section\n\n\n\n\n\n\nInit Testing Infrastructure\ngolem::use_recommended_tests() with set up the testthat architecture for unit tests.\n\ngolem::use_recommended_tests()\n\n\n\n\n\n\ngolem test files\n\n\n\n‚úî Setting active project to '/projects/dev/gap'\n‚úî Adding 'testthat' to Suggests field in DESCRIPTION\n‚úî Adding '3' to Config/testthat/edition\n‚úî Creating 'tests/testthat/'\n‚úî Writing 'tests/testthat.R'\n‚Ä¢ Call `use_test()` to initialize a basic test file and open it for editing\n\nIt also adds a few words to the WORDLIST file in the inst folder:\n\n‚úî Adding 'spelling' to Suggests field in DESCRIPTION\n‚úî Adding 'en-US' to Language\nThe following words will be added to the wordlist:\n - Lifecycle\n - goelm\n - golem\nAre you sure you want to update the wordlist?\n1: Yes\n2: No\n\nSelection: 1\nAdded 3 and removed 0 words in /projects/dev/gap/inst/WORDLIST\nUpdated /projects/dev/gap/tests/spelling.R\n‚Ä¢ Run `devtools::check()` to trigger spell check\n‚úî Tests added\n\ngolem::use_recommended_tests() also provides some examples for testing the UI, server, and other golem functions:\n\n\nshow/hide unit tests in test-golem-recommended.R\ntest_that(\"app ui\", {\n  ui &lt;- app_ui()\n  golem::expect_shinytaglist(ui)\n  # Check that formals have not been removed\n  fmls &lt;- formals(app_ui)\n  for (i in c(\"request\")) {\n    expect_true(i %in% names(fmls))\n  }\n})\n\ntest_that(\"app server\", {\n  server &lt;- app_server\n  expect_type(server, \"closure\")\n  # Check that formals have not been removed\n  fmls &lt;- formals(app_server)\n  for (i in c(\"input\", \"output\", \"session\")) {\n    expect_true(i %in% names(fmls))\n  }\n})\n\ntest_that(\n  \"app_sys works\",\n  {\n    expect_true(\n      app_sys(\"golem-config.yml\") != \"\"\n    )\n  }\n)\n\ntest_that(\n  \"golem-config works\",\n  {\n    config_file &lt;- app_sys(\"golem-config.yml\")\n    skip_if(config_file == \"\")\n\n    expect_true(\n      get_golem_config(\n        \"app_prod\",\n        config = \"production\",\n        file = config_file\n      )\n    )\n    expect_false(\n      get_golem_config(\n        \"app_prod\",\n        config = \"dev\",\n        file = config_file\n      )\n    )\n  }\n)\n\n# Configure this test to fit your need.\n# testServer() function makes it possible to test code in server functions and modules, without needing to run the full Shiny application\ntestServer(app_server, {\n\n  # Set and test an input\n  session$setInputs(x = 2)\n  expect_equal(input$x, 2)\n\n  # Example of tests you can do on the server:\n  # - Checking reactiveValues\n  # expect_equal(r$lg, 'EN')\n  # - Checking output\n  # expect_equal(output$txt, \"Text\")\n})\n\n# Configure this test to fit your need\ntest_that(\n  \"app launches\",\n  {\n    golem::expect_running(sleep = 5)\n  }\n)\n\n\nThese tests pass right out of the box, and they give a little ‚Äòsneak preview‚Äô of how the golem framework works.\n\n\nshow/hide results from unit tests in test-golem-recommended.R\n==&gt; Testing R file using 'testthat'\n\n‚Ñπ Loading gap\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ]\nLoading required package: shiny\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 10 ]\n\n‚îÄ‚îÄ Skipped tests (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚Ä¢ interactive() is not TRUE\n  (1):\n  test-golem-recommended.R:72:5\n\n\nTest complete\n\n\n\n\n\n\n\n\ngolem recommended tests\n\n\n\n\n\n\nI love this feature of golem apps! in a single function I have the folders required for unit testing, words added to the WORDLIST (which I almost never remember to do), and an example test with shiny‚Äôs testServer() function.\n\n\n\n\n\n\nFavicon\nA favicon is a the little image that shows up on your browser tab or address bar. golem has a default favicon in the inst/app/ folder:\n\n\n\n\n\ngolem favicon file\n\n\n\ninst/\n  ‚îî‚îÄ‚îÄ app\n       ‚îî‚îÄ‚îÄ www\n            ‚îî‚îÄ‚îÄ favicon.ico\n\n\n3 directories, 1 file\n\nThe inst/ folder serves a specific purpose in golem apps (and R packages), which I‚Äôll cover more below. For our purpose, the golem::use_favicon() function can use the existing image:\n\ngolem::use_favicon(path = \"inst/app/www/favicon.ico\")\n\nThe output introduces another common golem function: golem_add_external_resources()\n\n‚úî favicon.ico created at \n/projects/gap/inst/app/www/favicon.ico\nFavicon is automatically linked in app_ui via `golem_add_external_resources()`\n\nThis function is used to add external resources to your application (and will come up often during development).\n\n\nAdd helper functions\nMost applications will have two types of code‚Äìshiny functions for running your application (app functions), and functions that do everything else (or utility functions). The golem further distinguished utility functions into two types: ‚Äúsmall functions that are reused throughout the app‚Äù (with a utils_ prefix), and ‚Äúlarger functions, which are more central to the application‚Äù (with a fct_ prefix).\nThese descriptions from the text are helpful for distinguishing between the two:\n\nutils_ functions: ‚Äú‚Ä¶the hexmake app has two of these files, R/utils_ui.R and R/utils_server.R, in which you will find small functions that are reused throughout the app.‚Äù\n\n\nfct_ functions: ‚Äú‚Ä¶in hexmake, you will find R/fct_mongo.R, which is used to handle all the things related to connecting and interacting with the Mongodb database.‚Äù\n\n\nuse_utils_ui()\nThe golem::use_utils_ui() function will add a collection of utility functions for the UI. Including with_test = TRUE will add a test for these functions.\n\n\n\n\n\ngolem UI utility functions & tests\n\n\n\ngolem::use_utils_ui(with_test = TRUE)\n\n\n‚úî File created at /projects/gap/R/golem_utils_ui.R\n‚úî Utils UI added\n‚úî File created at /projects/gap/tests/testthat/test-golem_utils_ui.R\n‚úî Tests on utils_server added\n\n\n\nuse_utils_server()\ngolem also includes a set of functions for the application server (or server modules), golem::use_utils_server(). The with_test = TRUE will also add a test to the tests/testthat/ folder:\n\ngolem::use_utils_server(with_test = TRUE)\n\n\n‚úî File created at /projects/gap/R/golem_utils_server.R\n‚úî Utils server added\n‚úî File created at /projects/gap/tests/testthat/test-golem_utils_server.R\n‚úî Tests on utils_server added\n\n\n\n\n\n\ngolem server utility functions & tests\n\n\n\n\n\n\n\n\ngolem utility functions\n\n\n\n\n\n\nI consider these functions optional, but the examples in each file have a broad enough application that you‚Äôll probably discover something helpful for your golem application. The with_test argument also provides more examples of unit tests for your application functions, so you‚Äôre likely to find something useful!\n\n\n\n\nThis is the final function in the dev/01_start.R file. In the next golem dev script (dev/02_dev.R), I‚Äôll cover development of your golem application."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#build",
    "href": "series/shiny-frameworks/golem/index.html#build",
    "title": "Creating shiny app-packages (golem)",
    "section": "Build",
    "text": "Build\nThe dev/02_dev.R file is appropriately titled, ‚ÄòEngineering‚Äô, and unlike the functions in the first script, these functions will be used repeatedly for creating files in the R/ and inst/ folders.\n\nApp files\nLet‚Äôs start by examining the contents of the R/ folder in our new golem application:\n\n\n\n\n\ngolem application files\n\n\n\nR/\n‚îú‚îÄ‚îÄ app_config.R\n‚îú‚îÄ‚îÄ app_server.R\n‚îú‚îÄ‚îÄ app_ui.R\n‚îî‚îÄ‚îÄ run_app.R\n\n1 directory, 4 files\n\ngolem applications structure shiny apps into three files: R/app_ui.R, R/app_server.R, and R/run_app.R.\n\nThe R/app_ui.R and R/app_server.R scripts are golem‚Äôs version of ui.R and server.R\nR/run_app.R is a standalone app function, and\nR/app_config.R is used to set/get golem configuration settings (which we will cover more below).\n\n\napp_ui.R\napp_ui.R wraps the UI functions in shiny::tagList() (you‚Äôll see this function in shiny UI module functions, too).\n\n\nshow/hide app_ui()\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"gap\")\n    )\n  )\n}\n\n\napp_ui() also contains a call to golem_add_external_resources(), which we used above to add the favicon image.\n\n\nshow/hide golem_add_external_resources()\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"gap\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\n\n\napp_server.R\nThe contents of app_server.R file looks similar to a standard shiny server function:\n\n\nshow/hide app_server()\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n}\n\n\n\n\napp_config.R\nThe app_config.R file contains the ‚Äúinternal mechanics for golem, notably for referring to values in the inst/ folder, and to get values from the config file in the inst/ folder‚Äù. Two functions drive the internal mechanics of your golem app: app_sys() and get_golem_config()\n\napp_sys() is a wrapper around the system.file() function, and it‚Äôs used to ‚Äúquickly refer to the files inside the inst/ folder‚Äù\n\n\n\nshow/hide app_sys()\napp_sys &lt;- function(...) {\n  system.file(..., package = \"gap\")\n}\n\n\n\nget_golem_config() is where you‚Äôll set golem configuration options (covered here in the text).\n\n\n\nshow/hide get_golem_config()\nget_golem_config &lt;- function(\n  value,\n  config = Sys.getenv(\n    \"GOLEM_CONFIG_ACTIVE\",\n    Sys.getenv(\n      \"R_CONFIG_ACTIVE\",\n      \"default\"\n    )\n  ),\n  use_parent = TRUE,\n  # Modify this if your config file is somewhere else\n  file = app_sys(\"golem-config.yml\")\n) {\n  config::get(\n    value = value,\n    config = config,\n    file = file,\n    use_parent = use_parent\n  )\n}\n\n\nget_golem_config() reads the inst/golem-config.yml configuration file:\n\ndefault:\n  golem_name: gap\n  golem_version: 0.0.0.9000\n  app_prod: no\nproduction:\n  app_prod: yes\ndev:\n  golem_wd: !expr here::here()\n\ngolem-config.yml gives me access to the app version, name, and (development) working directory. This file is designed to add ‚Äúproduction-only elements‚Äù and be ‚Äúshareable across golem projects‚Äù\n\n\nrun_app.R\nrun_app.R is the exported function I‚Äôll use to run my golem app after loading/documenting/installing the package:\n\ndevtools::load_all(\".\")\n\n\n‚Ñπ Loading gap\n\n\ndevtools::document()\n\n\n‚Ñπ Updating gap documentation\n‚Ñπ Loading gap\n\nRestarting R session...\n\n\nlibrary(gap)\ngap::run_app()\n\n\n\n\n\n\n\ngolem app functions\n\n\n\n\n\n\nThe great thing about golem applications is that despite having a somewhat overwhelming amount of code and options, most of these can be ignored until you need to use them. R/app_config.R is a great example of this. The get_golem_config() function is a powerful tool for deploying apps in production, but you can get started developing your application without diving into the details.\n\n\n\n\n\n\n\n\nDependencies\nDependency management is a necessary evil of package development. shiny has a large ecosystem of user-written add-on packages. To use the code from add-on packages in our application, we need a way to keep track of which function belongs to which package.\n\n\n\n\n\ngolem app dependencies\n\n\nThe DESCRIPTION file manages package-level dependencies. The Imports field in the DESCRIPTION file specifies packages that my package uses, so the functions from these packages will be available for my package, but not for users (unless they use the :: operator or load the package themselves).\nThe NAMESPACE file manages function-level access. The NAMESPACE file manages the functions that are exported from my package (i.e., functions available to users who install my package), and the functions my package imports from other packages.\nThe golem text describes the difference between these files in the following way,\n\n‚ÄúThe DESCRIPTION file dictates which packages have to be installed when your application is installed‚Äù\n‚ÄúThe NAMESPACE file describes how your app interacts with the R session at run time, i.e.¬†when your application is launched‚Äù\n\nThe attachment package makes it easier to manage the dependencies in your golem application. It does this by looking through the files in your package to make sure everything is properly documented in the NAMESPACE and DESCRIPTION file (note that these two files are not equivalent or connected).\nThe att_amend_desc() function removes a lot of the tedium involved in dependency management:\n\nattachment::att_amend_desc()\n\nThis function adds the appropriate parameters to golem-config.yml and sets up function documentation in the DESCRIPTION file\n\nSaving attachment parameters to yaml config file\nUpdating [app-name] documentation\nSetting `RoxygenNote` to \"7.2.3\"\n\nIt loads the contents of our package (i.e.¬†devtools::load_all()) and writes the NAMESPACE file\n\n‚Ñπ Loading [app-name]\nWriting NAMESPACE\n\nIt also writes the help files in the man/ folder.\n\nWriting run_app.Rd\n\n\n\n\n\n\n\ngolem app dependencies\n\n\n\n\n\n\nManaging the dependencies in your app is an essential part of getting your application to deploy in a production environment, and this is a very helpful addition to your package development workflow (whether you‚Äôre building an app package or standard R package).\n\n\n\n\n\n\nAdd modules\ngolem has functions for quickly creating modules and utility/helper functions in the R/ folder.\n\nadd_module()\n\ngolem::add_module(name = \"name_of_module1\", with_test = TRUE) \ngolem::add_module(name = \"name_of_module2\", with_test = TRUE) \n\n\n\n\nAdd helper functions\ngolem apps differentiates two types of helper functions: uils_ and fct_.\n\nadd_utils()\n\nuils_ functions: ‚Äúsmall functions that might be used several times in the application‚Äù ‚Ä¶ ‚Äúmore ‚Äòtopic centered‚Äô, in the sense that they gather functions that relate to a specific feature of the application(+‚Äù\n\n\ngolem::add_utils(\"helpers\", with_test = TRUE)\n\n\n\nadd_fct()\n\nfct_ functions: ‚Äúlarger functions that are more central to the application‚Äù ‚Ä¶ ‚Äúmore used as a place to put miscellaneous functions‚Äù\n\n\ngolem::add_fct(\"helpers\", with_test = TRUE)\n\nwith_test = TRUE ensures these functions will also create test files in tests/\n\n\n\nExternal resources\ndev/02_dev.R includes golem wrappers for including CSS, JavaScript, and SASS files to the inst/app/www/ folder:\n\nJavaScript files\nYou can add JavaScript to your application using the golem::add_js_file(\"script\") and golem::add_js_handler(\"handlers\") functions.\nThe golem text has an entire chapter dedicated to JavaScript which is worth reading (and I‚Äôll demonstrate an example with these functions below).\n\n\nApp styling\nYou can add CSS or SASS styling to your application using the golem::add_css_file(\"custom\") and golem::add_sass_file(\"custom\") functions, too.\n\n\n\nAdd internal datasets\nIf you application uses data, you can add it to your application with the usethis functions (use_data_raw() or use_data()). I recommend reading the data section of R packages (and this section on adding data to inst/extdata).\n\nuse_data_raw()\nThe data-raw/ folder is for ‚Äòdata-creating script‚Äô that was used to create the version of the data in your app-package. Newly created .R scripts in use_data_raw() will have a call to use_data().\n\n\nuse_data()\nThe data/ folder stores the data files created from the scripts in data-raw/ (and any other data you need in your app-package).\n\n‚Äústore R objects and make them available to the user‚Ä¶in data/‚Äù\n\n\n\ninst/extdata\nAny other data you‚Äôd like to make available to users of your package should be stored in inst/extdata/\n\n‚Äústore data in some raw, non-R-specific form and make it available to the user‚Ä¶in inst/extdata/‚Äù\n\n\n\n\nTests\nThe tests/ folder was created in dev/01_start.R with golem::use_recommended_tests(), which is a wrapper around usethis::use_testthat()\nIn dev/02_dev.R, the golem::add_module() and golem::add_utils()/golem::add_fct() functions also include a with_test = TRUE argument, which creates a test file in the tests/ folder.\n\n\nDocumentation\nR package vignettes contain high-level, user-friendly explanations of the package, which includes a narrative that describes the functions, data, and behavior of the package. For shiny app-packages, the following types of documentation might be included in the vignettes:\n\n\n\n\n\n\nIntroduction to the package\nInstallation guide\nUsage examples\nDescription of the application and modules\n\n\n\n\n\nApplication workflow\nData preparation\nTroubleshooting\nFAQs\nAdvanced usage\nDetails on functions and datasets\nReferences and Contact information\n\n\n\n\n\nusethis::use_vignette(\"gap\")\n\n\n‚úî Setting active project to '/Users/mjfrigaard/projects/dev/gap'\n‚úî Adding 'knitr' to Suggests field in DESCRIPTION\n‚úî Adding 'rmarkdown' to Suggests field in DESCRIPTION\n‚úî Adding 'knitr' to VignetteBuilder\n‚úî Adding 'inst/doc' to '.gitignore'\n‚úî Creating 'vignettes/'\n‚úî Adding '*.html', '*.R' to 'vignettes/.gitignore'\n‚úî Writing 'vignettes/gap.Rmd'\n‚Ä¢ Modify 'vignettes/gap.Rmd'\n\nThe vignette file opens with the title matching the argument passed to use_vignette().\n\ndevtools::build_vignettes()\n\n\nCode Coverage\nTest code coverage measures the extent to which the test cases cover the possible execution paths in the package codebase‚Äìits a way to ensure that the tests are robust enough to verify that the code behaves as expected.\nThere are two functions/methods used to calculate code coverage in your application: usethis::use_coverage() and covrpage::covrpage().\n\nusethis::use_coverage()\nuse_coverage() is part of the usethis package and can be run interactively during development:\n\nusethis::use_coverage()\n\n‚úî Setting active project to '/Users/mjfrigaard/projects/pkgs/apps/gap'\n\n\ncovrpage::covrpage()\nInstall covrpage using the following:\n\n# install.packages(\"remotes\")\nremotes::install_github('yonicd/covrpage')\nlibrary(covrpage)\n\nTo use covrpage, run the following\n\n\n\nCI"
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#use",
    "href": "series/shiny-frameworks/golem/index.html#use",
    "title": "Creating shiny app-packages (golem)",
    "section": "Use",
    "text": "Use\n\nWriting code\nNew modules and utility functions can be created with golem::add_module() or golem::add_utils()/golem::add_fct()\n\nThese functions are added to the R/ folder and include @noRd by default (which must be removed create the .Rd files in the man/ folder)\n\n\n# UI module template -------------------\n#' test UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd\n#'\n#' @importFrom shiny NS tagList\n# server module template ---------------\n#' test Server Functions\n#'\n#' @noRd\n\n\nUI module functions end with a _ui suffix:\n\nClick on Code to view code in R/mod_plot.R\n\n\n\n#' plot UI Function\n#'\n#' @param id\n#'\n#' @return shiny UI module\n#' @export mod_plot_ui\n#'\n#' @importFrom shiny NS tagList tags\n#' @importFrom shiny plotOutput verbatimTextOutput\nmod_plot_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\n          \"The code for this application comes from the \",\n          shiny::tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    ),\n    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\nServer module functions end with a _server suffix:\n\nClick on Code to view code in R/mod_plot.R\n\n\n\n\nshow/hide\n#' plot Server Functions\n#'\n#' @param id module id\n#' @param var_inputs inputs from mod_var_input\n#'\n#' @return shiny server module\n#' @export mod_plot_server\n#'\n#' @importFrom shiny NS moduleServer reactive\n#' @importFrom tools toTitleCase\n#' @importFrom shiny renderPlot\n#' @importFrom stringr str_replace_all\n#' @importFrom ggplot2 labs theme_minimal theme\nmod_plot_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    movies &lt;- gap::movies\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs$plot_title())\n      list(\n        x = var_inputs$x(),\n        y = var_inputs$y(),\n        z = var_inputs$z(),\n        alpha = var_inputs$alpha(),\n        size = var_inputs$size(),\n        plot_title = plot_title\n      )\n    })\n\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n## To be copied in the UI\n# mod_plot_ui(\"plot_1\")\n\n## To be copied in the server\n# mod_plot_server(\"plot_1\")\n\n\n\n\nSee all of the modules I use in this application here on GitHub examples\n\n\n\n\n\n\n\n\n\nModule names\n\n\n\n\n\n\nIncluding mod in the name of module scripts and functions makes it easier to separate them from other functions in my package namespace, if I‚Äôm using tab-completion, or if I‚Äôm searching for a particular file using Ctrl + .:\n\n\n\n\n\n\n\nFigure¬†2: Go to File/Function in RStudio\n\n\n\n\n\n\n\nInclude tests for new modules and functions using the with_test = TRUE argument\n\n\ntests/testthat/\n            ‚îú‚îÄ‚îÄ _snaps\n            ‚îú‚îÄ‚îÄ test-golem-recommended.R\n            ‚îú‚îÄ‚îÄ test-golem_utils_server.R\n            ‚îú‚îÄ‚îÄ test-golem_utils_ui.R\n            ‚îú‚îÄ‚îÄ test-mod_plot.R\n            ‚îú‚îÄ‚îÄ test-mod_plot_utils_server.R\n            ‚îî‚îÄ‚îÄ test-mod_var_input.R\n\n2 directories, 6 files\n\n\n\n\n\nAdding resources\n\nTo include other files (like images), add the image file to inst/app/www/, then add the www/ to the path (see example UI code below)\n\n\n# add icon\nshiny::tags$img(src = \"www/shiny.png\")\n\n\nIf I wanted to include images in their own folder (like images/), I can use golem::addResourcePath() to add the name of the sub-folder to inst/app/\n\n\n# add icon\ngolem::add_resource_path(\n          prefix = 'images', \n          directoryPath = system.file('app/images', package = 'gap'))\n\n\nNow I can add the image file to the inst/app/www/images/ folder and include the following code in the UI:\n\n\n# add icon\nshiny::tags$img(src = \"www/images/golem-hex.png\")\n\n\nIn R/app_ui.R, the app_ui() function contains the UI layout functions (fluidPage(), sidebarLayout(), etc.), and a call to golem_add_external_resources():\n\nClick on Code to view the updated R/app_ui.R\n\n\n\n\nshow/hide\n#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_ui &lt;- function(request) {\n  shiny::tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    shiny::fluidPage(\n      shiny::tags$h1(\"gap\"),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          # add shiny hex in www/\n          shiny::tags$img(src = \"www/shiny.png\"),\n          mod_plot_ui(\"plot\"),\n          # add golem hex (in www/images/)\n          shiny::fluidRow(\n            shiny::tags$em(shiny::tags$h4(\n              \"Brought to you by: \",\n              shiny::tags$img(src = \"www/images/golem-hex.png\")\n            ))\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n\nClick on Code to view golem_add_external_resources()\n\n\n\n\nshow/hide\n# this is also included in the app_ui.R script\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"gap\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\n\nNow when I run devtools::load_all(), devtools::document(), install/restart, and load the package, I see the images properly rendered with the application:\n\n\n\nDeploy\n\nThe final step in the guided tour contains functions for deploying a new application to Posit Connect or Docker (it opens automatically after completing the dev/02_dev.R)\n\nClick on Code to view code in dev/03_deploy.R\n\n\n\n\nshow/hide\n## Run checks ----\n## Check the package before sending to prod\ndevtools::check()\nrhub::check_for_cran()\n\n# Deploy\n\n## Local, CRAN or Package Manager ----\n## This will build a tar.gz that can be installed locally,\n## sent to CRAN, or to a package manager\ndevtools::build()\n\n## RStudio ----\n## If you want to deploy on RStudio related platforms\ngolem::add_rstudioconnect_file()\ngolem::add_shinyappsio_file()\ngolem::add_shinyserver_file()\n\n## Docker ----\n## If you want to deploy via a generic Dockerfile\ngolem::add_dockerfile_with_renv()\n\n## If you want to deploy to ShinyProxy\ngolem::add_dockerfile_with_renv_shinyproxy()\n\n\n\n\nRStudio (Posit) Connect\n\ngolem::add_rstudioconnect_file(), golem::add_shinyappsio_file(), and golem::add_shinyserver_file()\n\nDocker\n\ngolem::add_dockerfile_with_renv() and golem::add_dockerfile_with_renv_shinyproxy()\n\nI‚Äôll deploy my app using shinyapps.io, so after running golem::add_shinyappsio_file() I will see the following output and a new app.R file.\n\n\nClick on Code to view the output from golem::add_shinyappsio_file()\n\n\n\n\nshow/hide\ngolem::add_shinyappsio_file()\n‚îÄ‚îÄ Creating _disable_autoload.R ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚úî Created\n‚úî Setting active project to '/Users/mjfrigaard/projects/gap'\n‚úî Adding '^app\\\\.R$' to '.Rbuildignore'\n‚úî Adding '^rsconnect$' to '.Rbuildignore'\n‚úî Adding 'pkgload' to Imports field in DESCRIPTION\n‚Ä¢ Refer to functions with `pkgload::fun()`\n‚úî File created at /Users/mjfrigaard/projects/gap/app.R\nTo deploy, run:\n‚Ä¢ rsconnect::deployApp()\n\n‚Ä¢ Note that you'll need to upload the whole package to ShinyApps.io\n\n\n\n\nThe app.R contents\n\n\nClick on Code to view the contents of app.R\n\n\n\n\nshow/hide\n# Launch the ShinyApp (Do not remove this comment)\n# To deploy, run: rsconnect::deployApp()\n# Or use the blue button on top of this file\n\npkgload::load_all(export_all = FALSE, helpers = FALSE, attach_testthat = FALSE)\noptions( \"golem.app.prod\" = TRUE)\ngap::run_app() # add parameters here (if any)\n\n\n\n\nBuilding an application with golem is very similar to developing an R package. New code files are placed in R/, external resources are placed in inst/, etc. I‚Äôll cover creating modules and utility functions in the next section."
  },
  {
    "objectID": "posts/box/index.html",
    "href": "posts/box/index.html",
    "title": "Writing modular code with box",
    "section": "",
    "text": "box provides a precise and concise method for using add-on packages and functions. box also doesn‚Äôt require bundling your code into R packages to make it reusable. This post covers tackling some common workflow steps to demonstrate how box modules work."
  },
  {
    "objectID": "posts/box/index.html#what-is-box",
    "href": "posts/box/index.html#what-is-box",
    "title": "Writing modular code with box",
    "section": "",
    "text": "box provides a precise and concise method for using add-on packages and functions. box also doesn‚Äôt require bundling your code into R packages to make it reusable. This post covers tackling some common workflow steps to demonstrate how box modules work."
  },
  {
    "objectID": "posts/box/index.html#packages-functions-and-namespaces",
    "href": "posts/box/index.html#packages-functions-and-namespaces",
    "title": "Writing modular code with box",
    "section": "Packages, functions, and namespaces",
    "text": "Packages, functions, and namespaces\nTo understand the problem box solves, we‚Äôll review the typical process for using add-on package functions in a standard R sesson and when developing R packages:\n\nR sessions\n\nAssume I want to use the glue() function from the glue package. The first step is to install it with install.packages(\"glue\")\n\nI‚Äôll use the example from the glue package website:\n\n\n\nshow/hide\ninstall.packages(\"glue\")\n## \n## The downloaded binary packages are in\n##  /var/folders/0x/x5wkbhmx0k74tncn9swz7xpr0000gn/T//RtmpAXeFDN/downloaded_packages\n\n\n\n\nTo use the functions from glue, I‚Äôll need to run library(glue) in the same R session.\n\nIf I try to use a function from a package but it hasn‚Äôt been attached with library or require, I see the following:\n\n\n\nshow/hide\nname &lt;- \"Fred\"\nglue('My name is {name}.')\n## Error in glue(\"My name is {name}.\"): could not find function \"glue\"\n\n\n\nThe error above can be confusing, because it doesn‚Äôt tell us if the package hasn‚Äôt been installed, or if the package hasn‚Äôt been attached.\nHowever, after installing glue, I can get around using library by explicitly calling the function from the package namespace (i.e., pkg::foo()):\n\n\n\nshow/hide\nname &lt;- \"Fred\"\nglue::glue('My name is {name}.')\n## My name is Fred.\n\n\n\nWhile this method works, it doesn‚Äôt attach the package to the search list (which I check with search())\n\n\n\nshow/hide\nbase::search()\n## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\n\n\n\nlibrary() attaches the glue package in the search list and makes the glue() function available to use (without the package:: prefix)\n\n\n\nshow/hide\nlibrary(glue)\nbase::search()\n##  [1] \".GlobalEnv\"        \"package:glue\"      \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n\n\n\nUnfortunately, library() also attaches all the objects from the glue package to the search() list, even though I‚Äôm only using a single function.\n\n\nRead more about namespaces in Advanced R and R packages.\n\n\nR packages\nIf I want to make the code I write using glue reusable, I can bundle it into an R package. Including glue as an add-on package (i.e., packages not loaded automatically with R) is done with the NAMESPACE file (created and edited via roxygen2 tags), and by listing these packages under Imports in the DESCRIPTION file.\n\nIn R/ files:\nAll .R files in R packages are placed in the R/ folder. If these files use add-on packages (i.e., library() or package::fun()), I include the @import or @importFrom tag. If I‚Äôd like to include and make my_name() available to users, I use the @export tag:\n\nI‚Äôve converted the use of glue() into a small function below:\n\nmy_name() is saved as R/my_name.R:\n\n\n\nshow/hide\nmy_name &lt;- function(x) {\n  name &lt;- x\n  glue::glue('My name is {name}.')\n}\nmy_name(\"Fred\")\n## My name is Fred.\n\n\n\nBelow is a default roxygen2 skeleton:\n\n\n\nshow/hide\n#' Introduce yourself \n#'\n#' @param x a name \n#'\n#' @return An glued introduction to R\n#' @export my_name\n#'\n#' @examples\n#' my_name(\"Fred\")\nmy_name &lt;- function(x) {\n  name &lt;- x\n  glue::glue('My name is {name}.')\n}\n\n\n\n\n\nAs we can see, the default roxygen2 skeleton doesn‚Äôt include @import or @importFrom. The general advice is to prefer @importFrom over @import, because @import imports the entire package namespace (only use this in ‚Äòvery special situations‚Äô such as ‚Äòheavy use‚Äô of a package functions).\n\nBelow is an example of using @importFrom:\n\n\n\nshow/hide\n#' Introduce yourself \n#'\n#' @param x a name \n#'\n#' @return An glued introduction to R\n#' @export my_name\n#'\n#' @examples\n#' my_name(\"Fred\")\n#'\n#' @importFrom glue glue\nmy_name &lt;- function(x) {\n  name &lt;- x\n  glue::glue('My name is {name}.')\n}\n\n\n\n\n\n\nNAMESPACE\nWhile developing my R package, I‚Äôll run devtools::load_all() and devtools::document() frequently, and each time the imported functions are available in the current session and the tags are converted into directives in the NAMESPACE file\nimport(package)\nimportFrom(package,function) \n\n\nDESCRIPTION\nA package DESCRIPTION file is managed completely independent of it‚Äôs NAMESPACE file. This can be confusing during package development, because it‚Äôs easy to assume some kind of connection between the roxygen2 tags, the NAMESPACE file, and the DESCRIPTION file:\n\nHowever, this is not the case:\n\nTo include glue in the DESCRIPTION under Imports, I also need to use usethis::use_package(\"glue\")\nAs noted in R packages, ‚ÄúThe Imports field [in the DESCRIPTION file] makes sure that the packages listed there are installed when your package is installed.‚Äù The DESCRIPTION file does not make functions available to the package developer (or the user).\n\n\nThe recommended practices for add-on packages are 1) use the namespace-qualified calls in the R/ scripts (i.e., package::function() with an accompanying @importFrom package function tag), and 2) list these packages in the DESCRIPTION file under Imports or Suggests to make sure a package is installed whenever your package is installed (i.e., with usethis::use_package(\"package\"))\nThe table below shows the connection between roxygen2 tags, the resulting NAMESPACE entry, and what should be listed in the DESCRIPTION (this is also covered in R packages)\n\n\n\n\n\n\n\n\nRefresher on roxygen2, NAMESPACE & DESCRPTION\n\n\n\n\n\n\n\n\n\n\n\nroxygen2 tag\n\n\nNAMESPACE directive\n\n\nDESCRIPTION\n\n\n\n\n\n\n@importFrom\n\n\nimportFrom() : import selected object from another namespace\n\n\nConsider listing under ‚ÄòSuggests‚Äô\n\n\n\n\n@import\n\n\nimport(): import all objects from another package‚Äôs namespace\n\n\nList under ‚ÄòImports‚Äô\n\n\n\n\n@export\n\n\nexport() : export the function, method, generic, or class so it‚Äôs available outside of the package (in the namespace)\n\n\nNothing to list"
  },
  {
    "objectID": "posts/box/index.html#how-box-is-different",
    "href": "posts/box/index.html#how-box-is-different",
    "title": "Writing modular code with box",
    "section": "How box is different",
    "text": "How box is different\nbox doesn‚Äôt require installing or attaching add-on packages. Instead, it uses modules to make package functions available. I‚Äôll demonstrate with a simplified example using the glue() package. Assume I have a project folder pkg/,\n\n\n\nshow/hide\npkg/\n  ‚îî‚îÄ‚îÄ pkg.Rproj\n\n1 directory, 1 file\n\n\n\n\nProjects in RStudio have a hidden folder, .Rproj.user/:\n\nThe the following contents are automatically created with a new .Rproj file:\n\n\n\ncontents of .Rproj\npkg/\n  ‚îú‚îÄ‚îÄ .Rproj.user\n  ‚îÇ      ‚îú‚îÄ‚îÄ 8CC5F70E\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ bibliography-index\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ ctx\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ explorer-cache\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ presentation\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ profiles-cache\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ sources\n  ‚îÇ      ‚îÇ      ‚îÇ      ‚îî‚îÄ‚îÄ session-16ca0811\n  ‚îÇ      ‚îÇ      ‚îÇ          ‚îî‚îÄ‚îÄ lock_file\n  ‚îÇ      ‚îÇ      ‚îú‚îÄ‚îÄ tutorial\n  ‚îÇ      ‚îÇ      ‚îî‚îÄ‚îÄ viewer-cache\n  ‚îÇ      ‚îî‚îÄ‚îÄ shared\n  ‚îÇ          ‚îî‚îÄ‚îÄ notebooks\n  ‚îÇ              ‚îî‚îÄ‚îÄ patch-chunk-names\n  ‚îî‚îÄ‚îÄ pkg.Rproj\n\n14 directories, 3 files\n\n\n\nNone of these contents deal with installing or loading packages, but I‚Äôve included it here for full transparency\n\n\n\nCreate a box module\nI‚Äôll put the modules in a box/fun.R file, which I‚Äôll create from the command-line:\n\n\n\nshow/hide\nmkdir box \ntouch box/fun.R\n\n\n\nNow my pkg folder looks like this:\n\n\n\nshow/hide\npkg/\n  ‚îú‚îÄ‚îÄ box\n  ‚îÇ    ‚îî‚îÄ‚îÄ fun.R\n  ‚îú‚îÄ‚îÄ pkg.Rproj\n  ‚îî‚îÄ‚îÄ use.R\n\n2 directories, 3 files\n\n\n\nIn pkg/box/fun.R I‚Äôll add the following:\n\na brief comment with the path to the module\nthe @export tag from roxygen2\na call to box::use(glue[glue])\n\n\n\n\nshow/hide\n# box/fun.R\n#' @export\nbox::use(\n  glue[glue]\n  )\n\n\n\nIn the parent folder, create another file named use.R.\nIn use.R, use the fun module by calling box::use(box/fun)\n\n\n\nshow/hide\nbox::use(box/fun)\n\n\n\nView fun by printing it to the console:\n\n\n\nshow/hide\n# print\nfun\n\n\n\n\nshow/hide\n&lt;module: box/fun&gt;\n\n\n\nThis confirms the module has been created.\n\n\nUsing modules\nThe glue function is available from fun using the $ (like a column in a data.frame or tibble)\n\n\n\nshow/hide\n# use \nx &lt;- \"module\"\nfun$glue('This is a box {x}.')\n\n\n\n\nshow/hide\nThis is a box module.\n\n\n\nbox modules are combinations of named folders and files, but unlike R packages, these folders and files can be nested. The folder/file structure is used for separating modules, the same way we might separate files in a project (i.e., project/data/file.csv and project/code/analysis.R)\n\nbox makes the function and package namespacing explicit by using box::use(package[fun])\nbox also simplifies using module by calling the same function when building/using modules box::use(folder/file):\n\n\n# CREATE MODULE\n# box/fun.R\n#' @export\nbox::use(\n  glue[glue]\n  )\n\n\n# USE MODULE\nbox::use(box/fun)\n\nBelow is a slightly more involved example:"
  },
  {
    "objectID": "posts/box/index.html#module-workflow",
    "href": "posts/box/index.html#module-workflow",
    "title": "Writing modular code with box",
    "section": "Module workflow",
    "text": "Module workflow\nBelow I‚Äôm going to create a module that imports, wrangles, and visualizes data from the palmerpenguins package. (which is installed, but not loaded).\n\nbox/import\nThis workflow starts with an import module in a pengbox project. The code below is stored in pengbox/box/import.R:\n\n\n\nimport module\n# box/import.R\nbox::use(\n  readr[read_csv],\n)\n#' @export\nget_raw_csv &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/3SQJ6E3\"\n  read_csv(raw_csv_url)\n}\n\n\n\nIn a the master pengbox/run.R file, I‚Äôll use import like so:\n\n\n\nshow/hide\n# import\nbox::use(box/import)\nstr(import$get_raw_csv(), give.attr = FALSE)\n\n\n\n\n\n\nshow/hide\nspc_tbl_ [344 √ó 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie\" ...\n $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \n $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \n $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 ...\n $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 ...\n $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 ...\n $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA ...\n\n\n\nI‚Äôll re-write this module in box/import.R using an alias for readrs read_csv() function (rcsv) and include the readr::cols() function to remove the lengthy message.\nThis code is stored in the box/import.R file:\n\n\n\nimport module with alias\n# box/import.R\nbox::use(\n  readr[rcsv = read_csv, cols]\n)\n#' @export\nraw &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/3SQJ6E3\"\n  # use alias for read_csv()\n  rcsv(raw_csv_url, col_types = cols())\n}\n\n\n\nUsing import with the new module is more concise:\n\n\n\nshow/hide\n# import\nbox::use(box/import)\nstr(import$raw(), give.attr = FALSE)\n\n\n\n\n\n\nshow/hide\nspc_tbl_ [344 √ó 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie\" ...\n $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \n $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \n $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 ...\n $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 ...\n $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 ...\n $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA ...\n\n\n\n\n\nbox/prep\nAfter importing the raw penguins data, I‚Äôll write a module for wrangling the data (that also imports the import module).\nThis module takes the following steps:\n\nReset the box.path\n\nImport the box/import module\n\nLoad all the functions from dplyr using [...]\n\nLoad aliases for stringr::str_extract() and janitor::clean_names()\n\nCompose prep() with the wrangling steps\n\n\n\n\nprep module with import\n# box/prep.R\n\n# reset the path\noptions(box.path = getwd())\n\n# import alias import module\nbox::use(box/import)\n\n# wrangle packages, functions, and aliases\nbox::use(\n  dplyr[...],\n  stringr[str_ext = str_extract],\n  janitor[fix_cols = clean_names]\n)\n\n#' @export\nprep = function() {\n  raw &lt;- import$raw()\n  clean_cols &lt;- fix_cols(raw)\n  vars &lt;- select(clean_cols, \n    species, \n    island, \n    bill_length_mm = culmen_length_mm,\n    bill_depth_mm = culmen_depth_mm,\n    flipper_length_mm,\n    body_mass_g,\n    sex)\n  mutate(vars, \n    species = str_ext(species, \"([[:alpha:]]+)\"),\n    sex = factor(sex))\n}\n\n\n\nWe can now the prep module to access the import module for the wrangled dataset.\n\n\n# prepare\nbox::use(box/prep)\npeng_clean &lt;- prep$prep()\nstr(peng_clean, give.attr = FALSE)\n\n\n\n\ntibble [344 √ó 7] (S3: tbl_df/tbl/data.frame)\n $ species          : chr [1:344] \"Adelie\" \"Adelie\" \"Adelie\" \"Adelie\" ...\n $ island           : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: num [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ sex              : Factor w/ 2 levels \"FEMALE\",\"MALE\": 2 1 1 NA 1 2 1 2 NA NA ...\n\n\nThese data look like they‚Äôre ready for graphing! Time to write another module‚Ä¶\n\n\nbox/plot\nI will build my visualization with ggplot2 (in the box/plot.R module) and dplyr::filter():\n\n\n\nplot module with prep\n# pengbox/plot.R\n\n# reset the path\noptions(box.path = getwd())\n\n# import prep module\nbox::use(box/prep)\n\n# import ggplot2\nbox::use(\n  dplyr[filter],\n  ggplot2 = ggplot2[ggplot, aes, geom_point, \n                    facet_wrap, labs, theme_minimal])\n\n#' @export\nscatter &lt;- function() {\n  prepped &lt;- prep$prep()\n  # remove missing sex\n  filtered &lt;- filter(prepped, !is.na(sex)) \n    # plot filtered data\n  plotted &lt;- ggplot2$ggplot(data = filtered, \n    ggplot2$aes(\n      x = flipper_length_mm,\n      y = body_mass_g,\n      group = sex\n    )\n  ) +\n    ggplot2$geom_point(\n      ggplot2$aes(color = island)\n    ) +\n    ggplot2$facet_wrap(. ~ sex) +\n    ggplot2$labs(x = \"Flipper Length (mm)\", y = \"Body Mass (g)\", \n      color = \"Island\", title = \"Flipper vs. Body Mass\", \n      subtitle = \"Palmer Penguins\") +\n    ggplot2$theme_minimal()\n  plotted\n}\n\n\n\nCheck our scatter plot with plot$scatter()\n\n\n\nshow/hide\n# plot\nbox::use(box/plot)\nplot$scatter()\n\n\n\n\n\n\n\n\nAnd there you have it! A complete pipeline using box modules! And the total project size (files and folders) is much smaller than building an R package:\n\n\n\nshow/hide\npengbox/\n    ‚îú‚îÄ‚îÄ box\n    ‚îÇ   ‚îú‚îÄ‚îÄ import.R\n    ‚îÇ   ‚îú‚îÄ‚îÄ plot.R\n    ‚îÇ   ‚îî‚îÄ‚îÄ prep.R\n    ‚îú‚îÄ‚îÄ penguins.Rproj\n    ‚îî‚îÄ‚îÄ run.R\n\n2 directories, 5 files\n\n\n\nBelow are the various ways to include packages and functions in box modules:\n\n\n\n\n\n\n\nOptions for creating box modules:\n\n\n\n\n\n\n\n\n\n\n\nInside box::use()\n\n\nAction\n\n\n\n\n\n\nbox::use( pkg )\n\n\nimports ‚Äòpkg‚Äô, does not attach any function names\n\n\n\n\nbox::use( p = pkg )\n\n\nimports ‚Äòpkg‚Äô with alias (‚Äòp‚Äô), does not attach any function names\n\n\n\n\nbox::use( pkg = pkg[foo, bar] )\n\n\nimports ‚Äòpkg‚Äô and attaches the function names ‚Äòpkg::foo()‚Äô and ‚Äòpkg::bar()‚Äô\n\n\n\n\nbox::use( pkg[my_foo = foo, ‚Ä¶] )\n\n\nimports ‚Äòpkg‚Äô with alias for ‚Äòfoo‚Äô (‚Äòmy_foo‚Äô) and attaches all exported function names"
  },
  {
    "objectID": "posts/box/index.html#nesting-modules",
    "href": "posts/box/index.html#nesting-modules",
    "title": "Writing modular code with box",
    "section": "Nesting modules",
    "text": "Nesting modules\nThe same workflow could be re-written as nested modules, with folders separating logical steps in an analysis workflow (or application). Consider the folder structure below:\n\n\n\nshow/hide\npengbox/\n    ‚îú‚îÄ‚îÄ box\n    ‚îÇ   ‚îî‚îÄ‚îÄ graph\n    ‚îÇ       ‚îú‚îÄ‚îÄ wrangle\n    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ clean\n    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import\n    ‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ raw.R\n    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cols.R\n    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ vars.R\n    ‚îÇ       ‚îî‚îÄ‚îÄ scatter.R\n    ‚îú‚îÄ‚îÄ penguins.Rproj\n    ‚îî‚îÄ‚îÄ run.R\n\n6 directories, 6 files\n\n\n\n\nimport\nWith this structure, the raw module is in the import folder:\n\n\n\nshow/hide\npengbox/box/graph/wrangle/clean/import\n                                    ‚îî‚îÄ‚îÄ raw.R\n\n1 directory, 1 file\n\n\n\n\nThe raw module‚Äìthe first step‚Äìis nested in the box/graph/wrangle/clean/import/raw.R file\n\nThe raw module imports the raw .csv data with an aliass for readr‚Äôs read_csv()\n\n\n\n\nraw module\n# box/graph/wrangle/clean/import/raw.R\nbox::use(\n  readr[rcsv = read_csv, cols]\n)\n#' @export\ncsv &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/3SQJ6E3\"\n  # use alias for read_csv()\n  rcsv(raw_csv_url, col_types = cols())\n}\n\n\n\n\n\nraw\n\nIn run.R, I run box/graph/wrangle/clean/import/raw to import the raw module\n\nThe csv() function imports the raw data\n\n\n\n\nshow/hide\n# in use.R\nbox::use(box/graph/wrangle/clean/import/raw)\nstr(raw$csv(), give.attr = FALSE)\n\n\n\n\n\n\nraw module output\nspc_tbl_ [344 √ó 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie\" ...\n $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \n $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \n $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 ...\n $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 ...\n $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 ...\n $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA ...\n\n\n\n\n\n\n\nclean\nThe clean folder contains the cols module and the snakes() function\n\n\n\nshow/hide\nbox/graph/wrangle/\n              ‚îú‚îÄ‚îÄ clean\n              ‚îÇ   ‚îú‚îÄ‚îÄ #import\n              ‚îÇ   ‚îÇ   #‚îî‚îÄ‚îÄ raw.R\n              ‚îÇ   ‚îî‚îÄ‚îÄ cols.R\n              ‚îî‚îÄ‚îÄ vars.R\n\n3 directories, 3 files\n\n\n\n\nsnakes\n\nThe box/graph/wrangle/clean/cols module standardizes the column names\n\ncols calls the snakes() function, which converts all the column names to lower_snake_case with an alias for janitor::clean_names(), then it imports select from dplyr to subset the columns\n\n\n\n\ncols module\n# box/graph/wrangle/clean/cols.R\n\n# reset the path\noptions(box.path = getwd())\n\n# use import raw module\nbox::use(box/graph/wrangle/clean/import/raw)\n\n# columns\nbox::use(\n  dplyr[select],\n  janitor[fix_cols = clean_names]\n)\n\n#' @export\nsnakes = function() {\n  raw &lt;- raw$csv()\n  clean_cols &lt;- fix_cols(raw)\n  vars &lt;- select(clean_cols, \n    species, \n    island, \n    bill_length_mm = culmen_length_mm,\n    bill_depth_mm = culmen_depth_mm,\n    flipper_length_mm,\n    body_mass_g,\n    sex)\n  return(vars)\n}\n\n\n\n\nBack in run.R, we call the cols module to convert the columns names with snakes():\n\n\n\n# clean columns\nbox::use(box/graph/wrangle/clean/cols)\nnames(cols$snakes())\n\n\n\n\n\ncols module output\n[1] \"species\"           \"island\"            \"bill_length_mm\"    \"bill_depth_mm\"                  \n[5] \"flipper_length_mm\" \"body_mass_g\"       \"sex\" \n\n\n\n\n\n\n\nwrangle\n\nNow that I have standardized columns and the subset of the variables to plot, I can call the vars module to wrangle the plot variables\n\n\n\n\nshow/hide\nbox/graph/wrangle/\n            ‚îú‚îÄ‚îÄ #clean\n            ‚îÇ   #‚îú‚îÄ‚îÄ #import\n            ‚îÇ   #‚îÇ   #‚îî‚îÄ‚îÄ raw.R\n            ‚îÇ   #‚îî‚îÄ‚îÄ cols.R\n            ‚îî‚îÄ‚îÄ vars.R\n\n3 directories, 3 files\n\n\n\n\nvars\n\nvars is nested in the wrangle folder, and imports the raw and cols modules\n\nThe vars module imports mutate and filter from dplyr and an alias for stringr::str_extract()\n\n\n\n\nvars module\n# box/graph/wrangle/vars.R\n\n# reset the path\noptions(box.path = getwd())\n\n# use clean names module\nbox::use(box/graph/wrangle/clean/cols)\n\n# wrangle packages/functions\nbox::use(dplyr[mutate, filter],\n  stringr[str_ext = str_extract])\n\n#' @export\nscatter = function() {\n  clean_cols &lt;- cols$snakes()\n  plot_vars &lt;- clean_cols |&gt;\n    mutate(\n      species = str_ext(species, \"([[:alpha:]]+)\"),\n      species = factor(species),\n      island = factor(island),\n      sex = factor(sex)\n    ) |&gt;\n    # remove missing sex\n    filter(!is.na(sex))\n  return(plot_vars)\n}\n\n\n\nIn run.R, we check the structure of the output from vars$scatter()\n\n\n\nshow/hide\n# in run.R\n# wrangle variables \nbox::use(box/graph/wrangle/vars)\nstr(vars$scatter())\n\n\n\n\n\n\nvars module output\ntibble [333 √ó 7] (S3: tbl_df/tbl/data.frame)                                                     \n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:333] 39.1 39.5 40.3 36.7 39.3 38.9 39.2 41.1 38.6 34.6 ...\n $ bill_depth_mm    : num [1:333] 18.7 17.4 18 19.3 20.6 17.8 19.6 17.6 21.2 21.1 ...\n $ flipper_length_mm: num [1:333] 181 186 195 193 190 181 195 182 191 198 ...\n $ body_mass_g      : num [1:333] 3750 3800 3250 3450 3650 ...\n $ sex              : Factor w/ 2 levels \"FEMALE\",\"MALE\": 2 1 1 1 2 1 2 1 2 2 ...\n\n\n\n\n\n\n\ngraph\nFinally, we get to the graph module. This module import all preceding modules.\n\n\nbox/\n‚îî‚îÄ‚îÄ graph\n    ‚îú‚îÄ‚îÄ #wrangle\n    ‚îÇ   #‚îú‚îÄ‚îÄ #clean\n    ‚îÇ   #‚îÇ   #‚îú‚îÄ‚îÄ #import\n    ‚îÇ   #‚îÇ   #‚îÇ   #‚îî‚îÄ‚îÄ raw.R\n    ‚îÇ   #‚îÇ   #‚îî‚îÄ‚îÄ cols.R\n    ‚îÇ   #‚îî‚îÄ‚îÄ vars.R\n    ‚îî‚îÄ‚îÄ scatter.R\n\n5 directories, 4 files\n\n\n\nscatter\n\nThe scatter module imports the vars module with the data that‚Äôs been imported, cleaned, and wrangled.\n\nThe ggp2() function includes the ggplot2 functions to build a scatter plot.\n\n\n\n\nscatter module\n# box/graph/scatter.R\n\n# reset the path\noptions(box.path = getwd())\n\n# import plot vars module\nbox::use(box/graph/wrangle/vars)\n\n# import ggplot2\nbox::use(\n  ggplot2 = ggplot2[ggplot, aes, geom_point, \n                    facet_wrap, labs, theme_minimal]\n)\n\n#' @export\nggp2 &lt;- function() {\n  scatter_vars &lt;- vars$scatter()\n  # plot prepped data\n  ggp2_plot &lt;- ggplot2$ggplot(data = scatter_vars, \n    ggplot2$aes(\n      x = flipper_length_mm,\n      y = bill_length_mm,\n      group = island\n    )\n  ) +\n    ggplot2$geom_point(\n      ggplot2$aes(color = species)\n    ) +\n    ggplot2$facet_wrap(. ~ island) +\n    ggplot2$labs(\n      x = \"Flipper Length (mm)\", \n      y = \"Bill length (mm)\", \n      color = \"Species\",\n      group = \"Island\",\n      title = \"Flipper vs. Bill Length\", \n      subtitle = \"Palmer Penguins\"\n    ) +\n    ggplot2$theme_minimal()\n  ggp2_plot\n}\n\n\n\nIn run.R, the final module call produces the plot.\n\n\n# graph\nbox::use(box/graph/scatter)\nscatter$ggp2()"
  },
  {
    "objectID": "posts/box/index.html#recap",
    "href": "posts/box/index.html#recap",
    "title": "Writing modular code with box",
    "section": "Recap",
    "text": "Recap\nIn this post I‚Äôve covered how the box package uses modules to separate your analysis and workflow into small, modular scripts. Nesting modules also adds a flexibility R packages do not have (because everything has to be contained in the R/ folder).\nBoth versions of the projects created in this example ended up with very few lines of code, and didn‚Äôt require a creating a NAMESPACE or DESCRIPTION file.\nView the final project here."
  },
  {
    "objectID": "posts/test-shiny-p1/index.html",
    "href": "posts/test-shiny-p1/index.html",
    "title": "Unit testing shiny utility functions",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(covr)\nThis post is the first in a series on testing shiny applications. I‚Äôll cover developing and testing a set of utility functions for a shiny app-package using testhat. If you‚Äôd like to follow along, all the code I‚Äôll be using is contained in the utap R package on GitHub.\n# renv::install(\"mjfrigaard/utap\")\nlibrary(utap)"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#shiny-app-packages",
    "href": "posts/test-shiny-p1/index.html#shiny-app-packages",
    "title": "Unit testing shiny utility functions",
    "section": "Shiny app-packages",
    "text": "Shiny app-packages\nTesting the code in shiny app-packages can be more complicated than testing the code in a typical R package, because app-packages contain two types of code:\n\nApplication code: functions designed to run the application (i.e., the ui and server functions, modules, standalone app functions will a call to shinyApp(), etc.)\nEverything else: functions or code used for connecting to databases, uploading, importing, or manipulating data, building visualizations and/or tables, generating custom HTML layouts, etc. The non-application code and functions in app-packages are typically referred to as ‚Äòutility‚Äô or ‚Äòhelper‚Äô functions\n\nThese two types of code require different types of tests. Utility functions are usually accompanied by unit tests similar to the tests you‚Äôd find in a standard R package, while application code is tested using the shiny::testServer() function, or with the shinytest2 package.\nThis post will cover writing unit tests for a set of utility functions using testthat and covr. Any tips or time-savers I‚Äôve found will be in green callout boxes:\n\n\n\n\n\n\nTIP!\n\n\n\n\n\n\nThis is a tip!"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#what-are-unit-tests",
    "href": "posts/test-shiny-p1/index.html#what-are-unit-tests",
    "title": "Unit testing shiny utility functions",
    "section": "What are unit tests?",
    "text": "What are unit tests?\n\n\n\n\n‚ÄúA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed. A unit test‚Äôs scope can span as little as a method or as much as multiple classes.‚Äù - The Art of Unit Testing, 2nd edition\n\nI‚Äôve found thinking of functions as ‚Äòunits of work‚Äô and their desired behavior as an ‚Äòend results‚Äô provides a useful mental model during TDD. These terms also align nicely with the testing advice offered by testthat:\n\nStrive to test each behaviour in one and only one test. Then if that behaviour later changes you only need to update a single test.\n\nIn app-packages, the testthat package provides a comprehensive and flexible framework for performing unit tests.\n\ntestthat\nGet started with testthat in your app-package by running usethis::use_testthat(). This function will create following files and folders:\ntests/\n  ‚îú‚îÄ‚îÄ testthat/\n  ‚îî‚îÄ‚îÄ testthat.R\nTo create new tests, run usethis::use_test(\"utils_fun\") (with \"utils_fun\" being the name of the function you‚Äôd like to test).\n\nusethis::use_test(\"utils_fun\")\n\n‚úî Setting active project to '/projects/apps/utap'\n‚úî Writing 'tests/testthat/test-utils_fun.R'\n‚Ä¢ Modify 'tests/testthat/test-utils_fun.R'\n\nTest files\nNew test files are be created and opened from the tests/testthat/ folder (with a test- prefix).\n\nThe initial contents of a new test file contains the boilerplate code below:\n\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n\n\n\n\n\n\n\nFigure¬†1: testthat test file\n\n\nTest files\n\n\nTest structure\ntest_that() sets the test ‚Äúscope‚Äù or ‚Äúexecution environment‚Äù, and encapsulates the expectations.\n\nNote the use of curly brackets after the code argument:\n\ntestthat::test_that(desc = \"description\", code = {\n\n})\n\n\n\n\n\n\n\nFigure¬†2: tests\n\n\ntestthat test\n\n\nExpectations\nTest expectations are the code that comes into direct contact with the unit of work and end result for each function. There are usually multiple expectations for any given function, so these are stored in tests (and the desc describes the test context for the set of expectations).\n\nAll testthat expectations have an expect_* prefix:\n\ntestthat::expect_equal(object = 2 * 2, expected = 4)\n\n\n\n\n\n\n\nFigure¬†3: expectations\n\n\ntestthat expectation\n\n\nUnit test development workflow\nI develop unit tests using the following workflow:\n\nCreate the test file and R script: I‚Äôll start by creating these files with usethis::use_r() and usethis::use_test(), even if I know the names of these files will likely change as I develop (see more below).\nDefine test context: I use the test context (entered as a character string in the first argument of testthat::test_that()) to capture each ‚Äúunit of work‚Äù for each function. I like to keep the test context short and sweet‚Äìthe ‚Äúunit of work‚Äù followed by ‚Äúworks‚Äù will suffice in most circumstances, unless there‚Äôs a need for more specific details.\nWrite expectations: These are the third item in the workflow, but conceptually these comes first‚Äìthese are the ‚Äúend results‚Äù I want from each function (i.e., compute a value, download a file, create a column, etc.).\n\nTests and expectations are grouped into test files based on their related objectives or goals, and should correspond to a similar .R file in the R/ folder.\nWhile this workflow is probably not technically considered test-driven development, I do set up the tests before I start writing any code in the R/ folder. This comes in handy if you‚Äôre having to remind yourself where you stopped developing on a given project‚ÄìI‚Äôll just run devtools::test() and the first failing test reminds me where to look.\n\n\n\n\n\n\nTIPS: Unit tests\n\n\n\n\n\n\nThe advice on unit tests below (in bold) comes from Effective Software Testing, 2022. I‚Äôve included descriptions of how testthat satisfies each recommendation:\n\nUnit tests should be fast: the text recommends unit tests take a ‚Äòcouple of milliseconds‚Äô to execute. testthat tests typically fall within this threshold (and provide time measurements to identify bottlenecks).\nUnit tests are easy to control: i.e., ‚Äòinput values and the expected result value are easy to adapt or modify in the test.‚Äô testthat expectations give us ample access to 1) the expected result and 2) the observed result.\nUnit tests are easy to write: i.e., ‚Äòdo not require a complicated setup or additional work‚Äô. When used combination with usethis, testthat unit tests can be set up, created, written, and run with a few lines of code:\n\nusethis::use_testthat()\n\nusethis::use_test()\n\n&lt; write test &gt;\n\ntestthat::test_file(), testthat::test_dir(), or devtools::test()"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#app-utility-functions",
    "href": "posts/test-shiny-p1/index.html#app-utility-functions",
    "title": "Unit testing shiny utility functions",
    "section": "App utility functions",
    "text": "App utility functions\nThe utility functions I‚Äôll be developing are designed to populate the choices argument for shiny::selectInput(). For example, the pull_numeric_cols() function would ‚Äòpull‚Äô the column names from an input data.frame or tibble (the example below uses palmerpenguins::penguins):\n\npull_numeric_cols(palmerpenguins::penguins)\n\n\n##      bill_length_mm       bill_depth_mm   flipper_length_mm \n##    \"bill_length_mm\"     \"bill_depth_mm\" \"flipper_length_mm\" \n##         body_mass_g                year \n##       \"body_mass_g\"              \"year\"\n\nThe return values would be passed to an updateSelectInput() in the server to provide column names by type (i.e., numeric, binary, or categorical). These functions can be used to quickly group variables into groups for data visualizations. For example, binary variables can be mapped the color aesthetic (if using ggplot2), and custom functions can be created for other graph layers (i.e., facets).\nThe unit of work for each hypothetical pull_[type]_cols() function would be, ‚Äúingest a data.frame or tibble and identify columns by type,‚Äù and their end result might be ‚Äúreturn a (named) vector of column names by type.‚Äù In this case, [type] refers to the variable type (i.e., numeric, categorical, binary, etc.). See the hypothetical UI output example below:\n\n# UI code\nshiny::selectInput(\n  inputId = ns(\"x\"),\n  label = \"X variable:\",\n  choices = NULL\n)\n\n\n# server code\nshiny::observe({\n  num_vars &lt;- pull_numeric_cols(df = data())\n  shiny::updateSelectInput(session,\n    inputId = \"x\",\n    choices = num_vars,\n    selected = num_vars[1])\n  }) |&gt;\n  shiny::bindEvent(data(),\n    ignoreNULL = TRUE)\n\nIn the example above, pull_numeric_cols() is passed a reactive dataset (data()), and the output is used to update the selectInput().\n\n\n\nX variable:\n\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nyear"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#micro-iteration",
    "href": "posts/test-shiny-p1/index.html#micro-iteration",
    "title": "Unit testing shiny utility functions",
    "section": "Micro-iteration",
    "text": "Micro-iteration\nIn R packages, micro-iteration is defined as, ‚Äúthe interactive phase where you initiate and refine a function and its tests in tandem.‚Äù If you‚Äôre using TDD, you‚Äôll write the test first, then write the function to pass the test.\nThe first unit test I‚Äôll create is for select_column_class(), a function designed to return columns according to their class().\n\nFunction names\nComing up with names for functions can be challenging. I like to follow the tidyverse style guide and use short verbs as a prefix (make_, get_, check_ etc.). I also like to use names that give ‚Äòfuture‚Äô me hints as to their behavior (i.e., select_column_class() imports and has similar behavior to dplyr::select(), while pull_[type]_cols() is more like dplyr::pull())\n\n\nCreate test file\nI create the test file and function file in the Console\n\nusethis::use_test(\"select_column_class\")\n\n‚úî Setting active project to '/projects/apps/utap'\n‚úî Writing 'tests/testthat/test-select_column_class.R'\n‚Ä¢ Modify 'tests/testthat/test-select_column_class.R'\n\nusethis::use_r(\"select_column_class\")\n\n‚Ä¢ Modify 'R/select_column_class.R'\n\n\nTest context\nThe test context (entered as a character string in the first argument of testthat::test_that()) includes the ‚Äúunit of work‚Äù for the function, followed by ‚Äúworks‚Äù:\n\ntestthat::test_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  \n})\n\nBefore I can start developing the select_column_class() function and it‚Äôs tests, I‚Äôll need data. R comes with example data objects in the datasets package, but it‚Äôs nice to have control over the data being used in your unit tests. I‚Äôll cover how to add test data available in your app-package.\n\n\nTest data\nCreating test data is covered in R packages, but I‚Äôll summarize the key points:\n\nTest data (and other objects) can either be created within a test, or as a persistent test fixture\n\nTest data fixtures should be stored in tests/testthat/fixtures/&lt;test_data.rds&gt;\nThe code used to create any test data fixtures should be stored in the same folder with a make_ prefix (i.e., tests/testthat/fixtures/&lt;make_test_data.R&gt;)\n\nThis is easier to picture with a demonstration: In the tests/testthat/ folder, I‚Äôll create a new fixtures folder, and add a make_testdata_col_class.R file.\ntests/testthat/\n        ‚îî‚îÄ‚îÄ fixtures/\n                ‚îî‚îÄ‚îÄ make_testdata_col_class.R\nIn make_testdata_col_class.R, I‚Äôll create testdata_col_class using the code below:\n\n\ntest_data for test-select_column_class.R\ntestdata_col_class &lt;- tibble::tibble(\n log_var = c(TRUE, FALSE, TRUE),\n int_var = c(1L, 2L, 3L),\n dbl_var = c(1.1, 2.2, 3.3),\n chr_var = c(\"item:1\", \"item:2\", \"item:3\"),\n fct_var = factor(\n   c(\"group 1\", \"group 2\", \"group 3\"),\n   levels = c(\n     \"group 1\", \"group 2\", \"group 3\")),\n ord_var = factor(\n   c(\"level 1\", \"level 2\", \"level 3\"),\n   levels = c(\"level 1\", \"level 2\", \"level 3\"),\n   ordered = TRUE),\n list_var = list(\n   log_vec = c(TRUE, FALSE),\n   dbl_vec = c(1.1, 2.2),\n   chr_var = c(\"item:1\", \"item:2\")))\n\n\n\ntestdata_col_class\n## # A tibble: 3 √ó 7\n##   log_var int_var dbl_var chr_var fct_var ord_var list_var  \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;   &lt;named li&gt;\n## 1 TRUE          1     1.1 item:1  group 1 level 1 &lt;lgl [2]&gt; \n## 2 FALSE         2     2.2 item:2  group 2 level 2 &lt;dbl [2]&gt; \n## 3 TRUE          3     3.3 item:3  group 3 level 3 &lt;chr [2]&gt;\n\nI‚Äôll save testdata_col_class in tests/testthat/fixtures/ as testdata_col_class.rds:\ntests/testthat/\n        ‚îî‚îÄ‚îÄ fixtures/\n                ‚îú‚îÄ‚îÄ make_testdata_col_class.R\n                ‚îî‚îÄ‚îÄ testdata_col_class.rds\nTo load the data into my test, I‚Äôll add the following to the top of the test context:\n\ntest_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  \n})\n\ntestthat::test_path() will load the data from the testing directory when I‚Äôm ready to run my test.\n\n\nExpectations\nIn expect_equal(), I‚Äôll verify the structure of the returned object is a data.frame/tibble.\n\ntest_that(\"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # check tibble\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"???\") |&gt;\n          tibble::is_tibble(),\n    expected = TRUE)\n})\n\nWriting my expectations first forces me to make some decisions about what the arguments will be for the select_column_class() function (i.e., df and class).\nselect_column_class() should return the columns according to their class, so I‚Äôll tests to verify the class of the return columns.\n\n  # check logical\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"log\") |&gt;\n          lapply(is.logical) |&gt; unlist() |&gt; unique(),\n    expected = TRUE)\n\nI try to write these in a way that‚Äôs flexible (should the test data change in the future).\n\n\n\n\n\n\nExpectation-Driven Development\n\n\n\n\n\nWhether or not you decide to adopt Test-Driven Development, I strongly recommend writing test expectations while you‚Äôre developing functions. It‚Äôs a great opportunity to clarify a function‚Äôs intended behaviors, arguments, and error/warning messages.\n\n\n\nAfter including tests for each class, I‚Äôll include a test for the error message from select_column_class() with testthat::expect_error():\n\n# test error type\ntestthat::test_that(\"select_column_class() type error\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # test type error\n  testthat::expect_error(\n    object = select_column_class(\n      df = testdata_col_class, \n      class = \"array\")\n  )\n})\n\nWhen I‚Äôve covered my intended ‚Äòend results‚Äô for select_column_class() (i.e., when it works and what happens when it doesn‚Äôt), I‚Äôll write the function:\n\n\nselect_column_class()\nselect_column_class &lt;- function(df, class) {\n\n  col_class &lt;- function(df, class) {\n    switch(class,\n      log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),\n      int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),\n      dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),\n      chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),\n      fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),\n      ord = dplyr::select(tibble::as_tibble(df), dplyr::where(is.ordered)),\n      list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list))\n    )\n  }\n\n  cl &lt;- unique(class)\n  cl_check &lt;- cl %nin% c(\"log\", \"int\", \"dbl\", \"chr\", \"fct\", \"ord\", \"list\")\n  if (any(cl_check)) {\n    cli::cli_abort(\"Invalid `class` argument. Must be one of:\\n\n          'log', 'int', 'dbl', 'chr', 'fct', 'ord', 'list'\")\n  }\n\n  col_list &lt;- purrr::map(.x = class, .f = col_class, df = df)\n\n  df_cols &lt;- purrr::list_cbind(col_list, size = nrow(df))\n\n  if (ncol(df_cols) &lt; 1 || nrow(df_cols) &lt; 1) {\n    df_cols &lt;- structure(list(),\n      class = c(\"tbl_df\", \"tbl\", \"data.frame\"),\n      row.names = integer(0),\n      names = character(0)\n    )\n    return(df_cols)\n  } else {\n    return(df_cols)\n  }\n}\n\n\n\nRecap: test data\nBelow is a summary of tips for adding data your tests.\n\n\n\n\n\n(a) Unit test fixtures\n\n\nFigure¬†4: Unit test fixtures"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#mezzo-iteration",
    "href": "posts/test-shiny-p1/index.html#mezzo-iteration",
    "title": "Unit testing shiny utility functions",
    "section": "Mezzo-iteration",
    "text": "Mezzo-iteration\nThe select_column_class() will return a tibble() with the columns matching the class argument, but I‚Äôll also need an argument that allows me to adjust the returned object to a named character vector.\nThat‚Äôs the job of get_column_class()‚Äìthis is a wrapper around select_column_class() with an additional return_tbl argument that, if FALSE, returns the column names as a named vector.\n\nAbstract syntax trees\nWhile developing R functions, I‚Äôve found the ast() function from the lobstr package can be great for keeping track of nested function calls.\nFor example, select_column_class() has a nested col_class() function that isn‚Äôt tested directly. So how do I make sure I‚Äôm keeping track of these nested functions in case they throw an error? I‚Äôll build an abstract function tree for the function in the documentation.\nBelow is the abstract syntax tree for select_column_class():\n\n\n‚ñà‚îÄselect_column_class \n‚îî‚îÄ‚ñà‚îÄcol_class \n\n\nThe tree above is simple‚Äìit only has two functions so far‚Äìbut as packages grow these abstract displays become more important for tracking function calls (and tests!).\n\n\nCombining tests\nget_column_class() calls select_column_class(), so I‚Äôll place both unit tests in the tests/testthat/test-column_classes.R file, and create the corresponding R/column_classes.R file\nTo capture these nested functions visually, I‚Äôll include a function tree in a vignette or other source documentation.\n\n\n‚ñà‚îÄget_column_class \n‚îî‚îÄ‚ñà‚îÄselect_column_class \n  ‚îî‚îÄ‚ñà‚îÄcol_class \n\n\nI‚Äôve combined select_column_class() and get_column_class() into a single file because I know every pull_[type]_cols() function would use get_column_class(). The following function tree captures this relationship.\n\n\n‚ñà‚îÄget_column_class \n‚îú‚îÄ‚ñà‚îÄselect_column_class \n‚îÇ ‚îî‚îÄ‚ñà‚îÄcol_class \n‚îú‚îÄ‚ñà‚îÄpull_binary_cols \n‚îú‚îÄ‚ñà‚îÄpull_facet_cols \n‚îú‚îÄ‚ñà‚îÄpull_cat_cols \n‚îî‚îÄ‚ñà‚îÄpull_numeric_cols \n\n\n\n\n\n\n\n\nFunction file names\n\n\n\n\n\nIn shiny app-packages, it‚Äôs common to combine related functions (i.e., function families) into a single .R file with a prefix.\nFor example, a standalone app function combines the code that would otherwise sit in ui.R and server.R.\n\nmyApp &lt;- function() {\n  shiny::shinyApp(ui = \n      shiny::tagList(\n        # code from ui.R\n      ),\n      server = # code from server.R\n    )\n}\n\nOther files that are automatically run with a standard shiny app (i.e., global.R or helpers.R files that used to load data, set themes/colors, etc.,) can be converted into functions and/or package files based on their purpose. For more information on organizing your R/ folder, read this section in R Packages.\nAlso check out golem::add_utils() and golem::add_fct() for creating function files specific to shiny modules.\n\n\n\nIn the test-column_classes.R test file, I‚Äôll need more data for testing, but rather than create test data files for each test, I‚Äôll use test helpers to create the test data.\n\n\nTest helpers\nTest helpers are stored in tests/testthat/helper.R and usually contain functions or code that 1) is too long to repeat with each test, and 2) doesn‚Äôt take too much time or memory to run. Read more about test helpers here.\nI‚Äôve created a set of test helpers in utap for creating different kinds of test data (because I‚Äôll be repeatedly defining columns with slightly different attributes).\nFor example, col_maker() can be used to create a tibble with columns based on the col_type, size, and missing:\n\ncol_maker(col_type = c(\"log\", \"int\", \"dbl\", \n                       \"chr\", \"fct\", \"ord\"),\n          size = 6,\n          missing = TRUE)\n## # A tibble: 6 √ó 6\n##   log_var int_var dbl_var chr_var fct_var ord_var\n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;  \n## 1 TRUE          1     0.1 item:1  group 1 level 1\n## 2 FALSE       135     3   item:2  group 2 level 2\n## 3 NA          269    NA   item:3  group 3 level 3\n## 4 TRUE        403     0.1 &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n## 5 FALSE        NA     3   item:1  group 1 level 1\n## 6 NA            1    NA   item:1  group 2 level 2\n\nI can also create tibbles with custom columns using individual helper _maker() functions:\n\ntibble::tibble(\n    log_var = log_maker(size = 2),\n    int_var = int_maker(size = 2),\n    dbl_var = dbl_maker(size = 2),\n    chr_var = chr_maker(size = 2),\n    list_var = list(fct_var = fct_maker(size = 3), \n                    ord_var = ord_maker(size = 3)),\n)\n## # A tibble: 2 √ó 5\n##   log_var int_var dbl_var chr_var list_var    \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;named list&gt;\n## 1 TRUE          1     0.1 item: 1 &lt;fct [3]&gt;   \n## 2 FALSE         7     1   item: 2 &lt;ord [3]&gt;\n\nThese helpers make it easier to iterate through the test expectations and function development, because tibbles like the one above can be developed inside each test.\n\nBelow is an example for testing if get_column_class() will correctly identify the logical columns (for both return objects):\n\n\nusing test helpers\ntestthat::test_that(\"get_column_class() logical\", {\n  # test logical class\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n      class = \"log\") |&gt;\n      unlist() |&gt;\n      is.logical(),\n    expected = TRUE\n  )\n  # test logical names\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n     class = \"log\",\n      return_tbl = FALSE\n    ),\n    expected = c(log_var = \"log_var\")\n  )\n})\n\n\n\nWhen I‚Äôm confident with the get_column_class() function and it‚Äôs tests, I‚Äôll save the test file and run testthat::test_file().\n\n\nshow/hide get_column_class()\nget_column_class &lt;- function(df, class, return_tbl = TRUE) {\n  if (isFALSE(return_tbl)) {\n    col_types_df &lt;- select_column_class(df, class = class)\n    nms &lt;- names(col_types_df)\n    col_types &lt;- purrr::set_names(nms)\n  } else {\n    col_types &lt;- select_column_class(df, class = class)\n  }\n  return(col_types)\n}\n\n\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 23 ]\n\n\nTest coverage\nHow many tests should I write?\nAs function behavior grows in complexity, so does the number of expectations. In testthat, expectations are captured in tests, and code coverage measures the extent to which the tests in the tests/testthat/ folder cover the possible execution paths of the functions in the R/ folder (i.e.¬†the package codebase).\nCode test coverage is a way to confirm that the unit tests are robust enough to verify that your code behaves as expected. In R packages, code coverage is discussed in the testing chapter using the covr package.\n\n\nCheck coverage interactively\nDuring development, check the code coverage of a test file with devtools::test_coverage_active_file(), or, if this function is being temperamental, use the combination of functions below from covr:\n\ncovr::file_coverage(\n  source_files = \"R/column_classes.R\", \n  test_files = \"tests/testthat/test-column_classes.R\") |&gt;\n  covr::report()\n\nBelow is the output in the Viewer when devtools::test_coverage_active_file() is entered in the Console:\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigure¬†5: Unit test coverage interactively\n\n\n\nI can see from the output I don‚Äôt have test coverage for the select_column_class() behavior when the class argument doesn‚Äôt return any columns from df. The function is designed to return an empty tibble if this occurs:\n\n\n\n\n\n(a) Behavior not tested in select_column_class()\n\n\nFigure¬†6: The area in red is the untested portion of select_column_class()\n\n\nTo test this behavior, I‚Äôll write two expectations:\n\nThe first expectation (expect_s3_class()) checks the class of the return object from select_column_class():\n\n  # test class of empty tibble\n  testthat::expect_s3_class(\n    object = select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\"),\n    class = c(\"tbl_df\", \"tbl\", \"data.frame\"))\n\nThe second expectation verifies there are zero columns in this return tibble:\n\n  # test rows of empty tibble\n  testthat::expect_equal(\n    object = ncol(select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\")),\n    expected = 0L)\n\n\nAfter adding these tests to the test-column_classes.R test file, I‚Äôll run testthat::test_file() and devtools::test_coverage_active_file() again:\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 25 ]\n\ndevtools::test_coverage_active_file()\n\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigure¬†7: Complete code coverage for column_classes.R\n\n\n\n100% is great, but uncommon. Striving for a high percentage of coverage is a good practice, it doesn‚Äôt guarantee that the function always behaves as expected. Unit tests might execute a line of code, but still not catch a bug due to the design of the test (it‚Äôs easy to have high coverage if the unit tests are shallow and don‚Äôt check for any potential edge cases).\nI‚Äôll address code coverage again in the next section, but checking coverage regularly will help ensure function behaviors don‚Äôt go overlooked."
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#macro-iteration",
    "href": "posts/test-shiny-p1/index.html#macro-iteration",
    "title": "Unit testing shiny utility functions",
    "section": "Macro-iteration",
    "text": "Macro-iteration\nAfter developing the functions in utap, the files in the R/ folder are organized into names based on the ‚Äòmain function and its supporting helpers‚Äô:\nR/\n‚îú‚îÄ‚îÄ column_classes.R\n‚îú‚îÄ‚îÄ pull_binary_cols.R\n‚îú‚îÄ‚îÄ pull_cat_cols.R\n‚îú‚îÄ‚îÄ pull_facet_cols.R\n‚îú‚îÄ‚îÄ pull_numeric_cols.R\n‚îî‚îÄ‚îÄ utils.R\n\nTest file organization\nThe tests/testthat/ folder file names have identical names as the files in the R/ folder.\ntests/testthat/\n        ‚îú‚îÄ‚îÄ test-column_classes.R\n        ‚îú‚îÄ‚îÄ test-pull_binary_cols.R\n        ‚îú‚îÄ‚îÄ test-pull_cat_cols.R\n        ‚îú‚îÄ‚îÄ test-pull_facet_cols.R\n        ‚îú‚îÄ‚îÄ test-pull_numeric_cols.R\n        ‚îî‚îÄ‚îÄ test-utils.R\n\nR/utils.R\nIt‚Äôs common for R packages to have a general R/utils.R file that defines the ‚Äòutility‚Äô functions. This practice isn‚Äôt discouraged in R Packages, but these files can become a catch-all for any functions that don‚Äôt have a clear home (read more here).\nI‚Äôve only stored the %nin% operator in R/utils.R, and it‚Äôs test is shown below:\n\ntestthat::test_that(\"%nin% works\", {\n  testthat::expect_false(\n    object = \"A\" %nin% LETTERS)\n  testthat::expect_false(\n    object = 1 %nin% 1:10)\n  testthat::expect_true(\n    object = 1 %nin% 2:10)\n})\n\n\n\n\nTest package\nWhen I‚Äôve completed a set of test files, I can use devtools::test() to check if they‚Äôre passing.\n\ndevtools::test()\n\n‚Ñπ Testing utap\n‚úî | F W S  OK | Context\n‚úî |        25 | column_classes                                                     \n‚úî |        29 | pull_binary_cols                                                   \n‚úî |         4 | pull_cat_cols                                                      \n‚úî |        20 | pull_facet_cols                                                    \n‚úî |         5 | pull_numeric_cols                                                  \n‚úî |         3 | utils                                                              \n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 2.1 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 86 ]\n\nüéØ Your tests hit the mark üéØ\nThe output above shows all tests are passing (and some helpful words of encouragement). As you can see, the number of tests correspond to the number of functions in each test file.\nFor example, pull_binary_cols() and pull_facet_cols() required additional internal functions to define their use:\n\n\n‚ñà‚îÄpull_binary_cols \n‚îú‚îÄ‚ñà‚îÄcheck_binary_vec \n‚îÇ ‚îú‚îÄ‚ñà‚îÄcheck_log_binary \n‚îÇ ‚îú‚îÄ‚ñà‚îÄcheck_int_binary \n‚îÇ ‚îî‚îÄ‚ñà‚îÄcheck_fct_binary \n‚îî‚îÄ‚ñà‚îÄmake_binary_vec \n\n\n‚ñà‚îÄpull_facet_cols \n‚îú‚îÄ‚ñà‚îÄcheck_facet_vec \n‚îÇ ‚îú‚îÄ‚ñà‚îÄcheck_chr_facet \n‚îÇ ‚îî‚îÄ‚ñà‚îÄcheck_fct_facet \n‚îî‚îÄ‚ñà‚îÄmake_facet_vec \n\n\nWheras pull_cat_cols() and pull_numeric_cols() map onto existing classes:\n\n\n‚ñà‚îÄpull_cat_cols \n‚îú‚îÄ‚ñà‚îÄis.factor \n‚îî‚îÄ‚ñà‚îÄis.character \n\n\n‚ñà‚îÄpull_numeric_cols \n‚îú‚îÄ‚ñà‚îÄis.integer \n‚îî‚îÄ‚ñà‚îÄis.double \n\n\n\n\nCheck coverage on build/install\nTo check the code coverage for the utap package, I can run devtools::test_coverage() to view the output in the Viewer.\n\ndevtools::test_coverage()\n\n‚Ñπ Computing test coverage for utap\n\n\n\n\n\n\n(a) Final test coverage for utap package\n\n\nFigure¬†8: devtools::test_coverage()\n\n\n\nClicking on any of the Files will open the Source tab and give a summary like the one above from devtools::test_coverage_active_file(). I can also use covr::package_coverage() in the Console for simpler output:\nutap Coverage: 100.00%\nR/column_classes.R: 100.00%\nR/pull_binary_cols.R: 100.00%\nR/pull_cat_cols.R: 100.00%\nR/pull_facet_cols.R: 100.00%\nR/pull_numeric_cols.R: 100.00%\nR/utils.R: 100.00%\n\nOther metrics\nSometimes it‚Äôs interesting to view the relationship between function size and number of tests using the cloc package..\n\nlibrary(cloc)\n\ncloc stands for Count Lines of Code, and it‚Äôs a rough metric used to gauge code complexity. It‚Äôs simple, but apparently provides ‚Äújust as much predictive power as more elaborate constructs like cyclomatic complexity.‚Äùsource\nBelow is a count of the lines of code in each file in the R folder:\n\ncloc::cloc_by_file(\"R\")\n\n# A tibble: 8 √ó 6\n  source filename                language   loc blank_lines comment_lines\n  &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;    &lt;int&gt;       &lt;int&gt;         &lt;int&gt;\n1 R      \"R/pull_binary_cols.R\"  R           53           2            57\n2 R      \"R/pull_facet_cols.R\"   R           42           2            73\n3 R      \"R/column_classes.R\"    R           41           6            65\n4 R      \"R/pull_numeric_cols.R\" R           19           1            24\n5 R      \"R/pull_cat_cols.R\"     R           13           0            19\n6 R      \"R/utils.R\"             R            3           0             7\n7 R      \"R/utap-package.R\"      R            2           0             7\n8 R      \"\"                      SUM        173          11           252\nThis output also confirms the relationship between lines of code and tests."
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#recap",
    "href": "posts/test-shiny-p1/index.html#recap",
    "title": "Unit testing shiny utility functions",
    "section": "Recap",
    "text": "Recap\nThis post has been an introduction to unit testing utility functions in a shiny app-package. When I‚Äôm confident the utility functions are working, I‚Äôll start adding them into modules (and testing with testServer() or shinytest2). Files names can change a lot throughout the course of developing a shiny app-package, so it‚Äôs helpful to adopt (or create) a naming convention.\nIf you‚Äôre using the golem framework to develop your shiny app-package, the utils_ and fct_ prefixes are used to define two different types of utility/helper functions:\n\nutils_ files contain ‚Äòsmall helper functions and‚Äôtop-level functions defining your user interface and your server function‚Äô\nfct_ files contain ‚Äòthe business logic, which are potentially large functions‚Ä¶the backbone of the application and may not be specific to a given module‚Äô.\n\nThis particular file naming convention isn‚Äôt required, but as with most conventions, it‚Äôs better when someone else comes up with the standard (and I just have to adopt and implement it). And having and sticking to a naming convention is typically more important than the convention itself."
  },
  {
    "objectID": "posts/debugging/index.html",
    "href": "posts/debugging/index.html",
    "title": "Debugging in RStudio",
    "section": "",
    "text": "In this post I‚Äôll cover using the browser() function with RStudio‚Äôs debugger. RStudio‚Äôs debugging tools are built into the IDE, which provides a seamless transition between writing, running, and debugging code."
  },
  {
    "objectID": "posts/debugging/index.html#getting-started",
    "href": "posts/debugging/index.html#getting-started",
    "title": "Debugging in RStudio",
    "section": "Getting started",
    "text": "Getting started\nI want to create a function that returns a table of ‚Äòdata structure‚Äô columns that describe the available data.frame or tibble objects loaded with a package. Below is a small example of the desired return object from this function:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nDataset\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\ndplyr\nstarwars\ntbl_df, tbl, data.frame\n13\n19066\n0\n11\n1\n1\n0\n\n\ndatasets\nmtcars\ndata.frame\n11\n32\n0\n11\n0\n0\n0\n\n\n\n\n\n\nThis table shows the storms data from dplyr and the mtcars data from datasets. The columns include the Package the data came from, the dataset name (Dataset), the data Title from the documentation, the Class of the data object, the total number of Columns and Rows, and the number of columns by type (Logical, Numeric, Character, Factor and List).\nOne of the first steps for creating this function is to verify a package‚Äôs namespace is loaded. I‚Äôve written the check_pkg_ns() to check this.\n\n\ncheck_pkg_ns()\ncheck_pkg_ns &lt;- function(pkg, quiet = FALSE) {\n  if (isFALSE(quiet)) {\n    # with messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = FALSE)) {\n        cat(paste0(\"Loading package: \", pkg, \"\\n\"))\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    } else {\n      cat(paste0(\"Package \", pkg, \" loaded\\n\"))\n    }\n  } else {\n    # without messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = TRUE)) {\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    }\n  }\n}\n\n\ncheck_pkg_ns() checks if a packages‚Äôs namespace is loaded, and if not, loads it. This function assumes the package (pkg) has been installed with install.packages() (I‚Äôve also written check_pkg_inst() to check if the package has been installed.)\n\nExperiment\nBefore debugging, I‚Äôll read the documentation and help files to find examples or use cases for ‚Äòmini-experiments.‚Äô These are designed to clarify any function arguments and learn how the code truly works. Experiments should produce predictable, definitive (preferably incompatible) outputs from each function.\n\nNamespace functions\nThe help file contains the following helpful statement on isNamespaceLoaded():\n\n‚ÄúisNamespaceLoaded(pkg) is equivalent to but more efficient than pkg %in% loadedNamespaces()‚Äù\n\nFirst, I‚Äôll check the loaded namespaces with loadedNamespaces(), then look for a package I know isn‚Äôt in the namespace with isNamespaceLoaded(). I‚Äôll use the fs package because it isn‚Äôt loaded or attached to the search() list:\n\n# what's in the namespace? \nloadedNamespaces()\n\n [1] \"compiler\"   \"rsconnect\"  \"graphics\"  \n [4] \"tools\"      \"rstudioapi\" \"utils\"     \n [7] \"grDevices\"  \"stats\"      \"datasets\"  \n[10] \"methods\"    \"base\"\nCheck if fs is in the loaded namespace:\n\n# verify fs is not loaded\nisNamespaceLoaded(\"fs\")\n\n[1] FALSE\nThe help file tells me the following about requireNamespace:\n\n‚ÄúrequireNamespace is a wrapper for loadNamespace analogous to require() that returns a logical value.‚Äù\n\n‚Ä¶and‚Ä¶\n\n‚ÄúrequireNamespace returns TRUE if it succeeds or FALSE‚Äù\n\nI‚Äôll load a package (\"fs\") with requireNamespace() and verify it‚Äôs in the namespace with isNamespaceLoaded().\n\n# add \"fs\" to the namespace\nrequireNamespace(\"fs\")\n\nLoading required namespace: fs\n[1] TRUE\n\n# verify it's been added \nisNamespaceLoaded(\"fs\")\n\n[1] TRUE\nFinally, I‚Äôll unload the \"fs\" package from the namespace so it can be tested in the debugger.\n\n# remove fs\nunloadNamespace(\"fs\")\n# verify fs has been unloaded\nisNamespaceLoaded(\"fs\")\n\n[1] FALSE\nThe great thing about designing these mini experiments is that they can be quickly converted into testthat tests. I‚Äôm now confident I can use the namespace functions to:\n\nView loaded packages namespaces\n\nCheck for a specific package in the loaded namespaces\n\nRequire a package namespace is loaded\n\nRemove a loaded package namespace\n\nThese are the behaviors I want to confirm in check_pkg_ns() using the browser() function."
  },
  {
    "objectID": "posts/debugging/index.html#browser",
    "href": "posts/debugging/index.html#browser",
    "title": "Debugging in RStudio",
    "section": "browser()",
    "text": "browser()\nIf I want to explore the behaviors of the namespace functions in check_pkg_ns(), I need to add browser() somewhere I can ‚Äòstep into‚Äô this function and then proceed through line-by-line. In this case, the top of the function makes sense:\n\n\n\n\n\n(a) browser() in check_pkg_ns()\n\n\nFigure¬†1: browser() placement in check_pkg_ns()\n\n\n\nDebug mode\nTo enter debugging mode, I‚Äôll need to run check_pkg_ns() or source R/check_pkg_ns.R with the package I used in my experiments.\n\ncheck_pkg_ns(\"fs\")\n\n\n\n\n\n\n\n(a) Debug mode\n\n\nFigure¬†2: RStudio IDE in debug mode\n\n\n\nThe browser() function is one of the multiple methods for using RStudio debugging tools (see the TIP callout box below for more).\n\n\n\n\n\n\nTIP: Other debugging methods\n\n\n\n\n\n\nIn this post, I focused on using the browser() function to enter debug mode, but RStudio has several built-in tools that can help you debug your R code:\n\nDebug function on error: You can set R to automatically enter the debugger when an error occurs by using options(error = utils::recover). Then, when an error occurs, you‚Äôll be given a menu of places to browse, the most recent (the location where the error occurred) first.\nBreakpoints: Breakpoints can be set in your R scripts to pause execution at a particular line of code. You can add breakpoints by clicking to the left of the line number in the script editor or by pressing Shift+F9 with your cursor on the desired line. Then, run your code. Execution will stop just before the line with the breakpoint, allowing you to inspect the current state of the environment.\ndebug(): You can use debug(function_name) to flag a function for ‚Äúdebug‚Äù mode. When you call the function, the debugger will open and stop at the first line of the function, where you can step through the function line by line, inspect the environment, and see what‚Äôs happening at each step.\ntraceback(): When an error occurs, you can call traceback() to get a stack trace that shows you the sequence of calls that led up to the error.\nCode Diagnostics: RStudio provides real-time notifications about potential issues in your code, like syntax errors or unused variables. These are not technically part of the debugger, but diagnostics will help you avoid bugs before you run your code.\n\nYou should read this blog post and this chapter of Advanced R, 2nd Ed. for more information on the various debugging methods.\n\n\n\n\n\n\nConsole\nWhen the browser() function is called, the Console enters the ‚Äòreactive browser environment,‚Äô tells me where the debugging function was called from, and changes the prompt to Browse[1]&gt;:\nCalled from: check_pkg_ns(\"fs\")\nBrowse[1]&gt; \nI can use the Console to inspect variables and ‚Äòstep through‚Äô the function code.\n\n\n\n\n\n\n(a) Debug mode in Console\n\n\nFigure¬†3: Debug mode with browser() in Console\n\n\n\nThe debugger toolbar is also placed at the top of the Console:\n\n\n\n\n\n(a) Debug toolbar Console\n\n\nFigure¬†4: Debug toolbar in Console\n\n\nI can use the toolbar or enter the following commands in the Console:\n\nn (next): execute the next step in the function\ns (step into): step into the function call on the current line\nc (continue): continue normal execution without stepping\nf (finish): execute the rest of the current loop or function\nQ (Quit): quit the debugger\n\nI‚Äôll return to the Console in a bit (this is where most of the debugging is done), but let‚Äôs view the other changes to the IDE first.\n\n\nSource\nIn the Source pane, we can see the line with browser() has been highlighted with an arrow:\n\n\n\n\n\n\n(a) Debug mode in Source\n\n\nFigure¬†5: Debug mode with browser() in Source\n\n\n\nThe Source pane will continually update and highlight my execution position (i.e., what‚Äôs going to be executed next) as I ‚Äòstep through‚Äô the code.\n*After we‚Äôve finished debugging, it‚Äôs important to remember to remove the browser() function so it isn‚Äôt triggered the next time it is executed.\n\n\nEnvironment\nThe (Environment) pane is changed from the global environment to the environment of the function that‚Äôs currently being executed in the Console:\n\n\n\n\n\n\n(a) Debug mode in Environment\n\n\nFigure¬†6: Debug mode with browser() in Environment\n\n\n\nIn the case of check_pkg_ns(), I can see the Values section contains the pkg (\"fs\") and quiet (FALSE) arguments.\n\nOther environments\nThe drop-down list of environments above the Values is arranged in reverse hierarchical order: The Global Environment is listed under the drop-down list, but it‚Äôs above the check_pkg_ns() environment in the search path:\n\n\n\n\n\n\n\n\n(a) Items in Environment debug mode\n\n\n\n\n\n\n\n(b) Package environments and the search path\n\n\n\n\nFigure¬†7: Environments with debugger\n\n\n\n\n\nTraceback\nThe traceback (or ‚Äòcall stack‚Äô) is the ‚Äòstack‚Äô of functions that have been run thus far:\n\n\n\n\n\n(a) Traceback in Environment\n\n\nFigure¬†8: Environment Traceback viewer\n\n\nClicking on an item in traceback will display the environment contents in the function‚Äôs code. Right now, it includes the call to source(\"R/check_pkg_ns.R\"), and ‚ÄòDebug source‚Äô call to check_pkg_ns(\"fs\").\nIf the Show internals option is selected, the internal functions are shown (slightly subdued in gray).\n\n\n\n\n\n(a) Traceback internals\n\n\nFigure¬†9: Traceback internals\n\n\n\n\n\nArguments\nThe pkg argument can be printed to verify it‚Äôs contents.\nBrowse[1]&gt; pkg\n[1] \"fs\"\nThe debugger lets me view the state of a function‚Äôs values or variables at each execution step, which helps me understand any incorrect or unexpected values.\nBased on the help files and my experiments, check_pkg_ns() should be looking through the namespace to see if a pkg is loaded; if it isn‚Äôt, that pkg is loaded in the namespace.\nI can also check the code from the mini experiments inside the debugger Console to see if the fs namespace has been loaded:\nBrowse[1]&gt; isNamespaceLoaded(\"fs\")\n[1] FALSE\nAt my current location in check_pkg_ns(), the fs package hasn‚Äôt been loaded.\n\n\nStepping through\nI can begin ‚Äòstepping through‚Äô check_pkg_ns() by entering n in the Console:\nBrowse[1]&gt; n\nNotice after the entering n in the Console, the debugger tells me where the browser() function has paused execution (debug at /path/to/function/file.R), the line number (#27), and the check_pkg_ns() function is printed to console (I‚Äôve omitted it here):\nBrowse[1]&gt; n\ndebug at ~/projects/apps/dbap/R/check_pkg_ns.R#27:\n\n&lt;...check_pkg_ns() function...&gt;\n\nBrowse[2]&gt;\nThe prompt also changes from Browse[1]&gt; to Browse[2]&gt; to let me know I‚Äôm inside the check_pkg_ns() function.\nI‚Äôll use n (or Next) to continue following the path pkg takes through the function:\n\n\n\n\n\n\n(a) Use Console to step through function\n\n\nFigure¬†10: Use n to step through check_pkg_ns()\n\n\n\nWhen I land on the line after the call to requireNamespace(), I can check to see if the fs namespace has been loaded with isNamespaceLoaded(\"fs\")\nBrowse[2]&gt; isNamespaceLoaded(\"fs\")\n[1] TRUE\n\n\nInspect values\nNow that I‚Äôve confirmed check_pkg_ns() works with fs, I should also confirm it works with a development package (i.e., not on CRAN). I can test this with the roxygen2Comment package‚Äìit contains an addin for pasting roxygen2 comment blocks.\nTo quit debug mode, I can enter Q in the Console or click on the red square (Stop) icon in the toolbar.\nBrowse[2]&gt; Q\nI‚Äôll confirm roxygen2Comment is not loaded with isNamespaceLoaded(), then change the pkg argument in check_pkg_ns() and re-run the function\nisNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\n&gt; check_pkg_ns(\"roxygen2Comment\")\nCalled from: check_pkg_ns(\"roxygen2Comment\")\nBrowse[1]&gt; \nThis time, when I step through check_pkg_ns(), I notice pkg takes an alternative path:\n\n\n\n\n\n\n(a) Alternative path through function\n\n\nFigure¬†11: Development package in check_pkg_ns()\n\n\n\nWhen the Source pane highlights the stop() function, I can check to confirm this package wasn‚Äôt loaded:\nBrowse[2]&gt; isNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\nIf I enter n one more time in the Console, I see the stop() error from the function is returned:\nBrowse[2]&gt; n\nError in check_pkg_ns(\"roxygen2Comment\") : \n  roxygen2Comment not available\nI‚Äôll perform one last check on check_pkg_ns(): what if I want to pass multiple packages to pkg? I‚Äôll check this with fs and box.\n\n# First make sure these aren't loaded...\nunloadNamespace(\"fs\")\nunloadNamespace(\"box\")\n# Now combine into vector\npkgs &lt;- c(\"fs\", \"box\")\ncheck_pkg_ns(pkgs)\n\nAfter entering debug mode, I want to proceed to the control flow and verify the pkgs variable:\n&gt; check_pkg_ns(pkgs)\nCalled from: check_pkg_ns(pkgs)\nBrowse[1]&gt; n\nBrowse[2]&gt; pkgs\n[1] \"fs\"  \"box\"\nThis confirms both packages are in the pkg variable. If I use n to proceed through to end of check_pkg_ns(), I see the final line returns the successful loading message twice:\nBrowse[2]&gt; n\nLoading package: fs\nLoading package: box\n\n\nbrowser() recap\nOnce execution is paused with browser(), using the n command in the Console (or in the debugging toolbar at the top-right of the pane) lets me step through the code line-by-line.\n\n\n\n\n\n(a) Step through/over\n\n\nFigure¬†12: Step through/over code\n\n\nThis allows me to inspect the state of the variables at various points within a function."
  },
  {
    "objectID": "posts/debugging/index.html#nested-functions",
    "href": "posts/debugging/index.html#nested-functions",
    "title": "Debugging in RStudio",
    "section": "Nested functions",
    "text": "Nested functions\nThe check_pkg_ns() function is fairly basic in that it performs a single ‚Äòunit of work‚Äô (i.e., check if add-on packages package have been loaded and attached; if not, load and attach them). When functions become more complex, it‚Äôs more efficient to use nested functions‚Äìi.e., functions within other functions‚Äìwhich allow me to execute multiple commands simultaneously.\nAn example of this is the pkg_data_results() function below:\n\n\npkg_data_results()\npkg_data_results(\"dplyr\")\n## # A tibble: 5 √ó 3\n##   Package Item              Title              \n##   &lt;chr&gt;   &lt;chr&gt;             &lt;chr&gt;              \n## 1 dplyr   band_instruments  Band membership    \n## 2 dplyr   band_instruments2 Band membership    \n## 3 dplyr   band_members      Band membership    \n## 4 dplyr   starwars          Starwars characters\n## 5 dplyr   storms            Storm tracks data\n\n\npkg_data_results() returns a data.frame with three columns: Package, Item, and Title.\nThe output from pkg_data_results() comes from the data(package = \"pkg\") output:\n\n\n\n\n\n(a) Output from data(package = )\n\n\nFigure¬†13: data(package = \"dplyr\")\n\n\nThis output is normally opened in a separate window, but it‚Äôs created as a matrix.\n\n\nstructure of data(package =)\nstr(data(package = \"dplyr\"))\n## List of 4\n##  $ title  : chr \"Data sets\"\n##  $ header : NULL\n##  $ results: chr [1:5, 1:4] \"dplyr\" \"dplyr\" \"dplyr\" \"dplyr\" ...\n##   ..- attr(*, \"dimnames\")=List of 2\n##   .. ..$ : NULL\n##   .. ..$ : chr [1:4] \"Package\" \"LibPath\" \"Item\" \"Title\"\n##  $ footer : NULL\n##  - attr(*, \"class\")= chr \"packageIQR\"\n\n\npkg_data_results() converts the matrix output into a data.frame three columns in (Package, Title, Item).\nI‚Äôve placed browser() at the top of pkg_data_results() and run it with the fivethirtyeight package.\npkg_data_results(\"fivethirtyeight\")\n\n\n\n\n\n(a) browser() in pkg_data_results(‚Äúfivethirtyeight‚Äù)\n\n\nFigure¬†14: browser() in pkg_data_results(\"fivethirtyeight\")\n\n\n\nStep into\nWhen the debugger lands on check_pkg_ns(), I can follow the fivethirtyeight package through this function by ‚Äòstepping into‚Äô this function by entering s in the Console (or the toolbar icon):\n\n\n\n\n\nStep into a function\n\n\n\n\n\n\n\n(a) browser() in pkg_data_results(‚Äúfivethirtyeight‚Äù)\n\n\nFigure¬†15: Step into in pkg_data_results(\"fivethirtyeight\")\n\n\n\n\nDebugging ‚Äòat‚Äô vs ‚Äòin‚Äô\nIn the Console, there are now debugging in and debug at locations:\nBrowse[2]&gt; s\ndebugging in: check_pkg_ns(pkg = pkg, quiet = TRUE)\ndebug at /apps/dbap/R/check_pkg_ns.R#25: \nThe debug at location is the the we location of the initial call to browser(), and debugging in is the function I stepped into.\nThe prompt has also changed from Browse[2]&gt; to Browse[3]&gt;:\nBrowse[3]&gt;\n\n\n\n\n\n\n(a) Use s to step into check_pkg_ns()\n\n\nFigure¬†16: Use s to step through check_pkg_ns()\n\n\n\nThe R/check_pkg_ns.R file will open with the highlighted function. I can proceed through check_pkg_ns() using n until I reach requireNamespace():\n\n\n\n\n\n\n(a) Use n to step through check_pkg_ns()\n\n\nFigure¬†17: Use n to step through check_pkg_ns()\n\n\n\nWhen I reach the final line in check_pkg_ns(), I can use either method below verify the pkg namespace is loaded:\nBrowse[3]&gt; pkg %in% loadedNamespaces()\n[1] TRUE\nBrowse[3]&gt; isNamespaceLoaded(pkg)\n[1] TRUE\nAfter the last line of check_pkg_ns() has been evaluated, the debugger will automatically return to the pkg_data_results() function. The Source pane will highlight the final step (and the prompt returns to Browse[2]&gt;):\n\n\n\n\n\n\n(a) Step into/through check_pkg_ns() from pkg_data_results()\n\n\nFigure¬†18: Step into and through check_pkg_ns() from pkg_data_results()\n\n\n\nA final n command in the Console will return the output table:\nBrowse[2]&gt; n\n### A tibble: 129 √ó 3\n##    Package         Item                Title\n##    &lt;chr&gt;           &lt;chr&gt;               &lt;chr&gt;\n##  1 fivethirtyeight US_births_1994_2003 Some People Are Too Superstitious To ‚Ä¶\n##  2 fivethirtyeight US_births_2000_2014 Some People Are Too Superstitious To ‚Ä¶\n##  3 fivethirtyeight ahca_polls          American Health Care Act Polls\n##  4 fivethirtyeight airline_safety      Should Travelers Avoid Flying Airline‚Ä¶\n##  5 fivethirtyeight antiquities_act     Trump Might Be The First President To‚Ä¶\n##  6 fivethirtyeight august_senate_polls How Much Trouble Is Ted Cruz Really  ‚Ä¶\n##  7 fivethirtyeight avengers            Joining The Avengers Is As Deadly As\n##  8 fivethirtyeight bachelorette        Bachelorette / Bachelor\n##  9 fivethirtyeight bad_drivers         Dear Mona, Which State Has The Worst ‚Ä¶\n## 10 fivethirtyeight bechdel             The Dollar-And-Cents Case Against Hol‚Ä¶\n## # ‚Ñπ 119 more rows\n## # ‚Ñπ Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/debugging/index.html#put-it-all-together",
    "href": "posts/debugging/index.html#put-it-all-together",
    "title": "Debugging in RStudio",
    "section": "Put it all together",
    "text": "Put it all together\nThe initial pkg_data_str() function for returning a table of ‚Äòpackage data structures‚Äô is below.\n\n\nexpand to see initial pkg_data_str()\npkg_data_str &lt;- function(pkg) {\n\n  data_results &lt;- pkg_data_results(pkg = pkg)\n\n  ds_list &lt;- purrr::map2(\n    .x = data_results[[\"Item\"]], \n    .y = data_results[[\"Package\"]],\n    .f = pkg_data_object, .progress = TRUE\n  )\n\n  cols_tbl &lt;- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |&gt;\n      purrr::map(paste0, collapse = \", \") |&gt; unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |&gt;\n      purrr::map(paste0, \" columns\") |&gt; unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |&gt;\n      purrr::map(paste0, \" rows\") |&gt; unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |&gt; unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |&gt; unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |&gt; unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |&gt; unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |&gt; unlist(),\n  )\n\n  pkg_tbls_dfs &lt;- dplyr::filter(cols_tbl,\n    stringr::str_detect(Class, \"data.frame\")\n  )\n\n  return(pkg_tbls_dfs)\n}\n\n\npkg_data_str() uses nested functions to create the following intermediate objects I can check while developing with browser() (the example below uses the forcats package)\n\nData results\nThe output from pkg_data_results() is stored in data_results:\n\ndata_results &lt;- pkg_data_results(pkg = pkg)\n\nBrowse[2]&gt; data_results\n# A tibble: 1 √ó 3\n  Package Item    Title                                                           \n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                                                           \n1 forcats gss_cat A sample of categorical variables from the General Social su...\n\n\nPackage data objects\nAfter extracting the Package, Title, and Type columns from pkg_data_results(), I use purrr:map2() to iterate over each Item and Package, which builds a list of datasets (ds_list). The .f argument is a nested pkg_data_object() function, which calls base::get().\n\nds_list &lt;- purrr::map2(\n  .x = data_results[[\"Item\"]],\n  .y = data_results[[\"Package\"]],\n  .f = pkg_data_object, .progress = TRUE\n)\n\nI‚Äôll view the contents of the list with str()\nBrowse[2]&gt; str(ds_list)\nList of 1\n $ : tibble [21,483 √ó 9] (S3: tbl_df/tbl/data.frame)\n  ..$ year   : int [1:21483] 2000 2000 2000 2000 2000 2000 2000 2000 ...\n  ..$ marital: Factor w/ 6 levels \"No answer\",\"Never married\",..: 2 4 ...\n  ..$ age    : int [1:21483] 26 48 67 39 25 25 36 44 44 47 ...\n  ..$ race   : Factor w/ 4 levels \"Other\",\"Black\",..: 3 3 3 3 3 3 3 3 3 3 ...\n  ..$ rincome: Factor w/ 16 levels \"No answer\",\"Don't know\",..: 8 8 16 16 ...\n  ..$ partyid: Factor w/ 10 levels \"No answer\",\"Don't know\",..: 6 5 7 6  ...\n  ..$ relig  : Factor w/ 16 levels \"No answer\",\"Don't know\",..: 15 15 15 ...\n  ..$ denom  : Factor w/ 30 levels \"No answer\",\"Don't know\",..: 25 23 3 ...\n  ..$ tvhours: int [1:21483] 12 NA 2 4 1 NA 3 NA 0 3 ...\n\n\nColumn counts\nThe ds_list created above is used to add the Class, Columns, and Rows columns to data_results using the class(), ncol(), nrow(). The column counts are added with the col_type_count() function.\n\n  cols_tbl &lt;- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |&gt;\n      purrr::map(paste0, collapse = \", \") |&gt; unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |&gt;\n      purrr::map(paste0, \" columns\") |&gt; unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |&gt;\n      purrr::map(paste0, \" rows\") |&gt; unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |&gt; unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |&gt; unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |&gt; unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |&gt; unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |&gt; unlist(),\n  )\n\nBrowse[2]&gt; cols_tbl\n# A tibble: 1 √ó 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n1 forcats gss_cat A sample of c‚Ä¶ tbl_‚Ä¶ 9 colu‚Ä¶ 2148‚Ä¶       0       3         0      6     0\n\n\nRectangular objects\nFinally, cols_tbl is filtered to only those objects with a class() containing the string ‚Äòdata.frame‚Äô.\n\npkg_tbls_dfs &lt;- dplyr::filter(.data = cols_tbl,\n                  stringr::str_detect(Class, \"data.frame\"))\n\nThis is exactly the same as the previous tibble because forcats has only one data object (gss_cat), and it‚Äôs a tibble:\nBrowse[2]&gt; pkg_tbls_dfs\n# A tibble: 1 √ó 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n1 forcats gss_cat A sample of c‚Ä¶ tbl_‚Ä¶ 9 colu‚Ä¶ 2148‚Ä¶       0       3         0      6     0\nI‚Äôm explicitly returning pkg_tbls_dfs to view it in the debugger. When I‚Äôm confident it‚Äôs behaving as expected, I‚Äôll remove this final object and ‚Äòrely on R to return the result of the last evaluated expression.‚Äô\n\n\nError!\nWhen I tried using the initial pkg_data_str() with a package that had zero data objects (fs), I get the following error:\n\npkg_data_str(\"fs\")\n\nError in `dplyr::filter()` at dbap/R/pkg_data_str.R:78:2:\n‚Ñπ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\nIn the debugger, I was able to pinpoint the source of this error (and the underlying condition causing it to occur).\n\nReplicate the error\nThe browser() beings at the top of pkg_data_str(), where I‚Äôll step into pkg_data_results()\n\n\n\n\n\n\n(a) pkg_data_results() from pkg_data_str()\n\n\nFigure¬†19: Step into pkg_data_results() from pkg_data_str()\n\n\n\nWhen I‚Äôm inside pkg_data_results(), I‚Äôll use n to verify the fs package namespace was loaded and the tibble was created:\n\n\n\n\n\n\n(a) Step through pkg_data_results()\n\n\nFigure¬†20: Step through pkg_data_results() (from pkg_data_str())\n\n\n\nBack in pkg_data_str(), the output from pkg_data_results() is stored as data_results. I can check the contents of data_results in the Console.\nBrowse[2]&gt; data_results\n# A tibble: 0 √ó 3\n# ‚Ñπ 3 variables: Package &lt;chr&gt;, Item &lt;chr&gt;, Title &lt;chr&gt;\nI see it‚Äôs empty. An empty data_results results in an empty list output from purrr::map2():\n\n\n\n\n\n\n(a) Step out of pkg_data_results()\n\n\nFigure¬†21: Step out of pkg_data_results() back into pkg_data_str()\n\n\n\nBrowse[2]&gt; ds_list\nlist()\nThe empty ds_list results in dplyr::mutate() being unable to create the Class column in cols_tbl:\n\n\n\n\n\n\n(a) dplyr::mutate() call in get_ds_strs()\n\n\nFigure¬†22: Create Class column in get_ds_strs()\n\n\n\nBrowse[2]&gt; cols_tbl\n# A tibble: 0 √ó 3\n# ‚Ñπ 3 variables: Package &lt;chr&gt;, Item &lt;chr&gt;, Title &lt;chr&gt;\nWhich triggers the error in dplyr::filter()\nBrowse[2]&gt; n\nError in `dplyr::filter()` at dbap/R/get_ds_str.R:60:2:\n‚Ñπ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\nThe full path for the fs package through the initial get_ds_str() is outlined in the figure below:\n\n\n\n\n\n\n(a) Error path in get_ds_strs()\n\n\nFigure¬†23: Replicate the error from get_ds_strs()\n\n\n\n\n\n\nSolution\nTo fix this error, I had to make some changes to both pkg_data_results() and pkg_data_str():\nIn pkg_data_results(), I added control flow to return a tibble of logical columns (all NA) if the package doesn‚Äôt have any data objects:\n\n\nExpand to view the updated pkg_data_results()\npkg_data_results &lt;- function(pkg) {\n  # load packages\n  check_pkg_ns(pkg = pkg, quiet = TRUE)\n\n  results &lt;- tibble::as_tibble(\n    data.frame(\n      Package = data(package = pkg)$results[, \"Package\"],\n      Item = data(package = pkg)$results[, \"Item\"],\n      Title = data(package = pkg)$results[, \"Title\"],\n      stringsAsFactors = FALSE,\n      check.names = FALSE,\n      row.names = NULL\n    )\n  )\n\n  if (nrow(results) == 0) {\n\n  data_results &lt;- tibble::as_tibble(\n    data.frame(\n        matrix(\n            nrow = 1, ncol = 11,\n            byrow = TRUE,\n            dimnames = list(NULL,\n              c(\"Package\", \"Item\", \"Title\",\n                \"Class\", \"Columns\", \"Rows\",\n                \"Logical\", \"Numeric\", \n                \"Character\", \"Factor\", \n                \"List\"))\n                ),\n        row.names = NULL))\n\n    return(data_results)\n\n\n  } else {\n\n    results\n\n  }\n\n}\n\n\nIn pkg_data_str(), I added two if statements:\n\nthe first if statement identifies the logical NA columns (indicating the results from data(package = pkg) didn‚Äôt have any data objects)\nthe second if statement creates the Class column first, then filters the rows to only those containing a data.frame string pattern. If none of the data objects have the data.frame string pattern in their class, an empty data_results table is returned\n\n\n\nExpand to view the updated pkg_data_str()\npkg_data_str &lt;- function(pkg) {\n  \n  data_results &lt;- pkg_data_results(pkg = pkg)\n  \n  if (!is.logical(data_results[[\"Item\"]])) {\n    # data_results contains data objects\n    ds_list &lt;- purrr::map2(\n      .x = data_results[[\"Item\"]], \n      .y = data_results[[\"Package\"]],\n      .f = pkg_data_object, .progress = TRUE\n    )\n\n    class_tbl &lt;- dplyr::mutate(data_results,\n      Class = purrr::map(.x = ds_list, .f = class) |&gt;\n        purrr::map(paste0, collapse = \", \") |&gt; unlist()\n    )\n\n    df_tbl &lt;- dplyr::filter(\n      class_tbl,\n      stringr::str_detect(Class, \"data.frame\")\n    )\n\n    if (nrow(df_tbl) == 0) {\n      # df_tbl does not contain 'data.frame' classes\n      data_results &lt;- tibble::as_tibble(\n        data.frame(\n          matrix(\n            nrow = 1, ncol = 11,\n            byrow = TRUE,\n            dimnames = list(\n              NULL,\n              c(\n                \"Package\", \"Item\", \"Title\",\n                \"Class\", \"Columns\", \"Rows\",\n                \"Logical\", \"Numeric\", \"Character\",\n                \"Factor\", \"List\"\n              )\n            )\n          ),\n          row.names = NULL\n        )\n      )\n\n      return(data_results)\n      \n    } else {\n      \n      # df_tbl contains 'data.frame' classes\n      dplyr::mutate(df_tbl,\n        Columns = purrr::map(.x = ds_list, .f = ncol) |&gt;\n          purrr::map(paste0, \" columns\") |&gt; unlist(),\n        Rows = purrr::map(.x = ds_list, .f = nrow) |&gt;\n          purrr::map(paste0, \" rows\") |&gt; unlist(),\n        Logical = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"log\") |&gt; unlist(),\n        Numeric = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"num\") |&gt; unlist(),\n        Character = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"chr\") |&gt; unlist(),\n        Factor = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"fct\") |&gt; unlist(),\n        List = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"lst\") |&gt; unlist())\n      \n    }\n    \n  } else {\n    \n    # data_results does not contains data objects\n    return(data_results)\n    \n  }\n  \n}\n\n\nRather than go through the debugger process again, I‚Äôll go through each of the the mini experiments I used to check the updated pkg_data_results() and pkg_data_str() functions:\n\nCheck single package without any data objects (box)\n\nknitr::kable(\n  pkg_data_str(\"box\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nCheck single package with data objects, but none with classes that contain data.frame (stringr)\n\nknitr::kable(\npkg_data_str(\"stringr\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nCheck single package with multiple data objects (dplyr)\n\nknitr::kable(\npkg_data_str(\"dplyr\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\ndplyr\nband_instruments\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_instruments2\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_members\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nstarwars\nStarwars characters\ntbl_df, tbl, data.frame\n14 columns\n87 rows\n0\n3\n8\n0\n3\n\n\ndplyr\nstorms\nStorm tracks data\ntbl_df, tbl, data.frame\n13 columns\n19066 rows\n0\n11\n1\n1\n0\n\n\n\n\n\nCheck multiple packages with multiple data objects (dplyr, forcats and lubridate)\n\nknitr::kable(\npkg_data_str(c(\"dplyr\", \"forcats\", \"lubridate\")))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\nforcats\ngss_cat\nA sample of categorical variables from the General Social survey\ntbl_df, tbl, data.frame\n9 columns\n21483 rows\n0\n3\n0\n6\n0\n\n\nlubridate\nlakers\nLakers 2008-2009 basketball data set\ndata.frame\n13 columns\n34624 rows\n0\n5\n8\n0\n0\n\n\ndplyr\nband_instruments\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_instruments2\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_members\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nstarwars\nStarwars characters\ntbl_df, tbl, data.frame\n14 columns\n87 rows\n0\n3\n8\n0\n3\n\n\ndplyr\nstorms\nStorm tracks data\ntbl_df, tbl, data.frame\n13 columns\n19066 rows\n0\n11\n1\n1\n0"
  },
  {
    "objectID": "posts/debugging/index.html#recap",
    "href": "posts/debugging/index.html#recap",
    "title": "Debugging in RStudio",
    "section": "Recap",
    "text": "Recap\nRStudio‚Äôs debugger is a powerful tool that can save tons of time when you‚Äôre developing new functions, discovering how a function‚Äôs code is executed, or dealing with errors. When you‚Äôve finished debugging, remember to remove the browser() call from your function.\nThe steps above should help get you started, and if you‚Äôd like to learn more, check out the debugging chapter of Advanced R, and the documentation for browser(), debug()/debugonce()/undebug(), and traceback() functions."
  },
  {
    "objectID": "posts/purrr1.0/index.html",
    "href": "posts/purrr1.0/index.html",
    "title": "purrr updates (v1.0.0)",
    "section": "",
    "text": "show/hide\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(sloop)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(waldo)\nThis post is going to cover the recent updates to the purrr package. The release of version 1.0.0 (and dev version v1.0.1) had some breaking changes, which I will cover below. But first, I‚Äôll dive into some attributes of R‚Äôs functions and objects that make purrr particularly useful, and I‚Äôll work through iteration problems I‚Äôve encountered (and solved with purrr)."
  },
  {
    "objectID": "posts/purrr1.0/index.html#generic-functions-s3-objects",
    "href": "posts/purrr1.0/index.html#generic-functions-s3-objects",
    "title": "purrr updates (v1.0.0)",
    "section": "Generic functions & S3 objects",
    "text": "Generic functions & S3 objects\nR‚Äôs syntax avoids explicit iteration by allowing certain generic functions to be used across different types (or objects). For example, the base plot() and summary() functions are S3 generic function:\n\n\n\nshow/hide\nsloop::ftype(plot)\n## [1] \"S3\"      \"generic\"\nsloop::ftype(summary)\n## [1] \"S3\"      \"generic\"\n\n\n\nWhich means plot() can be applied to S3 objects, like time-series (ts) and rectangular datasets (data.frame):\n\n\n\nshow/hide\nsloop::otype(datasets::LakeHuron)\n## [1] \"S3\"\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nsloop::otype(datasets::chickwts)\n## [1] \"S3\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n\n\n\n\nshow/hide\nsummary(datasets::LakeHuron)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   576.0   578.1   579.1   579.0   579.9   581.9\nsummary(datasets::chickwts)\n##      weight             feed   \n##  Min.   :108.0   casein   :12  \n##  1st Qu.:204.5   horsebean:10  \n##  Median :258.0   linseed  :12  \n##  Mean   :261.3   meatmeal :11  \n##  3rd Qu.:323.5   soybean  :14  \n##  Max.   :423.0   sunflower:12\n\n\n\n\nshow/hide\nplot(datasets::LakeHuron)\nplot(datasets::chickwts)\n\n\n\n\n\n\n\nTime-series plot\n\n\n\n\n\n\n\nScatter Plot\n\n\n\n\n\n\n\nsummary() is a particularly versatile function, because it can be used on data.frames, a single column in a data.frame, model outputs, and more.\n\nClick Code below to view an example using summary()\n\n\n\n\nshow/hide\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output  -------------------------------------------------------\nlm_mod &lt;- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024, Adjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(&gt;|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07"
  },
  {
    "objectID": "posts/purrr1.0/index.html#fp-oop",
    "href": "posts/purrr1.0/index.html#fp-oop",
    "title": "purrr updates (v1.0.0)",
    "section": "FP + OOP",
    "text": "FP + OOP\n\nFunctional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades. - Advanced R, 2nd edition\n\nplot() and summary() are parametric polymorphic (generic) functions, which means they have slightly different behaviors based on the objects passed into them.\nAs I can see, generic functions are flexible and efficient because of not having to re-define a new function for each input object‚Äìoutputs from generic functions will automatically change (in part) depending on the structure of the object provided to them.\nThe relationship between functions and objects is what makes purrr (and other tools for iteration) extremely helpful for solving iteration problems we commonly encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools."
  },
  {
    "objectID": "posts/purrr1.0/index.html#iteration-problems",
    "href": "posts/purrr1.0/index.html#iteration-problems",
    "title": "purrr updates (v1.0.0)",
    "section": "Iteration problems",
    "text": "Iteration problems\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include:\n\nYou have a list of objects and you‚Äôd like to apply a function (or a series of functions) over the elements in the list\nYou have a folder full of files you‚Äôd like to rename or copy to a new directory\nYou‚Äôd like to download a collection of files from separate URLS\nYou have several years of data, and each year is contained in separate file. You‚Äôd like to read these data into R, combine them into a single dataset\nYou have a non-rectangular (i.e., list) of datasets you‚Äôd like to split into individual data.frames, then export these into separate file paths.\n\nThese are all problems I‚Äôve personally encountered that required a variety of iteration tools to tackle. I‚Äôll start with the first example because the principles remain the same (regardless of the size/scope of the problem):"
  },
  {
    "objectID": "posts/purrr1.0/index.html#lapply",
    "href": "posts/purrr1.0/index.html#lapply",
    "title": "purrr updates (v1.0.0)",
    "section": "lapply()",
    "text": "lapply()\nSticking with the my_list and tolower() example, the apply function I want is lapply() (pronounced ‚Äòl-apply‚Äô), and the l stands for list.\nlapply() has only two required arguments:\n\nX the object we want to iterate over\nFUN being the function we want iterated\n\n\n\n\nshow/hide\nlapply(X = my_list, FUN = tolower)\n## $words\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"    \n## \n## $sentences\n## [1] \"we tried to replace the coin but failed.\"       \n## [2] \"he wrote his last novel there at the inn.\"      \n## [3] \"a whiff of it will cure the most stubborn cold.\"\n## \n## $letters\n##  [1] \"b\" \"t\" \"n\" \"o\" \"w\" \"h\" \"z\" \"u\" \"e\" \"m\""
  },
  {
    "objectID": "posts/purrr1.0/index.html#sapply",
    "href": "posts/purrr1.0/index.html#sapply",
    "title": "purrr updates (v1.0.0)",
    "section": "sapply()",
    "text": "sapply()\nsapply() attempts to simplify the result depending on the X argument. If X is a list containing vectors where every element has the same length (and it‚Äôs greater than 1), then sapply() returns a matrix:\n\n\n\nshow/hide\nstr(my_list[1])\n## List of 1\n##  $ words: chr [1:5] \"SpaCE\" \"pOsitiOn\" \"sOcIetY\" \"sTufF\" ...\nsapply(X = my_list[1], FUN = tolower)\n##      words     \n## [1,] \"space\"   \n## [2,] \"position\"\n## [3,] \"society\" \n## [4,] \"stuff\"   \n## [5,] \"hand\"\n\n\n\nIf a vector is passed to X where every element is length 1, then a vector is returned:\n\n\n\nshow/hide\nstr(my_list[[1]])\n##  chr [1:5] \"SpaCE\" \"pOsitiOn\" \"sOcIetY\" \"sTufF\" \"hAnd\"\nsapply(X = my_list[[1]], FUN = tolower) \n##      SpaCE   pOsitiOn    sOcIetY      sTufF       hAnd \n##    \"space\" \"position\"  \"society\"    \"stuff\"     \"hand\"\n\n\n\nFinally, if X is a list where elements have a length greater than 1, then a list is returned (making it identical to lapply()\n\n\n\nshow/hide\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n## ‚úî No differences\n\n\n\nThis is because sapply is a wrapper around lapply, but has simplify and USE.NAMES set to FALSE (see what happens below when I change them to TRUE)\n\n\n\nshow/hide\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n## `old` is a list\n## `new` is a character vector ('space', 'position', 'society', 'stuff', 'hand')"
  },
  {
    "objectID": "posts/purrr1.0/index.html#anonmymous-functions",
    "href": "posts/purrr1.0/index.html#anonmymous-functions",
    "title": "purrr updates (v1.0.0)",
    "section": "Anonmymous functions",
    "text": "Anonmymous functions\nThe FUN argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in my_list, I could pass an anonymous function the FUN (with the index):\n\n\n\nshow/hide\nlapply(X = my_list, FUN = function(x) x[[2]])\n## $words\n## [1] \"pOsitiOn\"\n## \n## $sentences\n## [1] \"He WrOTE HIS LaSt noVel ThErE aT ThE inn.\"\n## \n## $letters\n## [1] \"t\""
  },
  {
    "objectID": "posts/purrr1.0/index.html#vapply",
    "href": "posts/purrr1.0/index.html#vapply",
    "title": "purrr updates (v1.0.0)",
    "section": "vapply()",
    "text": "vapply()\nFinally vapply() is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n\n\nshow/hide\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n##                                       words \n##                                  \"pOsitiOn\" \n##                                   sentences \n## \"He WrOTE HIS LaSt noVel ThErE aT ThE inn.\" \n##                                     letters \n##                                         \"t\"\n\n\n\nThe apply functions get us much further than writing for loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) write less code. Unlike generic functions, apply functions are designed to work with specific object types, and return values depending on these objects.\nOne downside of apply functions is they don‚Äôt play well with data.frames or tibbles. However, we can control their return values (and manually supply these to tibble::tibble() or data.frame()\n\n\n\nshow/hide\ntibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n\n\n\nAnother downside of the apply functions is they‚Äôre not very uniform. Each function has slight variations in their arguments and rules for return values. This is where purrr comes in‚Ä¶"
  },
  {
    "objectID": "posts/purrr1.0/index.html#do-it-for-one-element",
    "href": "posts/purrr1.0/index.html#do-it-for-one-element",
    "title": "purrr updates (v1.0.0)",
    "section": "1. Do it for one element",
    "text": "1. Do it for one element\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\nFor this example, I need to subset my_list for a single element at position [[1]], [[2]], or [[3]] (or using one of the vector names).\nI‚Äôll then pass this element to tolower() and make sure it‚Äôs the desired behavior:\n\n# subset an element from the list\n? &lt;- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n\n\n? &lt;- my_list[[?]] = subset element from the list (my_list)\ntolower(?) = apply operation (i.e., function) to extracted element.\n\n\n\n\nshow/hide\nmy_words &lt;- my_list[['words']]\ntolower(my_words)\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"\n\n\n\nNow that I have a working example for one element, in the next step I‚Äôll abstract these parts into the function arguments."
  },
  {
    "objectID": "posts/purrr1.0/index.html#turn-it-into-a-recipe",
    "href": "posts/purrr1.0/index.html#turn-it-into-a-recipe",
    "title": "purrr updates (v1.0.0)",
    "section": "2. Turn it into a recipe",
    "text": "2. Turn it into a recipe\nA standard purrr recipe defines .x (the object) and .f (the function), followed by any additional function arguments.\n\n.x = a list or atomic vector\n.f = the function we want to apply over every element in .x\n\n\n.x = my_list, .f = tolower"
  },
  {
    "objectID": "posts/purrr1.0/index.html#map-it-across-all-elements",
    "href": "posts/purrr1.0/index.html#map-it-across-all-elements",
    "title": "purrr updates (v1.0.0)",
    "section": "3. map() it across all elements",
    "text": "3. map() it across all elements\nIn purrr::map(), the .x argument is the object (list or atomic vector) I want to iterate over, and .f is the function (i.e., operation) I want applied to every element of .x\nIf I want to convert the case of every element in my_list to lowercase with tolower() I would use the following standard purrr::map() format:\n\n\n\nshow/hide\npurrr::map(.x = my_list, .f = tolower)\n## $words\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"    \n## \n## $sentences\n## [1] \"we tried to replace the coin but failed.\"       \n## [2] \"he wrote his last novel there at the inn.\"      \n## [3] \"a whiff of it will cure the most stubborn cold.\"\n## \n## $letters\n##  [1] \"b\" \"t\" \"n\" \"o\" \"w\" \"h\" \"z\" \"u\" \"e\" \"m\"\n\n\n\nAnd there you have it! map() is the core function and workhorse of the purrr package. It‚Äôs important to note that purrr::map() always returns a list, regardless of the object supplied to .x."
  },
  {
    "objectID": "posts/purrr1.0/index.html#map-updates",
    "href": "posts/purrr1.0/index.html#map-updates",
    "title": "purrr updates (v1.0.0)",
    "section": "map() updates",
    "text": "map() updates\nAs noted above, by default purrr::map() returns a list. If I‚Äôd like to return a vector, I can use one of the map_ variations (there‚Äôs one for each vector type).\n\nBy mapping the is.&lt;type&gt;() functions the elements in mixed_list, I can test which elements in mixed_list return TRUE:\n\nmap_lgl(): returns a logical vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_lgl(\\(x) is.logical(x))\n\n\nbooleans integers  doubles  strings    dates \n    TRUE    FALSE    FALSE    FALSE    FALSE \n\n\n\n\nmap_int(): returns an integer vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_int(\\(x) is.integer(x))\n\n\nbooleans integers  doubles  strings    dates \n       0        1        0        0        0 \n\n\n\n\nmap_dbl(): returns a double vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_dbl(\\(x) is.double(x))\n\n\nbooleans integers  doubles  strings    dates \n       0        0        1        0        1 \n\n\n\n\nmap_chr(): returns a character vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_chr(\\(x) is.character(x))\n\n\nWarning: Automatic coercion from logical to character was deprecated in purrr 1.0.0.\n‚Ñπ Please use an explicit call to `as.character()` within `map_chr()` instead.\n\n\nbooleans integers  doubles  strings    dates \n \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\" \n\n\n\n\nWhen we test for characters in mixed_list, we see the following warning:\n\n\nWarning: Automatic coercion from logical to character was deprecated in purrr 1.0.0. Please use an explicit call to as.character() within map_chr() instead\n\n\nAs we can see from the output above, the logical return values from is.character() are coerced to characters (this behavior is now deprecated).\n\nmap_vec()\n\nHowever, the previous purrr::map_raw() function has been replaced with purrr::map_vec(), which ‚Äúsimplifies to the common type of the output.‚Äù I‚Äôll demonstrate below with the characters in mixed_list:\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_vec(\\(x) is.character(x))\n## booleans integers  doubles  strings    dates \n##    FALSE    FALSE    FALSE     TRUE    FALSE\n\n\n\nNotice the difference in output? The results are the same as above, but output is not commented (##). The same is true when I test the dates in mixed_list using lubridate::is.Date():\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_vec(\\(x) lubridate::is.Date(x))\n## booleans integers  doubles  strings    dates \n##    FALSE    FALSE    FALSE    FALSE     TRUE"
  },
  {
    "objectID": "posts/purrr1.0/index.html#anonymous-functions",
    "href": "posts/purrr1.0/index.html#anonymous-functions",
    "title": "purrr updates (v1.0.0)",
    "section": "Anonymous functions",
    "text": "Anonymous functions\nR introduced the shorthand anonymous function syntax in version 4.1.0:\n\n‚Äú\\(x) x + 1 is parsed as function(x) x + 1.‚Äù\n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\nStandard anonymous function\n\n\n\nshow/hide\n(function(x) tolower(x))(\"pIrAtES Ship\")\n## [1] \"pirates ship\"\n\n\n\nThe updated anonymous syntax is below:\n\n\n\nshow/hide\n(\\(x) tolower(x))(\"pIrAtES Ship\")\n## [1] \"pirates ship\"\n\n\n\n\nWriting the code above using an anonymous function would look like this:\n\n\n\nshow/hide\nmy_list |&gt; purrr::map(\\(x) tolower(x))\n## $words\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"    \n## \n## $sentences\n## [1] \"we tried to replace the coin but failed.\"       \n## [2] \"he wrote his last novel there at the inn.\"      \n## [3] \"a whiff of it will cure the most stubborn cold.\"\n## \n## $letters\n##  [1] \"b\" \"t\" \"n\" \"o\" \"w\" \"h\" \"z\" \"u\" \"e\" \"m\"\n\n\n\nAnonymous functions make it easier to understand which arguments belong to which function and will tend to yield better error messages.\nI‚Äôll confirm the outputs from both methods are identical using waldo::compare():\n\n\n\nshow/hide\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |&gt; purrr::map(\\(x) tolower(x)))\n## ‚úî No differences\n\n\n\n\n\n\n\n\n\nThe formula (~ .x + 1)\n\n\n\n\n\nPrior to purrr v1.0.0, I could also use the formula syntax, but now it‚Äôs ‚Äúonly recommended if you require backward compatibility with older versions of R.‚Äù I‚Äôll cover the formula syntax briefly because you‚Äôre likely to encounter it.\n\n\nThe formula syntax is typically used with pipes, so the contents of purrr::map() become the right-hand side of the formula, with the function we want to iterate (&lt;FUNCTION&gt;) and a placeholder (.x) in the appropriate argument.\n\n\n&lt;OBJECT&gt; |&gt; purrr::map(~ &lt;FUNCTION&gt;(.x))\n\n\nFor the example above, my_list is ‚Äòpiped‚Äô to purrr::map(), where the formula maps the tolower() function (using the .x placeholder).\n\n\n# written as normal expression\n my_list |&gt; purrr::map(~ tolower(.x))\n\n\nJenny Bryan offers a great description on her purrr tutorial,\n\n‚Äú[formula syntax] should start with the ~ symbol and then look like a typical top-level expression, as you might write in a script. Use .x to refer to the input, i.e.¬†an individual element of the primary vector or list.‚Äù\n\nI can double-check to see that the output from two variations are identical using waldo::compare().\n\n\n\n\nshow/hide\nwaldo::compare(\n  x = my_list |&gt; purrr::map(\\(x) tolower(x)), \n  y = my_list |&gt; purrr::map(~ tolower(.x)))\n## ‚úî No differences"
  },
  {
    "objectID": "posts/purrr1.0/index.html#downloading-files",
    "href": "posts/purrr1.0/index.html#downloading-files",
    "title": "purrr updates (v1.0.0)",
    "section": "Downloading files",
    "text": "Downloading files\n\nYou‚Äôd like to download a collection of files from separate URLS\n\nI have a collection of 30 .csv files from Doing Data Science by Cathy O‚ÄôNeil and Rachel Schutt (O‚ÄôReilly Media) in a GitHub repo. Let‚Äôs assume I want to download one week of these files into my RStudio session (without downloading the repo).\nI‚Äôll navigate to the raw url for the first data file (nyt1.csv), then paste this into a character vector:\n\n\n\nshow/hide\nnyt_url &lt;- \"https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n\n\n\nKnowing that all of the files on GitHub with have a similar sheme and domain, I can use nyt_url to generate urls for each of the 7 files.\n\nFirst I get the folder of the files on GitHub with fs::path_dir()\n\n\n\n\nshow/hide\n# create file urls \nnyt_dir_url &lt;- fs::path_dir(nyt_url)\nnyt_dir_url\n\n\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main\"\n\n\n\n\nI create a vector with the 7 file names\n\n\n\n\nshow/hide\n# create file names for 7th through 13th\nnyt_file_nms &lt;- paste0(\"nyt\", 7:13, \".csv\")\nnyt_file_nms\n\n\n[1] \"nyt7.csv\"  \"nyt8.csv\"  \"nyt9.csv\"  \"nyt10.csv\" \"nyt11.csv\" \"nyt12.csv\"\n[7] \"nyt13.csv\"\n\n\n\n\nI combine the directory portion of the url with file name in nyt_file_urls\n\n\n\n\nshow/hide\n# combine\nnyt_file_urls &lt;- paste(nyt_dir_url, nyt_file_nms, sep = \"/\")\nnyt_file_urls\n\n\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt7.csv\" \n[2] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt8.csv\" \n[3] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt9.csv\" \n[4] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt10.csv\"\n[5] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt11.csv\"\n[6] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt12.csv\"\n[7] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt13.csv\"\n\n\n\nI‚Äôll need another vector of destination file names on my local machine, which I can do by combining the file names (nyt_file_nms) with the local destination folder (dds-nyt).\n\n\n\nshow/hide\nnyt_local_pths &lt;- paste(\"dds-nyt\", nyt_file_nms, sep = \"/\")\nnyt_local_pths\n\n\n[1] \"dds-nyt/nyt7.csv\"  \"dds-nyt/nyt8.csv\"  \"dds-nyt/nyt9.csv\" \n[4] \"dds-nyt/nyt10.csv\" \"dds-nyt/nyt11.csv\" \"dds-nyt/nyt12.csv\"\n[7] \"dds-nyt/nyt13.csv\"\n\n\n\nAfter creating the destination folder, I‚Äôll use the download.file() function to test downloading a single .csv files into my local folder (dds-nyt/). download.file() has a progress bar which tells me if the file downloaded successfully.\n\n\nshow/hide\n# do it for one\nfs::dir_create(\"dds-nyt\")\ndownload.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])\n\ntrying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'\nContent type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)\n==================================================\ndownloaded 4.7 MB\n\ndownload.file() takes two inputs (url and destfile), which changes the recipe a bit, because I need a purrr function with the following:\n\n.x the input vector of existing url paths\n.y the output vector of destination file paths\nAdditional arguments passed from download.file() (like quiet = TRUE)\n\nIn this case, I don‚Äôt need purrr to return value‚ÄìI just need the purrr function to iterate over the items and write them to the new location.\nwalk() is ideal for this circumstance:\n\n‚Äúwalk() returns the input .x (invisibly)‚Äù and ‚ÄúThe return value of .f() is ignored‚Äù\n\nWhat do ‚Äòreturn .x invisibly‚Äô and ‚Äòthe side-effect of .f‚Äô mean?\n\nReturn invisibly\nThe previous purrr functions I covered varied in the kinds of values they returned (lists vs.¬†vectors), but for some operations I won‚Äôt need a return value. If I‚Äôm ever curious about whether I should be using map() or walk(), I‚Äôll ask myself, ‚Äúwould it make sense to assign the output from this function to an object?‚Äù\nIf the answer is no, then I probably need to be thinking walk() instead of map()\n\n\nSide-effects\nIn the help documentation walk()‚Äôs description states, ‚Äúcalls .f for its side-effect‚Äù, which can be generally interpreted as, ‚Äúthere‚Äôs nothing to assign the output from that function to.‚Äù\n\n\npurrr progress bars\nI‚Äôll use walk2() below and add .progress = TRUE to view the purrr progress bar (and quiet = TRUE to silence the download.file() progress bar).\n\n\n\nshow/hide\nwalk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, \n      .progress = TRUE, quiet = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI can confirm the download using fs::dir_tree()\n\n\n\nshow/hide\nfs::dir_tree(\"dds-nyt\")\n## dds-nyt\n## ‚îú‚îÄ‚îÄ nyt10.csv\n## ‚îú‚îÄ‚îÄ nyt11.csv\n## ‚îú‚îÄ‚îÄ nyt12.csv\n## ‚îú‚îÄ‚îÄ nyt13.csv\n## ‚îú‚îÄ‚îÄ nyt7.csv\n## ‚îú‚îÄ‚îÄ nyt8.csv\n## ‚îî‚îÄ‚îÄ nyt9.csv"
  },
  {
    "objectID": "posts/purrr1.0/index.html#copying-a-directory-of-files",
    "href": "posts/purrr1.0/index.html#copying-a-directory-of-files",
    "title": "purrr updates (v1.0.0)",
    "section": "Copying a directory of files",
    "text": "Copying a directory of files\n\nYou have a folder of files you‚Äôd like to rename or copy to a new directory\n\nThe collection of 7 .csv files from Doing Data Science by Cathy O‚ÄôNeil and Rachel Schutt (O‚ÄôReilly Media) are now in the dds-nyt/ folder.\nAs with any project, I don‚Äôt want to alter the raw data, so I‚Äôm going to copy these files into dds-nyt-raw/ and dds-nyt-processed/. I also want the processed file names to have a date stamp prefix.\n\n\n\nshow/hide\nfile_pths &lt;- list.files(\"dds-nyt\", full.names = TRUE, pattern = \".csv$\")\nfile_pths\n## [1] \"dds-nyt/nyt10.csv\" \"dds-nyt/nyt11.csv\" \"dds-nyt/nyt12.csv\"\n## [4] \"dds-nyt/nyt13.csv\" \"dds-nyt/nyt7.csv\"  \"dds-nyt/nyt8.csv\" \n## [7] \"dds-nyt/nyt9.csv\"\n\n\n\nI‚Äôll start with the raw data folder. I need to create a vector of the new raw file paths and names: raw_file_pths (the raw data paths will have the original file names)\n\n\n\nshow/hide\n# do it for one\ngsub(pattern = \"^dds-nyt\",\n  replacement = \"dds-nyt/raw\",\n  x = file_pths[1])\n## [1] \"dds-nyt/raw/nyt10.csv\"\n\n# write the recipe\nfile_pths |&gt; purrr::map_chr(\\(x) gsub(x, \n                                pattern = \"^dds-nyt\", \n                                replacement = \"dds-nyt/raw\")) |&gt; head()\n## [1] \"dds-nyt/raw/nyt10.csv\" \"dds-nyt/raw/nyt11.csv\" \"dds-nyt/raw/nyt12.csv\"\n## [4] \"dds-nyt/raw/nyt13.csv\" \"dds-nyt/raw/nyt7.csv\"  \"dds-nyt/raw/nyt8.csv\"\n\n# map it across all\nraw_file_pths &lt;- file_pths |&gt; \n                  purrr::map_chr(\\(x) gsub(x, \n                                        pattern = \"^dds-nyt\", \n                                        replacement = \"dds-nyt/raw\"))\n\n\n\nBefore copying the files, I need to create the destination folder for the raw data (dds-nyt/raw). Then, I‚Äôll make sure I can copy the first element from file_pths into the path in the first element of raw_file_pths:\n\n\n\nshow/hide\nfs::dir_create(\"dds-nyt/raw\")\n# do it for one\nfs::file_copy(\n  path = file_pths[1], \n  new_path = raw_file_pths[1], \n  overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n## dds-nyt/raw\n## ‚îî‚îÄ‚îÄ nyt10.csv\n\n\n\nI can see this is working, so I can use purrr::walk2() to move all the files from dds-nyt/ to dds-nyt/raw/\n\n\n\nshow/hide\npurrr::walk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, \n      .progress = TRUE, overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n## dds-nyt/raw\n## ‚îú‚îÄ‚îÄ nyt10.csv\n## ‚îú‚îÄ‚îÄ nyt11.csv\n## ‚îú‚îÄ‚îÄ nyt12.csv\n## ‚îú‚îÄ‚îÄ nyt13.csv\n## ‚îú‚îÄ‚îÄ nyt7.csv\n## ‚îú‚îÄ‚îÄ nyt8.csv\n## ‚îî‚îÄ‚îÄ nyt9.csv\n\n\n\nNow that I‚Äôve copied the files into their respective folders, I‚Äôll need to remove the files from their original location in the parent dds-nyt folder.\nFortunately, I have a vector of these files in file_pths, and I can test removal with fs::file_delete():\n\n\n\nshow/hide\nfs::file_delete(file_pths[1])\n\n\n\nGreat! Now that I know this will work, I‚Äôll use walk() because I want .x returned invisibly and the side-effect of .f.\nBut I‚Äôve also deleted the first element in file_pths, so when fs::file_delete() goes looking for that file, it will find nothing and returned an error.\n\n\n\nshow/hide\nError in `map()`:\n‚Ñπ In index: 1.\nCaused by error:\n! [ENOENT] Failed to remove 'dds-nyt/nyt10.csv': no such file or directory\n\n\n\nI can protect against this by supplying the output from list.files() directly to purrr::walk2(), but include a pattern so it only matches the .csv files.\n\n\n\nshow/hide\npurrr:::walk(\n  # list CURRENT files \n    .x = list.files(\n      path = \"dds-nyt\",\n      pattern = \".csv$\",\n      full.names = TRUE),\n    # map function\n    .f = fs::file_delete)\n\n\n\nAnd confirm the new folder contents and structure\n\n\n\nshow/hide\nfs::dir_tree(\"dds-nyt\", type = \"any\", recurse = TRUE)\n## dds-nyt\n## ‚îî‚îÄ‚îÄ raw\n##     ‚îú‚îÄ‚îÄ nyt10.csv\n##     ‚îú‚îÄ‚îÄ nyt11.csv\n##     ‚îú‚îÄ‚îÄ nyt12.csv\n##     ‚îú‚îÄ‚îÄ nyt13.csv\n##     ‚îú‚îÄ‚îÄ nyt7.csv\n##     ‚îú‚îÄ‚îÄ nyt8.csv\n##     ‚îî‚îÄ‚îÄ nyt9.csv"
  },
  {
    "objectID": "posts/purrr1.0/index.html#import-multiple-datasets",
    "href": "posts/purrr1.0/index.html#import-multiple-datasets",
    "title": "purrr updates (v1.0.0)",
    "section": "Import multiple datasets",
    "text": "Import multiple datasets\n\nYou have several days of data, and each day is contained in separate file. You‚Äôd like to read these data into R, and combine them into a single dataset\n\nNow that I have separate raw and processed folders, I can import the NYT data into R. Below I‚Äôve imported a single file from the raw data folder to examine it‚Äôs contents:\n\n\n\nshow/hide\nnyt1 &lt;- vroom::vroom(file = raw_file_pths[1],\n  delim = \",\", \n  show_col_types = FALSE)\nstr(nyt1)\n## spc_tbl_ [452,766 √ó 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##  $ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##  $ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##  $ Impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##  $ Clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##  $ Signed_In  : num [1:452766] 1 0 1 1 1 1 1 1 0 1 ...\n##  - attr(*, \"spec\")=\n##   .. cols(\n##   ..   Age = col_double(),\n##   ..   Gender = col_double(),\n##   ..   Impressions = col_double(),\n##   ..   Clicks = col_double(),\n##   ..   Signed_In = col_double(),\n##   ..   .delim = \",\"\n##   .. )\n##  - attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nEach nyt file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: Age, Gender (0 = female, 1 = male), Impressions (number impressions), Clicks (number clicks), and a binary indicator for signed in or not Signed_in.\nI‚Äôll add some hypothetical wrangling steps to make this example more realistic.\n\nCreate age_group, an ordered factor which contains six levels of Age (‚Äú&lt;18‚Äù, ‚Äú18-24‚Äù, ‚Äú25-34‚Äù, ‚Äú35-44‚Äù, ‚Äú45-54‚Äù, ‚Äú55-64‚Äù, and ‚Äú65+‚Äù)\nCreate ctr_rate or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.\nCreate female, a factor version of Gender, where when Gender = 0, then female = \"yes\", and when Gender = 1, then female = \"no\"\nCreate signed_in, a factor variable with levels \"no\" and \"yes\" from the Signed_In = 0 and 1\n\nI‚Äôve bundled all of these steps into a function (nyt_data_processing()) that I can pass each dataset through:\n\n\n\nshow/hide\nnyt_data_processing &lt;- function(nyt_csv) {\n  orig_nms &lt;- c(\"Age\", \"Gender\", \"Impressions\", \"Clicks\", \"Signed_In\")\n  nyt_nms &lt;- names(nyt_csv)\n  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {\n    cli::cli_abort(\"these data don't have the correct columns!\")\n  } else {\n    nyt_proc &lt;- nyt_csv |&gt;\n      dplyr::mutate(\n        # create age_group variable\n        age_group = case_when(\n          Age &lt; 18 ~ \"&lt;18\",\n          Age &gt;= 18 & Age &lt; 25 ~ \"18-24\",\n          Age &gt;= 25 & Age &lt; 35 ~ \"25-34\",\n          Age &gt;= 35 & Age &lt; 45 ~ \"35-44\",\n          Age &gt;= 45 & Age &lt; 55 ~ \"45-54\",\n          Age &gt;= 55 & Age &lt; 65 ~ \"55-64\",\n          Age &gt;= 65 ~ \"65+\"\n        ),\n        # factor age_group (ordered)\n        age_group = factor(age_group,\n          levels = c(\n            \"&lt;18\", \"18-24\", \"25-34\",\n            \"35-44\", \"45-54\", \"55-64\", \"65+\"\n          ),\n          ordered = TRUE\n        ),\n        # create CTR variable\n        ctr_rate = round(x = Clicks / Impressions, digits = 3),\n        # create new Female variable\n        female = case_when(\n          Gender == 0 ~ \"yes\",\n          Gender == 1 ~ \"no\",\n          TRUE ~ NA_character_\n        ),\n        # factor female (un-ordered)\n        female = factor(female,\n          levels = c(\"no\", \"yes\")\n        ),\n        Signed_In = case_when(\n          Signed_In == 0 ~ \"no\", \n          Signed_In == 1 ~ \"yes\", \n          TRUE ~ NA_character_),\n        # factor Signed_In (un-ordered) \n        Signed_In = factor(Signed_In, levels = c(\"no\", \"yes\"))) |&gt;\n      # format columns\n      janitor::clean_names()\n  }\n  return(nyt_proc)\n}\n\n\n\nI‚Äôll do some quick checks to make sure it only works with the raw data columns:\n\n\n\nshow/hide\nnyt1_proc &lt;- nyt_data_processing(nyt1)\nstr(nyt1_proc)\n## spc_tbl_ [452,766 √ó 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##  $ age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##  $ gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##  $ impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##  $ clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##  $ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 2 2 2 2 2 1 2 ...\n##  $ age_group  : Ord.factor w/ 7 levels \"&lt;18\"&lt;\"18-24\"&lt;..: 6 1 2 4 3 3 4 4 1 2 ...\n##  $ ctr_rate   : num [1:452766] 0 0.143 0 0 0 0 0 0 0.111 0 ...\n##  $ female     : Factor w/ 2 levels \"no\",\"yes\": 1 2 2 1 1 1 2 2 2 1 ...\n##  - attr(*, \"spec\")=\n##   .. cols(\n##   ..   Age = col_double(),\n##   ..   Gender = col_double(),\n##   ..   Impressions = col_double(),\n##   ..   Clicks = col_double(),\n##   ..   Signed_In = col_double(),\n##   ..   .delim = \",\"\n##   .. )\n##  - attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nI‚Äôll run nyt_data_processing() against a processed data file (nyt1_proc)\n\n\n\nshow/hide\nnyt_data_processing(nyt1_proc)\n## Error in `nyt_data_processing()`:\n## ! these data don't have the correct columns!\n\n\n\nNow I‚Äôm ready to write the import step. First I‚Äôll store the raw file paths in raw_data_pths\n\n\n\nshow/hide\nraw_data_pths &lt;- list.files(path = \"dds-nyt/raw\", pattern = \".csv$\", full.names = TRUE)\n\n\n\nWe‚Äôll test purrr::map() and vroom::vroom() to import the .csv files in raw_data_pths into a list. I also add utils::head() and dplyr::glimpse() to limit the output.\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # import\n  purrr::map(\n    vroom::vroom, \n        delim = \",\", show_col_types = FALSE) |&gt; \n  utils::head(2) |&gt; \n  dplyr::glimpse()\n## List of 2\n##  $ : spc_tbl_ [452,766 √ó 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##   ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##   ..$ Impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##   ..$ Clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##   ..$ Signed_In  : num [1:452766] 1 0 1 1 1 1 1 1 0 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt; \n##  $ : spc_tbl_ [478,066 √ó 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:478066] 28 51 29 20 19 0 58 42 35 44 ...\n##   ..$ Gender     : num [1:478066] 1 0 1 1 0 0 0 0 1 0 ...\n##   ..$ Impressions: num [1:478066] 8 5 2 4 5 3 5 6 8 4 ...\n##   ..$ Clicks     : num [1:478066] 0 0 0 0 0 1 1 0 0 0 ...\n##   ..$ Signed_In  : num [1:478066] 1 1 1 1 1 0 1 1 1 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nThis returns a list, but you may have noticed I don‚Äôt have a great way for keeping track of the data files in the list‚Äìthis is where purrr::set_names() comes in handy.\npurrr::set_names() works a lot like names(), but purrr::set_names() will automatically set the names of x to as.character(x) if no names are provided to nm. See below:\n\n\n\nshow/hide\nraw_data_pths |&gt; purrr::set_names()\n##   dds-nyt/raw/nyt10.csv   dds-nyt/raw/nyt11.csv   dds-nyt/raw/nyt12.csv \n## \"dds-nyt/raw/nyt10.csv\" \"dds-nyt/raw/nyt11.csv\" \"dds-nyt/raw/nyt12.csv\" \n##   dds-nyt/raw/nyt13.csv    dds-nyt/raw/nyt7.csv    dds-nyt/raw/nyt8.csv \n## \"dds-nyt/raw/nyt13.csv\"  \"dds-nyt/raw/nyt7.csv\"  \"dds-nyt/raw/nyt8.csv\" \n##    dds-nyt/raw/nyt9.csv \n##  \"dds-nyt/raw/nyt9.csv\"\n\n\n\nNow the imported file will have their file path and name associated with the dataset:\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import  \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  utils::head(2) |&gt; \n  dplyr::glimpse()\n## List of 2\n##  $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 √ó 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##   ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##   ..$ Impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##   ..$ Clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##   ..$ Signed_In  : num [1:452766] 1 0 1 1 1 1 1 1 0 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt; \n##  $ dds-nyt/raw/nyt11.csv: spc_tbl_ [478,066 √ó 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:478066] 28 51 29 20 19 0 58 42 35 44 ...\n##   ..$ Gender     : num [1:478066] 1 0 1 1 0 0 0 0 1 0 ...\n##   ..$ Impressions: num [1:478066] 8 5 2 4 5 3 5 6 8 4 ...\n##   ..$ Clicks     : num [1:478066] 0 0 0 0 0 1 1 0 0 0 ...\n##   ..$ Signed_In  : num [1:478066] 1 1 1 1 1 0 1 1 1 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nTo add the wrangling function, I can pipe in another call to purrr::map(), and add nyt_data_processing().\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |&gt; \n  utils::head(2) |&gt; \n  dplyr::glimpse()\n## List of 2\n##  $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 √ó 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##   ..$ gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##   ..$ impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##   ..$ clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##   ..$ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 2 2 2 2 2 1 2 ...\n##   ..$ age_group  : Ord.factor w/ 7 levels \"&lt;18\"&lt;\"18-24\"&lt;..: 6 1 2 4 3 3 4 4 1 2 ...\n##   ..$ ctr_rate   : num [1:452766] 0 0.143 0 0 0 0 0 0 0.111 0 ...\n##   ..$ female     : Factor w/ 2 levels \"no\",\"yes\": 1 2 2 1 1 1 2 2 2 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt; \n##  $ dds-nyt/raw/nyt11.csv: spc_tbl_ [478,066 √ó 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ age        : num [1:478066] 28 51 29 20 19 0 58 42 35 44 ...\n##   ..$ gender     : num [1:478066] 1 0 1 1 0 0 0 0 1 0 ...\n##   ..$ impressions: num [1:478066] 8 5 2 4 5 3 5 6 8 4 ...\n##   ..$ clicks     : num [1:478066] 0 0 0 0 0 1 1 0 0 0 ...\n##   ..$ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 2 2 2 2 1 2 2 2 2 ...\n##   ..$ age_group  : Ord.factor w/ 7 levels \"&lt;18\"&lt;\"18-24\"&lt;..: 3 5 3 2 2 1 6 4 4 4 ...\n##   ..$ ctr_rate   : num [1:478066] 0 0 0 0 0 0.333 0.2 0 0 0 ...\n##   ..$ female     : Factor w/ 2 levels \"no\",\"yes\": 1 2 1 1 2 2 2 2 1 2 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\n\nlist_rbind()\nFor the final step, I‚Äôll bind all the data into a data.frame with the updated purrr::list_rbind() function (set names_to = \"id\").\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |&gt; \n  # bind\n  purrr::list_rbind(names_to = \"id\") |&gt; \n  dplyr::glimpse()\n## Rows: 3,488,345\n## Columns: 9\n## $ id          &lt;chr&gt; \"dds-nyt/raw/nyt10.csv\", \"dds-nyt/raw/nyt10.csv\", \"dds-nyt‚Ä¶\n## $ age         &lt;dbl&gt; 59, 0, 19, 44, 30, 33, 41, 41, 0, 23, 28, 34, 0, 17, 33, 6‚Ä¶\n## $ gender      &lt;dbl&gt; 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0‚Ä¶\n## $ impressions &lt;dbl&gt; 4, 7, 5, 5, 4, 3, 1, 3, 9, 1, 4, 4, 7, 3, 7, 6, 6, 2, 7, 2‚Ä¶\n## $ clicks      &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n## $ signed_in   &lt;fct&gt; yes, no, yes, yes, yes, yes, yes, yes, no, yes, yes, yes, ‚Ä¶\n## $ age_group   &lt;ord&gt; 55-64, &lt;18, 18-24, 35-44, 25-34, 25-34, 35-44, 35-44, &lt;18,‚Ä¶\n## $ ctr_rate    &lt;dbl&gt; 0.000, 0.143, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.‚Ä¶\n## $ female      &lt;fct&gt; no, yes, yes, no, no, no, yes, yes, yes, no, no, no, yes, ‚Ä¶\n\n\n\nNow that we have a complete recipe, I store the result in nyt_data_proc. I can also confirm all files were imported and wrangled by checking the count() of id.\n\n\n\nshow/hide\nnyt_data_proc &lt;- raw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |&gt; \n  # bind\n  purrr::list_rbind(names_to = \"id\") \n\n\n\n\nshow/hide\nnyt_data_proc |&gt; dplyr::count(id)\n## # A tibble: 7 √ó 2\n##   id                         n\n##   &lt;chr&gt;                  &lt;int&gt;\n## 1 dds-nyt/raw/nyt10.csv 452766\n## 2 dds-nyt/raw/nyt11.csv 478066\n## 3 dds-nyt/raw/nyt12.csv 396308\n## 4 dds-nyt/raw/nyt13.csv 786044\n## 5 dds-nyt/raw/nyt7.csv  452493\n## 6 dds-nyt/raw/nyt8.csv  463196\n## 7 dds-nyt/raw/nyt9.csv  459472"
  },
  {
    "objectID": "posts/purrr1.0/index.html#export-multiple-datasets",
    "href": "posts/purrr1.0/index.html#export-multiple-datasets",
    "title": "purrr updates (v1.0.0)",
    "section": "Export multiple datasets",
    "text": "Export multiple datasets\n\nYou have a dataset you‚Äôd like to split into individual data.frames, then export these into separate file paths\n\nI have a processed dataset with seven data files (nyt_data_proc), and I want to export these into seven processed data files in a dds-nyt/processed/ folder.\nCreating a vector of processed data file paths is a little more involved because I wanted to add a date prefix to the exported files, and because I want to add this path as a variable in the nyt_data_proc dataset.\nBelow I create a new file_nm and proc_file_pth column to nyt_data_proc:\n\n\n\nshow/hide\n# create file names \nnyt_data_proc &lt;- dplyr::mutate(.data = nyt_data_proc,\n        file_nm = tools::file_path_sans_ext(base::basename(id)),\n        proc_file_pth = paste0(\"dds-nyt/processed/\", \n                        as.character(Sys.Date()), \"-\", \n                        file_nm))\nnyt_data_proc |&gt; dplyr::count(proc_file_pth)\n## # A tibble: 7 √ó 2\n##   proc_file_pth                           n\n##   &lt;chr&gt;                               &lt;int&gt;\n## 1 dds-nyt/processed/2023-07-08-nyt10 452766\n## 2 dds-nyt/processed/2023-07-08-nyt11 478066\n## 3 dds-nyt/processed/2023-07-08-nyt12 396308\n## 4 dds-nyt/processed/2023-07-08-nyt13 786044\n## 5 dds-nyt/processed/2023-07-08-nyt7  452493\n## 6 dds-nyt/processed/2023-07-08-nyt8  463196\n## 7 dds-nyt/processed/2023-07-08-nyt9  459472\n\n\n\nNote that I don‚Äôt include the file extension in proc_file_pth, because I might want to use different file types when I‚Äôm exporting.\nI‚Äôll cover two methods for exporting datasets from a list.\nIn this first method, I‚Äôll use the base::split() function to split nyt_data_proc by the proc_file_pth variable into a list of data frames. I‚Äôll also use utils::head(), purrr::walk(), and dplyr::glimpse() to view the output.\n\n\n\nshow/hide\nsplit(x = nyt_data_proc, f = nyt_data_proc$proc_file_pth) |&gt;\n  utils::head(3) |&gt; \n  purrr::walk(.f = glimpse)\n## Rows: 452,766\n## Columns: 11\n## $ id            &lt;chr&gt; \"dds-nyt/raw/nyt10.csv\", \"dds-nyt/raw/nyt10.csv\", \"dds-n‚Ä¶\n## $ age           &lt;dbl&gt; 59, 0, 19, 44, 30, 33, 41, 41, 0, 23, 28, 34, 0, 17, 33,‚Ä¶\n## $ gender        &lt;dbl&gt; 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0,‚Ä¶\n## $ impressions   &lt;dbl&gt; 4, 7, 5, 5, 4, 3, 1, 3, 9, 1, 4, 4, 7, 3, 7, 6, 6, 2, 7,‚Ä¶\n## $ clicks        &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n## $ signed_in     &lt;fct&gt; yes, no, yes, yes, yes, yes, yes, yes, no, yes, yes, yes‚Ä¶\n## $ age_group     &lt;ord&gt; 55-64, &lt;18, 18-24, 35-44, 25-34, 25-34, 35-44, 35-44, &lt;1‚Ä¶\n## $ ctr_rate      &lt;dbl&gt; 0.000, 0.143, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, ‚Ä¶\n## $ female        &lt;fct&gt; no, yes, yes, no, no, no, yes, yes, yes, no, no, no, yes‚Ä¶\n## $ file_nm       &lt;chr&gt; \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"n‚Ä¶\n## $ proc_file_pth &lt;chr&gt; \"dds-nyt/processed/2023-07-08-nyt10\", \"dds-nyt/processed‚Ä¶\n## Rows: 478,066\n## Columns: 11\n## $ id            &lt;chr&gt; \"dds-nyt/raw/nyt11.csv\", \"dds-nyt/raw/nyt11.csv\", \"dds-n‚Ä¶\n## $ age           &lt;dbl&gt; 28, 51, 29, 20, 19, 0, 58, 42, 35, 44, 62, 20, 0, 0, 43,‚Ä¶\n## $ gender        &lt;dbl&gt; 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n## $ impressions   &lt;dbl&gt; 8, 5, 2, 4, 5, 3, 5, 6, 8, 4, 6, 4, 5, 4, 4, 5, 3, 2, 5,‚Ä¶\n## $ clicks        &lt;dbl&gt; 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,‚Ä¶\n## $ signed_in     &lt;fct&gt; yes, yes, yes, yes, yes, no, yes, yes, yes, yes, yes, ye‚Ä¶\n## $ age_group     &lt;ord&gt; 25-34, 45-54, 25-34, 18-24, 18-24, &lt;18, 55-64, 35-44, 35‚Ä¶\n## $ ctr_rate      &lt;dbl&gt; 0.000, 0.000, 0.000, 0.000, 0.000, 0.333, 0.200, 0.000, ‚Ä¶\n## $ female        &lt;fct&gt; no, yes, no, no, yes, yes, yes, yes, no, yes, yes, yes, ‚Ä¶\n## $ file_nm       &lt;chr&gt; \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"n‚Ä¶\n## $ proc_file_pth &lt;chr&gt; \"dds-nyt/processed/2023-07-08-nyt11\", \"dds-nyt/processed‚Ä¶\n## Rows: 396,308\n## Columns: 11\n## $ id            &lt;chr&gt; \"dds-nyt/raw/nyt12.csv\", \"dds-nyt/raw/nyt12.csv\", \"dds-n‚Ä¶\n## $ age           &lt;dbl&gt; 29, 0, 27, 0, 69, 0, 0, 39, 53, 27, 0, 13, 26, 63, 79, 0‚Ä¶\n## $ gender        &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1,‚Ä¶\n## $ impressions   &lt;dbl&gt; 4, 1, 2, 5, 9, 1, 6, 4, 7, 3, 1, 1, 2, 5, 6, 7, 3, 1, 5,‚Ä¶\n## $ clicks        &lt;dbl&gt; 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,‚Ä¶\n## $ signed_in     &lt;fct&gt; yes, no, yes, no, yes, no, no, yes, yes, yes, no, yes, y‚Ä¶\n## $ age_group     &lt;ord&gt; 25-34, &lt;18, 25-34, &lt;18, 65+, &lt;18, &lt;18, 35-44, 45-54, 25-‚Ä¶\n## $ ctr_rate      &lt;dbl&gt; 0.250, 0.000, 0.000, 0.200, 0.111, 0.000, 0.000, 0.000, ‚Ä¶\n## $ female        &lt;fct&gt; yes, yes, yes, yes, no, yes, yes, no, yes, no, yes, no, ‚Ä¶\n## $ file_nm       &lt;chr&gt; \"nyt12\", \"nyt12\", \"nyt12\", \"nyt12\", \"nyt12\", \"nyt12\", \"n‚Ä¶\n## $ proc_file_pth &lt;chr&gt; \"dds-nyt/processed/2023-07-08-nyt12\", \"dds-nyt/processed‚Ä¶\n\n\n\nI can see this is returning a list of data frames as expected, so now I need to pass this list into purrr::walk2() so I can iterate vroom::vroom_write() over the processed data paths in proc_file_pth.\n\nFirst I create the processed data folder (dds-nyt/processed/)\n\n\n\n\nshow/hide\nfs::dir_create(\"dds-nyt/processed/\")\n\n\n\n\nSecond, I create the .x argument, which is the split list of nyt_data_proc by proc_file_pth\n\n\n\n\nshow/hide\n# split nyt_data_proc (.x)\nby_proc_pths &lt;- nyt_data_proc |&gt; \n  split(nyt_data_proc$proc_file_pth)\n\n\n\n\nThird, I get the unique processed data paths in the proc_file_pth column and store it as a vector for the .y\n\n\n\n\nshow/hide\n# get unique processed paths in nyt_data_proc (.y) with .csv extension\nproc_pths &lt;- paste0(unique(nyt_data_proc$proc_file_pth), \".csv\")\nproc_pths\n## [1] \"dds-nyt/processed/2023-07-08-nyt10.csv\"\n## [2] \"dds-nyt/processed/2023-07-08-nyt11.csv\"\n## [3] \"dds-nyt/processed/2023-07-08-nyt12.csv\"\n## [4] \"dds-nyt/processed/2023-07-08-nyt13.csv\"\n## [5] \"dds-nyt/processed/2023-07-08-nyt7.csv\" \n## [6] \"dds-nyt/processed/2023-07-08-nyt8.csv\" \n## [7] \"dds-nyt/processed/2023-07-08-nyt9.csv\"\n\n\n\nNow I can perform purrr::walk2() on by_proc_pths using proc_pths and vroom::vroom_write():\n\n\n\nshow/hide\n# iterate with .f\nwalk2(.x = by_proc_pths, .y = proc_pths, \n      .f = vroom::vroom_write, delim = \",\")\n# or as an anonymous function \n\n\n\nOr I could write this as an an anonymous function:\n\n\n\nshow/hide\nnyt_data_proc |&gt; \n  split(nyt_data_proc$proc_file_pth) |&gt; \n  walk2(.y = proc_pths, \n    \\(x, y)\n    vroom::vroom_write(x = x, \n      file = y,  delim = \",\"))\n\n\n\nI‚Äôll want to perform a sanity check on this output with the first exported item in dds-nyt/processed and check it against the nyt1_proc data to evaluate the differences.\n\n\n\nshow/hide\nnyt1_proc_check_01 &lt;- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n\n\n\nI‚Äôll check the differences with diffobj::diffStr(). Click on Code below to view the differences:\n\n\n\nshow/hide\nwaldo::compare(\n  x = names(nyt1_proc),\n  y = names(nyt1_proc_check_01), \n  max_diffs = 20)\n##     old           | new                 \n## [1] \"age\"         - \"id\"            [1] \n## [2] \"gender\"      - \"age\"           [2] \n## [3] \"impressions\" - \"gender\"        [3] \n## [4] \"clicks\"      - \"impressions\"   [4] \n## [5] \"signed_in\"   - \"clicks\"        [5] \n## [6] \"age_group\"   - \"signed_in\"     [6] \n## [7] \"ctr_rate\"    - \"age_group\"     [7] \n## [8] \"female\"      - \"ctr_rate\"      [8] \n##                   - \"female\"        [9] \n##                   - \"file_nm\"       [10]\n##                   - \"proc_file_pth\" [11]\n\n\n\nThese are differences I‚Äôd expect, given the two data frames will have slightly different columns (id, file_nm, and proc_file_pth)\n\ngroup_walk()\nAnother option involves the group_walk() function from dplyr (WARNING: this is experimental). But I need to remove the processed folder so I‚Äôm not confusing myself:\n\n\n\nshow/hide\nwalk(.x = list.files(path = \"dds-nyt/processed\", \n                     full.names = TRUE, \n                     pattern = \".csv$\"),\n    .f = fs::file_delete)\nfs::dir_tree(\"dds-nyt\", recurse = TRUE)\n## dds-nyt\n## ‚îú‚îÄ‚îÄ processed\n## ‚îî‚îÄ‚îÄ raw\n##     ‚îú‚îÄ‚îÄ nyt10.csv\n##     ‚îú‚îÄ‚îÄ nyt11.csv\n##     ‚îú‚îÄ‚îÄ nyt12.csv\n##     ‚îú‚îÄ‚îÄ nyt13.csv\n##     ‚îú‚îÄ‚îÄ nyt7.csv\n##     ‚îú‚îÄ‚îÄ nyt8.csv\n##     ‚îî‚îÄ‚îÄ nyt9.csv\n\n\n\nThe help file on group_walk() gives an example with purrr‚Äôs formula syntax (which I‚Äôve adapted below):\n\n\n\nshow/hide\nnyt_data_proc |&gt; \n  dplyr::group_by(proc_file_pth) |&gt;   \n  dplyr::group_walk( ~vroom::vroom_write(x = .x, \n                          file = paste0(.y$proc_file_pth, \".csv\"),\n                          delim = \",\"))\n\n\n\nI‚Äôve also re-written this as an anonymous function (which is more stable, since the formula syntax is no longer recommended).\n\n\n\nshow/hide\n# now re-create\nfs::dir_create(\"dds-nyt/processed/\")\nnyt_data_proc |&gt; \n  dplyr::group_by(proc_file_pth) |&gt;   \n  dplyr::group_walk(\\(x, y) \n    vroom::vroom_write(\n    x = x, \n    file = paste0(y$proc_file_pth, \".csv\"),\n    delim = \", \")\n    )\n# check\nfs::dir_tree(\"dds-nyt/processed/\", pattern = \"csv$\")\n## dds-nyt/processed/\n## ‚îú‚îÄ‚îÄ 2023-07-08-nyt10.csv\n## ‚îú‚îÄ‚îÄ 2023-07-08-nyt11.csv\n## ‚îú‚îÄ‚îÄ 2023-07-08-nyt12.csv\n## ‚îú‚îÄ‚îÄ 2023-07-08-nyt13.csv\n## ‚îú‚îÄ‚îÄ 2023-07-08-nyt7.csv\n## ‚îú‚îÄ‚îÄ 2023-07-08-nyt8.csv\n## ‚îî‚îÄ‚îÄ 2023-07-08-nyt9.csv\n\n\n\nOnce again, I‚Äôll import the first file in the new processed data folder and check it against the columns nyt1_proc_check_01 data to evaluate the differences.\n\n\n\nshow/hide\n# now re-check\nnyt1_proc_check_02 &lt;- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n\n\n\n\n\n\nshow/hide\nwaldo::compare(\n  x = names(nyt1_proc_check_01),\n  y = names(nyt1_proc_check_02), \n  max_diffs = 20)\n## `old[8:11]`: \"ctr_rate\" \"female\" \"file_nm\" \"proc_file_pth\"\n## `new[8:10]`: \"ctr_rate\" \"female\" \"file_nm\""
  },
  {
    "objectID": "posts/test-shiny-p3/index.html",
    "href": "posts/test-shiny-p3/index.html",
    "title": "Testing shiny module server functions",
    "section": "",
    "text": "This is the third post in a series on testing shiny applications. I‚Äôll cover testing shiny module server functions using the testhat package and shiny‚Äôs testServer() function."
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#testing-shiny-modules",
    "href": "posts/test-shiny-p3/index.html#testing-shiny-modules",
    "title": "Testing shiny module server functions",
    "section": "Testing shiny modules",
    "text": "Testing shiny modules\n\n\n\nShiny functions pose a couple of unique challenges for testing. First, we can‚Äôt execute shiny server functions in the console. Second, as shiny apps become more complex, it‚Äôs highly recommended to break up the code base into modules. Modules have additional challenges due to their reactivity being split between interconnected UI and server functions.\nshiny doesn‚Äôt provide a direct, built-in way to test modules, but the testServer() function addresses these challenges by testing ‚Äúreactive interactions‚Äù in module server functions. testServer() also works with testthat, which means we can structure these ‚Äòreactive interaction‚Äô tests just like other unit tests (for non-application functions)."
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#shiny-app-package",
    "href": "posts/test-shiny-p3/index.html#shiny-app-package",
    "title": "Testing shiny module server functions",
    "section": "Shiny app-package",
    "text": "Shiny app-package\ntestthat is designed to work within an R package, so I‚Äôve put together the mstsap, (i.e., a Mastering Shiny testServer app-package) to demonstrate writing tests with testServer(). The functions, modules, and applications in mstsap come from the Shiny Modules chapter of Mastering Shiny. Specifically, sections 19.3 through 19.3.4. If you haven‚Äôt read this chapter‚Äìstart there.\n\n# to get the mstsap package used in this post:\nrenv::install(\"mjfrigaard/mstsap\", prompt = FALSE)\nlibrary(mstsap)\n\n\n\n\n\n\n\nWhy create an app-package?\n\n\n\n\n\n\nA shiny app-package is a shiny application that‚Äôs been developed as (or converted to) an R package. The benefits of storing shiny apps in R packages have been well documented, but I‚Äôll summarize just a few that are specific to testing:\n\nStandardized folder structure:\n\nIf unit tests are performed with testthat, minimal setup is required to perform tests.\nusethis::use_testthat() sets up test files in the tests/testthat/ folder (to test the code in the R/ folder)\n\nRead more about using testthat with R packages here.\n\nTest extras:\n\nTest data can be placed in tests/testthat/&lt;test dir&gt;/&lt;test_data.rds&gt;\n\nThe code used to create the test data should be placed in make_&lt;test_data.rds&gt;\n\nAdditional testing functions can be stored in tests/testthat/helpers.R\n\nRead more about test helpers here.\n\nDevelopment tools:\n\nIf you‚Äôre using RStudio, tests can be run individually (testthat::test_file()) or collectively (devtools::test()), and code helpers and data are loaded using devtools::load_all()\n\nTests created with testthat remain isolated during development\n\nRead more about developing packages with RStudio in the R Packages text."
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#modules",
    "href": "posts/test-shiny-p3/index.html#modules",
    "title": "Testing shiny module server functions",
    "section": "Modules",
    "text": "Modules\nShiny modules are ‚Äòa pair of UI and server functions‚Äô designed to compartmentalize input and output IDs into distinct namespaces (‚Äúa namespace is to an ID as a directory is to a file‚Äù).\n\n‚ñà‚îÄshinyApp \n‚îú‚îÄui = ‚ñà‚îÄfluidPage \n‚îÇ      ‚îî‚îÄ‚ñà‚îÄmod_ui \n‚îÇ        ‚îî‚îÄid = \"X\" \n‚îú‚îÄserver = `function(input, output, session)` \n‚îî‚îÄ‚ñà‚îÄmod_server \n  ‚îî‚îÄid = \"X\" \n\nIn a previous post, I used the following definition for unit tests,\n\n‚ÄúA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work.‚Äù - The Art of Unit Testing, 2nd edition\n\nModules can also be broken into discrete ‚Äòunits of work‚Äô with expected ‚Äòend results.‚Äô However, the ‚Äòunit of work‚Äô for a shiny module is usually accomplished using a combination of three functions: a module UI function, a module server function, and any helper/utility functions.\n\n\n\n\n\n\nShiny module refresher\n\n\n\n\n\nModule UI functions typically wrap the layout, input, and output functions in tagList(). Module server functions contain the ‚Äòbackend‚Äô code that typically goes in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using NS() (namespace) in the UI function, and called in the server function with moduleServer().\n\nModule UI functions\nBelow is an example module UI function:\n\nmod_fun_ui &lt;- function(id) {\n  tagList(\n    numericInput(inputId = NS(namespace = id, id = \"num_input\")),\n    uiOutput(outputId = NS(namespace = id, id = \"num_out\"))\n  )\n}\n\n\nmod_fun_ui creates a dedicated namespace for one inputId and one outputId with shiny::NS():\n\n‚ñà‚îÄmod_fun_ui \n‚îú‚îÄid \n‚îî‚îÄ‚ñà‚îÄtagList \n  ‚îú‚îÄ‚ñà‚îÄnumericInput \n  ‚îÇ ‚îî‚îÄinputId = ‚ñà‚îÄNS \n  ‚îÇ             ‚îú‚îÄnamespace = id \n  ‚îÇ             ‚îî‚îÄid = \"num_input\" \n  ‚îî‚îÄ‚ñà‚îÄuiOutput \n    ‚îî‚îÄoutputId = ‚ñà‚îÄNS \n                 ‚îú‚îÄnamespace = id \n                 ‚îî‚îÄid = \"num_out\" \n\n\n\n\nModule server functions\nThe corresponding module server function is below:\n\nmod_fun_server &lt;- function(id) {\n        moduleServer(id, function(input, output, session) {\n            ns &lt;- session\n          output$num_out &lt;- uiOutput(outputId = input$num_input)\n      })\n}\n\n\nThe code to render the reactive input$num_input with output$num_out is contained in the nested call to moduleServer()\n\n‚ñà‚îÄmod_fun_server \n‚îú‚îÄid \n‚îî‚îÄ‚ñà‚îÄmoduleServer \n  ‚îú‚îÄid = id \n  ‚îú‚îÄserver = ‚ñà‚îÄ`function(input, output, session)` \n  ‚îÇ          ‚îú‚îÄ`ns &lt;- session` \n  ‚îÇ          ‚îú‚îÄ`output$num_out &lt;-` \n  ‚îÇ          ‚îî‚îÄ‚ñà‚îÄrenderUI \n  ‚îÇ            ‚îî‚îÄ`input$num_input` \n  ‚îî‚îÄsession = session \n\n\n\n\nUsing modules\nBoth module functions are combined in the ui and server arguments of shinyApp():\n\nshinyApp(\n    ui = fluidPage(\n          mod_fun_ui(id = \"mod\")\n        ),\n   server = function(input, output, session) \n          mod_fun_server(\"mod\")\n  )\n\n\nThe id arguments connect the UI and server functions to communicate between the UI and backend of the app:\n\n‚ñà‚îÄshinyApp \n‚îú‚îÄui = ‚ñà‚îÄfluidPage \n‚îÇ      ‚îî‚îÄ‚ñà‚îÄmod_fun_ui \n‚îÇ        ‚îî‚îÄid = \"mod namespace\" \n‚îî‚îÄserver = ‚ñà‚îÄ`function(input, output, session)` \n           ‚îî‚îÄ‚ñà‚îÄmod_fun_server \n             ‚îî‚îÄid = \"mod namespace\" \n\n\nI recommend creating test files when you create module files (i.e., with usethis::use_r() & usethis::use_test()).\n\n\n\n\n\nModules in mstsap\nmstsap contains three modules: dataset, selectVar, and selectDataVar. If you‚Äôre like more information on a module, click on the links in the numbered list.\n\nDataset module\n\ndatasetInput/datasetServer: loads and returns data object from the datasets package (filtered by data frames or matrices)\n\n\n\n\n\n\n(a) dataset module\n\n\nFigure¬†1: dataset module\n\n\n\nThe objects from datasets are filtered in the UI module function with a filter argument that can be used to ‚Äúlimit the options to built-in datasets that are either data frames (filter = is.data.frame) or matrices (filter = is.matrix)‚Äù. The names are passed to the choices in the selectInput():\n\n\nshow/hide choices in datasetInput()\nnames &lt;- ls(\"package:datasets\")\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n\nThe datasets object is returned with get() (wrapped in reactive()). See below:\n\n\nshow/hide returned data from datasetServer()\nshiny::reactive(\n      get(input$dataset, \"package:datasets\")\n    )\n\n\n\n\n\nselectVar module\n\nselectVarInput/selectVarServer: displays a selectInput() that ‚Äúallows the user to select variables of specified type from a given reactive dataset.‚Äù\n\n\n\n\n\n\n(a) selectVar module\n\n\nFigure¬†2: selectVar module\n\n\nThe data argument in selectVarServer() is the returned value from datasetServer():\n\ndata() is used with the filter argument in the find_vars() function:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter) {\n # I've included the updated version with the 'stopifnot()' checks!\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\nThe filter argument can be used to return variables by class/type (using is.* functions like is.numeric() or is.character())\n\nWhen data() changes, the output from find_vars() updates the choices in the variable selectInput() (i.e., input$var) (see below)\n\n\n\n\n\n\n(a) selectVar and find_vars()\n\n\nFigure¬†3: selectVar module and find_vars() function\n\n\n\nselectVarServer() also returns the selected variable (input$var) as a reactive value (var())\n\n\n\nselectDataVar module\n\nselectDataVarUI/selectDataVarServer: The selectDataVar module is from the section titled, ‚ÄúModules inside of modules‚Äù, so here we see the dataset and selectVar modules placed inside the selectDataVar module (each with a new namespace (NS())).\n\n\n\n\n\n\n(a) selectDataVar module\n\n\nFigure¬†4: selectDataVar module\n\n\n\n\n\n\n\n\nNaming modules\n\n\n\n\n\n\nWhen creating an app-packages, modules are stored in the R/ folder as a single file, typically following a naming convention that differentiates modules from the other package functions. The modules in this post use camelCase, with suffix variations (i.e., Input/Server and UI/Server) for each functions. Other options come from the golem and leprechaun packages.\ngolem modules are created with golem::add_module()\n\n\n\nexpand to see golem::add_module(‚Äúinputs‚Äù)\nmod_inputs_ui &lt;- function(id){\n  ns &lt;- NS(id)\n  tagList(\n  )\n}\nmod_inputs_server &lt;- function(id){\n  moduleServer( id, function(input, output, session){\n    ns &lt;- session$ns\n \n  })\n}\n## To be copied in the UI\n# mod_inputs_ui(\"inputs_1\")\n    \n## To be copied in the server\n# mod_inputs_server(\"inputs_1\")\n\n\n\ngolem modules the following naming convention:\n\nAll new module functions have a mod_ prefix\ngolem module functions are differentiated with either a _ui or _server suffix\nNew golem module files are named R/mod_&lt;name&gt;.R\n\nleprechaun modules are also created with a leprechaun::add_module() function.\n\n\n\nexpand to see leprechaun::add_module(‚Äúinputs‚Äù)\ninputsUI &lt;- function(id){\n    ns &lt;- NS(id)\n    tagList(\n        h2(\"inputs\")\n    )\n}\ninputs_server &lt;- function(id){\n  moduleServer(id, function(input, output, session) {\n                ns &lt;- session$ns\n                send_message &lt;- make_send_message(session)\n                # your code here\n        }\n    )\n}\n# UI\n# inputsUI('id')\n\n# server\n# inputs_server('id')\n\n\n\nleprechaun modules have a slightly different naming convention:\n\nAll new UI module functions have a UI suffix\nAll new module server functions have a _server suffix\nleprechaun module functions do not have a prefix\nNew leprechaun modules named module_&lt;name&gt;.R\n\nShiny app-packages often require multiple modules and utility functions, so uniform names will make it easier to manage (and test!) your code.\n\n\n\n\n\n\n\nStandalone app functions\nmstsap contains three standalone functions for running each set of module functions.\nI‚Äôve made a small change to each standalone app function‚Äìeach app has a call to reactiveValuesToList() that displays in the UI.\n\n\nprint reactive values\n  shiny::verbatimTextOutput(\"vals\")\n\n  output$vals &lt;- shiny::renderPrint({\n    x &lt;- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n\n\n\ndatasetApp\ndatasetApp() contains a call to the dataset module, and includes a tableOutput() to render the selected data object:\n\n\n\n\n\n(a) datasetApp\n\n\nFigure¬†5: datasetApp\n\n\nWhen datasetApp() is run, the app displays the dataset object in the tableOutput(), and the verbatimTextOutput() renders the reactive values as a text:\n\n\n\n\n\n(a) datasetApp with reactive values\n\n\nFigure¬†6: datasetApp with reactiveValuesToList()\n\n\nThe output above shows what NS() does in the dataset module‚Äìit appends the module id argument to the inputId (which is why we see dataset-dataset).\n\ndataset-: the module id\ndataset-dataset the inputId from the selectInput()\n\n\n\nselectVarApp\nselectVarApp() includes both dataset and selectVar modules, but instead of rendering the output in a table, the UI renders the variable output in a verbatimTextOutput().\n\n\n\n\n\n(a) selectVarApp\n\n\nFigure¬†7: selectVarApp\n\n\nNote that selectVarApp() contains namespaces for two modules:\n\n\"data\": the namespace for the datasetnput() and datasetServer() modules, inheriting the filter argument and creating the data object\n\"var\": the selectVar modules are linked with the \"var\" id. selectVarServer() uses the data object created by datasetServer() (and also inherits the filter argument).\n\nThese namespaced IDs are rendered below with reactiveValuesToList():\n\n\n\n\n\n(a) selectVarApp with reactive values\n\n\nFigure¬†8: selectVarApp with reactiveValuesToList()\n\n\nThere‚Äôs a lot happening in selectVarApp(), so I‚Äôve created the figure below to display the code for the modules with their displayed outputs:\n\n\n\n\n\n\n(a) selectVarApp schema\n\n\nFigure¬†9: dataset and selectVar modules with rendered outputs\n\n\n\nAs we can see, the data output from the dataset module is used to generate the vars() reactive for the verbatimTextOutput() in selectVarApp(). Note that both dataset and selectVar modules don‚Äôt contain any output functions‚Äìthese have been provided in the UI for both datasetApp() and selectVarApp().\n\n\nselectDataVarApp\nThe final app in mstsap is selectDataVarApp(). Here the inputs from dataset and selectVar have been moved into the sidebarPanel(), and the output is rendered in the mainPanel().\n\n\n\n\n\n(a) selectDataVarApp\n\n\nFigure¬†10: selectDataVarApp\n\n\nThe reactive values here show how the ‚ÄòModules inside of modules‚Äô work‚Äìby adding the additional call to NS() in the datasetInput() and selectVarInput() functions within selectDataVarUI() and selectDataVarServer(), an additional namespace is appended to the reactive values (input$dataset and input$var):\n\n\n\n\n\n(a) selectDataVarApp with reactive values\n\n\nFigure¬†11: selectDataVarApp with reactiveValuesToList()\n\n\nBelow is a figure that displays the contents of the selectDataVar modules (I‚Äôve removed the tagList() and moduleServer() for simplicity), the selectDataVarApp(), and the rendered outputs:\n\n\n\n\n\n\n(a) selectDataVarApp schema\n\n\nFigure¬†12: dataset and selectVar modules inside selectDataVar module with rendered outputs"
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#testserver",
    "href": "posts/test-shiny-p3/index.html#testserver",
    "title": "Testing shiny module server functions",
    "section": "testServer()",
    "text": "testServer()\nModule server functions can be tested the same way as a traditional shiny server function, as long as you provide the inputs and verify the correct outputs. Below I‚Äôll cover some general advice on module server tests (and the arguments in testServer()).\n\nTesting module server functions\nBefore writing tests, make sure you can answer the following:\n\nWhat is the overall purpose of the application?\n\nThis information is typically referred to as the ‚Äòbusiness logic‚Äô of the application, and should be stored in a specifications or requirements document. If I can‚Äôt answer this question, I‚Äôm probably better off not writing test for code that is likely to undergo major changes.\n\nHow does this module fit within that overall purpose?\n\nSpecifically, how does this module help the application achieve the specifications or requirements? This could also be considered the ‚Äòunit of work‚Äô and ‚Äòend result‚Äô for the module.\n\nWhat dependencies (i.e., utility functions, data, add-on packages) are required for the module to execute?\n\nIf the module depends on other functions, data, or packages to perform it‚Äôs expected behavior, those functions should either be included in the testServer() test, or have their own tests (or both).\n\n\n\nWhat should I test?\nThe items below have been compiled from Mastering Shiny, R Packages, and Engineering Production-Grade Shiny Apps:\n\nDo the inputs/outputs behave as expected?\n\nThese tests verify the module server function inputIds and outputIds are properly namespaced and accessible\n\nDoes the module contain the expected reactive values/objects?\n\nTests should verify it‚Äôs reactivity‚Äìmodule server functions will automatically recompute the outputs when it‚Äôs inputs change, so tests should verify changes to inputs produce the expected behaviors and outputs. This includes any returned values from the module (and any additional function arguments).\n\nAre the calculations correct?\n\nIf the module server function performs calculations or data manipulations, the tests should verify the module produces the correct result (ideally for a variety of inputs and edge cases).\n\nHow are errors handled in the module?\n\nWhat errors are displayed from the module? Tests should simulate scenarios that can test if the module: 1) returns errors that are informative, 2) fails silently (when appropriate), or 3) falls back to the correct default behavior.\n\n\nThe last piece of advice I‚Äôve found helpful when writing tests comes from R Packages,\n\n‚Äúfocus your time on code that you‚Äôre not sure about, is fragile, or has complicated interdependencies‚Äù\n\nThe quote isn‚Äôt in reference to testing modules or shiny application functions, but I‚Äôve found it‚Äôs easy to fall into the trap of trying to test everything when a targeted approach is more efficient (and equally valid).\nThe first test I‚Äôll perform is for datasetServer(), the module used to return a data object from the datasets package.\n\n\n\ntestServer() arguments\n\napp can be a module server function (i.e., datasetServer), or any shiny.appobj\nexpr is where I‚Äôll add the testthat expectations and other test code\nargs is a list() I can use to include any module server function arguments\n\n\n\nInputs\nI created the test file with usethis::use_test(\"datasetServer\") and the module server function is the first argument in testServer().\nI‚Äôll start by testing if the initial input value (input$dataset) in datasetServer() is set to NULL:\n\nshiny::testServer(app = datasetServer, expr = {\n  testthat::expect_equal(input$dataset, NULL)\n  cat(\"\\ndatasetServer: dataset$input is NULL\", \"\\n\")\n})\n\n\nI‚Äôll add a custom message with cat() and the inputId I‚Äôm testing, load, document, and install the package, then run the test with testthat::test_file():\ndevtools::load_all()\n‚Ñπ Loading mstsap\ndevtools::document()\n‚Ñπ Updating mstsap documentation\n‚Ñπ Loading mstsap\n\nRestarting R session...\n\nlibrary(mstsap)\n\nAnd run the test with testthat::test_file():\n\n\ntest_file(\"tests/testthat/test-datasetServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\ndatasetServer: dataset$input is NULL \n\n\n\n\n\n\n\nCreating test messages with testServer()\n\n\n\n\n\n\nThe testServer() documentation has examples of using cat() to create custom messages. I put a function for creating testServer() messages (test_cmt()) in the helper.R file (read more about test helpers here).\nIt has two arguments (test and msg), and makes it easy to print messages to the console while I‚Äôm developing tests.\n\ntest_cmt(test = \"mod_server_function\", msg = \"test contents\")\n\n       mod_server_function: test contents \n\n\n\n\n\n\nSetting test inputs\ntestServer() allows us to mimic changing application (or module) inputIds with session$setInputs() like so:\n\nsession$setInputs(inputId = \"value\")\n\nI‚Äôll demonstrate with a test for input$dataset in datasetServer():\n\n  session$setInputs(dataset = \"faithful\")\n  testthat::expect_equal(\n    object = input$dataset,\n    expected = \"faithful\")\n  test_cmt(\"datasetServer\", \"dataset$input\")\n\nThe results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetServer: dataset$input\n\n\n\nReturned values\nAny returned values from module server functions can be accessed in testServer() with session$returned(). I‚Äôll verify input$dataset returns an object from datasetServer() by testing the class of session$returned():\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"airquality\")\n  testthat::expect_equal(\n    object = class(session$returned()),\n    expected = \"data.frame\")\n  test_cmt(\"datasetServer\", \"class(session$returned())\")\n\n  session$setInputs(dataset = \"WorldPhones\")\n  testthat::expect_true(\n    object = is.matrix(session$returned()))\n  test_cmt(\"datasetServer\", \"is.matrix(session$returned())\")\n\n\nNote that both methods above can be used to check the class of the returned object.\nThe updated results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetServer: class(session$returned()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetServer: is.matrix(session$returned()) \n\nI can also use the typeof(datasets::mtcars) for a direct comparison:\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"mtcars\")\n  expect_equal(\n    # app value...\n    object = typeof(session$returned()), \n    # ...compared to actual output\n    expected = typeof(datasets::mtcars)) \n  test_cmt(\"datasetServer\", \"typeof(session$returned())\")\n\n\n\n\n\nModule server arguments\nIf the module server function has additional arguments beyond id, then it has additional functionality to verify with unit tests. To test additional module server arguments, pass these to testServer(args = list()). The args list should include named arguments from the module server function, i.e., list(arg1 = \"param1\", arg2 = \"param2\").\nFor example, selectVarServer() has data and filter arguments:\n\ndata is the returned reactive object from datasetServer()\nfilter is the function passed to the find_vars() utility function\n\n\n\n\n\n\n\n(a) dataset() -&gt; selectVar()\n\n\nFigure¬†13: Object returned from datasetServer() and passed to selectVarServer()\n\n\n\nBelow is a test for selectVarServer() using args to verify the reactive data() is datasets::mtcars:\n\nshiny::testServer(selectVarServer,\n  args = list(data = datasets::mtcars,\n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\nBut this fails with the following error:\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n‚îÄ‚îÄ Error (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ‚îÄ‚îÄ‚îÄ\nError in `(function (id, data, filter = is.numeric) \n{\n    stopifnot(shiny::is.reactive(data))\n    stopifnot(!shiny::is.reactive(filter))\n\nWhat happened?\n\nI‚Äôve included this example because it‚Äôs not in the testServer() documentation, and it‚Äôs common to pass values between modules (see here in Engineering Production-Grade Shiny Apps and here in Mastering Shiny)\n\nTesting module communication\nThe error message above tells me the issue is originating from the stopifnot() calls in selectVarServer().\n\n\n\n\n\n\nUpdating selectVarServer() and find_vars()\n\n\n\n\n\n\nBoth selectVarServer() and find_vars() are updated from their original versions to include stopifnot() checks for is.reactive(), is.data.frame() and is.function():\n\nOriginal versions:\n\nfind_vars &lt;- function(data, filter) {\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session, \"var\", choices = find_vars(data(), filter))\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\nUpdated versions:\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n\n  stopifnot(is.reactive(data))\n  stopifnot(!is.reactive(filter))\n\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session = session, \n        inputId = \"var\", \n        choices = find_vars(data(), filter)\n        )\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\n\nfind_vars &lt;- function(data, filter) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\n\n\nI‚Äôll stop a moment here to address what‚Äôs happening in each module:\n\nThe datasetServer() returns the results of input$dataset as a reactive (data())\ndata() enters selectVarServer() in the data argument\nInside selectVarServer(), two stopifnot() functions evaluate the reactivity of data and filter with shiny::is.reactive()\n\nIn datasetServer(), the return object is wrapped in the reactive() function, so the items args = list() also need to be wrapped in reactive().\nI‚Äôll re-write the test above to a more basic test using is.reactive():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data()))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n       selectVarServer: is.reactive(data()) \n‚îÄ‚îÄ Failure (test-selectVarServer.R:1:1): (code run outside of `test_that()`) ‚îÄ‚îÄ‚îÄ\nis.reactive(data()) is not TRUE\n\n`actual`:   FALSE\n`expected`: TRUE \n\nAnother failure???\n\nThe results of this test might seem confusing given my advice to wrap the args list in reactive(), but some reading of the x argument in is.reactive() will clear up the error:\n\nFor is.reactive(), an object to test. For reactive(), an expression.\n\nRemoving the parentheses from data() will result in the proper test results:\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectVarServer: is.reactive(data()) \n\n\n\nUtility functions\nNow that I have a reactive data() input, I can explore how this value is used inside selectVarServer(). To update input$var, the data() input is passed to find_vars() (a function that uses a filter argument ‚Äúused to select which variables to list‚Äù). See the example below:\n\nmstsap::find_vars(\n  data = datasets::chickwts, \n  filter = is.factor)\n## [1] \"feed\"\n\nI‚Äôll write an expectation that captures the behavior of find_vars() in selectVarServer():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::chickwts),\n              filter = is.numeric), expr = {\n  testthat::expect_equal(\n    object = find_vars(data(), is.factor),\n    expected = \"feed\")\n  test_cmt(\"selectVarServer\", \"find_vars()\")\n})\n\nThe results are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectVarServer: find_vars()\nTo verify that the returned object from selectVarServer() is the selected column, I‚Äôll need to simulate the application behavior in the tests:\n\nCreate a reactive data() input in selectVarServer():\n\n\nsetting args = list()\n  shiny::testServer(selectVarServer,\n    args = list(data = reactive(datasets::chickwts),\n                filter = is.numeric), expr = {\n\n    # include expectations below...\n\n  })\n\n\nSet the input$var and verify the input$var:\n\n\nverify input$var\n  session$setInputs(var = \"weight\")\n  testthat::expect_equal(object = input$var,\n      expected = \"weight\")\n  test_cmt(\"selectVarServer\", \"input$var\")\n\n\nSet the input$var and verify the session$returned()\n\n\nverify session$returned()\n  session$setInputs(var = \"feed\")\n  testthat::expect_equal(object = session$returned(),\n    expected = datasets::chickwts[[\"feed\"]])\n  test_cmt(\"selectVarServer\", \"session$returned()\")\n\n\n\nThe results from these tests are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectVarServer: input$var \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       selectVarServer: session$returned() \n\n\nModule outputs\nRendered outputs can be accessed in testServer() just like inputs (i.e., with output$outputId). But the modules in mstsap don‚Äôt have outputs‚Äìthese are included in the standalone app functions (datasetApp(), selectVarApp(), and selectDaraVarApp()).\nFortunately, app functions can also be passed to the app argument of testServer(). I‚Äôll use datasetApp() to demonstrate.\n\n\n\n\n\nTesting a standalone app function is similar to testing a module server function, but with a few minor differences. First, the output from the standalone app function is assigned to an object (ds_app), then placed in the app argument:\n\nds_app &lt;- datasetApp()\n  shiny::testServer(ds_app, expr = {\n\n  })\n\nTo use session$setInputs() need to include the namespace for the inputId:\n\n\n\n\n\nThe output from reactiveValuesToList() in datasetApp() shows me how to access the inputId in the datasetServer() module (i.e., input$`dataset-dataset`):\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n\n})\n\n\nOutput testing strategy\nTesting outputs with testServer() is different than testing outputs in regular unit tests, because shiny outputs are executed in the server, but then rendered in the UI. The testServer() documentation outlines a testing strategy for complex outputs:\n\n*The goal for your tests should be to ask ‚Äúis the code that I wrote producing the plot I want?‚Äù There are two components to that question:\n\nDoes the plot generate without producing an error?\nIs the plot visually correct?\n\ntestServer is great for assessing the first component here. By merely referencing output$plot in your test, you‚Äôll confirm that the plot was generated without an error.\n\nIf we replace plot with table in the advice above, the tests for datasetApp() should confirm output$data is generated without producing an error.\nInstead of writing an expectation, I‚Äôll use cat() to display the contents of output$data after setting the `dataset-dataset` input:\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n  cat(\"\\n\\toutput$data:\\n\", output$data, \"\\n\")\n})\n\nThe results from the test is below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$data:\n &lt;table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'&gt;\n  &lt;thead&gt; \n      &lt;tr&gt; \n        &lt;th style='text-align: right;'&gt; weight &lt;/th&gt; \n        &lt;th style='text-align: left;'&gt; feed &lt;/th&gt;  \n     &lt;/tr&gt; \n    &lt;/thead&gt; \n      &lt;tbody&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 179.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 160.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 136.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 227.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 217.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 168.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n   &lt;/tbody&gt; \n &lt;/table&gt; \nThe output is the HTML used to render the table in the UI. This doesn‚Äôt add a passing test, but it confirms that the table is being generated from the data() reactive.\nThe tests for datasetApp() will confirm the inputId, and verify the class and names of the data() reactive (which will be passed to the renderTable() function):\n\n  testthat::expect_equal(\n    object = input$`dataset-dataset`,\n    expected = \"chickwts\")\n  test_cmt(\"datasetApp\", \"input$`dataset-dataset`\")\n\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  test_cmt(\"datasetApp\", \"is.data.frame(data())\")\n\n  testthat::expect_equal(\n    object = names(data()),\n    expected = names(datasets::chickwts))\n  test_cmt(\"datasetApp\", \"names(data())\")\n\nI can include a test for the class of output$data, but note that this is a character output:\n\n  testthat::expect_equal(\n    object = class(output$data),\n    expected = \"character\")\n  test_cmt(\"datasetApp\", \"class(output$data)\")\n\nThe results from test_file() are below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       datasetApp: input$`dataset-dataset` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetApp: is.data.frame(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetApp: names(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetApp: class(output$data) \nThe same method can be used to test the selectVarApp(), but note this app requires passing both inputIds to session$setInputs():\n\n\nshow/hide selectVarApp() tests\nsv_app &lt;- selectVarApp()\nshiny::testServer(app = sv_app, expr = {\n  session$setInputs(`var-var` = \"Ozone\",\n                    `data-dataset` = \"airquality\")\n  # confirm contents of output$out\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n  \n  # confirm var is reactive \n  testthat::expect_true(object = is.reactive(var))\n  # confirm var input\n  testthat::expect_equal(\n    object = input$`var-var`,\n    expected = \"Ozone\")\n  # confirm data is reactive\n  testthat::expect_true(object = is.reactive(data))\n  # confirm data() is a data.frame\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  # confirm 'data' can be subsetted with 'var'\n  testthat::expect_equal(\n    object = data()[[input$`var-var`]],\n    expected = airquality[[\"Ozone\"]])\n})\n\n\n\n\nTesting nested modules\nI highly recommend viewing the output of reactiveValuesToList() if your application has nested modules. It‚Äôs easy to lose track of ids if they span multiple layers.\nWe know selectDataVarApp() contains ‚Äòmodules inside other modules‚Äô, and these layers are reflected in the namespaces:\n\n\n\n\n\nTo access the inputIds in the nested modules, we need to pass the full ‚Äòappended‚Äô namespace:\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n})\n\nAfter setting the inputs, I can confirm the contents of output$out\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$out:\n   [1]  41  36  12  18  NA  28  23  19   8  NA   7  16  11  14  18\n [16]  14  34   6  30  11   1  11   4  32  NA  NA  NA  23  45 115\n [31]  37  NA  NA  NA  NA  NA  NA  29  NA  71  39  NA  NA  23  NA\n [46]  NA  21  37  20  12  13  NA  NA  NA  NA  NA  NA  NA  NA  NA\n [61]  NA 135  49  32  NA  64  40  77  97  97  85  NA  10  27  NA\n [76]   7  48  35  61  79  63  16  NA  NA  80 108  20  52  82  50\n [91]  64  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28\n[106]  65  NA  22  59  23  31  44  21   9  NA  45 168  73  NA  76\n[121] 118  84  85  96  78  73  91  47  32  20  23  21  24  44  21\n[136]  28   9  13  46  18  13  24  16  13  23  36   7  14  30  NA\n[151]  14  18  20 \nAfter confirming output$out, I‚Äôll test the inputs:\n\n  testthat::expect_equal(\n    object = input$`var-var-var`,\n    expected = \"Ozone\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-var-var`\")\n\n  testthat::expect_equal(\n    object = input$`var-data-dataset`,\n    expected = \"airquality\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-data-dataset`\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectDataVarApp: input$`var-var-var` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectDataVarApp: input$`var-data-dataset`\nI can also verify the contents of the reactive var() inside the test:\n\n  testthat::expect_true(object = is.reactive(var))\n  test_cmt(\"selectDataVarApp\", \"is.reactive(var)\")\n  cat(\"\\n\\tvar:\\n\", var(), \"\\n\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectDataVarApp: is.reactive(var) \n\n    var:\n 41 36 12 18 NA 28 23 19 8 NA 7 16 11 14 18 14 34 6 30 11 1 11 4 32 NA NA NA 23 \n    45 115 37 NA NA NA NA NA NA 29 NA 71 39 NA NA 23 NA NA 21 37 20 12 13 NA NA NA\n    NA NA NA NA NA NA NA 135 49 32 NA 64 40 77 97 97 85 NA 10 27 NA 7 48 35 61 79 \n    63 16 NA NA 80 108 20 52 82 50 64 59 39 9 16 78 35 66 122 89 110 NA NA 44 28 \n    65 NA 22 59 23 31 44 21 9 NA 45 168 73 NA 76 118 84 85 96 78 73 91 47 32 20 23\n    21 24 44 21 28 9 13 46 18 13 24 16 13 23 36 7 14 30 NA 14 18 20"
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#recap",
    "href": "posts/test-shiny-p3/index.html#recap",
    "title": "Testing shiny module server functions",
    "section": "Recap",
    "text": "Recap\nThis post has shown how shiny‚Äôs testServer() function allows you to isolate and test module server functions, which makes it easier to ensure that your server function behaves as expected (and locate and fix bugs).\nI hope you have a better understanding of how you can use testServer() to test a modules inputs/outputs, reactivity, calculations, and errors.\nIn the next post I‚Äôll cover performing integration tests with shinytest2!"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html",
    "href": "posts/test-shiny-p4/index.html",
    "title": "Testing shiny apps with shinytest2",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\nThis is the fourth post in a series on testing shiny applications. My previous posts have covered unit testing utility functions and testing module server functions with testServer(). In this post, I‚Äôll be covering testing shiny applications using testthat and shinytest2."
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#set-up",
    "href": "posts/test-shiny-p4/index.html#set-up",
    "title": "Testing shiny apps with shinytest2",
    "section": "Set up",
    "text": "Set up\nshinytest2 requires a few steps to get up and running, so I‚Äôve included my start up steps below (in hopes that someone might find them useful).\n\nChromium\nFirst make sure you have Chromium headless browser installed. Chromium is the browser used to test and debug shiny apps with shinytest2.\nIf you‚Äôre using macOS, you can install Chromium using homebrew:\n\nbrew install --cask chromium\n\n\n\nshow/hide output\n==&gt; Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==&gt; Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==&gt; Installing Cask chromium\n==&gt; Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==&gt; Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nüç∫  chromium was successfully installed!\n\n\n\n\nchromote\nThe chromote package allows R to open Chromium. I had to make sure R knew where to find the Chromium application (this section helps) by passing the path to the app to Sys.setenv()\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\nYou can use find_chrome() to find your chrome app:\n\nchromote::find_chrome()\n\nYou can also locate the path to Chromium using by holding command ‚åò and clicking on the application icon\nThen set the CHROMOTE_CHROME environment variable to the Chromium path (make sure it‚Äôs not the path to Chrome.app:\n\n\nshow/hide\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n\n\nVerify the Chromium app/chromote install with ChromoteSession$new()\n\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n\n\n\n(a) Chromium\n\n\n\n\nFigure¬†1: Chromium headless browser\n\n\n\nGreat! Going through this step means shinytest2‚Äôs test recorder will (should) deploy when I‚Äôm recording tests."
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#app-package-contents",
    "href": "posts/test-shiny-p4/index.html#app-package-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "App-package contents",
    "text": "App-package contents\nI‚Äôve created msst2ap (i.e., Mastering Shiny shinytest2 app-package) with devtools and usethis. It somewhat resembles an application using the golem framework, but with fewer opinions. You can download msst2ap here or install it using the following:\n\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n\nThe applications in msst2ap can be run with the their standalone app functions.\n\nModules & apps\nThe modules in msst2ap are from the Modules chapter of Mastering Shiny, with a few minor adjustments. These modules create namespaces for their inputs and outputs with the shiny::NS() function, which appends a second id string to each inputId/outputId.\nEach standalone app also includes the output from shiny::reactiveValuesToList():\n\nIn the ui:\n\n# for printing reactive values in application modules\nshiny::verbatimTextOutput(\"vals\")\n\nIn the server:\n\n# for printing reactive values in application modules\noutput$vals &lt;- shiny::renderPrint({\n  x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n  print(x, width = 30, max.levels = NULL)\n}, width = 30)\n\n\n\ndataset module\nThe dataset module displays the objects in the datasets package in a selectInput() according to a filter argument (i.e., is.data.frame, is.matrix, etc.).\ndatasetServer() returns the selected object as a reactive value. Read more here.\n\n\ndatasetInput() & datasetServer()\ndatasetInput &lt;- function(id, filter = NULL) {\n  names &lt;- ls(\"package:datasets\")\n\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n}\ndatasetServer &lt;- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    shiny::reactive(get(input$dataset, \"package:datasets\"))\n  })\n}\n\n\n\ndatasetApp()\n\n\ndatasetApp()\ndatasetApp &lt;- function(filter = NULL) {\n  ui &lt;- shiny::fluidPage(\n    datasetInput(\"dataset\", filter = is.data.frame),\n    shiny::tableOutput(\"data\"),\n    \n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"dataset\")\n    output$data &lt;- shiny::renderTable(head(data()))\n    \n    # for printing reactive values in application modules\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) datasetApp()\n\n\nFigure¬†2: datasetApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nBelow the table output in datasetApp(), the reactive values displays the inputId from datasetInput() and the namespace value from the shared id argument with datasetServer():\n$`dataset-dataset`\n\n\n\nselectVar module\nThe selectVar module selects a numeric variable the data() object returned from datasetServer().\nIt has a single utility function (find_vars()) which is used to filter the columns (variables):\n\n\nshow/hide selectVarInput() & selectVarServer()\nselectVarInput &lt;- function(id) {\n  shiny::selectInput(\n    shiny::NS(id, \"var\"),\n    label = \"Variable\",\n    choices = NULL\n  )\n}\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  \n  stopifnot(shiny::is.reactive(data))\n  stopifnot(!shiny::is.reactive(filter))\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n    shiny::observe({\n      shiny::updateSelectInput(\n        session, \"var\",\n        choices = find_vars(data(), filter))\n    }) |&gt;\n      shiny::bindEvent(data())\n\n    return(\n      shiny::reactive({\n        if (input$var %in% names(data())) {\n          data()[input$var]\n        } else {\n          NULL\n        }\n      }) |&gt;\n      shiny::bindEvent(input$var)\n    )\n\n  })\n}\n\n\nI‚Äôve made a few small changes to selectVarServer():\n\nIn the original version, input$var is returned as a vector:\n\nreactive(data()[[input$var]])\n\nI‚Äôve added some validation and return input$var as a single column from data():\n\nshiny::reactive({\n    if (input$var %in% names(data())) {\n        data()[input$var]\n    } else {\n        NULL\n    }\n  }) \n\nThe find_vars() function is also below:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter = is.vector) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\nselectVarApp()\nThe selectVarApp() extends the dataset module by collecting the returned reactive value, passing it to find_vars(), and returning a single column.\n\n\nshow/hide selectVarApp()\nselectVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n            shiny::tableOutput(\"out\"),\n            shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectVarApp()\n\n\nFigure¬†3: selectVarApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe reactive values in selectVarApp() are displayed below the table:\n\n\n\n\nVariables\n\nthe 1st var is from the inputId in selectVarInput()\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module\n$`var-var` \n\n\n\nData\n\ndataset is from the inputId in datasetInput()\n$`-dataset`\ndata is the shared namespace id from the dataset module\n$`data-dataset`\n\n\n\n\n\n\nselectDataVar module\nselectDataVar is from the Modules inside of modules section, so true to form, both the dataset and selectVar modules are called inside of the UI and Server modules:\n\n\nselectDataVarUI() & selectDataVarServer()\nselectDataVarUI &lt;- function(id) {\n  shiny::tagList(\n    datasetInput(\n      shiny::NS(id, \"data\"), \n        filter = is.data.frame),\n    selectVarInput(\n      shiny::NS(id, \"var\"))\n  )\n}\nselectDataVarServer &lt;- function(id, filter = is.numeric) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n    var\n\n  })\n}\n\n\n\nselectDataVarApp()\nThe selectDataVarApp() places the inputs in the sidebarPanel() and the outputs in the mainPanel().\n\n\nselectDataVarApp()\nselectDataVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        selectDataVarUI(\"var\")\n        ),\n      shiny::mainPanel(\n        shiny::tableOutput(\"out\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n        )\n    )\n  )\n  server &lt;- function(input, output, session) {\n    var &lt;- selectDataVarServer(\"var\", filter)\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectDataVarApp()\n\n\nFigure¬†4: selectDataVarApp() in msst2ap\n\n\n\nThe reactive values from selectDataVarApp() reflect the nested module structure:\n\n\n\n\nVariables\n\nThe first var belongs to the inputId in selectVarInput(),\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module,\n$`-var-var`\nthe 3rd var is the call to the selectVar module inside selectDataVar\n$`var-var-var` \n[1] \"Ozone\"\n\n\n\nData\n\ndataset belongs to the inputId in datasetInput(),\n$`-dataset` \ndata is the shared namespace id from the dataset module,\n$`-data-dataset` \nvar is the call to the dataset module inside selectDataVar\n$`var-data-dataset` \n[1] \"airquality\"\n\n\n\n\n\n\nhistogram module\nThe final modules and application I‚Äôll use from Mastering Shiny are from the Case study: histogram section. This application uses the existing dataset and selectVar modules to pass a single variable to the render a histogram:\n\n\nshow/hide histogramOutput() & histogramServer()\nhistogramOutput &lt;- function(id) {\n  shiny::tagList(\n    shiny::numericInput(\n      shiny::NS(id, \"bins\"),\n      label = \"bins\",\n      value = 10,\n      min = 1,\n      step = 1\n    ),\n    shiny::plotOutput(\n      shiny::NS(id, \"hist\"))\n  )\n}\nhistogramServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(shiny::is.reactive(x))\n  stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    output$hist &lt;- shiny::renderPlot({\n        shiny::req(x())\n        main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main\n        )\n      }, res = 96)\n\n    output$data &lt;- shiny::renderPrint({\n      shiny::req(x())\n      print(head(x()))\n    })\n  })\n}\n\n\nI‚Äôve made some changes to the histogramServer() function (to accomodate the changes to the selectVar module).\n\nThe original renderPlot() call in histogramServer():\n\n  output$hist &lt;- renderPlot({\n    req(is.numeric(x()))\n    main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n    hist(x(), breaks = input$bins, main = main)\n  }, res = 96)\n\nThe updated renderPlot() call in histogramServer():\n\n  output$hist &lt;- shiny::renderPlot({\n    shiny::req(x())\n    main &lt;- paste0(title(), \" [bins =\", input$bins, \"]\")\n    hist(purrr::as_vector(x()),\n      breaks = input$bins,\n      main = main)\n  }, res = 96)\n\n\nAs you can see, req() is verifying x() exists, but doesn‚Äôt check it‚Äôs class with is.numeric().\nx() is also passed to purrr::as_vector() before it‚Äôs plotted with hist()\n\n\n\nhistogramApp()\n\n\nhistogramApp()\nhistogramApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    x &lt;- selectVarServer(\"var\", data)\n    histogramServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\nFigure¬†5: histogramApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe displayed reactive values in histogramApp() are described below:\n\n\n\n\nPlot\n\nThe inputId from histogramOutput() and the shared namespace id\n$`hist-bins`\n[1] 10\n\n\n\nVariables\n\nThe inputId from selectVarInput() and the shared namespace id\n$`var-var`\n[1] \"Ozone\"\n\n\n\nData\n\nThe inputId from datasetInput() and the shared namespace id\n$`data-dataset` \n[1] \"airquality\""
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#using-shinytest2",
    "href": "posts/test-shiny-p4/index.html#using-shinytest2",
    "title": "Testing shiny apps with shinytest2",
    "section": "Using shinytest2",
    "text": "Using shinytest2\nshinytest2 is extremely well documentation. I highly recommended the Get Started vignette. In the next sections, I‚Äôll cover some examples for what I‚Äôve included in the msst2ap.\n\n\n\n\n\n\nWhy shinytest2?\n\n\n\n\n\n\nWhat happened to shinytest?\nshinytest2 replaced shinytest on 2022-04-27. If you‚Äôve previously written tests with shinytest‚Äìor are curious how shinytest2 if different‚ÄìI recommend going through the Migrating from shinytest vignette.\n\n\n\n\nRun shinytest2::use_shinytest2() to create the initial files for shinytest2:\n\nshinytest2::use_shinytest2()\n\n\n\nshow/hide output from use_shinytest2()\n! Runner already found: tests/testthat.R\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚úî Adding '*_.new.png' to '.gitignore'\n‚úî Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\n‚úî Setting active project to '/projects/msst2ap'\n‚úî Adding 'shinytest2' to Suggests field in DESCRIPTION\n‚Ä¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\n‚Ä¢ Then directly refer to functions with `shinytest2::fun()`\n‚úî Setting active project to '&lt;no active project&gt;'\n\n\n\nuse_shinytest2() adds the setup-shinytest2.R script to my tests/testthat/ folder:\n\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îî‚îÄ‚îÄ setup-shinytest2.R\n\n\nThe setup-shinytest2.R file contains a single call to shinytest2::load_app_env(), which ‚ÄúExecutes all ./R files and global.R into the current environment‚Äù"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#recording-tests",
    "href": "posts/test-shiny-p4/index.html#recording-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recording tests",
    "text": "Recording tests\nNew tests with shinytest2 can be created by launching the test event recorder, which allows us interact with our application, observe it‚Äôs behavior, and record inputs, reactive values, and outputs. To record a test, run shinytest2::record_test().\nThe first argument in record_test() is the path to application. If you‚Äôve stored your application in an app.R file, record_test() will automatically load that application.\n\nIf you encounter a message telling you Chromium is disconnected, try installing the development version of chromote:\n\n# run this in the console to make sure you have dev version of chromote\nremotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\n\nIn msst2ap, the application in app.R is the histogramApp(), so the test recorder will automatically open with this application if I run record_test() (without providing the path to a shiny app).\n\nshinytest2::record_test()\n\n\nIn Chromium\n\n\n\n\n\n\n\n\n(a) shinytest2::record_test()\n\n\n\n\nFigure¬†6: record_test() with application in app.R\n\n\n\nThe app argument can also be a ‚Äúpath to a Shiny application‚Äù. For example, I have ‚Äòdevelopment‚Äô versions of each application in msst2ap in inst/dev/:\n\n\nshow/hide contents of msst2ap/inst/dev\ninst/dev\n‚îú‚îÄ‚îÄ datasetApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ histogramApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ selectDataVarApp\n‚îÇ   ‚îú‚îÄ‚îÄ DESCRIPTION\n‚îÇ   ‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n‚îÇ   ‚îú‚îÄ‚îÄ README.md\n‚îÇ   ‚îî‚îÄ‚îÄ app.R\n‚îî‚îÄ‚îÄ selectVarApp\n    ‚îú‚îÄ‚îÄ DESCRIPTION\n    ‚îú‚îÄ‚îÄ R\n    ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n    ‚îú‚îÄ‚îÄ README.md\n    ‚îî‚îÄ‚îÄ app.R\n\n9 directories, 16 files\n\n\nI can pass the path to each application to the app argument in record_test():\n\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n\nThis opens Chromium with our shiny app:\n\n\n\n\n\n\n\n\n(a) record_test(‚Äúinst/dev/histogramApp/‚Äù)\n\n\n\n\nFigure¬†7: record_test() with app in inst/dev/histogramApp/ folder\n\n\n\nThe test event recorder displays the shiny app, but also includes a window for recording each application ‚Äòevent.‚Äô\n\nExpectations\nI‚Äôll start by recording a test for histogramApp(). On the right-hand side of the Chromium headless browser, you‚Äôll see the shinytest2 expectations window:\n\n\n\n\n\n\n\n\n(a) shinytest2 expectations\n\n\n\n\nFigure¬†8: shinytest2 expectations in record_test()\n\n\n\nThe initial value in the Code window displays the dimensions of the application in Chromium (app$set_window_size(width = , height = )).\n\n\nEvents\nWhen I interact with the application (i.e., make changes to the inputs), each change is an ‚Äòevent‚Äô that is recorded in the test:\n\n\n\n\n\n\n\n\n(a) change inputs\n\n\n\n\nFigure¬†9: Changing app inputs\n\n\n\n\n\nCode\nAll events are recorded as code in the Code section of shinytest2 expectations:\n\n\n\n\n\n\n\n\n(a) shinytest2 code expectations\n\n\n\n\nFigure¬†10: Recorded code for each event\n\n\n\n\n\nExpect Shiny values\nWhen I‚Äôve finished interacting with the application, I click on the Expect Shiny values button at the top of shinytest2 expectations. This will add app$expect_values() to the Code section:\n\n\n\n\n\n\n\n\n(a) expect-shiny-values\n\n\n\n\nFigure¬†11: Expect Shiny values in shinytest2 expectations\n\n\n\n\n\nSave test and exit\nFinally, to save the test, enter a Test name and click Save test and exit\n\n\n\n\n\n\n\n\n(a) name-save-exit\n\n\n\n\nFigure¬†12: Name, save and exit record_test()\n\n\n\n\n\n\nIn Console\nBack in the Console, the shinytest2 test recorder is performing the following actions behind the scenes:\n\nThe Chromium headless browser opens with the histogramApp() and shiny is loaded\n\nListening on http://127.0.0.1:7418\n{shiny} R stderr ----------- Loading required package: shiny\n\nWarning: The first warning is a caused by the call to shiny::loadSupport(). It‚Äôs a known issue, so we can assume the developers are working on it!\n\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\n  contain an R package. Sourcing files in R/ may cause unexpected behavior.\n\nWe are told the application is being run in test mode, which ‚Äòlets the AppDriver retrieve values‚Äô from the app\n\n{shiny} R stderr ----------- Running application in test mode.\n{shiny} R stdout ----------- ‚Ñπ Loading msst2ap\n\nWarning: The tests/testthat.R file (i.e., the ‚Äòtest runner‚Äô) was overwritten and tests are now run with shinytest2::test_app()\n\nWarning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\ncall to ensure proper a testing environment.\n\nWhen I clicked ‚ÄúSave test and exit‚Äù, the changes made to tests/testthat.R and tests/testthat/test-shinytest2.R are saved:\n\n‚Ä¢ Saving test runner: tests/testthat.R\n‚Ä¢ Saving test file: tests/testthat/test-shinytest2.R\n\nA call to shinytest2::load_app_env() is added to setup-shinytest2.R and the test file (tests/testthat/test-shinytest2.R) is opened:\n\n‚úî Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n‚Ä¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n\nThe new test is saved in the tests/testthat/test-shinytest2.R file and automatically run.\n\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#test-contents",
    "href": "posts/test-shiny-p4/index.html#test-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test contents",
    "text": "Test contents\nThe contents of the test file generated from the test recorder are below:\n\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on Run Test or by using test_file() from testthat:\n\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nBecause msst2ap is a package, running tests with shinytest2 will produce the warning below:\n\n\n\nshiny::loadSupport() warning\n\n\nAs noted above, this warning is known by the shinytest2 package authors and is being addressed in a future release.\n\n\n\n\nNow that I know the first shinytest2 test is passing, I‚Äôll dive into each line in the test.\n\nAppDriver\nshinytest2 uses the AppDriver to create ‚Äúa full simulation of a Shiny app‚Äù. When recording tests, this will be the first argument (along with the name of the .png and .json snapshot testthat files, and the height and width of the ChromoteSession).\n\nThe example from the test above is below:\n\n app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n\n\n\n\nset_inputs()\nWhen recording shinytest2 tests, every change to the applications inputs will result in a call to app$set_inputs(). This function is similar to the testServer() call to session$setInputs() (i.e., the inputs are provided as ‚Äúname-value pairs‚Äù, i.e., inputId = \"value\").\n\nIn the histogramApp(), these are provided with the appended namespaces:\n\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n\n\n\n\nexpect_values()\nThe documentation on expect_values() is definitely worth reading. expect_values() is added to the test file when Expect Shiny values is clicked in the test recorder and ‚Äúcreates a list of values and compares them to the current values of the application.‚Äù\n\nexpect_values() = ‚ÄúExpect all input, output, and export values are consistent‚Äù\n\n  app$expect_values()"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#test-results",
    "href": "posts/test-shiny-p4/index.html#test-results",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test results",
    "text": "Test results\nThe results from running the new test file (test-shinytest2.R) are below:\n\n‚Ä¢ Running recorded test: tests/testthat/test-shinytest2.R\n‚úî | F W S  OK | Context\n‚úî |   2     1 | shinytest2 [6.3s]                                             \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\nTwo warnings are displayed because the test adds two new files to the tests/testthat/_snaps/ folder:\n\ntests/testthat/_snaps/\n‚îî‚îÄ‚îÄ shinytest2\n    ‚îú‚îÄ‚îÄ histogramApp-001.json\n    ‚îî‚îÄ‚îÄ histogramApp-001_.png\n\n2 directories, 2 files\n\nThese are the files new test runs will be compared against (i.e., our ‚Äòbaseline‚Äô snapshots). I‚Äôll briefly cover their contents below:\n\n_snaps\nexpect_values() generates two snapshot files in the tests/testthat/_snaps/ folder: one .png and one .json file:\n\n.png\nThe image saved in tests/testthat/_snaps/histogramApp-001_.png is below:\n\n\n\n\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (attitude and privileges).\n\n\n.json\nThe .json file saved in tests/testthat/_snaps/histogramApp-001.json contains the snapshot inputs, outputs, and exports:\n\nThe inputs show the three changed values (\"data-dataset\", \"var-var\", and \"hist-bins\").\n\n\nshow/hide snapshot inputs\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n    \"hist-bins\": 15,\n    \"var-var\": \"privileges\"\n  },\n\n\n\nThe two outputs are stored in \"hist-hist\" and \"vals\":\n\n\"hist-hist\" holds the updated image (stored in the image data hash), along with various other characteristics of the plot:\n\n\nshow/hide snapshot outputs\n  \"output\": {\n    \"hist-hist\": {\n      \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n      \"width\": 682.6640625,\n      \"height\": 400,\n      \"alt\": \"Plot object\",\n      \"coordmap\": {\n        \"panels\": [\n          {\n            \"domain\": {\n              \"left\": 27.8,\n              \"right\": 87.2,\n              \"bottom\": -0.24,\n              \"top\": 6.24\n            },\n            \"range\": {\n              \"left\": 78.79664956011726,\n              \"right\": 642.3048029692084,\n              \"bottom\": 301.08,\n              \"top\": 77.71999999999998\n            },\n            \"log\": {\n              \"x\": null,\n              \"y\": null\n            },\n            \"mapping\": {\n\n            }\n          }\n        ],\n        \"dims\": {\n          \"width\": 682.6640625,\n          \"height\": 400\n        }\n      }\n    },\n\n\n\"vals\" contains the reactive values from reactiveValuesToList():\n\n\nshow/hide snapshot outputs\n    \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n  },\n\n\nI didn‚Äôt export any values in this test, so \"export\" is empty:\n\n\nshow/hide snapshot outputs\n  \"export\": {\n\n  }\n}\n\n\n\nI‚Äôll cover this in a later test.\n\n\n\n\nNamespaces\nThe contents of the .json snapshot should look somewhat familiar for the three modules contained in histogramApp():\n\nFor example, the inputId for \"dataset\" in the datasetInput/Server module communicates between the UI and server using the shared id argument \"data\"\n\n# in datasetInput()\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n# in histogramApp()\n  shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame)\n      )\n\nThis creates the $`data-dataset` output we see the verbatimTextOutput() at the bottom of the application:\n\n$`data-dataset`\n[1] \"attitude\"\n\nIn the .json snapshot, this inputId is represented in the following \"input\":\n\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n  },\n\n\nNamespaces and inputIds will come up again if you start writing your own tests, which I‚Äôll cover below."
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#writing-tests",
    "href": "posts/test-shiny-p4/index.html#writing-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Writing tests",
    "text": "Writing tests\nThe great thing about testing with shinytest2 is the ability to interact with the AppDriver as you write tests. I‚Äôll demo writing a test for the datasetApp() by adapting the contents of test-shinytest2.R into a new test-shinytest2-datasetApp.R file.\n\ntests/testthat/\n‚îú‚îÄ‚îÄ _snaps/\n‚îÇ   ‚îî‚îÄ‚îÄ shinytest2/\n‚îÇ       ‚îú‚îÄ‚îÄ histogramApp-001.json\n‚îÇ       ‚îî‚îÄ‚îÄ histogramApp-001_.png\n‚îú‚îÄ‚îÄ setup-shinytest2.R\n‚îú‚îÄ‚îÄ test-shinytest2-datasetApp.R &lt;- new test file!\n‚îî‚îÄ‚îÄ test-shinytest2.R\n\n3 directories, 5 files\n\nIn the new test test-shinytest2-datasetApp.R file, I‚Äôll start with a call to testthat::test_that(), then create a new app object with the Chromium headless browser.\nThe namespaced standalone app function can be used to create a ds_app object, then ds_app is passed to the first argument of AppDriver$new() (I‚Äôve adjusted the height and weight to fit the datasetApp()).\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n})\n\nIn the Console, I can use app$view() to open the Chromium browser:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigure¬†13: View application with app$view()\n\n\n\nChromium displays the same app I see when I run msst2ap::datasetApp() in the console, but the headless browser has some additional developer tools (read more).\n\nSetting inputs\nIf I continue to adapt each line in test-shinytest2.R to the datasetApp(), I see that next lines set the inputIds for dataset-dataset to the attitude dataset with app$set_input() (Note that this uses the module notation above (i.e., \"id-inputId\"):\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n\nIf you can see both windows, you‚Äôll see the application values change in the Chromium browser:\n\n\n\n\n\n\n\n\n(a) app$set_inputs()\n\n\n\n\nFigure¬†14: Set application inputs with app$set_inputs()\n\n\n\n\n\nChecking inputs\nIn the previous test, I used the expect_values() to capture a list of all the app values (input, output, export). I can also capture these values in a list inside the test by including a call to app$get_values() and assigning the output to app_values.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n})\n\napp_values has a similar structure to the .json snapshot covered above (i.e., with input, output, and export):\n\nstr(app_values)\n\n\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"&lt;table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n\nI can narrow the scope of the test by using app_values to verify only the input that was changed with app$set_inputs()::\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n\nAt the end of the test, I‚Äôll add a call app$stop() to close the Chromium app.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n\n\n\nRunning tests\nI‚Äôll save the test-shinytest2-datasetApp.R file and run the test with testthat::test_file():\n\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nIf you encounter the error message below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\n‚îÄ‚îÄ Skipped tests (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚Ä¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n\nTry installing and loading chromote and shinytest2 again (this seemed to work for me).\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n\n\n\n\n\nIn the initial run of the test for datasetApp(), no snapshot files are generated because the test didn‚Äôt include a call to app$export_values().\nI see this initial test passes:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#exporting-test-values",
    "href": "posts/test-shiny-p4/index.html#exporting-test-values",
    "title": "Testing shiny apps with shinytest2",
    "section": "Exporting test values",
    "text": "Exporting test values\nThe shinytest2 documentation repeatedly recommends exporting test values from shiny applications with shiny::exportTestValues().\n\nexportTestValues()\nI‚Äôll demonstrate exporting test values from selectVarApp() by adding the following to the server function in inst/dev/app.R:\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n\n\n\nUsing system.file()\nAfter loading, documenting and installing the package, I‚Äôll create a test-shinytest2-selectVarApp.R test file and add the initial contents to create the AppDriver object:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n\nNote that to test the development version of selectVarApp(), I pass a call to system.file() to the app_dir argument (this is a similar folder structure to apps built with golem and leprechaun frameworks)\nAfter entering app$view() in the Console, the application opens in the Chromium headless browser again:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigure¬†15: View selectVarApp() application with app$view()\n\n\n\nIn the test file, I‚Äôll use app$set_values() to change the $`data-dataset` and $`var-var` inputs:\n\nChange $`data-dataset` to mtcars:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n    app$set_inputs(`data-dataset` = \"mtcars\")\n\n})\n\n\n\n\n\n\n\n\n\n\n(a) Set data-dataset\n\n\n\n\nFigure¬†16: View selectVarApp() after setting data-dataset with app$set_inputs()\n\n\n\n\nChange $`var-var` to wt:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n\n})\n\n\n\n\n\n\n\n\n\n\n(a) Set var-var\n\n\n\n\nFigure¬†17: View selectVarApp() after setting var-var with app$set_inputs()\n\n\n\n\n\nget_values()\nI‚Äôll use app$get_values() to store the exported input, output, and export test values in app_values:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values &lt;- app$get_values()\n    \n})\n\napp_values is a list (similar to the .json snapshot file), but now we‚Äôve explicitly exported values from the server in selectVarApp():\n\nnames(app_values$export)\n\n\n[1] \"data\" \"var\" \n\n\n\nexported expectations\nI can use app_values to verify the structure of each exported object:\n\ndata should be a data.frame()\n\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n\nvar should be a single column data.frame()\n\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\nOnce again, I end the test with a call to app$stop(). The completed test for selectVarApp() is below:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values &lt;- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n\nI can run the test with testthat::test_file().\n\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n\nThe results are below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#testing-complex-outputs",
    "href": "posts/test-shiny-p4/index.html#testing-complex-outputs",
    "title": "Testing shiny apps with shinytest2",
    "section": "Testing complex outputs",
    "text": "Testing complex outputs\nI‚Äôve created an adapted version of the histogramApp() in the inst/dev/gghistApp/ folder (view contents here):\n\ninst/dev/gghistApp/\n            ‚îú‚îÄ‚îÄ DESCRIPTION\n            ‚îú‚îÄ‚îÄ R/\n            ‚îÇ   ‚îî‚îÄ‚îÄ modules.R\n            ‚îú‚îÄ‚îÄ README.md\n            ‚îî‚îÄ‚îÄ app.R\n\n2 directories, 4 files\n\ngghistApp() renders a ggplot2 graph, which makes it easier to demonstrate this example of checking a plot from the shinytest2 package website.\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\n\n\n\n\n\n(b) gghistApp()\n\n\n\n\nFigure¬†18: histogramApp() vs.¬†gghistApp()\n\n\n\nThe gghistApp() is similar to histogramApp(), but instead of using hist() to generate the plot, a reactive plot_obj() is passed to shiny::renderPlot() (like the example above).\nDue to the structure of the modules in the application, the exportTestValues() function is placed in the gghistServer() function:\n\n\nshow/hide gghistServer()\ngghistServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj &lt;- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist &lt;- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |&gt;\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n\n\n\ngghistServer() is replaces histogramServer() in the standalone app function (gghistApp()):\n\n\nshow/hide gghistApp()\ngghistApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n\n    x &lt;- selectVarServer(\"var\", data)\n\n    gghistServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n      }, width = 30)\n\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\nIn the test-shinytest2-gghistApp.R test file, I‚Äôll verify the vdiffr package is installed with testthat::skip_if_not_installed(), then create the AppDriver object with a call to system.file() and set the height and width:\n\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n\nView the application in the Chromium browser by running app$view() in the Console:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigure¬†19: View gghistApp() application with app$view()\n\n\n\nI‚Äôll replicate the example from the website using the gghistApp():\n\nVerify initial input\n\nThe first expectations in the example test the default input values with app$get_value(input = ):\n\n  # Verify initial data\n  app_init_data &lt;- app$get_value(input = \"data-dataset\")\n  testthat::expect_equal(\n    object = app_init_data,\n    expected = \"BOD\")\n\n  # Verify initial variable\n  app_init_var &lt;- app$get_value(input = \"var-var\")\n  testthat::expect_equal(\n    object = app_init_var,\n    expected = \"Time\")\n\n\n\n\nSet and verify export\n\nNext, we check the exported values after changing the inputs with app$set_values() and app$get_value(export = )\n\n  # Verify exported `x()` data\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app_exp_x_01 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_01, \n    expected = mtcars[1])\n\n  # Verify exported `plot_obj()` data\n  app$set_inputs(`var-var` = \"wt\")\n  app_exp_plot_obj_01 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_01,\n    expected = purrr::as_vector(app_exp_plot_obj_01))\n\nThe bins are also set to a new value with app$set_inputs() after verifying the exported values:\n\n  # Verify `hist-bins` changes\n  app$set_inputs(`hist-bins` = 15)\n  app_set_bins_01 &lt;- app$get_value(input = \"hist-bins\")\n  testthat::expect_equal(\n    object = app_set_bins_01,\n    expected = 15)\n\n\n\n\n\n\n\n\n\n\n(a) set_inputs() and get_value() in gghistApp()\n\n\n\n\nFigure¬†20: Set inputs and get exported values in gghistApp()\n\n\n\n\n\nVerify plot with vdiffr\n\nNow we verify the plot with the exported plot_obj (in the hist module) with expect_doppelganger() from the vdiffr package.\n\n  # Verify `hist-plot_obj` changes\n  plot_obj_15 &lt;- app$get_value(export = \"hist-plot_obj\")\n  vdiffr::expect_doppelganger(\n    title = \"hist-plot_obj-15\",\n    fig = plot_obj_15)\n\n\nI saved the test file and ran the test to confirm the snapshot file was created in tests/testthat/_snaps/:\n\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n\n\n\n\nset_, get_, expect_\nThe process above is repeated with new values passed to app$set_inputs() and verified with app$get_value(export = ):\n\nThe x(), plot_obj() and hist-bins are updated again with new values:\n\n  ## Update `data` to USArrests\n  app$set_inputs(`data-dataset` = \"USArrests\")\n  app_exp_x_02 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_02,\n    expected = USArrests[1])\n\n  ## Update `var` to UrbanPop\n  app$set_inputs(`var-var` = \"UrbanPop\")\n  app_exp_plot_obj_02 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_02,\n    expected = purrr::as_vector(app_exp_plot_obj_02))\n\n  ## Update `bins` to 12\n  app$set_inputs(`hist-bins` = 12)\n  app_set_bins_02 &lt;- app$get_value(input = \"hist-bins\")\n  expect_equal(\n    object = app_set_bins_02,\n    expected = 12)\n\nThe new plot is verified again with expect_doppelganger()\n\n  ## Verify updates to `hist-plot_obj`\n  plot_obj_12 &lt;- app$get_value(export = \"hist-plot_obj\")\n  vdiffr::expect_doppelganger(\n    title = \"hist-plot_obj-12\",\n    fig = plot_obj_12)\n\n\nThis initial run of this test will show a warning again as the snapshot file is saved to tests/testthat/_snaps/:\n\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n‚îÄ‚îÄ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp ‚îÄ‚îÄ‚îÄ\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n\n\n\n\nResults\nThe final results of the test-shinytest2-gghistApp.R are below:\n\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n\nThe vector in each plot_obj() test is printed with expect_doppelganger(), but this doesn‚Äôt interfere with the results.\nI can run devtools::test() to run all the tests in msst2ap:\n\ndevtools::test()"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#recap",
    "href": "posts/test-shiny-p4/index.html#recap",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recap",
    "text": "Recap\nThis post has covered creating tests with testthat and shinytest2 for an app-package containing a shiny application (with modules!). As you can see, the test recorder makes it easier to test specific app behaviors, and the AppDriver makes it possible to build a set of test expectations iteratively. Other items to consider when writing shinytest2 tests include:\n\nDefine What to Test: Since Shiny apps are interactive, so shinytest2 tests should simulate user interaction as much as possible. The tests should focus on key user interactions and the output they should generate. shinytest2 provides functions for simulating user clicks, inputs, and other interactions. Not every interaction needs to be tested, but crucial ones and those that handle complex logic should be.\nOrganize Your Tests & Use Descriptive Test Names: Organize your tests into separate files based on what they are testing. Each test should have a descriptive name that clarifies what the test is for. Organizing your test files with unambiguous names will make it easier to manage multiple tests, and it will make it easier to understand what‚Äôs going wrong when a test fails.\nCreate snapshots for expected outputs: Use snapshot files to verify that an app‚Äôs output matches the expected results. AppDriver$expect_values() generates .json and .png snapshot files for the application. The .json file contains input, output, and export values, and the .png file is a debug screenshot, which records how the app looked when the values where captured. These files can then be compared to a baseline snapshot.\nExport app values: While snapshot files are great for detecting changes, it‚Äôs important to remember that ‚Äúdifferences in the captured screenshot will never cause test failures.‚Äù Manually inspecting the snapshot .png files during test development can also be time-consuming and tedious. Wherever possible, export app values and compare them against expected reference values.\n\nIn general, shinytest2 is designed for end-to-end testing of shiny applications. These tests can capture the state of a shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots), which is useful for regression testing.\nshinytest2 tests can also simulate user interaction in a way that shiny::testServer() tests can‚Äôt, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. shinytest2 can also be resource-intensive, so it‚Äôs recommended to write these tests after you‚Äôve completed the standard testthat unit tests and testServer() tests."
  },
  {
    "objectID": "posts/duap/index.html",
    "href": "posts/duap/index.html",
    "title": "Creating shiny app-packages",
    "section": "",
    "text": "In this post, I‚Äôll be using devtools and usethis to develop duap, an R package that contains a shiny application (i.e., devtools/usethis app-package).\nThe R package development workflow is well documented in R Packages and Mastering Shiny. I‚Äôve written this post because I frequently encountered R developers who were comfortable with shiny application development, but had never developed an R package.\nThis post walks through converting an existing shiny application into an app-package in detail because R package development differs from creating a standalone shiny application. My hope is that by reading this will prevent you from having to rebuild your application entirely from scratch.\nI‚Äôve organized the app-package development process into three areas: Start, Build, and Use.\nThe GitHub repo with the code for duap is located here if you‚Äôd like to follow along."
  },
  {
    "objectID": "posts/duap/index.html#from-console",
    "href": "posts/duap/index.html#from-console",
    "title": "Creating shiny app-packages",
    "section": "From Console",
    "text": "From Console\nIf I am creating a package from the console, the function for building a new package is usethis::create_package():\n\nusethis::create_package(path = \"duap\")\n\nA new RStudio session will open (and the name of the project‚Äìi.e., the name of the .Rproj file‚Äìwill be identical to the package name)."
  },
  {
    "objectID": "posts/duap/index.html#from-project-wizard",
    "href": "posts/duap/index.html#from-project-wizard",
    "title": "Creating shiny app-packages",
    "section": "From Project Wizard",
    "text": "From Project Wizard\nIf I am using RStudio‚Äôs New Project Wizard to create a new shiny app package, I‚Äôd see the following defaults:\n\n\n\n\n\n\n\nFigure¬†1: Default usethis::create_package project setup\n\n\nThe new package built from the console will have the following folder and files:\nduap/\n  ‚îú‚îÄ‚îÄ DESCRIPTION\n  ‚îú‚îÄ‚îÄ NAMESPACE\n  ‚îú‚îÄ‚îÄ R/\n  ‚îî‚îÄ‚îÄ duap.Rproj\n  \n1 directory, 3 files\nPackages built from the New Project Wizard will have a few additional folders and files:\nduap/\n  ‚îú‚îÄ‚îÄ DESCRIPTION\n  ‚îú‚îÄ‚îÄ NAMESPACE\n  ‚îú‚îÄ‚îÄ R/\n  ‚îÇ   ‚îî‚îÄ‚îÄ hello.R\n  ‚îú‚îÄ‚îÄ man/\n  ‚îÇ   ‚îî‚îÄ‚îÄ hello.Rd\n  ‚îú‚îÄ‚îÄ myRPkg.Rproj\n  ‚îî‚îÄ‚îÄ renv/\n      ‚îú‚îÄ‚îÄ activate.R\n      ‚îú‚îÄ‚îÄ sandbox/\n      ‚îÇ   ‚îî‚îÄ‚îÄ R-4.2\n      ‚îî‚îÄ‚îÄ settings.dcf\n\n4 directories, 7 files\nThese additional files are:\n\nhello.R in the R/ folder\n\nhello.Rd in the man/ folder\n\na renv/ folder for package management\n\nR/hello.R and man/hello.Rd are boilerplate files and can be deleted, but both package setups have a DESCRIPTION, NAMESPACE, R/ folder, and .Rproj file. These four items can be thought of as the ‚Äòminimal package‚Äô setup required to access RStudio‚Äôs Build tools."
  },
  {
    "objectID": "posts/duap/index.html#metadata-files",
    "href": "posts/duap/index.html#metadata-files",
    "title": "Creating shiny app-packages",
    "section": "Metadata files",
    "text": "Metadata files\nR packages have two metadata files: DESCRIPTION and NAMESPACE. Neither of these files have extensions, and both contain vital information for your package to function properly.\nWe‚Äôll manually edit the DESCRIPTION file, but the NAMESPACE file is automatically generated during the development process.\n\nDESCRIPTION\nThe DESCRIPTION file plays an important role in R packages‚Äìthat‚Äôs why creating this file is the first step when converting an existing app (and when creating a new golem apps).\n\n\n\n\n\n\nDESCRIPTION files\n\n\n\n\n\n\n\n\n\n\n\n‚ÄòRStudio and devtools consider any directory containing DESCRIPTION to be a package‚Äô - R Packages\n\n\n\n\nThe initial DESCRIPTION file in duap is below:\nPackage: duap\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", \n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\nThe package name is automatically added, but the remaining fields need to be completed (consult R packages for more information on filling out the DESCRIPTION file).\nThe DESCRIPTION file in the duap prompts the RStudio IDE to activate the Build tools pane (see below):\n\n\n\n\n\n\n\nFigure¬†2: Package Build tools"
  },
  {
    "objectID": "posts/duap/index.html#application-code",
    "href": "posts/duap/index.html#application-code",
    "title": "Creating shiny app-packages",
    "section": "Application code",
    "text": "Application code\nThe contents of the app.R and utils.R need to be moved into the R/ folder. When developing R packages, new .R files are created with usethis::use_r().\n\nuse_r()\nI‚Äôm going to create duap using modules to separate the app into the following digestible mental ‚Äòchunks‚Äô:\n\nThe app collects the inputs in the shiny::sidebarPanel()\nThese values are then used to create a plot in the shiny::mainPanel()\n\nBased on this layout, I‚Äôll create one module to collect and return the user-inputs (mod_var_input), and another module to display the plot (mod_display_plot).\nI‚Äôll create these files using usethis::use_r() below:\n\nusethis::use_r(\"mod_var_input\")\n\n‚úî Setting active project to '/Users/mjfrigaard/projects/duap'\n‚Ä¢ Modify 'R/mod_var_input.R'\n‚Ä¢ Call `use_test()` to create a matching test file\n\nusethis::use_r(\"mod_display_plot\")\n\n‚Ä¢ Modify 'R/mod_display_plot.R'\n‚Ä¢ Call `use_test()` to create a matching test file\nThe display module also relies on a utility function (plot_points()), so I need to create a script for the utility function, which I put in a file with a name similar to the module it belongs to (i.e., utils_display_plot).\n\nusethis::use_r(\"utils_display_plot\")\n\n‚Ä¢ Modify 'R/utils_display_plot.R'\n‚Ä¢ Call `use_test()` to create a matching test file\nFinally, I‚Äôll place the modules into basic ui and server arguments in a call to shiny::shinyApp():\n\nusethis::use_r(\"moviesApp\")\n\n‚Ä¢ Modify 'R/moviesApp.R'\n‚Ä¢ Call `use_test()` to create a matching test file\nModules consist of two functions; one in the UI (with a _ui suffix), and another in the server (with a _server suffix), but it‚Äôs common practice to combine them in a single file.\nBelow is the mod_var_input module:\n\nThe ui function is stored in mod_var_input_ui:\n\nClick on Code to view the UI function in R/mod_var_input/R\n\n\n\nshow/hide\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\nThe server function is stored in mod_var_input_server:\n\nClick on Code to view the server function in R/mod_var_input/R\n\n\n\nshow/hide\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n      list(\n        \"x\" = shiny::reactive({\n          input$x\n        }),\n        \"y\" = shiny::reactive({\n          input$y\n        }),\n        \"z\" = shiny::reactive({\n          input$z\n        }),\n        \"alpha\" = shiny::reactive({\n          input$alpha\n        }),\n        \"size\" = shiny::reactive({\n          input$size\n        }),\n        \"plot_title\" = shiny::reactive({\n          input$plot_title\n        })\n      )\n    )\n  })\n}\n\n\n\nView the display module here.\n\n\n\n\nStandalone app function\nAfter I‚Äôve written the modules and utility functions, I need to add these into a standalone app function moviesApp() (stored in R/moviesApp.R).\n\nThis file contains a call to shiny::shinyApp() and includes the module functions (in their relative positions)\n\nNote the ids in each module function pair must match to create the shared namespace.\n\n\nmoviesApp &lt;- function() {\n  # call to shinyApp()\n  shiny::shinyApp(\n\n    # UI ----\n    ui = shiny::fluidPage(\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          # UI input module ----\n          mod_var_input_ui(\"vars\")\n        ),\n        # UI display module ----\n        shiny::mainPanel(\n          mod_display_plot_ui(\"plot\")\n        )\n      )\n    ),\n\n    server = function(input, output, session) {\n      # server input module (capturing inputs) ----\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n      # server display module (rendering outputs) ----\n      mod_display_plot_server(\"plot\", \n                              var_inputs = selected_vars)\n    }\n  )\n}\n\n\n\n\nroxygen2\nWhen I‚Äôm confident my code works (and the app renders), I want to make sure these functions are properly documented by describing each function with roxygen2 tags. To quickly insert a roxygen2 skeleton, use the RStudio IDE (or the keyboard shortcut: Option + Shift + Command + R)\nThe standard roxygen2 skeleton tags include @param, @return, @export, and @examples\n\n@param lists the existing arguments (or variables) for the function\n@return should be a description of the object/side-effect/thing the function produces (and any warnings or errors if used incorrectly)\n\nThe following roxygen2 tags will be used to update the NAMESPACE file (which you should never edit manually!)\n\n@export will make the function available to other people when they use your package\n@importFrom vs.¬†@import\n\nit‚Äôs always a good idea to be explicit about the external functions and packages you‚Äôre using, so most of the time you should use @importFrom (there‚Äôs even a handy helper usethis::use_import_from(\"package\", \"function\"))\n\n@import should only be used when ‚Äúyou make such heavy use of so many functions from another package that you want to import its entire namespace. This should be relatively rare.‚Äù\n\n\nroxygen2 imports and exports are covered in more depth in R packages..\nYou can see the full code for point_plot() below (or follow this link to view all the modules in the R/ folder):\n\nClick on Code to view\n\n\n\nshow/hide\n#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return plot object\n#' @export point_plot\n#'\n#' @importFrom ggplot2 ggplot aes geom_point\n#'\n#' @examples\n#' require(duap)\n#' movies &lt;- duap::movies\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n#' }\npoint_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\n\n\n\nTip: roxygen2 skeleton\n\n\n\n\n\n\nAs well as generating .Rd files, roxygen will also create a NAMESPACE for you, and will manage the Collate field in DESCRIPTION\n\n\n\n\n\n\n\nFigure¬†3: Standard roxygen2 skeleton"
  },
  {
    "objectID": "posts/duap/index.html#test-drive",
    "href": "posts/duap/index.html#test-drive",
    "title": "Creating shiny app-packages",
    "section": "Test drive",
    "text": "Test drive\n\n\n‚ÄúThe load_all() function is arguably the most important part of the devtools workflow.‚Äù - R Packages, 2ed\n\n\nYou‚Äôll use the devtools::load_all() function frequently while you‚Äôre developing your app-package. load_all() simulates how your functions will work when someone else uses your package. This removes the need to define them in the global workspace. It also gives you access to the functions from any add-on packages you‚Äôve imported into your NAMESPACE (i.e., you won‚Äôt need to run library()).\nI highly recommend using the keyboard shortcuts:\n\n\n\n\n\n\ndevtools::load_all() keyboard shortcuts\n\n\n\n\n\nmacOS: Cmd + Shift + L\nWindows/Linux: Ctrl + Shift + L\n\n\n\n\nThe full benefits of using load_all() are covered in R packages.\n\nload_all()\nAfter documenting everything with roxygen2, I want to make sure none of the functions are in my Environment (remove with rm() if necessary) and load the functions with devtools::load_all().\n\ndevtools::load_all()\n\n‚Ñπ Loading duap"
  },
  {
    "objectID": "posts/duap/index.html#namespace-help-pages",
    "href": "posts/duap/index.html#namespace-help-pages",
    "title": "Creating shiny app-packages",
    "section": "NAMESPACE & Help pages",
    "text": "NAMESPACE & Help pages\ndevtools::document() processes the roxygen2 tags to generate the NAMESPACE and the .Rd files in the man/ folder. The .Rd files are used to access the help files (i.e., package::function() can be accessed with ??function).\nManaging your package NAMESPACE file is not something you do directly: it‚Äôs handled with the roxygen2 tags we covered above. The keyboard shortcuts for devtools::document() are below:\n\n\n\n\n\n\ndevtools::document() keyboard shortcuts\n\n\n\n\n\nmacOS: Cmd + Shift + D\nWindows/Linux: Ctrl + Shift + D\n\n\n\n\n\ndocument()\nRun devtools::document() when you‚Äôve written a new function with roxygen2 tags or included a package in the DESCRIPTION file under Imports:\n\ndevtools::document()\n\n‚Ñπ Updating duap documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\n‚Ñπ Loading duap\nWriting NAMESPACE\nWriting mod_plot_ui.Rd\nWriting mod_plot_server.Rd\nWriting point_plot.Rd\nWriting mod_var_input_ui.Rd\nWriting mod_var_input_server.Rd\nWriting moviesApp.Rd\n\nNAMESPACE != DESCRIPTION\nIt‚Äôs important to understand that devtools::document() will use the roxygen2 tags to create the man/*.Rd files and update the NAMESPACE, but devtools::document() does not update the Imports: section in the DESCRIPTION.\nTo add packages dependencies to the DESCRIPTION, you‚Äôll need to use the usethis::use_package() function. Read more on this topic in Confusion about Imports.\nThe table below shows the connection between roxygen2 tags, the resulting NAMESPACE entry, and what should be listed in the DESCRIPTION.\n\n\n\n\n\n\n\nroxygen2, NAMESPACE & DESCRPTION\n\n\n\n\n\n\n\n\n\n\n\nroxygen2 tag\n\n\nNAMESPACE directive\n\n\nAdded in DESCRIPTION\n\n\n\n\n\n\n@importFrom\n\n\nimportFrom() : import selected object from another NAMESPACE\n\n\nNothing\n\n\n\n\n@import\n\n\nimport(): import all objects from another package‚Äôs NAMESPACE.\n\n\nImports:\n\n\n\n\n@export\n\n\nexport() : export the function, method, generic, or class so it‚Äôs available outside of the package (in the NAMESPACE)\n\n\nNothing"
  },
  {
    "objectID": "posts/duap/index.html#checking-installation",
    "href": "posts/duap/index.html#checking-installation",
    "title": "Creating shiny app-packages",
    "section": "Checking installation",
    "text": "Checking installation\nAfter loading and documenting the duap package, I want to make sure I can install the package into my library with devtools::install(). The keyboard shortcut for devtools::install() is below:\n\n\n\n\n\n\ndevtools::document() keyboard shortcuts\n\n\n\n\n\nmacOS: Cmd + Shift + B\nWindows/Linux: Ctrl + Shift + B\n\n\n\n\n\ninstall()\n\ndevtools::install()\n\n‚îÄ‚îÄ R CMD build ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚úî  checking for file ‚Äò/Users/mjfrigaard/projects/duap/DESCRIPTION‚Äô ...\n‚îÄ  preparing ‚Äòduap‚Äô: (1.8s)\n‚úî  checking DESCRIPTION meta-information\n‚îÄ  checking for LF line-endings in source and make files and shell scripts (520ms)\n‚îÄ  checking for empty or unneeded directories\n   Omitted ‚ÄòLazyData‚Äô from DESCRIPTION\n‚îÄ  building ‚Äòduap_0.1.0.tar.gz‚Äô\n   \nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD INSTALL \n  --install-tests \n* installing to library ...\n* installing *source* package ‚Äòduap‚Äô ...\n** using staged installation ...\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (duap)\nRestart your R session and ensure you have a clean workspace:\n   Restarting R session...\n\n* Project '~/projects/duap' loaded. [renv 0.16.0]\nThen load your package with library():\n\nlibrary(duap)\n\nYou can also use Install icon in the Build pane, which installs the package, restarts the R session, and loads the package all with one click!\n\n\n\n\n\n\n\nFigure¬†4: Build install package\n\n\n\n\n\n\n\n\n\nFigure¬†5: Build restart and load\n\n\n\nRecap: the R/ folder\nThe sequence I‚Äôve demonstrated above (create .R file, write function, document with roxygen2, load, document, install) is the ‚Äòminimal version‚Äô of the full development workflow.\nOnce a ‚Äòbeta‚Äô version of the app is deployed, you will want to come back to the app to refactor, write tests, and make sure all the items in devtools::check() pass.\nStoring the application‚Äôs code in the R/ folder and (using RStudio‚Äôs build tools) keeps files organized, well documented, and self-contained:\n\nAll the code is stored in the R/ folder\nI‚Äôve separated my code into smaller pieces (modules) that can be tested independently (more on this later)\nMy dependencies are being managed by roxygen2 and devtools::document(), which will update the NAMESPACE with any functions tagged with @importFrom (or @import)\n\nI can also access functions I‚Äôve written outside by adding @export\n\n\n\n\n\n\n\n\n\nFigure¬†6: Function documentation in man/ folder\n\n\nNow that I have the R version/package management being tracked and stored with renv/ & renv.lock, function documentation in the .Rd files, the DESCRIPTION and NAMESPACE, I can move onto adding and using data in a shiny app package."
  },
  {
    "objectID": "posts/duap/index.html#additional-package-files",
    "href": "posts/duap/index.html#additional-package-files",
    "title": "Creating shiny app-packages",
    "section": "Additional package files",
    "text": "Additional package files\nMost app-packages will require files beyond the .R files in the R/ folder. Apps will often use data files when they‚Äôre deployed, which we‚Äôll cover next.\n\nuse_data_raw()\nusethis::use_data() or usethis::use_data_raw() make it simple to add data to the application package:\n\nusethis::use_data_raw(\"movies\")\n\n‚úî Creating 'data-raw/'\n‚úî Writing 'data-raw/movies.R'\n‚Ä¢ Modify 'data-raw/movies.R'\n‚Ä¢ Finish the data preparation script in 'data-raw/movies.R'\n‚Ä¢ Use `usethis::use_data()` to add prepared data to package\nIn the data-raw/movies.R script, I want to import the movies.RData file, but where should I import it from? It depends. In R packages, data is stored in either data/ or data-raw/. To access a copy of the movies dataset in duap (i.e., with duap::movies), I can place the movies.RData file in data-raw/ and import it by adding the following to data-raw/movies.R:\n## code to prepare `movies` dataset goes here\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\nNote data-raw/movies.R includes a call to usethis::use_data(), and when it‚Äôs executed, I can see a data/ folder is created and movies is saved as movies.rda:\n\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n\n‚úî Adding 'R' to Depends field in DESCRIPTION\n‚úî Creating 'data/'\n‚úî Saving 'movies' to 'data/movies.rda'\n‚Ä¢ Document your data (see 'https://r-pkgs.org/data.html')"
  },
  {
    "objectID": "posts/duap/index.html#installed-package-files",
    "href": "posts/duap/index.html#installed-package-files",
    "title": "Creating shiny app-packages",
    "section": "Installed package files",
    "text": "Installed package files\nThe inst/ folder plays a special role when developing R packages:\n\n\n‚ÄúWhen a package is installed, everything in inst/ is copied into the top-level directory of the installed package‚Äù - R Packages, 2ed\n\n\nConsider the example folder and files below: file.txt, CITATION, and extdata/my_data.csv:\n\n\n\nSource (development) form\ninst/\n  ‚îú‚îÄ‚îÄ file.txt\n  ‚îú‚îÄ‚îÄ CITATION\n  ‚îî‚îÄ‚îÄ extdata/\n        ‚îî‚îÄ‚îÄ my_data.csv\n\n\nBinary (installed) form\nfile.txt\nCITATION\nextdata/\n  ‚îî‚îÄ‚îÄ my_data.csv\n\n\n\nThe neat thing about the inst/ folder is that after we‚Äôve loaded and installed our package, we can access the files in inst/extdata/ with the system.file() function:\nIf I want to test functions in duap using movies.RData (or another dataset), those should be placed in inst/extdata/\n\ninst/\nA great way to understand what files are available in inst/ when your package is to pass system.file() to fs::dir_tree():\n\nfs::dir_tree( # wrap this in a folder tree\n  system.file(package = \"duap\"))\n\n\n\nexpand to see inst/ folder contents\n/path/to/installed/package/duap\n‚îú‚îÄ‚îÄ DESCRIPTION\n‚îú‚îÄ‚îÄ INDEX\n‚îú‚îÄ‚îÄ LICENSE\n‚îú‚îÄ‚îÄ Meta\n‚îÇ   ‚îú‚îÄ‚îÄ Rd.rds\n‚îÇ   ‚îú‚îÄ‚îÄ data.rds\n‚îÇ   ‚îú‚îÄ‚îÄ features.rds\n‚îÇ   ‚îú‚îÄ‚îÄ hsearch.rds\n‚îÇ   ‚îú‚îÄ‚îÄ links.rds\n‚îÇ   ‚îú‚îÄ‚îÄ nsInfo.rds\n‚îÇ   ‚îî‚îÄ‚îÄ package.rds\n‚îú‚îÄ‚îÄ NAMESPACE\n‚îú‚îÄ‚îÄ R\n‚îÇ   ‚îú‚îÄ‚îÄ duap\n‚îÇ   ‚îú‚îÄ‚îÄ duap.rdb\n‚îÇ   ‚îî‚îÄ‚îÄ duap.rdx\n‚îú‚îÄ‚îÄ data\n‚îÇ   ‚îú‚îÄ‚îÄ Rdata.rdb\n‚îÇ   ‚îú‚îÄ‚îÄ Rdata.rds\n‚îÇ   ‚îî‚îÄ‚îÄ Rdata.rdx\n‚îú‚îÄ‚îÄ extdata\n‚îÇ   ‚îî‚îÄ‚îÄ movies.RData\n‚îú‚îÄ‚îÄ help\n‚îÇ   ‚îú‚îÄ‚îÄ AnIndex\n‚îÇ   ‚îú‚îÄ‚îÄ aliases.rds\n‚îÇ   ‚îú‚îÄ‚îÄ duap.rdb\n‚îÇ   ‚îú‚îÄ‚îÄ duap.rdx\n‚îÇ   ‚îú‚îÄ‚îÄ figures\n‚îÇ   ‚îî‚îÄ‚îÄ paths.rds\n‚îî‚îÄ‚îÄ html\n    ‚îú‚îÄ‚îÄ 00Index.html\n    ‚îî‚îÄ‚îÄ R.css\n\n\nThe system.file() function will show me the path to the locally installed version of the package (hence the /path/to/installed/package/ at the beginning of the path).\nThe inst/exdata/ folder comes in handy for adding example data, but it‚Äôs also useful for application development (more on that later).\n\n\n\n\n\n\nThe inst/ folder\n\n\n\n\nTake a look at the inst/extdata/ folder readr::readr_example() function to understand more about how this works.\n\n\n\n\nRecap: data and installed files\nR Packages have a consistent and standardized way of storing data, and have designated locations for internal and external data.\n\n\n\n\n\n\n\nFigure¬†7: Package data folders"
  },
  {
    "objectID": "posts/duap/index.html#documentation",
    "href": "posts/duap/index.html#documentation",
    "title": "Creating shiny app-packages",
    "section": "Documentation",
    "text": "Documentation\nFunction documentation is handled with the R/ folder and roxygen2 comments/tags, but duap needs a README file, and a place for long-form documentation. Fortuntely, RMarkdown handles each of these well:\n\nuse_readme_rmd()\nI can create a README file using usethis::use_readme_md() or usethis::use_readme_rmd()\n\nI prefer the .Rmd file because it comes with executable code chunks.\n\nusethis::use_readme_rmd()\n\n‚úî Setting active project to '/Users/mjfrigaard/projects/duap'\n‚úî Writing 'README.Rmd'\n‚úî Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n‚Ä¢ Modify 'README.Rmd'\n‚Ä¢ Update 'README.Rmd' to include installation instructions.\n‚úî Writing '.git/hooks/pre-commit'\n\nWhen I knit README.Rmd, it automatically generates the README.md for the package.\n\n\n\n\nuse_vignette()\nFor long-form documentation I can use vignettes.\n\nVignettes can be created with usethis::use_vignette()\n\nusethis::use_vignette(\"duap\")\n\n‚úî Adding 'knitr' to Suggests field in DESCRIPTION\n‚úî Setting VignetteBuilder field in DESCRIPTION to 'knitr'\n‚úî Adding 'inst/doc' to '.gitignore'\n‚úî Creating 'vignettes/'\n‚úî Adding '*.html', '*.R' to 'vignettes/.gitignore'\n‚úî Adding 'rmarkdown' to Suggests field in DESCRIPTION\n‚úî Writing 'vignettes/duap.Rmd'\n‚Ä¢ Modify 'vignettes/duap.Rmd'\n\nVignettes are also written in RMarkdown and rendered whenever the package is built/installed.\nduap/\n    ‚îî‚îÄ‚îÄ vignettes/\n            ‚îî‚îÄ‚îÄ duap.Rmd\n\n1 directory, 1 file\nBy combining rmarkdown and knitr, R packages have a documentation framework that has the added benefit of being somewhat fool-proof: vignettes have to successfully render for the package to be installed.\n\n\n\n\n\n\n\nFigure¬†8: Package vignettes\n\n\n\n\n\n\n\n\nVignette figures\n\n\n\n\n\n\nImages in vignettes are kept in man/figures/\nduap/\n  ‚îú‚îÄ‚îÄ vignettes/\n  ‚îÇ       ‚îî‚îÄ‚îÄ duap.Rmd\n  ‚îî‚îÄ‚îÄ man/\n      ‚îî‚îÄ‚îÄ figures/\n          ‚îî‚îÄ‚îÄ duap-img-1.png\n\n\n\n\n\n\nRecap: documentation\nThe vignettes folder will long-form documentation about how the application works, use cases, and features (and roxygen2 will document each function).\n\n\n\n\n\n\n\nFigure¬†9: Documentation in README and vignettes/"
  },
  {
    "objectID": "posts/duap/index.html#tests",
    "href": "posts/duap/index.html#tests",
    "title": "Creating shiny app-packages",
    "section": "Tests",
    "text": "Tests\nTesting is an important part of any package, and apps tend to require additional tests (especially when they‚Äôre moving from ‚Äòdevelopment‚Äô into ‚Äòproduction‚Äô environments).\n\nuse_testthat()\nTo apply the testing framework provided by the testthat package. package, I‚Äôll use usethis::use_testthat():\n\nusethis::use_testthat()\n\n‚úî Adding 'testthat' to Suggests field in DESCRIPTION\n‚úî Setting Config/testthat/edition field in DESCRIPTION to '3'\n‚úî Creating 'tests/testthat/'\n‚úî Writing 'tests/testthat.R'\n‚Ä¢ Call `use_test()` to initialize a basic test file and open it for editing.\nThis creates a new tests/ folder, with a testthat/ sub-folder and script.\nduap/\n    ‚îî‚îÄ‚îÄ tests/\n          ‚îú‚îÄ‚îÄ testthat/\n          ‚îî‚îÄ‚îÄ testthat.R\n        \n2 directories, 1 file\n\nWriting tests\ntestthat is designed for unit tests (i.e., testing each functional ‚Äòunit‚Äô in the code), but for shiny apps, we need to think beyond standard unit testing. We need to confirm the functions work and return predictable results, but we also need to make sure they play well with each other (integration tests), and that the application can be deployed (system tests).\n\n\nRecap: testing\nTesting is well described in the shiny documentation and in Mastering Shiny. Generally speaking, unit tests are performed with testthat, and module testing can be done with shiny::testServer(). To test the full application (or a specific behavior) use the shinytest2 package.\n\n\n\n\n\n\n\nFigure¬†10: Testing framework from testthat"
  },
  {
    "objectID": "posts/duap/index.html#recap",
    "href": "posts/duap/index.html#recap",
    "title": "Creating shiny app-packages",
    "section": "Recap",
    "text": "Recap\nI‚Äôve skipped over some important development steps covered in R packages (license, using Git/GitHub, code coverage, NEWS, etc.), and you should bookmark this text as you start developing shiny app-packages. Hopefully this post has demonstrated that by building shiny apps as R packages, a suite of developer tools are available in the RStudio IDE (and the application files and folders have a uniform structure).\nduap is a substantial improvement over a vanilla shiny application‚Äìthe app-package holds the code, data, documentation, and includes explicit information on the dependencies and requirements (in the DESCRIPTION and NAMESPACE)."
  },
  {
    "objectID": "posts/test-shiny-p2/index.html",
    "href": "posts/test-shiny-p2/index.html",
    "title": "Unit tests for (non-package) shiny apps",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(vdiffr)\nlibrary(shinytest2)\nThis post is the second in a series on testing shiny applications. I‚Äôll cover testing shiny module server functions using the testhat package outside an R package. This application is stored in the noap GitHub repo if you‚Äôd like to follow along."
  },
  {
    "objectID": "posts/test-shiny-p2/index.html#testing-module-server-functions",
    "href": "posts/test-shiny-p2/index.html#testing-module-server-functions",
    "title": "Unit tests for (non-package) shiny apps",
    "section": "Testing module server functions",
    "text": "Testing module server functions\n\n‚Ä¶the ABCs of testing shiny server modules‚Ä¶\n\nThis post covers how shiny::testServer() works using the abcApp() shiny app.. The code for abcApp() is an RStudio project (i.e., there is a noap.Rproj file in the parent folder), but it‚Äôs not part of an R package. Developing shiny applications as R packages is highly recommended, but it‚Äôs possible to begin writing unit tests before your application is a fully developed shiny app-package.\nFor more information regarding performing tests outside of the package environment, see this issue on GitHub.\n\nabcApp()\nThe abcApp() application has been written using shiny modules and a single utility function.\ntestthat is designed to perform unit tests for R packages, but for the sake of simplicity,abcApp() has not been developed as part of a package. This will allow us to focus on the files involved in testing (and not all the other files that accompany R packages).\nThe standalone application function (abcApp()) is stored in app.R, the modules are contained in modules.R, and the single utility function is stored in utils.R:\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ app.R\n‚îú‚îÄ‚îÄ app.Rproj\n‚îú‚îÄ‚îÄ modules.R\n‚îú‚îÄ‚îÄ tests\n‚îî‚îÄ‚îÄ utils.R\n\n2 directories, 5 files\n\nThe tests folder contains the following:\ntests\n‚îú‚îÄ‚îÄ testthat\n‚îÇ   ‚îî‚îÄ‚îÄ test-mod_abc_server.R\n‚îî‚îÄ‚îÄ testthat.R\n\n2 directories, 2 files\n\ntests/ has a testthat.R file\n\nNew test files should be placed in tests/testthat/ (see example test-mod_abc_server.R below):\n\n\n\nUI module function\nIn this small example app, both ui and server modules are stored in the modules.R file.\n\nUI module:\n\n\nmod_abc_ui() (example ui module function)\n# ui module\nmod_abc_ui &lt;- function(id) {\n\n  ns &lt;- shiny::NS(id)\n\n  shiny::tagList(\n    shiny::numericInput(\n      inputId = ns(\"num\"),\n      label = shiny::h4(\n        shiny::code(\"alphabet number\")),\n        value = 5, min = 1, max = 26\n    ),\n    shiny::verbatimTextOutput(\n      outputId = ns(\"txt\"))\n  )\n}\n\n\n\n\n\nServer module function\nThe counterpart to mod_abc_ui() is mod_abc_server():\n\nServer module:\n\n\nmod_abc_server() (example server module function)\n# server module\nmod_abc_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    # reactive \n    letter &lt;- shiny::reactive({ LETTERS[input$num] })\n    # super script\n    sup_scrpt &lt;- shiny::reactive({ \n      num_super_script(x = input$num)\n    })\n    # output\n    output$txt &lt;- shiny::renderPrint({\n      paste0(\"The \", input$num, sup_scrpt(), \n             \" letter in the alphabet is: \", letter())\n    })\n\n  })\n}\n\n\n\n\n\nModule utility function\nThe mod_abc_server() function uses the num_super_script() function stored in utils.R:\n\nUtility function:\n\n\nnum_super_script() (example utility function)\n# utility function\nnum_super_script &lt;- function(x) {\n      num &lt;- as.numeric(x)\n      if (num == 1) {\n        super_script &lt;- \"st\"\n      } else if (num == 2) {\n        super_script &lt;- \"nd\"\n      } else if (num == 3) {\n        super_script &lt;- \"rd\"\n      } else {\n        super_script &lt;- \"th\"\n      }\n    return(super_script)\n}\n\n\n\n\n\nStandalone app function\n\nStandalone app functions include a call to shiny::shinyApp():\n\n\nabcApp() (example app with modules)\n# standalone shiny app function\nabcApp &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      mod_abc_ui(\"x\")\n    ), \n    server = function(input, output, session) { \n      mod_abc_server(\"x\")\n    }\n  )\n}\nabcApp()\n\n\n\nThe call to shiny::shinyApp() is placed inside the abcApp() function\nThe ui argument is wrapped in shiny::fluidPage() and the ui module function (mod_abc_ui()) is placed inside\nThe server argument includes the standard function(input, output, session) and the module server companion function‚Äìmod_abc_server()‚Äìwith a matching id arguments\nThe abcApp() function is stored in the app.R file\n\n\nBecause abcApp() is not part of a package, shiny and testthat are loaded and the modules and utility function are sourced in the top of the app.R file.\n\n\nsource utils.R and modules.R in app.R\n# packages --------------------------------------------------------\nlibrary(shiny)\nlibrary(testthat)\n\n# utils ------------------------------------------------------------------\nsource(\"utils.R\")\n\n# modules ------------------------------------------------------------------\nsource(\"modules.R\")\n\n\n\n\n\nUsing testServer()\nIn the test-mod_abc_server.R file, I‚Äôll add testServer() and include the module server function as the first argument:\n\napp is the module server function (mod_abc_server) or any shiny.appobj\n\n\napp = shiny.appobj\nshiny::testServer(app = mod_abc_server, {\n\n})\n\n\n\n\nTesting input$s\n\nThe first test I‚Äôll add will check the initial value of input$num\n\nI‚Äôll also include a custom message with cat()\n\n\n\ntest initial value with custom message\nshiny::testServer(mod_abc_server, {\n  # Test 1: check initial value\n  testthat::expect_equal(input$num, NULL)\n  cat(\"\\n Test 1 initial input$num = NULL: \", is.null(input$num), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTest 1 initial input$num = NULL:  TRUE \n\ntestServer() allows me to set new input values with session$setInputs()\n\nUse session$setInputs() to set input$num to 3\nTest 2 confirms input$num has changed\nAdd another custom message with cat()\n\n\n\n\nsetInputs() and test inputs\nshiny::testServer(mod_abc_server, {\n  # set inputs\n  session$setInputs(num = 3)\n  # Test 2: check set inputs\n  testthat::expect_equal(input$num, 3)\n  cat(\"\\n Test 2 setInputs(num = 3):\", input$num, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 2 setInputs(num = 3): 3 \n\n\n\nTesting reactive values\n\nThe module‚Äôs reactive values are also available to in testServer()\n\nTest 3 adds a test for sup_scrpt() (given the changed value of input$num)\n\nThe expected value is what I‚Äôm expecting num_super_script() to return.\n\n\n\n\nCheck sup_scrpt() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 3: check super script\n  testthat::expect_equal(object = sup_scrpt(), expected = \"rd\")\n  cat(\"\\n Test 3 sup_scrpt(): = 'rd':\", sup_scrpt(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 3 sup_scrpt(): = 'rd': rd  \n\nFor completeness I‚Äôll add a test for letter()\n\n\n\nCheck letter() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 4: check letter\n  testthat::expect_equal(object = letter(), expected = \"C\")\n  cat(\"\\n Test 4 letter() = C:\", letter(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 4 letter() = C: C \n\n\n\nTesting output$s\n\nThe module output values are also available as output$&lt;value&gt;\n\nTest 5 will verify the output$txt (given the updated input$num)\n\n\n\nCheck module output values\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\n‚îÄ- Failure (test-mod_abc_server.R:1:1): (code run outside of `test_that()`) ‚îÄ‚îÄ\noutput$txt (`actual`) not equal to \"The 3rd letter in the alphabet is: C\" (`expected`).\n\n`actual`:   \"[1] \\\"The 3rd letter in the alphabet is: C\\\"\"\n`expected`: \"The 3rd letter in the alphabet is: C\"        \nBacktrace:\n  1. shiny::testServer(...)\n       at test-mod_abc_server.R:1:0\n 22. testthat::expect_equal(object = output$txt, \n   expected = \"The 3rd letter in the alphabet is: C\")\n       at test-mod_abc_server.R:17:4\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\nWhat happened? I forgot to add the escape characters (\\\") and line number ([1]) for the output\n\nI‚Äôll change the expected value and re-run the test:\n\n\n\n\nCheck module output values (again)\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\nFinally, I‚Äôll run the tests with test_dir()\n\n\ntest_dir(path = \"/path/to/app/tests/testthat/\")\n\n‚úî | F W S  OK | Context\n‚†è |         0 | mod_abc_server         \n\n Test 1 initial input$num = NULL:  TRUE \n\n Test 2 setInputs(num = 3): 3 \n\n Test 3 sup_scrpt(): = 'rd': rd \n\n Test 4 letter() = C: C \n\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n‚úî |         5 | mod_abc_server\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 0.2 s\n [ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\nüåà Your tests are over the rainbow üåà\n\nThe results show the tests passed! Now I am confident inputs, reactive values (sup_scrpt() & letter()), outputs behave as expected.\n\n\n\nRecap\nThe example above provides a workflow for using testServer() with testthat outside a package environment. The checklist below summarizes the steps required to test your application‚Äôs module server functions:\n\nCreate test files (in tests/testthat/)\n\nAll test files should have the test- prefix\n\nVerify inputs with session$setInputs(inputId = &lt;value&gt;)\n\nAll input$ values should initially be NULL\n\nTest reactive values by referring to them as you would in the module server\n\nCompare expected values after changing inputs with session$setInputs()\n\nTest outputs using output$&lt;value&gt; to check changes to the inputs and reactives\n\nCheck output values with output$txt\n\n\nThis concludes running tests on abcApp(). Ideally, shiny applications are developed as an R package (which I‚Äôll cover in a future post), but now you know how to perform tests if this isn‚Äôt the case. The files for this demonstration are located here.\nFor a more comprehensive review of testing, check out the chapters on testing in R packages and Mastering Shiny."
  },
  {
    "objectID": "series.html",
    "href": "series.html",
    "title": "Series",
    "section": "",
    "text": "These posts focus on testing shiny applications with testthat, shiny::testServer(), and shinytest2.\n\n\n\n\n\n\nTypes of tests\n\n\n\n\n\n\n\ntestthat: testthat is a popular unit testing framework that allows R package developers to create tests scripts for functions and logic systematically. In a shiny app-package, it‚Äôs used for testing the non-reactive components (i.e., utility functions). This includes functions for data processing, plots, modeling, and other code that‚Äôs part of the package. However, it is not designed to work with shiny‚Äôs reactive model.\ntestServer(): testServer() comes from the shiny package and is designed to test the server-side logic of your app. These tests can be used to simulate user inputs and verify the corresponding outputs. testServer() can also test the functionality of module server functions (reactivity, outputs, and any returned values) in isolation from their UI function counterparts. However, testServer() doesn‚Äôt capture how UI elements are rendered or simulate key user interactions (i.e., execution paths) through the application.\nshinytest2(): shinytest2 is designed to perform end-to-end testing of shiny apps. These tests can capture a shiny app‚Äôs current state (i.e., a snapshot) and compare it with a previously saved (or expected) states. Snapshots are useful for end-to-end testing because they can simulate key user interaction in a way that unit tests and testServer() can‚Äôt (i.e., the delay between input changes and rendering updated outputs, specific sequences of selections on action buttons, radio buttons, etc.). shinytest2 tests are resource-intensive, so it‚Äôs recommended to write these tests after writing testthat unit tests and testServer() tests.\n\nIn summary, use testthat for unit testing utility/helper functions, then testServer() for the server-side logic, and finish off with shinytest2 tests for end-to-end functionality of your shiny app. These tools complement each other to provide a comprehensive testing framework.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDate\n\n\n\n\n\n\nUnit testing shiny utility functions\n\n\nMay 1, 2023\n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nMay 7, 2023\n\n\n\n\nTesting shiny module server functions\n\n\nJun 20, 2023\n\n\n\n\nTesting shiny apps with shinytest2\n\n\nJul 4, 2023\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\nUnit testing shiny utility functions: This post covers unit testing a set of utility functions with testthat. You can also read the documentation from the package website, in R packages, and in Mastering Shiny. The app-package for this post is stored in this Github Repo.\n\nPackage website\n\nUnit tests for (non-package) shiny apps: Your shiny app should be developed as a package, but this isn‚Äôt always the case. If you‚Äôd like to test your application‚Äôs code without converting it to a package, check out the second post (GitHub repo with the code).\nTesting shiny module server functions: If you‚Äôve built your shiny application as a package and it contains modules, this post covers testing module server functions using the examples from the ‚ÄòModules‚Äô chapter of Mastering Shiny. The code and examples are in this GitHub repo\n\nPackage website\n\nTesting shiny apps with shinytest2: This post picks up where the previous post left off with the shinytest2 package. The app-package used in the examples is stored in this GitHub repo.\n\nPackage website"
  },
  {
    "objectID": "series.html#testing-shiny-applications",
    "href": "series.html#testing-shiny-applications",
    "title": "Series",
    "section": "",
    "text": "These posts focus on testing shiny applications with testthat, shiny::testServer(), and shinytest2.\n\n\n\n\n\n\nTypes of tests\n\n\n\n\n\n\n\ntestthat: testthat is a popular unit testing framework that allows R package developers to create tests scripts for functions and logic systematically. In a shiny app-package, it‚Äôs used for testing the non-reactive components (i.e., utility functions). This includes functions for data processing, plots, modeling, and other code that‚Äôs part of the package. However, it is not designed to work with shiny‚Äôs reactive model.\ntestServer(): testServer() comes from the shiny package and is designed to test the server-side logic of your app. These tests can be used to simulate user inputs and verify the corresponding outputs. testServer() can also test the functionality of module server functions (reactivity, outputs, and any returned values) in isolation from their UI function counterparts. However, testServer() doesn‚Äôt capture how UI elements are rendered or simulate key user interactions (i.e., execution paths) through the application.\nshinytest2(): shinytest2 is designed to perform end-to-end testing of shiny apps. These tests can capture a shiny app‚Äôs current state (i.e., a snapshot) and compare it with a previously saved (or expected) states. Snapshots are useful for end-to-end testing because they can simulate key user interaction in a way that unit tests and testServer() can‚Äôt (i.e., the delay between input changes and rendering updated outputs, specific sequences of selections on action buttons, radio buttons, etc.). shinytest2 tests are resource-intensive, so it‚Äôs recommended to write these tests after writing testthat unit tests and testServer() tests.\n\nIn summary, use testthat for unit testing utility/helper functions, then testServer() for the server-side logic, and finish off with shinytest2 tests for end-to-end functionality of your shiny app. These tools complement each other to provide a comprehensive testing framework.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDate\n\n\n\n\n\n\nUnit testing shiny utility functions\n\n\nMay 1, 2023\n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nMay 7, 2023\n\n\n\n\nTesting shiny module server functions\n\n\nJun 20, 2023\n\n\n\n\nTesting shiny apps with shinytest2\n\n\nJul 4, 2023\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\nUnit testing shiny utility functions: This post covers unit testing a set of utility functions with testthat. You can also read the documentation from the package website, in R packages, and in Mastering Shiny. The app-package for this post is stored in this Github Repo.\n\nPackage website\n\nUnit tests for (non-package) shiny apps: Your shiny app should be developed as a package, but this isn‚Äôt always the case. If you‚Äôd like to test your application‚Äôs code without converting it to a package, check out the second post (GitHub repo with the code).\nTesting shiny module server functions: If you‚Äôve built your shiny application as a package and it contains modules, this post covers testing module server functions using the examples from the ‚ÄòModules‚Äô chapter of Mastering Shiny. The code and examples are in this GitHub repo\n\nPackage website\n\nTesting shiny apps with shinytest2: This post picks up where the previous post left off with the shinytest2 package. The app-package used in the examples is stored in this GitHub repo.\n\nPackage website"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "@mjfrigaard",
    "section": "",
    "text": "Testing shiny apps with shinytest2\n\n\nPart 4: recording tests and snapshots\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJul 4, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nTesting shiny module server functions\n\n\nPart 3: Using testthat and testServer()\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nDebugging in RStudio\n\n\nDeveloping code with browser()\n\n\n\n\ncode\n\n\ndebugging\n\n\n\n\n\n\n\n\n\n\n\nJun 1, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nPart 2: Testing in non-package shiny apps\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 7, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nUnit testing shiny utility functions\n\n\nPart 1: Unit tests in shiny app-packages\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 1, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nWriting modular code with box\n\n\n\n\n\n\n\npackages\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 21, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\npurrr updates (v1.0.0)\n\n\n\n\n\n\n\niteration\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nCreating shiny app-packages\n\n\nBuilding a shiny app within an R package: whole-game\n\n\n\n\nshiny\n\n\nusethis\n\n\ndevtools\n\n\npackages\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! I am Martin Frigaard. This is my personal blog where I write about projects I‚Äôm currently working on (or topics I‚Äôm thinking about).\nIn my professional life, I‚Äôm a data visualization engineer at Atorus Research where I build shiny applications and write R packages. I also create training materials and workshops on data management, visualizations, and reproducible research. I have 15 years of experience with data analysis, statistics, and research. I‚Äôm also a fully certified tidyverse trainer.\nCheck out my other website here."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "@mjfrigaard",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTesting shiny apps with shinytest2\n\n\nPart 4: recording tests and snapshots\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJul 4, 2023\n\n\n\n\n\n\n\n\nTesting shiny module server functions\n\n\nPart 3: Using testthat and testServer()\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2023\n\n\n\n\n\n\n\n\nDebugging in RStudio\n\n\nDeveloping code with browser()\n\n\n\n\ncode\n\n\ndebugging\n\n\n\n\n\n\n\n\n\n\n\nJun 1, 2023\n\n\n\n\n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nPart 2: Testing in non-package shiny apps\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 7, 2023\n\n\n\n\n\n\n\n\nUnit testing shiny utility functions\n\n\nPart 1: Unit tests in shiny app-packages\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 1, 2023\n\n\n\n\n\n\n\n\nWriting modular code with box\n\n\n\n\n\n\n\npackages\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 21, 2023\n\n\n\n\n\n\n\n\npurrr updates (v1.0.0)\n\n\n\n\n\n\n\niteration\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2023\n\n\n\n\n\n\n\n\nCreating shiny app-packages\n\n\nBuilding a shiny app within an R package: whole-game\n\n\n\n\nshiny\n\n\nusethis\n\n\ndevtools\n\n\npackages\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2023\n\n\n\n\n\n\nNo matching items"
  }
]