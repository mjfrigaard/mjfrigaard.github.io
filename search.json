[
  {
    "objectID": "series/testing/series-testing-p4/index.html",
    "href": "series/testing/series-testing-p4/index.html",
    "title": "Testing shiny apps with shinytest2",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\nThis is the fourth post in a series on testing shiny applications. My previous posts have covered unit testing utility functions and testing module server functions with testServer(). In this post, Iâ€™ll be covering testing shiny applications using testthat and shinytest2."
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#set-up",
    "href": "series/testing/series-testing-p4/index.html#set-up",
    "title": "Testing shiny apps with shinytest2",
    "section": "Set up",
    "text": "Set up\nshinytest2 requires a few steps to get up and running, so Iâ€™ve included my start up steps below (in hopes that someone might find them useful).\n\nChromium\nFirst make sure you have Chromium headless browser installed. Chromium is the browser used to test and debug shiny apps with shinytest2.\nIf youâ€™re using macOS, you can install Chromium using homebrew:\n\nbrew install --cask chromium\n\n\n\nshow/hide output\n==&gt; Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==&gt; Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==&gt; Installing Cask chromium\n==&gt; Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==&gt; Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nğŸº  chromium was successfully installed!\n\n\n\n\nchromote\nThe chromote package allows R to open Chromium. I had to make sure R knew where to find the Chromium application (this section helps) by passing the path to the app to Sys.setenv()\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\nYou can use find_chrome() to find your chrome app:\n\nchromote::find_chrome()\n\nYou can also locate the path to Chromium using by holding command âŒ˜ and clicking on the application icon\nThen set the CHROMOTE_CHROME environment variable to the Chromium path (make sure itâ€™s not the path to Chrome.app:\n\n\nshow/hide\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n\n\nVerify the Chromium app/chromote install with ChromoteSession$new()\n\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n\n\n\n(a) Chromium\n\n\n\n\nFigureÂ 1: Chromium headless browser\n\n\n\nGreat! Going through this step means shinytest2â€™s test recorder will (should) deploy when Iâ€™m recording tests."
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#app-package-contents",
    "href": "series/testing/series-testing-p4/index.html#app-package-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "App-package contents",
    "text": "App-package contents\nIâ€™ve created msst2ap (i.e., Mastering Shiny shinytest2 app-package) with devtools and usethis. It somewhat resembles an application using the golem framework, but with fewer opinions. You can download msst2ap here or install it using the following:\n\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n\nThe applications in msst2ap can be run with the their standalone app functions.\n\nModules & apps\nThe modules in msst2ap are from the Modules chapter of Mastering Shiny, with a few minor adjustments. These modules create namespaces for their inputs and outputs with the shiny::NS() function, which appends a second id string to each inputId/outputId.\nEach standalone app also includes the output from shiny::reactiveValuesToList():\n\nIn the ui:\n\n# for printing reactive values in application modules\nshiny::verbatimTextOutput(\"vals\")\n\nIn the server:\n\n# for printing reactive values in application modules\noutput$vals &lt;- shiny::renderPrint({\n  x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n  print(x, width = 30, max.levels = NULL)\n}, width = 30)\n\n\n\ndataset module\nThe dataset module displays the objects in the datasets package in a selectInput() according to a filter argument (i.e., is.data.frame, is.matrix, etc.).\ndatasetServer() returns the selected object as a reactive value. Read more here.\n\n\ndatasetInput() & datasetServer()\ndatasetInput &lt;- function(id, filter = NULL) {\n  names &lt;- ls(\"package:datasets\")\n\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n}\ndatasetServer &lt;- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    shiny::reactive(get(input$dataset, \"package:datasets\"))\n  })\n}\n\n\n\ndatasetApp()\n\n\ndatasetApp()\ndatasetApp &lt;- function(filter = NULL) {\n  ui &lt;- shiny::fluidPage(\n    datasetInput(\"dataset\", filter = is.data.frame),\n    shiny::tableOutput(\"data\"),\n    \n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"dataset\")\n    output$data &lt;- shiny::renderTable(head(data()))\n    \n    # for printing reactive values in application modules\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) datasetApp()\n\n\nFigureÂ 2: datasetApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nBelow the table output in datasetApp(), the reactive values displays the inputId from datasetInput() and the namespace value from the shared id argument with datasetServer():\n$`dataset-dataset`\n\n\n\nselectVar module\nThe selectVar module selects a numeric variable the data() object returned from datasetServer().\nIt has a single utility function (find_vars()) which is used to filter the columns (variables):\n\n\nshow/hide selectVarInput() & selectVarServer()\nselectVarInput &lt;- function(id) {\n  shiny::selectInput(\n    shiny::NS(id, \"var\"),\n    label = \"Variable\",\n    choices = NULL\n  )\n}\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  \n  stopifnot(shiny::is.reactive(data))\n  stopifnot(!shiny::is.reactive(filter))\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n    shiny::observe({\n      shiny::updateSelectInput(\n        session, \"var\",\n        choices = find_vars(data(), filter))\n    }) |&gt;\n      shiny::bindEvent(data())\n\n    return(\n      shiny::reactive({\n        if (input$var %in% names(data())) {\n          data()[input$var]\n        } else {\n          NULL\n        }\n      }) |&gt;\n      shiny::bindEvent(input$var)\n    )\n\n  })\n}\n\n\nIâ€™ve made a few small changes to selectVarServer():\n\nIn the original version, input$var is returned as a vector:\n\nreactive(data()[[input$var]])\n\nIâ€™ve added some validation and return input$var as a single column from data():\n\nshiny::reactive({\n    if (input$var %in% names(data())) {\n        data()[input$var]\n    } else {\n        NULL\n    }\n  }) \n\nThe find_vars() function is also below:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter = is.vector) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\nselectVarApp()\nThe selectVarApp() extends the dataset module by collecting the returned reactive value, passing it to find_vars(), and returning a single column.\n\n\nshow/hide selectVarApp()\nselectVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n            shiny::tableOutput(\"out\"),\n            shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectVarApp()\n\n\nFigureÂ 3: selectVarApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe reactive values in selectVarApp() are displayed below the table:\n\n\n\n\nVariables\n\nthe 1st var is from the inputId in selectVarInput()\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module\n$`var-var` \n\n\n\nData\n\ndataset is from the inputId in datasetInput()\n$`-dataset`\ndata is the shared namespace id from the dataset module\n$`data-dataset`\n\n\n\n\n\n\nselectDataVar module\nselectDataVar is from the Modules inside of modules section, so true to form, both the dataset and selectVar modules are called inside of the UI and Server modules:\n\n\nselectDataVarUI() & selectDataVarServer()\nselectDataVarUI &lt;- function(id) {\n  shiny::tagList(\n    datasetInput(\n      shiny::NS(id, \"data\"), \n        filter = is.data.frame),\n    selectVarInput(\n      shiny::NS(id, \"var\"))\n  )\n}\nselectDataVarServer &lt;- function(id, filter = is.numeric) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n    var\n\n  })\n}\n\n\n\nselectDataVarApp()\nThe selectDataVarApp() places the inputs in the sidebarPanel() and the outputs in the mainPanel().\n\n\nselectDataVarApp()\nselectDataVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        selectDataVarUI(\"var\")\n        ),\n      shiny::mainPanel(\n        shiny::tableOutput(\"out\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n        )\n    )\n  )\n  server &lt;- function(input, output, session) {\n    var &lt;- selectDataVarServer(\"var\", filter)\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectDataVarApp()\n\n\nFigureÂ 4: selectDataVarApp() in msst2ap\n\n\n\nThe reactive values from selectDataVarApp() reflect the nested module structure:\n\n\n\n\nVariables\n\nThe first var belongs to the inputId in selectVarInput(),\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module,\n$`-var-var`\nthe 3rd var is the call to the selectVar module inside selectDataVar\n$`var-var-var` \n[1] \"Ozone\"\n\n\n\nData\n\ndataset belongs to the inputId in datasetInput(),\n$`-dataset` \ndata is the shared namespace id from the dataset module,\n$`-data-dataset` \nvar is the call to the dataset module inside selectDataVar\n$`var-data-dataset` \n[1] \"airquality\"\n\n\n\n\n\n\nhistogram module\nThe final modules and application Iâ€™ll use from Mastering Shiny are from the Case study: histogram section. This application uses the existing dataset and selectVar modules to pass a single variable to the render a histogram:\n\n\nshow/hide histogramOutput() & histogramServer()\nhistogramOutput &lt;- function(id) {\n  shiny::tagList(\n    shiny::numericInput(\n      shiny::NS(id, \"bins\"),\n      label = \"bins\",\n      value = 10,\n      min = 1,\n      step = 1\n    ),\n    shiny::plotOutput(\n      shiny::NS(id, \"hist\"))\n  )\n}\nhistogramServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(shiny::is.reactive(x))\n  stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    output$hist &lt;- shiny::renderPlot({\n        shiny::req(x())\n        main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main\n        )\n      }, res = 96)\n\n    output$data &lt;- shiny::renderPrint({\n      shiny::req(x())\n      print(head(x()))\n    })\n  })\n}\n\n\nIâ€™ve made some changes to the histogramServer() function (to accomodate the changes to the selectVar module).\n\nThe original renderPlot() call in histogramServer():\n\n  output$hist &lt;- renderPlot({\n    req(is.numeric(x()))\n    main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n    hist(x(), breaks = input$bins, main = main)\n  }, res = 96)\n\nThe updated renderPlot() call in histogramServer():\n\n  output$hist &lt;- shiny::renderPlot({\n    shiny::req(x())\n    main &lt;- paste0(title(), \" [bins =\", input$bins, \"]\")\n    hist(purrr::as_vector(x()),\n      breaks = input$bins,\n      main = main)\n  }, res = 96)\n\n\nAs you can see, req() is verifying x() exists, but doesnâ€™t check itâ€™s class with is.numeric().\nx() is also passed to purrr::as_vector() before itâ€™s plotted with hist()\n\n\n\nhistogramApp()\n\n\nhistogramApp()\nhistogramApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    x &lt;- selectVarServer(\"var\", data)\n    histogramServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\nFigureÂ 5: histogramApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe displayed reactive values in histogramApp() are described below:\n\n\n\n\nPlot\n\nThe inputId from histogramOutput() and the shared namespace id\n$`hist-bins`\n[1] 10\n\n\n\nVariables\n\nThe inputId from selectVarInput() and the shared namespace id\n$`var-var`\n[1] \"Ozone\"\n\n\n\nData\n\nThe inputId from datasetInput() and the shared namespace id\n$`data-dataset` \n[1] \"airquality\"\n\n\n\n\n## Using shinytest2\nshinytest2 is extremely well documentation. I highly recommended the Get Started vignette. In the next sections, Iâ€™ll cover some examples for what Iâ€™ve included in the msst2ap.\n\n\n\n\n\n\nWhy shinytest2?\n\n\n\n\n\n\nWhat happened to shinytest?\nshinytest2 replaced shinytest on 2022-04-27. If youâ€™ve previously written tests with shinytestâ€“or are curious how shinytest2 if differentâ€“I recommend going through the Migrating from shinytest vignette.\n\n\n\n\nRun shinytest2::use_shinytest2() to create the initial files for shinytest2:\n\nshinytest2::use_shinytest2()\n\n\n\nshow/hide output from use_shinytest2()\n! Runner already found: tests/testthat.R\nâœ” Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\nâœ” Adding '*_.new.png' to '.gitignore'\nâœ” Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\nâœ” Setting active project to '/projects/msst2ap'\nâœ” Adding 'shinytest2' to Suggests field in DESCRIPTION\nâ€¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\nâ€¢ Then directly refer to functions with `shinytest2::fun()`\nâœ” Setting active project to '&lt;no active project&gt;'\n\n\n\nuse_shinytest2() adds the setup-shinytest2.R script to my tests/testthat/ folder:\n\ntests/testthat/\nâ”œâ”€â”€ _snaps/\nâ””â”€â”€ setup-shinytest2.R\n\n\nThe setup-shinytest2.R file contains a single call to shinytest2::load_app_env(), which â€œExecutes all ./R files and global.R into the current environmentâ€"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#recording-tests",
    "href": "series/testing/series-testing-p4/index.html#recording-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recording tests",
    "text": "Recording tests\nNew tests with shinytest2 can be created by launching the test event recorder, which allows us interact with our application, observe itâ€™s behavior, and record inputs, reactive values, and outputs. To record a test, run shinytest2::record_test().\nThe first argument in record_test() is the path to application. If youâ€™ve stored your application in an app.R file, record_test() will automatically load that application.\n\nIf you encounter a message telling you Chromium is disconnected, try installing the development version of chromote:\n\n# run this in the console to make sure you have dev version of chromote\nremotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\n\nIn msst2ap, the application in app.R is the histogramApp(), so the test recorder will automatically open with this application if I run record_test() (without providing the path to a shiny app).\n\nshinytest2::record_test()\n\n\nIn Chromium\n\n\n\n\n\n\n\n\n(a) shinytest2::record_test()\n\n\n\n\nFigureÂ 6: record_test() with application in app.R\n\n\n\nThe app argument can also be a â€œpath to a Shiny applicationâ€. For example, I have â€˜developmentâ€™ versions of each application in msst2ap in inst/dev/:\n\n\nshow/hide contents of msst2ap/inst/dev\ninst/dev\nâ”œâ”€â”€ datasetApp\nâ”‚   â”œâ”€â”€ DESCRIPTION\nâ”‚   â”œâ”€â”€ R\nâ”‚   â”‚   â””â”€â”€ modules.R\nâ”‚   â”œâ”€â”€ README.md\nâ”‚   â””â”€â”€ app.R\nâ”œâ”€â”€ histogramApp\nâ”‚   â”œâ”€â”€ DESCRIPTION\nâ”‚   â”œâ”€â”€ R\nâ”‚   â”‚   â””â”€â”€ modules.R\nâ”‚   â”œâ”€â”€ README.md\nâ”‚   â””â”€â”€ app.R\nâ”œâ”€â”€ selectDataVarApp\nâ”‚   â”œâ”€â”€ DESCRIPTION\nâ”‚   â”œâ”€â”€ R\nâ”‚   â”‚   â””â”€â”€ modules.R\nâ”‚   â”œâ”€â”€ README.md\nâ”‚   â””â”€â”€ app.R\nâ””â”€â”€ selectVarApp\n    â”œâ”€â”€ DESCRIPTION\n    â”œâ”€â”€ R\n    â”‚   â””â”€â”€ modules.R\n    â”œâ”€â”€ README.md\n    â””â”€â”€ app.R\n\n9 directories, 16 files\n\n\nI can pass the path to each application to the app argument in record_test():\n\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n\nThis opens Chromium with our shiny app:\n\n\n\n\n\n\n\n\n(a) record_test(â€œinst/dev/histogramApp/â€)\n\n\n\n\nFigureÂ 7: record_test() with app in inst/dev/histogramApp/ folder\n\n\n\nThe test event recorder displays the shiny app, but also includes a window for recording each application â€˜event.â€™\n\nExpectations\nIâ€™ll start by recording a test for histogramApp(). On the right-hand side of the Chromium headless browser, youâ€™ll see the shinytest2 expectations window:\n\n\n\n\n\n\n\n\n(a) shinytest2 expectations\n\n\n\n\nFigureÂ 8: shinytest2 expectations in record_test()\n\n\n\nThe initial value in the Code window displays the dimensions of the application in Chromium (app$set_window_size(width = , height = )).\n\n\nEvents\nWhen I interact with the application (i.e., make changes to the inputs), each change is an â€˜eventâ€™ that is recorded in the test:\n\n\n\n\n\n\n\n\n(a) change inputs\n\n\n\n\nFigureÂ 9: Changing app inputs\n\n\n\n\n\nCode\nAll events are recorded as code in the Code section of shinytest2 expectations:\n\n\n\n\n\n\n\n\n(a) shinytest2 code expectations\n\n\n\n\nFigureÂ 10: Recorded code for each event\n\n\n\n\n\nExpect Shiny values\nWhen Iâ€™ve finished interacting with the application, I click on the Expect Shiny values button at the top of shinytest2 expectations. This will add app$expect_values() to the Code section:\n\n\n\n\n\n\n\n\n(a) expect-shiny-values\n\n\n\n\nFigureÂ 11: Expect Shiny values in shinytest2 expectations\n\n\n\n\n\nSave test and exit\nFinally, to save the test, enter a Test name and click Save test and exit\n\n\n\n\n\n\n\n\n(a) name-save-exit\n\n\n\n\nFigureÂ 12: Name, save and exit record_test()\n\n\n\n\n\n\nIn Console\nBack in the Console, the shinytest2 test recorder is performing the following actions behind the scenes:\n\nThe Chromium headless browser opens with the histogramApp() and shiny is loaded\n\nListening on http://127.0.0.1:7418\n{shiny} R stderr ----------- Loading required package: shiny\n\nWarning: The first warning is a caused by the call to shiny::loadSupport(). Itâ€™s a known issue, so we can assume the developers are working on it!\n\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\n  contain an R package. Sourcing files in R/ may cause unexpected behavior.\n\nWe are told the application is being run in test mode, which â€˜lets the AppDriver retrieve valuesâ€™ from the app\n\n{shiny} R stderr ----------- Running application in test mode.\n{shiny} R stdout ----------- â„¹ Loading msst2ap\n\nWarning: The tests/testthat.R file (i.e., the â€˜test runnerâ€™) was overwritten and tests are now run with shinytest2::test_app()\n\nWarning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\ncall to ensure proper a testing environment.\n\nWhen I clicked â€œSave test and exitâ€, the changes made to tests/testthat.R and tests/testthat/test-shinytest2.R are saved:\n\nâ€¢ Saving test runner: tests/testthat.R\nâ€¢ Saving test file: tests/testthat/test-shinytest2.R\n\nA call to shinytest2::load_app_env() is added to setup-shinytest2.R and the test file (tests/testthat/test-shinytest2.R) is opened:\n\nâœ” Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\nâ€¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n\nThe new test is saved in the tests/testthat/test-shinytest2.R file and automatically run.\n\nâ€¢ Running recorded test: tests/testthat/test-shinytest2.R"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#test-contents",
    "href": "series/testing/series-testing-p4/index.html#test-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test contents",
    "text": "Test contents\nThe contents of the test file generated from the test recorder are below:\n\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on Run Test or by using test_file() from testthat:\n\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nBecause msst2ap is a package, running tests with shinytest2 will produce the warning below:\n\n\n\nshiny::loadSupport() warning\n\n\nAs noted above, this warning is known by the shinytest2 package authors and is being addressed in a future release.\n\n\n\n\nNow that I know the first shinytest2 test is passing, Iâ€™ll dive into each line in the test.\n\nAppDriver\nshinytest2 uses the AppDriver to create â€œa full simulation of a Shiny appâ€. When recording tests, this will be the first argument (along with the name of the .png and .json snapshot testthat files, and the height and width of the ChromoteSession).\n\nThe example from the test above is below:\n\n app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n\n\n\n\nset_inputs()\nWhen recording shinytest2 tests, every change to the applications inputs will result in a call to app$set_inputs(). This function is similar to the testServer() call to session$setInputs() (i.e., the inputs are provided as â€œname-value pairsâ€, i.e., inputId = \"value\").\n\nIn the histogramApp(), these are provided with the appended namespaces:\n\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n\n\n\n\nexpect_values()\nThe documentation on expect_values() is definitely worth reading. expect_values() is added to the test file when Expect Shiny values is clicked in the test recorder and â€œcreates a list of values and compares them to the current values of the application.â€\n\nexpect_values() = â€œExpect all input, output, and export values are consistentâ€\n\n  app$expect_values()"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#test-results",
    "href": "series/testing/series-testing-p4/index.html#test-results",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test results",
    "text": "Test results\nThe results from running the new test file (test-shinytest2.R) are below:\n\nâ€¢ Running recorded test: tests/testthat/test-shinytest2.R\nâœ” | F W S  OK | Context\nâœ” |   2     1 | shinytest2 [6.3s]                                             \n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\nTwo warnings are displayed because the test adds two new files to the tests/testthat/_snaps/ folder:\n\ntests/testthat/_snaps/\nâ””â”€â”€ shinytest2\n    â”œâ”€â”€ histogramApp-001.json\n    â””â”€â”€ histogramApp-001_.png\n\n2 directories, 2 files\n\nThese are the files new test runs will be compared against (i.e., our â€˜baselineâ€™ snapshots). Iâ€™ll briefly cover their contents below:\n\n_snaps\nexpect_values() generates two snapshot files in the tests/testthat/_snaps/ folder: one .png and one .json file:\n\n.png\nThe image saved in tests/testthat/_snaps/histogramApp-001_.png is below:\n\n\n\n\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (attitude and privileges).\n\n\n.json\nThe .json file saved in tests/testthat/_snaps/histogramApp-001.json contains the snapshot inputs, outputs, and exports:\n\nThe inputs show the three changed values (\"data-dataset\", \"var-var\", and \"hist-bins\").\n\n\nshow/hide snapshot inputs\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n    \"hist-bins\": 15,\n    \"var-var\": \"privileges\"\n  },\n\n\n\nThe two outputs are stored in \"hist-hist\" and \"vals\":\n\n\"hist-hist\" holds the updated image (stored in the image data hash), along with various other characteristics of the plot:\n\n\nshow/hide snapshot outputs\n  \"output\": {\n    \"hist-hist\": {\n      \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n      \"width\": 682.6640625,\n      \"height\": 400,\n      \"alt\": \"Plot object\",\n      \"coordmap\": {\n        \"panels\": [\n          {\n            \"domain\": {\n              \"left\": 27.8,\n              \"right\": 87.2,\n              \"bottom\": -0.24,\n              \"top\": 6.24\n            },\n            \"range\": {\n              \"left\": 78.79664956011726,\n              \"right\": 642.3048029692084,\n              \"bottom\": 301.08,\n              \"top\": 77.71999999999998\n            },\n            \"log\": {\n              \"x\": null,\n              \"y\": null\n            },\n            \"mapping\": {\n\n            }\n          }\n        ],\n        \"dims\": {\n          \"width\": 682.6640625,\n          \"height\": 400\n        }\n      }\n    },\n\n\n\"vals\" contains the reactive values from reactiveValuesToList():\n\n\nshow/hide snapshot outputs\n    \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n  },\n\n\nI didnâ€™t export any values in this test, so \"export\" is empty:\n\n\nshow/hide snapshot outputs\n  \"export\": {\n\n  }\n}\n\n\n\nIâ€™ll cover this in a later test.\n\n\n\n\nNamespaces\nThe contents of the .json snapshot should look somewhat familiar for the three modules contained in histogramApp():\n\nFor example, the inputId for \"dataset\" in the datasetInput/Server module communicates between the UI and server using the shared id argument \"data\"\n\n# in datasetInput()\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n# in histogramApp()\n  shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame)\n      )\n\nThis creates the $`data-dataset` output we see the verbatimTextOutput() at the bottom of the application:\n\n$`data-dataset`\n[1] \"attitude\"\n\nIn the .json snapshot, this inputId is represented in the following \"input\":\n\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n  },\n\n\nNamespaces and inputIds will come up again if you start writing your own tests, which Iâ€™ll cover below."
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#writing-tests",
    "href": "series/testing/series-testing-p4/index.html#writing-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Writing tests",
    "text": "Writing tests\nThe great thing about testing with shinytest2 is the ability to interact with the AppDriver as you write tests. Iâ€™ll demo writing a test for the datasetApp() by adapting the contents of test-shinytest2.R into a new test-shinytest2-datasetApp.R file.\n\ntests/testthat/\nâ”œâ”€â”€ _snaps/\nâ”‚   â””â”€â”€ shinytest2/\nâ”‚       â”œâ”€â”€ histogramApp-001.json\nâ”‚       â””â”€â”€ histogramApp-001_.png\nâ”œâ”€â”€ setup-shinytest2.R\nâ”œâ”€â”€ test-shinytest2-datasetApp.R &lt;- new test file!\nâ””â”€â”€ test-shinytest2.R\n\n3 directories, 5 files\n\nIn the new test test-shinytest2-datasetApp.R file, Iâ€™ll start with a call to testthat::test_that(), then create a new app object with the Chromium headless browser. The namespaced standalone app function can be passed to the first argument of AppDriver$new(), followed by the height and weight (which Iâ€™ve adjusted to fit the datasetApp()).\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n})\n\nIn the Console, I can use app$view() to open the Chromium browser:\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigureÂ 13: View application with app$view()\n\n\n\nChromium displays the same app I see when I run msst2ap::datasetApp() in the console, but the headless browser has some additional developer tools (read more).\n\nSetting inputs\nIf I continue to adapt each line in test-shinytest2.R to the datasetApp(), I see that next lines set the inputIds for dataset-dataset to the attitude dataset with app$set_input() (Note that this uses the module notation above (i.e., \"id-inputId\"):\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n\nIf you can see both windows, youâ€™ll see the application values change in the Chromium browser:\n\n\n\n\n\n\n\n\n(a) app$set_inputs()\n\n\n\n\nFigureÂ 14: Set application inputs with app$set_inputs()\n\n\n\n\n\nChecking inputs\nIn the previous test, I used the expect_values() to capture a list of all the app values (input, output, export). I can also capture these values in a list inside the test by including a call to app$get_values() and assigning the output to app_values.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n})\n\napp_values has a similar structure to the .json snapshot covered above (i.e., with input, output, and export):\n\nstr(app_values)\n\n\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"&lt;table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n\nI can narrow the scope of the test by using app_values to verify only the input that was changed with app$set_inputs()::\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n\nAt the end of the test, Iâ€™ll add a call app$stop() to close the Chromium app.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  app &lt;- AppDriver$new(msst2ap::datasetApp(), height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n\n\n\nRunning tests\nIâ€™ll save the test-shinytest2-datasetApp.R file and run the test with testthat::test_file():\n\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nIf you encounter the error message below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\nâ”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ€¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n\nTry installing and loading chromote and shinytest2 again (this seemed to work for me).\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n\n\n\n\n\nIn the initial run of the test for datasetApp(), no snapshot files are generated because the test didnâ€™t include a call to app$export_values().\nI see the tests passes:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#exporting-test-values",
    "href": "series/testing/series-testing-p4/index.html#exporting-test-values",
    "title": "Testing shiny apps with shinytest2",
    "section": "Exporting test values",
    "text": "Exporting test values\nThe shinytest2 documentation repeatedly recommends exporting test values from shiny applications with shiny::exportTestValues().\nIâ€™ll demonstrate exporting test values from selectVarApp() by adding the following to the server function in inst/dev/app.R:\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n\nAfter saving, loading and building the package, Iâ€™ll create the test-shinytest2-selectVarApp.R test file and add the initial contents to create the AppDriver object:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n\nNote that in this test, I can load the development version of selectVarApp() with system.file() (this is a similar folder structure to apps built with golem and leprechaun frameworks)\nAfter entering app$view() in the Console, the application opens in the Chromium headless browser again:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigureÂ 15: View selectVarApp() application with app$view()\n\n\n\nIn the test file, Iâ€™ll use app$set_values() to change the $`data-dataset` and $`var-var` inputs:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n})\n\nIâ€™ll use app$get_values() to store the exported input/output/export test values in app_values:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values &lt;- app$get_values()\n    \n})\n\napp_values is a list (similar to the .json snapshot file), but now weâ€™ve explicitly exported values from the server in selectVarApp():\n\nnames(app_values$export)\n\n\n[1] \"data\" \"var\" \n\nI can use app_values to verify the structure of each exported object:\n\ndata should be a data.frame()\n\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n\nvar should be a single column data.frame()\n\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\nOnce again, I end the test with a call to app$stop(). The completed test for selectVarApp() is below:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values &lt;- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n\nI can run the test with testthat::test_file().\n\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n\nThe results are below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#testing-complex-outputs",
    "href": "series/testing/series-testing-p4/index.html#testing-complex-outputs",
    "title": "Testing shiny apps with shinytest2",
    "section": "Testing complex outputs",
    "text": "Testing complex outputs\nIâ€™ve created an adapted version of the histogramApp() in the inst/dev/gghistApp/ folder (view contents here):\n\ninst/dev/gghistApp/\n            â”œâ”€â”€ DESCRIPTION\n            â”œâ”€â”€ R/\n            â”‚   â””â”€â”€ modules.R\n            â”œâ”€â”€ README.md\n            â””â”€â”€ app.R\n\n2 directories, 4 files\n\ngghistApp() renders a ggplot2 graph, which makes it easier to demonstrate this example of checking a plot from the shinytest2 package website.\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\n\n\n\n\n\n(b) gghistApp()\n\n\n\n\nFigureÂ 16: histogramApp() vs.Â gghistApp()\n\n\n\nThe gghistApp() is similar to histogramApp(), but instead of using hist() to generate the plot, a reactive plot_obj() is passed to shiny::renderPlot() (like the example above).\nDue to the structure of the modules in the application, the exportTestValues() function is placed in the gghistServer() function:\n\n\nshow/hide gghistServer()\ngghistServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj &lt;- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist &lt;- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |&gt;\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n\n\n\ngghistServer() is replaces histogramServer() in the standalone app function (gghistApp()):\n\n\nshow/hide gghistApp()\ngghistApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n\n    x &lt;- selectVarServer(\"var\", data)\n\n    gghistServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n      }, width = 30)\n\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\nIn the test-shinytest2-gghistApp.R test file, Iâ€™ll verify the vdiffr package is installed with testthat::skip_if_not_installed(), then create the AppDriver object with a call to system.file() and set the height and width:\n\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n\nView the application in the Chromium browser by running app$view() in the Console:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigureÂ 17: View gghistApp() application with app$view()\n\n\n\n\nExpectations\nIâ€™ll replicate the example from the website using the gghistApp():\n\nThe first expectations in the example test the default input values with app$get_value(input = ):\n\n  # Verify initial data\n  app_init_data &lt;- app$get_value(input = \"data-dataset\")\n  testthat::expect_equal(\n    object = app_init_data, \n    expected = \"BOD\")\n\n  # Verify initial variable\n  app_init_var &lt;- app$get_value(input = \"var-var\")\n  testthat::expect_equal(\n    object = app_init_var, \n    expected = \"Time\")\n\nNext, the expectations check the exported values after changing inputs with app$set_values() and app$get_value(export = )\n\n  # Verify exported `x()` data\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app_exp_x_01 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_01, \n    expected = mtcars[1])\n\n  # Verify exported `plot_obj()` data\n  app$set_inputs(`var-var` = \"wt\")\n  app_exp_plot_obj_01 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_01,\n    expected = purrr::as_vector(app_exp_plot_obj_01))\n\nThe bins are set to a new value after verifying the exported values with app$set_values() and app$get_value(input = )\n\n  # Verify `hist-bins` changes\n  app$set_inputs(`hist-bins` = 15)\n  app_set_bins_01 &lt;- app$get_value(input = \"hist-bins\")\n  testthat::expect_equal(\n    object = app_set_bins_01,\n    expected = 15)\n\nThe plot is verified with the exported hist-plot_obj and expect_doppelganger() from the vdiffr package.\n\n# Verify `hist-plot_obj` changes\nplot_obj_15 &lt;- app$get_value(export = \"hist-plot_obj\")\nvdiffr::expect_doppelganger(\n  title = \"hist-plot_obj-15\",\n  fig = plot_obj_15)\n\n\nI saved the test file and ran the test to confirm the snapshot file was created in tests/testthat/_snaps/:\n\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\nâ”€â”€ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp â”€â”€â”€\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n\nThe x(), plot_obj() and hist-bins are updated again with new values:\n\n  ## Update `data` to USArrests\n  app$set_inputs(`data-dataset` = \"USArrests\")\n  app_exp_x_02 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_02,\n    expected = USArrests[1])\n\n  ## Update `var` to UrbanPop\n  app$set_inputs(`var-var` = \"UrbanPop\")\n  app_exp_plot_obj_02 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_02,\n    expected = purrr::as_vector(app_exp_plot_obj_02))\n\n  ## Update `bins` to 12\n  app$set_inputs(`hist-bins` = 12)\n  app_set_bins_02 &lt;- app$get_value(input = \"hist-bins\")\n  expect_equal(\n    object = app_set_bins_02,\n    expected = 12)\n\nThe new plot is verified again with expect_doppelganger()\n\n  # Verify `hist-plot_obj` changes\n  plot_obj_12 &lt;- app$get_value(export = \"hist-plot_obj\")\n  vdiffr::expect_doppelganger(\n    title = \"hist-plot_obj-12\",\n    fig = plot_obj_12)\n\nThis initial run of this test will show a warning again as the snapshot file is saved to tests/testthat/_snaps/:\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\nâ”€â”€ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp â”€â”€â”€\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n\n\n\n\nResults\nThe final results of the test-shinytest2-gghistApp.R are below:\n\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]"
  },
  {
    "objectID": "series/testing/series-testing-p4/index.html#recap",
    "href": "series/testing/series-testing-p4/index.html#recap",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recap",
    "text": "Recap\nThis post has covered tests with shinytest2 for an app-package containing a shiny application with modules. The test recorder simplifies testing specific behaviors, and the AppDriver makes it possible to build a set of test expectations iteratively."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html",
    "href": "series/testing/series-testing-p3/index.html",
    "title": "How do I test shiny modules?",
    "section": "",
    "text": "This is the third post in a series on testing shiny applications. Iâ€™ll cover testing shiny module server functions using the testhat package and shinyâ€™s testServer() function."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#testing-shiny-modules",
    "href": "series/testing/series-testing-p3/index.html#testing-shiny-modules",
    "title": "How do I test shiny modules?",
    "section": "Testing shiny modules",
    "text": "Testing shiny modules\n\n\n\nShiny functions pose a couple of unique challenges for testing. First, we canâ€™t execute shiny server functions in the console. Second, as shiny apps become more complex, itâ€™s highly recommended to break up the code base into modules. Modules have additional challenges due to their reactivity being split between interconnected UI and server functions.\nshiny doesnâ€™t provide a direct, built-in way to test modules, but the testServer() function addresses these challenges by testing â€œreactive interactionsâ€ in module server functions. testServer() also works with testthat, which means we can structure these â€˜reactive interactionâ€™ tests just like other unit tests (for non-application functions)."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#shiny-app-package",
    "href": "series/testing/series-testing-p3/index.html#shiny-app-package",
    "title": "How do I test shiny modules?",
    "section": "Shiny app-package",
    "text": "Shiny app-package\ntestthat is designed to work within an R package, so Iâ€™ve put together the mstsap, (i.e., a Mastering Shiny testServer app-package) to demonstrate writing tests with testServer(). The functions, modules, and applications in mstsap come from the Shiny Modules chapter of Mastering Shiny. Specifically, sections 19.3 through 19.3.4. If you havenâ€™t read this chapterâ€“start there.\n\n# to get the mstsap package used in this post:\nrenv::install(\"mjfrigaard/mstsap\", prompt = FALSE)\nlibrary(mstsap)\n\n\n\n\n\n\n\nWhy create an app-package?\n\n\n\n\n\n\nA shiny app-package is a shiny application thatâ€™s been developed as (or converted to) an R package. The benefits of storing shiny apps in R packages have been well documented, but Iâ€™ll summarize just a few that are specific to testing:\n\nStandardized folder structure:\n\nIf unit tests are performed with testthat, minimal setup is required to perform tests.\nusethis::use_testthat() sets up test files in the tests/testthat/ folder (to test the code in the R/ folder)\n\nRead more about using testthat with R packages here.\n\nTest extras:\n\nTest data can be placed in tests/testthat/&lt;test dir&gt;/&lt;test_data.rds&gt;\n\nThe code used to create the test data should be placed in make_&lt;test_data.rds&gt;\n\nAdditional testing functions can be stored in tests/testthat/helpers.R\n\nRead more about test helpers here.\n\nDevelopment tools:\n\nIf youâ€™re using RStudio, tests can be run individually (testthat::test_file()) or collectively (devtools::test()), and code helpers and data are loaded using devtools::load_all()\n\nTests created with testthat remain isolated during development\n\nRead more about developing packages with RStudio in the R Packages text."
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#modules",
    "href": "series/testing/series-testing-p3/index.html#modules",
    "title": "How do I test shiny modules?",
    "section": "Modules",
    "text": "Modules\nShiny modules are â€˜a pair of UI and server functionsâ€™ designed to compartmentalize input and output IDs into distinct namespaces (â€œa namespace is to an ID as a directory is to a fileâ€).\n\nâ–ˆâ”€shinyApp \nâ”œâ”€ui = â–ˆâ”€fluidPage \nâ”‚      â””â”€â–ˆâ”€mod_ui \nâ”‚        â””â”€id = \"X\" \nâ”œâ”€server = `function(input, output, session)` \nâ””â”€â–ˆâ”€mod_server \n  â””â”€id = \"X\" \n\nIn a previous post, I used the following definition for unit tests,\n\nâ€œA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work.â€ - The Art of Unit Testing, 2nd edition\n\nModules can also be broken into discrete â€˜units of workâ€™ with expected â€˜end results.â€™ However, the â€˜unit of workâ€™ for a shiny module is usually accomplished using a combination of three functions: a module UI function, a module server function, and any helper/utility functions.\n\n\n\n\n\n\nShiny module refresher\n\n\n\n\n\nModule UI functions typically wrap the layout, input, and output functions in tagList(). Module server functions contain the â€˜backendâ€™ code that typically goes in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using NS() (namespace) in the UI function, and called in the server function with moduleServer().\n\nModule UI functions\nBelow is an example module UI function:\n\nmod_fun_ui &lt;- function(id) {\n  tagList(\n    numericInput(inputId = NS(namespace = id, id = \"num_input\")),\n    uiOutput(outputId = NS(namespace = id, id = \"num_out\"))\n  )\n}\n\n\nmod_fun_ui creates a dedicated namespace for one inputId and one outputId with shiny::NS():\n\nâ–ˆâ”€mod_fun_ui \nâ”œâ”€id \nâ””â”€â–ˆâ”€tagList \n  â”œâ”€â–ˆâ”€numericInput \n  â”‚ â””â”€inputId = â–ˆâ”€NS \n  â”‚             â”œâ”€namespace = id \n  â”‚             â””â”€id = \"num_input\" \n  â””â”€â–ˆâ”€uiOutput \n    â””â”€outputId = â–ˆâ”€NS \n                 â”œâ”€namespace = id \n                 â””â”€id = \"num_out\" \n\n\n\n\nModule server functions\nThe corresponding module server function is below:\n\nmod_fun_server &lt;- function(id) {\n        moduleServer(id, function(input, output, session) {\n            ns &lt;- session\n          output$num_out &lt;- uiOutput(outputId = input$num_input)\n      })\n}\n\n\nThe code to render the reactive input$num_input with output$num_out is contained in the nested call to moduleServer()\n\nâ–ˆâ”€mod_fun_server \nâ”œâ”€id \nâ””â”€â–ˆâ”€moduleServer \n  â”œâ”€id = id \n  â”œâ”€server = â–ˆâ”€`function(input, output, session)` \n  â”‚          â”œâ”€`ns &lt;- session` \n  â”‚          â”œâ”€`output$num_out &lt;-` \n  â”‚          â””â”€â–ˆâ”€renderUI \n  â”‚            â””â”€`input$num_input` \n  â””â”€session = session \n\n\n\n\nUsing modules\nBoth module functions are combined in the ui and server arguments of shinyApp():\n\nshinyApp(\n    ui = fluidPage(\n          mod_fun_ui(id = \"mod\")\n        ),\n   server = function(input, output, session) \n          mod_fun_server(\"mod\")\n  )\n\n\nThe id arguments connect the UI and server functions to communicate between the UI and backend of the app:\n\nâ–ˆâ”€shinyApp \nâ”œâ”€ui = â–ˆâ”€fluidPage \nâ”‚      â””â”€â–ˆâ”€mod_fun_ui \nâ”‚        â””â”€id = \"mod namespace\" \nâ””â”€server = â–ˆâ”€`function(input, output, session)` \n           â””â”€â–ˆâ”€mod_fun_server \n             â””â”€id = \"mod namespace\" \n\n\nI recommend creating test files when you create module files (i.e., with usethis::use_r() & usethis::use_test()).\n\n\n\n\n\nModules in mstsap\nmstsap contains three modules: dataset, selectVar, and selectDataVar. If youâ€™re like more information on a module, click on the links in the numbered list.\n\nDataset module\n\ndatasetInput/datasetServer: loads and returns data object from the datasets package (filtered by data frames or matrices)\n\n\n\n\n\n\n(a) dataset module\n\n\nFigureÂ 1: dataset module\n\n\n\nThe objects from datasets are filtered in the UI module function with a filter argument that can be used to â€œlimit the options to built-in datasets that are either data frames (filter = is.data.frame) or matrices (filter = is.matrix)â€. The names are passed to the choices in the selectInput():\n\n\nshow/hide choices in datasetInput()\nnames &lt;- ls(\"package:datasets\")\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n\nThe datasets object is returned with get() (wrapped in reactive()). See below:\n\n\nshow/hide returned data from datasetServer()\nshiny::reactive(\n      get(input$dataset, \"package:datasets\")\n    )\n\n\n\n\n\nselectVar module\n\nselectVarInput/selectVarServer: displays a selectInput() that â€œallows the user to select variables of specified type from a given reactive dataset.â€\n\n\n\n\n\n\n(a) selectVar module\n\n\nFigureÂ 2: selectVar module\n\n\nThe data argument in selectVarServer() is the returned value from datasetServer():\n\ndata() is used with the filter argument in the find_vars() function:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter) {\n # I've included the updated version with the 'stopifnot()' checks!\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\nThe filter argument can be used to return variables by class/type (using is.* functions like is.numeric() or is.character())\n\nWhen data() changes, the output from find_vars() updates the choices in the variable selectInput() (i.e., input$var) (see below)\n\n\n\n\n\n\n(a) selectVar and find_vars()\n\n\nFigureÂ 3: selectVar module and find_vars() function\n\n\n\nselectVarServer() also returns the selected variable (input$var) as a reactive value (var())\n\n\n\nselectDataVar module\n\nselectDataVarUI/selectDataVarServer: The selectDataVar module is from the section titled, â€œModules inside of modulesâ€, so here we see the dataset and selectVar modules placed inside the selectDataVar module (each with a new namespace (NS())).\n\n\n\n\n\n\n(a) selectDataVar module\n\n\nFigureÂ 4: selectDataVar module\n\n\n\n\n\n\n\n\nNaming modules\n\n\n\n\n\n\nWhen creating an app-packages, modules are stored in the R/ folder as a single file, typically following a naming convention that differentiates modules from the other package functions. The modules in this post use camelCase, with suffix variations (i.e., Input/Server and UI/Server) for each functions. Other options come from the golem and leprechaun packages.\ngolem modules are created with golem::add_module()\n\n\n\nexpand to see golem::add_module(â€œinputsâ€)\nmod_inputs_ui &lt;- function(id){\n  ns &lt;- NS(id)\n  tagList(\n  )\n}\nmod_inputs_server &lt;- function(id){\n  moduleServer( id, function(input, output, session){\n    ns &lt;- session$ns\n \n  })\n}\n## To be copied in the UI\n# mod_inputs_ui(\"inputs_1\")\n    \n## To be copied in the server\n# mod_inputs_server(\"inputs_1\")\n\n\n\ngolem modules the following naming convention:\n\nAll new module functions have a mod_ prefix\ngolem module functions are differentiated with either a _ui or _server suffix\nNew golem module files are named R/mod_&lt;name&gt;.R\n\nleprechaun modules are also created with a leprechaun::add_module() function.\n\n\n\nexpand to see leprechaun::add_module(â€œinputsâ€)\ninputsUI &lt;- function(id){\n    ns &lt;- NS(id)\n    tagList(\n        h2(\"inputs\")\n    )\n}\ninputs_server &lt;- function(id){\n  moduleServer(id, function(input, output, session) {\n                ns &lt;- session$ns\n                send_message &lt;- make_send_message(session)\n                # your code here\n        }\n    )\n}\n# UI\n# inputsUI('id')\n\n# server\n# inputs_server('id')\n\n\n\nleprechaun modules have a slightly different naming convention:\n\nAll new UI module functions have a UI suffix\nAll new module server functions have a _server suffix\nleprechaun module functions do not have a prefix\nNew leprechaun modules named module_&lt;name&gt;.R\n\nShiny app-packages often require multiple modules and utility functions, so uniform names will make it easier to manage (and test!) your code.\n\n\n\n\n\n\n\nStandalone app functions\nmstsap contains three standalone functions for running each set of module functions.\nIâ€™ve made a small change to each standalone app functionâ€“each app has a call to reactiveValuesToList() that displays in the UI.\n\n\nprint reactive values\n  shiny::verbatimTextOutput(\"vals\")\n\n  output$vals &lt;- shiny::renderPrint({\n    x &lt;- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n\n\n\ndatasetApp\ndatasetApp() contains a call to the dataset module, and includes a tableOutput() to render the selected data object:\n\n\n\n\n\n(a) datasetApp\n\n\nFigureÂ 5: datasetApp\n\n\nWhen datasetApp() is run, the app displays the dataset object in the tableOutput(), and the verbatimTextOutput() renders the reactive values as a text:\n\n\n\n\n\n(a) datasetApp with reactive values\n\n\nFigureÂ 6: datasetApp with reactiveValuesToList()\n\n\nThe output above shows what NS() does in the dataset moduleâ€“it appends the module id argument to the inputId (which is why we see dataset-dataset).\n\ndataset-: the module id\ndataset-dataset the inputId from the selectInput()\n\n\n\nselectVarApp\nselectVarApp() includes both dataset and selectVar modules, but instead of rendering the output in a table, the UI renders the variable output in a verbatimTextOutput().\n\n\n\n\n\n(a) selectVarApp\n\n\nFigureÂ 7: selectVarApp\n\n\nNote that selectVarApp() contains namespaces for two modules:\n\n\"data\": the namespace for the datasetnput() and datasetServer() modules, inheriting the filter argument and creating the data object\n\"var\": the selectVar modules are linked with the \"var\" id. selectVarServer() uses the data object created by datasetServer() (and also inherits the filter argument).\n\nThese namespaced IDs are rendered below with reactiveValuesToList():\n\n\n\n\n\n(a) selectVarApp with reactive values\n\n\nFigureÂ 8: selectVarApp with reactiveValuesToList()\n\n\nThereâ€™s a lot happening in selectVarApp(), so Iâ€™ve created the figure below to display the code for the modules with their displayed outputs:\n\n\n\n\n\n\n(a) selectVarApp schema\n\n\nFigureÂ 9: dataset and selectVar modules with rendered outputs\n\n\n\nAs we can see, the data output from the dataset module is used to generate the vars() reactive for the verbatimTextOutput() in selectVarApp(). Note that both dataset and selectVar modules donâ€™t contain any output functionsâ€“these have been provided in the UI for both datasetApp() and selectVarApp().\n\n\nselectDataVarApp\nThe final app in mstsap is selectDataVarApp(). Here the inputs from dataset and selectVar have been moved into the sidebarPanel(), and the output is rendered in the mainPanel().\n\n\n\n\n\n(a) selectDataVarApp\n\n\nFigureÂ 10: selectDataVarApp\n\n\nThe reactive values here show how the â€˜Modules inside of modulesâ€™ workâ€“by adding the additional call to NS() in the datasetInput() and selectVarInput() functions within selectDataVarUI() and selectDataVarServer(), an additional namespace is appended to the reactive values (input$dataset and input$var):\n\n\n\n\n\n(a) selectDataVarApp with reactive values\n\n\nFigureÂ 11: selectDataVarApp with reactiveValuesToList()\n\n\nBelow is a figure that displays the contents of the selectDataVar modules (Iâ€™ve removed the tagList() and moduleServer() for simplicity), the selectDataVarApp(), and the rendered outputs:\n\n\n\n\n\n\n(a) selectDataVarApp schema\n\n\nFigureÂ 12: dataset and selectVar modules inside selectDataVar module with rendered outputs"
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#testserver",
    "href": "series/testing/series-testing-p3/index.html#testserver",
    "title": "How do I test shiny modules?",
    "section": "testServer()",
    "text": "testServer()\nModule server functions can be tested the same way as a traditional shiny server function, as long as you provide the inputs and verify the correct outputs. Below Iâ€™ll cover some general advice on module server tests (and the arguments in testServer()).\n\nTesting module server functions\nBefore writing tests, make sure you can answer the following:\n\nWhat is the overall purpose of the application?\n\nThis information is typically referred to as the â€˜business logicâ€™ of the application, and should be stored in a specifications or requirements document. If I canâ€™t answer this question, Iâ€™m probably better off not writing test for code that is likely to undergo major changes.\n\nHow does this module fit within that overall purpose?\n\nSpecifically, how does this module help the application achieve the specifications or requirements? This could also be considered the â€˜unit of workâ€™ and â€˜end resultâ€™ for the module.\n\nWhat dependencies (i.e., utility functions, data, add-on packages) are required for the module to execute?\n\nIf the module depends on other functions, data, or packages to perform itâ€™s expected behavior, those functions should either be included in the testServer() test, or have their own tests (or both).\n\n\n\nWhat should I test?\nThe items below have been compiled from Mastering Shiny, R Packages, and Engineering Production-Grade Shiny Apps:\n\nDo the inputs/outputs behave as expected?\n\nThese tests verify the module server function inputIds and outputIds are properly namespaced and accessible\n\nDoes the module contain the expected reactive values/objects?\n\nTests should verify itâ€™s reactivityâ€“module server functions will automatically recompute the outputs when itâ€™s inputs change, so tests should verify changes to inputs produce the expected behaviors and outputs. This includes any returned values from the module (and any additional function arguments).\n\nAre the calculations correct?\n\nIf the module server function performs calculations or data manipulations, the tests should verify the module produces the correct result (ideally for a variety of inputs and edge cases).\n\nHow are errors handled in the module?\n\nWhat errors are displayed from the module? Tests should simulate scenarios that can test if the module: 1) returns errors that are informative, 2) fails silently (when appropriate), or 3) falls back to the correct default behavior.\n\n\nThe last piece of advice Iâ€™ve found helpful when writing tests comes from R Packages,\n\nâ€œfocus your time on code that youâ€™re not sure about, is fragile, or has complicated interdependenciesâ€\n\nThe quote isnâ€™t in reference to testing modules or shiny application functions, but Iâ€™ve found itâ€™s easy to fall into the trap of trying to test everything when a targeted approach is more efficient (and equally valid).\nThe first test Iâ€™ll perform is for datasetServer(), the module used to return a data object from the datasets package.\n\n\n\ntestServer() arguments\n\napp can be a module server function (i.e., datasetServer), or any shiny.appobj\nexpr is where Iâ€™ll add the testthat expectations and other test code\nargs is a list() I can use to include any module server function arguments\n\n\n\nInputs\nI created the test file with usethis::use_test(\"datasetServer\") and the module server function is the first argument in testServer().\nIâ€™ll start by testing if the initial input value (input$dataset) in datasetServer() is set to NULL:\n\nshiny::testServer(app = datasetServer, expr = {\n  testthat::expect_equal(input$dataset, NULL)\n  cat(\"\\ndatasetServer: dataset$input is NULL\", \"\\n\")\n})\n\n\nIâ€™ll add a custom message with cat() and the inputId Iâ€™m testing, load, document, and install the package, then run the test with testthat::test_file():\ndevtools::load_all()\nâ„¹ Loading mstsap\ndevtools::document()\nâ„¹ Updating mstsap documentation\nâ„¹ Loading mstsap\n\nRestarting R session...\n\nlibrary(mstsap)\n\nAnd run the test with testthat::test_file():\n\n\ntest_file(\"tests/testthat/test-datasetServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\ndatasetServer: dataset$input is NULL \n\n\n\n\n\n\n\nCreating test messages with testServer()\n\n\n\n\n\n\nThe testServer() documentation has examples of using cat() to create custom messages. I put a function for creating testServer() messages (test_cmt()) in the helper.R file (read more about test helpers here).\nIt has two arguments (test and msg), and makes it easy to print messages to the console while Iâ€™m developing tests.\n\ntest_cmt(test = \"mod_server_function\", msg = \"test contents\")\n\n       mod_server_function: test contents \n\n\n\n\n\n\nSetting test inputs\ntestServer() allows us to mimic changing application (or module) inputIds with session$setInputs() like so:\n\nsession$setInputs(inputId = \"value\")\n\nIâ€™ll demonstrate with a test for input$dataset in datasetServer():\n\n  session$setInputs(dataset = \"faithful\")\n  testthat::expect_equal(\n    object = input$dataset,\n    expected = \"faithful\")\n  test_cmt(\"datasetServer\", \"dataset$input\")\n\nThe results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetServer: dataset$input\n\n\n\nReturned values\nAny returned values from module server functions can be accessed in testServer() with session$returned(). Iâ€™ll verify input$dataset returns an object from datasetServer() by testing the class of session$returned():\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"airquality\")\n  testthat::expect_equal(\n    object = class(session$returned()),\n    expected = \"data.frame\")\n  test_cmt(\"datasetServer\", \"class(session$returned())\")\n\n  session$setInputs(dataset = \"WorldPhones\")\n  testthat::expect_true(\n    object = is.matrix(session$returned()))\n  test_cmt(\"datasetServer\", \"is.matrix(session$returned())\")\n\n\nNote that both methods above can be used to check the class of the returned object.\nThe updated results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetServer: class(session$returned()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetServer: is.matrix(session$returned()) \n\nI can also use the typeof(datasets::mtcars) for a direct comparison:\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"mtcars\")\n  expect_equal(\n    # app value...\n    object = typeof(session$returned()), \n    # ...compared to actual output\n    expected = typeof(datasets::mtcars)) \n  test_cmt(\"datasetServer\", \"typeof(session$returned())\")\n\n\n\n\n\nModule server arguments\nIf the module server function has additional arguments beyond id, then it has additional functionality to verify with unit tests. To test additional module server arguments, pass these to testServer(args = list()). The args list should include named arguments from the module server function, i.e., list(arg1 = \"param1\", arg2 = \"param2\").\nFor example, selectVarServer() has data and filter arguments:\n\ndata is the returned reactive object from datasetServer()\nfilter is the function passed to the find_vars() utility function\n\n\n\n\n\n\n\n(a) dataset() -&gt; selectVar()\n\n\nFigureÂ 13: Object returned from datasetServer() and passed to selectVarServer()\n\n\n\nBelow is a test for selectVarServer() using args to verify the reactive data() is datasets::mtcars:\n\nshiny::testServer(selectVarServer,\n  args = list(data = datasets::mtcars,\n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\nBut this fails with the following error:\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\nâ”€â”€ Error (test-selectVarServer.R:1:1): (code run outside of `test_that()`) â”€â”€â”€\nError in `(function (id, data, filter = is.numeric) \n{\n    stopifnot(shiny::is.reactive(data))\n    stopifnot(!shiny::is.reactive(filter))\n\nWhat happened?\n\nIâ€™ve included this example because itâ€™s not in the testServer() documentation, and itâ€™s common to pass values between modules (see here in Engineering Production-Grade Shiny Apps and here in Mastering Shiny)\n\nTesting module communication\nThe error message above tells me the issue is originating from the stopifnot() calls in selectVarServer().\n\n\n\n\n\n\nUpdating selectVarServer() and find_vars()\n\n\n\n\n\n\nBoth selectVarServer() and find_vars() are updated from their original versions to include stopifnot() checks for is.reactive(), is.data.frame() and is.function():\n\nOriginal versions:\n\nfind_vars &lt;- function(data, filter) {\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session, \"var\", choices = find_vars(data(), filter))\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\nUpdated versions:\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n\n  stopifnot(is.reactive(data))\n  stopifnot(!is.reactive(filter))\n\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session = session, \n        inputId = \"var\", \n        choices = find_vars(data(), filter)\n        )\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\n\nfind_vars &lt;- function(data, filter) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\n\n\nIâ€™ll stop a moment here to address whatâ€™s happening in each module:\n\nThe datasetServer() returns the results of input$dataset as a reactive (data())\ndata() enters selectVarServer() in the data argument\nInside selectVarServer(), two stopifnot() functions evaluate the reactivity of data and filter with shiny::is.reactive()\n\nIn datasetServer(), the return object is wrapped in the reactive() function, so the items args = list() also need to be wrapped in reactive().\nIâ€™ll re-write the test above to a more basic test using is.reactive():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data()))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n       selectVarServer: is.reactive(data()) \nâ”€â”€ Failure (test-selectVarServer.R:1:1): (code run outside of `test_that()`) â”€â”€â”€\nis.reactive(data()) is not TRUE\n\n`actual`:   FALSE\n`expected`: TRUE \n\nAnother failure???\n\nThe results of this test might seem confusing given my advice to wrap the args list in reactive(), but some reading of the x argument in is.reactive() will clear up the error:\n\nFor is.reactive(), an object to test. For reactive(), an expression.\n\nRemoving the parentheses from data() will result in the proper test results:\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectVarServer: is.reactive(data()) \n\n\n\nUtility functions\nNow that I have a reactive data() input, I can explore how this value is used inside selectVarServer(). To update input$var, the data() input is passed to find_vars() (a function that uses a filter argument â€œused to select which variables to listâ€). See the example below:\n\nmstsap::find_vars(\n  data = datasets::chickwts, \n  filter = is.factor)\n## [1] \"feed\"\n\nIâ€™ll write an expectation that captures the behavior of find_vars() in selectVarServer():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::chickwts),\n              filter = is.numeric), expr = {\n  testthat::expect_equal(\n    object = find_vars(data(), is.factor),\n    expected = \"feed\")\n  test_cmt(\"selectVarServer\", \"find_vars()\")\n})\n\nThe results are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectVarServer: find_vars()\nTo verify that the returned object from selectVarServer() is the selected column, Iâ€™ll need to simulate the application behavior in the tests:\n\nCreate a reactive data() input in selectVarServer():\n\n\nsetting args = list()\n  shiny::testServer(selectVarServer,\n    args = list(data = reactive(datasets::chickwts),\n                filter = is.numeric), expr = {\n\n    # include expectations below...\n\n  })\n\n\nSet the input$var and verify the input$var:\n\n\nverify input$var\n  session$setInputs(var = \"weight\")\n  testthat::expect_equal(object = input$var,\n      expected = \"weight\")\n  test_cmt(\"selectVarServer\", \"input$var\")\n\n\nSet the input$var and verify the session$returned()\n\n\nverify session$returned()\n  session$setInputs(var = \"feed\")\n  testthat::expect_equal(object = session$returned(),\n    expected = datasets::chickwts[[\"feed\"]])\n  test_cmt(\"selectVarServer\", \"session$returned()\")\n\n\n\nThe results from these tests are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectVarServer: input$var \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       selectVarServer: session$returned() \n\n\nModule outputs\nRendered outputs can be accessed in testServer() just like inputs (i.e., with output$outputId). But the modules in mstsap donâ€™t have outputsâ€“these are included in the standalone app functions (datasetApp(), selectVarApp(), and selectDaraVarApp()).\nFortunately, app functions can also be passed to the app argument of testServer(). Iâ€™ll use datasetApp() to demonstrate.\n\n\n\n\n\nTesting a standalone app function is similar to testing a module server function, but with a few minor differences. First, the output from the standalone app function is assigned to an object (ds_app), then placed in the app argument:\n\nds_app &lt;- datasetApp()\n  shiny::testServer(ds_app, expr = {\n\n  })\n\nTo use session$setInputs() need to include the namespace for the inputId:\n\n\n\n\n\nThe output from reactiveValuesToList() in datasetApp() shows me how to access the inputId in the datasetServer() module (i.e., input$`dataset-dataset`):\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n\n})\n\n\nOutput testing strategy\nTesting outputs with testServer() is different than testing outputs in regular unit tests, because shiny outputs are executed in the server, but then rendered in the UI. The testServer() documentation outlines a testing strategy for complex outputs:\n\n*The goal for your tests should be to ask â€œis the code that I wrote producing the plot I want?â€ There are two components to that question:\n\nDoes the plot generate without producing an error?\nIs the plot visually correct?\n\ntestServer is great for assessing the first component here. By merely referencing output$plot in your test, youâ€™ll confirm that the plot was generated without an error.\n\nIf we replace plot with table in the advice above, the tests for datasetApp() should confirm output$data is generated without producing an error.\nInstead of writing an expectation, Iâ€™ll use cat() to display the contents of output$data after setting the `dataset-dataset` input:\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n  cat(\"\\n\\toutput$data:\\n\", output$data, \"\\n\")\n})\n\nThe results from the test is below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$data:\n &lt;table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'&gt;\n  &lt;thead&gt; \n      &lt;tr&gt; \n        &lt;th style='text-align: right;'&gt; weight &lt;/th&gt; \n        &lt;th style='text-align: left;'&gt; feed &lt;/th&gt;  \n     &lt;/tr&gt; \n    &lt;/thead&gt; \n      &lt;tbody&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 179.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 160.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 136.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 227.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 217.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 168.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n   &lt;/tbody&gt; \n &lt;/table&gt; \nThe output is the HTML used to render the table in the UI. This doesnâ€™t add a passing test, but it confirms that the table is being generated from the data() reactive.\nThe tests for datasetApp() will confirm the inputId, and verify the class and names of the data() reactive (which will be passed to the renderTable() function):\n\n  testthat::expect_equal(\n    object = input$`dataset-dataset`,\n    expected = \"chickwts\")\n  test_cmt(\"datasetApp\", \"input$`dataset-dataset`\")\n\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  test_cmt(\"datasetApp\", \"is.data.frame(data())\")\n\n  testthat::expect_equal(\n    object = names(data()),\n    expected = names(datasets::chickwts))\n  test_cmt(\"datasetApp\", \"names(data())\")\n\nI can include a test for the class of output$data, but note that this is a character output:\n\n  testthat::expect_equal(\n    object = class(output$data),\n    expected = \"character\")\n  test_cmt(\"datasetApp\", \"class(output$data)\")\n\nThe results from test_file() are below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       datasetApp: input$`dataset-dataset` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetApp: is.data.frame(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetApp: names(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetApp: class(output$data) \nThe same method can be used to test the selectVarApp(), but note this app requires passing both inputIds to session$setInputs():\n\n\nshow/hide selectVarApp() tests\nsv_app &lt;- selectVarApp()\nshiny::testServer(app = sv_app, expr = {\n  session$setInputs(`var-var` = \"Ozone\",\n                    `data-dataset` = \"airquality\")\n  # confirm contents of output$out\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n  \n  # confirm var is reactive \n  testthat::expect_true(object = is.reactive(var))\n  # confirm var input\n  testthat::expect_equal(\n    object = input$`var-var`,\n    expected = \"Ozone\")\n  # confirm data is reactive\n  testthat::expect_true(object = is.reactive(data))\n  # confirm data() is a data.frame\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  # confirm 'data' can be subsetted with 'var'\n  testthat::expect_equal(\n    object = data()[[input$`var-var`]],\n    expected = airquality[[\"Ozone\"]])\n})\n\n\n\n\nTesting nested modules\nI highly recommend viewing the output of reactiveValuesToList() if your application has nested modules. Itâ€™s easy to lose track of ids if they span multiple layers.\nWe know selectDataVarApp() contains â€˜modules inside other modulesâ€™, and these layers are reflected in the namespaces:\n\n\n\n\n\nTo access the inputIds in the nested modules, we need to pass the full â€˜appendedâ€™ namespace:\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n})\n\nAfter setting the inputs, I can confirm the contents of output$out\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$out:\n   [1]  41  36  12  18  NA  28  23  19   8  NA   7  16  11  14  18\n [16]  14  34   6  30  11   1  11   4  32  NA  NA  NA  23  45 115\n [31]  37  NA  NA  NA  NA  NA  NA  29  NA  71  39  NA  NA  23  NA\n [46]  NA  21  37  20  12  13  NA  NA  NA  NA  NA  NA  NA  NA  NA\n [61]  NA 135  49  32  NA  64  40  77  97  97  85  NA  10  27  NA\n [76]   7  48  35  61  79  63  16  NA  NA  80 108  20  52  82  50\n [91]  64  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28\n[106]  65  NA  22  59  23  31  44  21   9  NA  45 168  73  NA  76\n[121] 118  84  85  96  78  73  91  47  32  20  23  21  24  44  21\n[136]  28   9  13  46  18  13  24  16  13  23  36   7  14  30  NA\n[151]  14  18  20 \nAfter confirming output$out, Iâ€™ll test the inputs:\n\n  testthat::expect_equal(\n    object = input$`var-var-var`,\n    expected = \"Ozone\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-var-var`\")\n\n  testthat::expect_equal(\n    object = input$`var-data-dataset`,\n    expected = \"airquality\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-data-dataset`\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectDataVarApp: input$`var-var-var` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectDataVarApp: input$`var-data-dataset`\nI can also verify the contents of the reactive var() inside the test:\n\n  testthat::expect_true(object = is.reactive(var))\n  test_cmt(\"selectDataVarApp\", \"is.reactive(var)\")\n  cat(\"\\n\\tvar:\\n\", var(), \"\\n\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectDataVarApp: is.reactive(var) \n\n    var:\n 41 36 12 18 NA 28 23 19 8 NA 7 16 11 14 18 14 34 6 30 11 1 11 4 32 NA NA NA 23 \n    45 115 37 NA NA NA NA NA NA 29 NA 71 39 NA NA 23 NA NA 21 37 20 12 13 NA NA NA\n    NA NA NA NA NA NA NA 135 49 32 NA 64 40 77 97 97 85 NA 10 27 NA 7 48 35 61 79 \n    63 16 NA NA 80 108 20 52 82 50 64 59 39 9 16 78 35 66 122 89 110 NA NA 44 28 \n    65 NA 22 59 23 31 44 21 9 NA 45 168 73 NA 76 118 84 85 96 78 73 91 47 32 20 23\n    21 24 44 21 28 9 13 46 18 13 24 16 13 23 36 7 14 30 NA 14 18 20"
  },
  {
    "objectID": "series/testing/series-testing-p3/index.html#recap",
    "href": "series/testing/series-testing-p3/index.html#recap",
    "title": "How do I test shiny modules?",
    "section": "Recap",
    "text": "Recap\nThis post has shown how shinyâ€™s testServer() function allows you to isolate and test module server functions, which makes it easier to ensure that your server function behaves as expected (and locate and fix bugs).\nI hope you have a better understanding of how you can use testServer() to test a modules inputs/outputs, reactivity, calculations, and errors.\nIn the next post Iâ€™ll cover performing integration tests with shinytest2!"
  },
  {
    "objectID": "series/testing/series-testing-p2/index.html",
    "href": "series/testing/series-testing-p2/index.html",
    "title": "How do I test my (non-package) shiny application?",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(vdiffr)\nlibrary(shinytest2)\nThis post is the second in a series on testing shiny applications. Iâ€™ll cover testing shiny module server functions using the testhat package outside an R package. This application is stored in the noap GitHub repo if youâ€™d like to follow along."
  },
  {
    "objectID": "series/testing/series-testing-p2/index.html#testing-module-server-functions",
    "href": "series/testing/series-testing-p2/index.html#testing-module-server-functions",
    "title": "How do I test my (non-package) shiny application?",
    "section": "Testing module server functions",
    "text": "Testing module server functions\n\nâ€¦the ABCs of testing shiny server modulesâ€¦\n\nThis post covers how shiny::testServer() works using the abcApp() shiny app.. The code for abcApp() is an RStudio project (i.e., there is a noap.Rproj file in the parent folder), but itâ€™s not part of an R package. Developing shiny applications as R packages is highly recommended, but itâ€™s possible to begin writing unit tests before your application is a fully developed shiny app-package.\nFor more information regarding performing tests outside of the package environment, see this issue on GitHub.\n\nabcApp()\nThe abcApp() application has been written using shiny modules and a single utility function.\ntestthat is designed to perform unit tests for R packages, but for the sake of simplicity,abcApp() has not been developed as part of a package. This will allow us to focus on the files involved in testing (and not all the other files that accompany R packages).\nThe standalone application function (abcApp()) is stored in app.R, the modules are contained in modules.R, and the single utility function is stored in utils.R:\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ app.R\nâ”œâ”€â”€ app.Rproj\nâ”œâ”€â”€ modules.R\nâ”œâ”€â”€ tests\nâ””â”€â”€ utils.R\n\n2 directories, 5 files\n\nThe tests folder contains the following:\ntests\nâ”œâ”€â”€ testthat\nâ”‚   â””â”€â”€ test-mod_abc_server.R\nâ””â”€â”€ testthat.R\n\n2 directories, 2 files\n\ntests/ has a testthat.R file\n\nNew test files should be placed in tests/testthat/ (see example test-mod_abc_server.R below):\n\n\n\nUI module function\nIn this small example app, both ui and server modules are stored in the modules.R file.\n\nUI module:\n\n\nmod_abc_ui() (example ui module function)\n# ui module\nmod_abc_ui &lt;- function(id) {\n\n  ns &lt;- shiny::NS(id)\n\n  shiny::tagList(\n    shiny::numericInput(\n      inputId = ns(\"num\"),\n      label = shiny::h4(\n        shiny::code(\"alphabet number\")),\n        value = 5, min = 1, max = 26\n    ),\n    shiny::verbatimTextOutput(\n      outputId = ns(\"txt\"))\n  )\n}\n\n\n\n\n\nServer module function\nThe counterpart to mod_abc_ui() is mod_abc_server():\n\nServer module:\n\n\nmod_abc_server() (example server module function)\n# server module\nmod_abc_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    # reactive \n    letter &lt;- shiny::reactive({ LETTERS[input$num] })\n    # super script\n    sup_scrpt &lt;- shiny::reactive({ \n      num_super_script(x = input$num)\n    })\n    # output\n    output$txt &lt;- shiny::renderPrint({\n      paste0(\"The \", input$num, sup_scrpt(), \n             \" letter in the alphabet is: \", letter())\n    })\n\n  })\n}\n\n\n\n\n\nModule utility function\nThe mod_abc_server() function uses the num_super_script() function stored in utils.R:\n\nUtility function:\n\n\nnum_super_script() (example utility function)\n# utility function\nnum_super_script &lt;- function(x) {\n      num &lt;- as.numeric(x)\n      if (num == 1) {\n        super_script &lt;- \"st\"\n      } else if (num == 2) {\n        super_script &lt;- \"nd\"\n      } else if (num == 3) {\n        super_script &lt;- \"rd\"\n      } else {\n        super_script &lt;- \"th\"\n      }\n    return(super_script)\n}\n\n\n\n\n\nStandalone app function\n\nStandalone app functions include a call to shiny::shinyApp():\n\n\nabcApp() (example app with modules)\n# standalone shiny app function\nabcApp &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      mod_abc_ui(\"x\")\n    ), \n    server = function(input, output, session) { \n      mod_abc_server(\"x\")\n    }\n  )\n}\nabcApp()\n\n\n\nThe call to shiny::shinyApp() is placed inside the abcApp() function\nThe ui argument is wrapped in shiny::fluidPage() and the ui module function (mod_abc_ui()) is placed inside\nThe server argument includes the standard function(input, output, session) and the module server companion functionâ€“mod_abc_server()â€“with a matching id arguments\nThe abcApp() function is stored in the app.R file\n\n\nBecause abcApp() is not part of a package, shiny and testthat are loaded and the modules and utility function are sourced in the top of the app.R file.\n\n\nsource utils.R and modules.R in app.R\n# packages --------------------------------------------------------\nlibrary(shiny)\nlibrary(testthat)\n\n# utils ------------------------------------------------------------------\nsource(\"utils.R\")\n\n# modules ------------------------------------------------------------------\nsource(\"modules.R\")\n\n\n\n\n\nUsing testServer()\nIn the test-mod_abc_server.R file, Iâ€™ll add testServer() and include the module server function as the first argument:\n\napp is the module server function (mod_abc_server) or any shiny.appobj\n\n\napp = shiny.appobj\nshiny::testServer(app = mod_abc_server, {\n\n})\n\n\n\n\nTesting input$s\n\nThe first test Iâ€™ll add will check the initial value of input$num\n\nIâ€™ll also include a custom message with cat()\n\n\n\ntest initial value with custom message\nshiny::testServer(mod_abc_server, {\n  # Test 1: check initial value\n  testthat::expect_equal(input$num, NULL)\n  cat(\"\\n Test 1 initial input$num = NULL: \", is.null(input$num), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTest 1 initial input$num = NULL:  TRUE \n\ntestServer() allows me to set new input values with session$setInputs()\n\nUse session$setInputs() to set input$num to 3\nTest 2 confirms input$num has changed\nAdd another custom message with cat()\n\n\n\n\nsetInputs() and test inputs\nshiny::testServer(mod_abc_server, {\n  # set inputs\n  session$setInputs(num = 3)\n  # Test 2: check set inputs\n  testthat::expect_equal(input$num, 3)\n  cat(\"\\n Test 2 setInputs(num = 3):\", input$num, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 2 setInputs(num = 3): 3 \n\n\n\nTesting reactive values\n\nThe moduleâ€™s reactive values are also available to in testServer()\n\nTest 3 adds a test for sup_scrpt() (given the changed value of input$num)\n\nThe expected value is what Iâ€™m expecting num_super_script() to return.\n\n\n\n\nCheck sup_scrpt() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 3: check super script\n  testthat::expect_equal(object = sup_scrpt(), expected = \"rd\")\n  cat(\"\\n Test 3 sup_scrpt(): = 'rd':\", sup_scrpt(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 3 sup_scrpt(): = 'rd': rd  \n\nFor completeness Iâ€™ll add a test for letter()\n\n\n\nCheck letter() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 4: check letter\n  testthat::expect_equal(object = letter(), expected = \"C\")\n  cat(\"\\n Test 4 letter() = C:\", letter(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 4 letter() = C: C \n\n\n\nTesting output$s\n\nThe module output values are also available as output$&lt;value&gt;\n\nTest 5 will verify the output$txt (given the updated input$num)\n\n\n\nCheck module output values\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\nâ”€- Failure (test-mod_abc_server.R:1:1): (code run outside of `test_that()`) â”€â”€\noutput$txt (`actual`) not equal to \"The 3rd letter in the alphabet is: C\" (`expected`).\n\n`actual`:   \"[1] \\\"The 3rd letter in the alphabet is: C\\\"\"\n`expected`: \"The 3rd letter in the alphabet is: C\"        \nBacktrace:\n  1. shiny::testServer(...)\n       at test-mod_abc_server.R:1:0\n 22. testthat::expect_equal(object = output$txt, \n   expected = \"The 3rd letter in the alphabet is: C\")\n       at test-mod_abc_server.R:17:4\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\nWhat happened? I forgot to add the escape characters (\\\") and line number ([1]) for the output\n\nIâ€™ll change the expected value and re-run the test:\n\n\n\n\nCheck module output values (again)\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\nFinally, Iâ€™ll run the tests with test_dir()\n\n\ntest_dir(path = \"/path/to/app/tests/testthat/\")\n\nâœ” | F W S  OK | Context\nâ  |         0 | mod_abc_server         \n\n Test 1 initial input$num = NULL:  TRUE \n\n Test 2 setInputs(num = 3): 3 \n\n Test 3 sup_scrpt(): = 'rd': rd \n\n Test 4 letter() = C: C \n\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \nâœ” |         5 | mod_abc_server\nâ•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nDuration: 0.2 s\n [ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\nğŸŒˆ Your tests are over the rainbow ğŸŒˆ\n\nThe results show the tests passed! Now I am confident inputs, reactive values (sup_scrpt() & letter()), outputs behave as expected.\n\n\n\nRecap\nThe example above provides a workflow for using testServer() with testthat outside a package environment. The checklist below summarizes the steps required to test your applicationâ€™s module server functions:\n\nCreate test files (in tests/testthat/)\n\nAll test files should have the test- prefix\n\nVerify inputs with session$setInputs(inputId = &lt;value&gt;)\n\nAll input$ values should initially be NULL\n\nTest reactive values by referring to them as you would in the module server\n\nCompare expected values after changing inputs with session$setInputs()\n\nTest outputs using output$&lt;value&gt; to check changes to the inputs and reactives\n\nCheck output values with output$txt\n\n\nThis concludes running tests on abcApp(). Ideally, shiny applications are developed as an R package (which Iâ€™ll cover in a future post), but now you know how to perform tests if this isnâ€™t the case. The files for this demonstration are located here.\nFor a more comprehensive review of testing, check out the chapters on testing in R packages and Mastering Shiny."
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html",
    "href": "series/testing/series-testing-p1/index.html",
    "title": "How do I test shiny utility functions?",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(covr)\nThis post is the first in a series on testing shiny applications. Iâ€™ll cover developing and testing a set of utility functions for a shiny app-package using testhat. If youâ€™d like to follow along, all the code Iâ€™ll be using is contained in the utap R package on GitHub.\n# renv::install(\"mjfrigaard/utap\")\nlibrary(utap)"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#shiny-app-packages",
    "href": "series/testing/series-testing-p1/index.html#shiny-app-packages",
    "title": "How do I test shiny utility functions?",
    "section": "Shiny app-packages",
    "text": "Shiny app-packages\nTesting the code in shiny app-packages can be more complicated than testing the code in a typical R package, because app-packages contain two types of code:\n\nApplication code: functions designed to run the application (i.e., the ui and server functions, modules, standalone app functions will a call to shinyApp(), etc.)\nEverything else: functions or code used for connecting to databases, uploading, importing, or manipulating data, building visualizations and/or tables, generating custom HTML layouts, etc. The non-application code and functions in app-packages are typically referred to as â€˜utilityâ€™ or â€˜helperâ€™ functions\n\nThese two types of code require different types of tests. Utility functions are usually accompanied by unit tests similar to the tests youâ€™d find in a standard R package, while application code is tested using the shiny::testServer() function, or with the shinytest2 package.\nThis post will cover writing unit tests for a set of utility functions using testthat and covr. Any tips or time-savers Iâ€™ve found will be in green callout boxes:\n\n\n\n\n\n\nTIP!\n\n\n\n\n\n\nThis is a tip!"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#what-are-unit-tests",
    "href": "series/testing/series-testing-p1/index.html#what-are-unit-tests",
    "title": "How do I test shiny utility functions?",
    "section": "What are unit tests?",
    "text": "What are unit tests?\n\n\n\n\nâ€œA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed. A unit testâ€™s scope can span as little as a method or as much as multiple classes.â€ - The Art of Unit Testing, 2nd edition\n\nIâ€™ve found thinking of functions as â€˜units of workâ€™ and their desired behavior as an â€˜end resultsâ€™ provides a useful mental model during TDD. These terms also align nicely with the testing advice offered by testthat:\n\nStrive to test each behaviour in one and only one test. Then if that behaviour later changes you only need to update a single test.\n\nIn app-packages, the testthat package provides a comprehensive and flexible framework for performing unit tests.\n\ntestthat\nGet started with testthat in your app-package by running usethis::use_testthat(). This function will create following files and folders:\ntests/\n  â”œâ”€â”€ testthat/\n  â””â”€â”€ testthat.R\nTo create new tests, run usethis::use_test(\"utils_fun\") (with \"utils_fun\" being the name of the function youâ€™d like to test).\n\nusethis::use_test(\"utils_fun\")\n\nâœ” Setting active project to '/projects/apps/utap'\nâœ” Writing 'tests/testthat/test-utils_fun.R'\nâ€¢ Modify 'tests/testthat/test-utils_fun.R'\n\nTest files\nNew test files are be created and opened from the tests/testthat/ folder (with a test- prefix).\n\nThe initial contents of a new test file contains the boilerplate code below:\n\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n\n\n\n\n\n\n\nFigureÂ 1: testthat test file\n\n\nTest files\n\n\nTest structure\ntest_that() sets the test â€œscopeâ€ or â€œexecution environmentâ€, and encapsulates the expectations.\n\nNote the use of curly brackets after the code argument:\n\ntestthat::test_that(desc = \"description\", code = {\n\n})\n\n\n\n\n\n\n\nFigureÂ 2: tests\n\n\ntestthat test\n\n\nExpectations\nTest expectations are the code that comes into direct contact with the unit of work and end result for each function. There are usually multiple expectations for any given function, so these are stored in tests (and the desc describes the test context for the set of expectations).\n\nAll testthat expectations have an expect_* prefix:\n\ntestthat::expect_equal(object = 2 * 2, expected = 4)\n\n\n\n\n\n\n\nFigureÂ 3: expectations\n\n\ntestthat expectation\n\n\nUnit test development workflow\nI develop unit tests using the following workflow:\n\nCreate the test file and R script: Iâ€™ll start by creating these files with usethis::use_r() and usethis::use_test(), even if I know the names of these files will likely change as I develop (see more below).\nDefine test context: I use the test context (entered as a character string in the first argument of testthat::test_that()) to capture each â€œunit of workâ€ for each function. I like to keep the test context short and sweetâ€“the â€œunit of workâ€ followed by â€œworksâ€ will suffice in most circumstances, unless thereâ€™s a need for more specific details.\nWrite expectations: These are the third item in the workflow, but conceptually these comes firstâ€“these are the â€œend resultsâ€ I want from each function (i.e., compute a value, download a file, create a column, etc.).\n\nTests and expectations are grouped into test files based on their related objectives or goals, and should correspond to a similar .R file in the R/ folder.\nWhile this workflow is probably not technically considered test-driven development, I do set up the tests before I start writing any code in the R/ folder. This comes in handy if youâ€™re having to remind yourself where you stopped developing on a given projectâ€“Iâ€™ll just run devtools::test() and the first failing test reminds me where to look.\n\n\n\n\n\n\nTIPS: Unit tests\n\n\n\n\n\n\nThe advice on unit tests below (in bold) comes from Effective Software Testing, 2022. Iâ€™ve included descriptions of how testthat satisfies each recommendation:\n\nUnit tests should be fast: the text recommends unit tests take a â€˜couple of millisecondsâ€™ to execute. testthat tests typically fall within this threshold (and provide time measurements to identify bottlenecks).\nUnit tests are easy to control: i.e., â€˜input values and the expected result value are easy to adapt or modify in the test.â€™ testthat expectations give us ample access to 1) the expected result and 2) the observed result.\nUnit tests are easy to write: i.e., â€˜do not require a complicated setup or additional workâ€™. When used combination with usethis, testthat unit tests can be set up, created, written, and run with a few lines of code:\n\nusethis::use_testthat()\n\nusethis::use_test()\n\n&lt; write test &gt;\n\ntestthat::test_file(), testthat::test_dir(), or devtools::test()"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#app-utility-functions",
    "href": "series/testing/series-testing-p1/index.html#app-utility-functions",
    "title": "How do I test shiny utility functions?",
    "section": "App utility functions",
    "text": "App utility functions\nThe utility functions Iâ€™ll be developing are designed to populate the choices argument for shiny::selectInput(). For example, the pull_numeric_cols() function would â€˜pullâ€™ the column names from an input data.frame or tibble (the example below uses palmerpenguins::penguins):\n\npull_numeric_cols(palmerpenguins::penguins)\n\n\n##      bill_length_mm       bill_depth_mm   flipper_length_mm \n##    \"bill_length_mm\"     \"bill_depth_mm\" \"flipper_length_mm\" \n##         body_mass_g                year \n##       \"body_mass_g\"              \"year\"\n\nThe return values would be passed to an updateSelectInput() in the server to provide column names by type (i.e., numeric, binary, or categorical). These functions can be used to quickly group variables into groups for data visualizations. For example, binary variables can be mapped the color aesthetic (if using ggplot2), and custom functions can be created for other graph layers (i.e., facets).\nThe unit of work for each hypothetical pull_[type]_cols() function would be, â€œingest a data.frame or tibble and identify columns by type,â€ and their end result might be â€œreturn a (named) vector of column names by type.â€ In this case, [type] refers to the variable type (i.e., numeric, categorical, binary, etc.). See the hypothetical UI output example below:\n\n# UI code\nshiny::selectInput(\n  inputId = ns(\"x\"),\n  label = \"X variable:\",\n  choices = NULL\n)\n\n\n# server code\nshiny::observe({\n  num_vars &lt;- pull_numeric_cols(df = data())\n  shiny::updateSelectInput(session,\n    inputId = \"x\",\n    choices = num_vars,\n    selected = num_vars[1])\n  }) |&gt;\n  shiny::bindEvent(data(),\n    ignoreNULL = TRUE)\n\nIn the example above, pull_numeric_cols() is passed a reactive dataset (data()), and the output is used to update the selectInput().\n\n\n\nX variable:\n\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nyear"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#micro-iteration",
    "href": "series/testing/series-testing-p1/index.html#micro-iteration",
    "title": "How do I test shiny utility functions?",
    "section": "Micro-iteration",
    "text": "Micro-iteration\nIn R packages, micro-iteration is defined as, â€œthe interactive phase where you initiate and refine a function and its tests in tandem.â€ If youâ€™re using TDD, youâ€™ll write the test first, then write the function to pass the test.\nThe first unit test Iâ€™ll create is for select_column_class(), a function designed to return columns according to their class().\n\nFunction names\nComing up with names for functions can be challenging. I like to follow the tidyverse style guide and use short verbs as a prefix (make_, get_, check_ etc.). I also like to use names that give â€˜futureâ€™ me hints as to their behavior (i.e., select_column_class() imports and has similar behavior to dplyr::select(), while pull_[type]_cols() is more like dplyr::pull())\n\n\nCreate test file\nI create the test file and function file in the Console\n\nusethis::use_test(\"select_column_class\")\n\nâœ” Setting active project to '/projects/apps/utap'\nâœ” Writing 'tests/testthat/test-select_column_class.R'\nâ€¢ Modify 'tests/testthat/test-select_column_class.R'\n\nusethis::use_r(\"select_column_class\")\n\nâ€¢ Modify 'R/select_column_class.R'\n\n\nTest context\nThe test context (entered as a character string in the first argument of testthat::test_that()) includes the â€œunit of workâ€ for the function, followed by â€œworksâ€:\n\ntestthat::test_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  \n})\n\nBefore I can start developing the select_column_class() function and itâ€™s tests, Iâ€™ll need data. R comes with example data objects in the datasets package, but itâ€™s nice to have control over the data being used in your unit tests. Iâ€™ll cover how to add test data available in your app-package.\n\n\nTest data\nCreating test data is covered in R packages, but Iâ€™ll summarize the key points:\n\nTest data (and other objects) can either be created within a test, or as a persistent test fixture\n\nTest data fixtures should be stored in tests/testthat/fixtures/&lt;test_data.rds&gt;\nThe code used to create any test data fixtures should be stored in the same folder with a make_ prefix (i.e., tests/testthat/fixtures/&lt;make_test_data.R&gt;)\n\nThis is easier to picture with a demonstration: In the tests/testthat/ folder, Iâ€™ll create a new fixtures folder, and add a make_testdata_col_class.R file.\ntests/testthat/\n        â””â”€â”€ fixtures/\n                â””â”€â”€ make_testdata_col_class.R\nIn make_testdata_col_class.R, Iâ€™ll create testdata_col_class using the code below:\n\n\ntest_data for test-select_column_class.R\ntestdata_col_class &lt;- tibble::tibble(\n log_var = c(TRUE, FALSE, TRUE),\n int_var = c(1L, 2L, 3L),\n dbl_var = c(1.1, 2.2, 3.3),\n chr_var = c(\"item:1\", \"item:2\", \"item:3\"),\n fct_var = factor(\n   c(\"group 1\", \"group 2\", \"group 3\"),\n   levels = c(\n     \"group 1\", \"group 2\", \"group 3\")),\n ord_var = factor(\n   c(\"level 1\", \"level 2\", \"level 3\"),\n   levels = c(\"level 1\", \"level 2\", \"level 3\"),\n   ordered = TRUE),\n list_var = list(\n   log_vec = c(TRUE, FALSE),\n   dbl_vec = c(1.1, 2.2),\n   chr_var = c(\"item:1\", \"item:2\")))\n\n\n\ntestdata_col_class\n## # A tibble: 3 Ã— 7\n##   log_var int_var dbl_var chr_var fct_var ord_var list_var  \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;   &lt;named li&gt;\n## 1 TRUE          1     1.1 item:1  group 1 level 1 &lt;lgl [2]&gt; \n## 2 FALSE         2     2.2 item:2  group 2 level 2 &lt;dbl [2]&gt; \n## 3 TRUE          3     3.3 item:3  group 3 level 3 &lt;chr [2]&gt;\n\nIâ€™ll save testdata_col_class in tests/testthat/fixtures/ as testdata_col_class.rds:\ntests/testthat/\n        â””â”€â”€ fixtures/\n                â”œâ”€â”€ make_testdata_col_class.R\n                â””â”€â”€ testdata_col_class.rds\nTo load the data into my test, Iâ€™ll add the following to the top of the test context:\n\ntest_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  \n})\n\ntestthat::test_path() will load the data from the testing directory when Iâ€™m ready to run my test.\n\n\nExpectations\nIn expect_equal(), Iâ€™ll verify the structure of the returned object is a data.frame/tibble.\n\ntest_that(\"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # check tibble\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"???\") |&gt;\n          tibble::is_tibble(),\n    expected = TRUE)\n})\n\nWriting my expectations first forces me to make some decisions about what the arguments will be for the select_column_class() function (i.e., df and class).\nselect_column_class() should return the columns according to their class, so Iâ€™ll tests to verify the class of the return columns.\n\n  # check logical\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"log\") |&gt;\n          lapply(is.logical) |&gt; unlist() |&gt; unique(),\n    expected = TRUE)\n\nI try to write these in a way thatâ€™s flexible (should the test data change in the future).\n\n\n\n\n\n\nExpectation-Driven Development\n\n\n\n\n\nWhether or not you decide to adopt Test-Driven Development, I strongly recommend writing test expectations while youâ€™re developing functions. Itâ€™s a great opportunity to clarify a functionâ€™s intended behaviors, arguments, and error/warning messages.\n\n\n\nAfter including tests for each class, Iâ€™ll include a test for the error message from select_column_class() with testthat::expect_error():\n\n# test error type\ntestthat::test_that(\"select_column_class() type error\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # test type error\n  testthat::expect_error(\n    object = select_column_class(\n      df = testdata_col_class, \n      class = \"array\")\n  )\n})\n\nWhen Iâ€™ve covered my intended â€˜end resultsâ€™ for select_column_class() (i.e., when it works and what happens when it doesnâ€™t), Iâ€™ll write the function:\n\n\nselect_column_class()\nselect_column_class &lt;- function(df, class) {\n\n  col_class &lt;- function(df, class) {\n    switch(class,\n      log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),\n      int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),\n      dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),\n      chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),\n      fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),\n      ord = dplyr::select(tibble::as_tibble(df), dplyr::where(is.ordered)),\n      list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list))\n    )\n  }\n\n  cl &lt;- unique(class)\n  cl_check &lt;- cl %nin% c(\"log\", \"int\", \"dbl\", \"chr\", \"fct\", \"ord\", \"list\")\n  if (any(cl_check)) {\n    cli::cli_abort(\"Invalid `class` argument. Must be one of:\\n\n          'log', 'int', 'dbl', 'chr', 'fct', 'ord', 'list'\")\n  }\n\n  col_list &lt;- purrr::map(.x = class, .f = col_class, df = df)\n\n  df_cols &lt;- purrr::list_cbind(col_list, size = nrow(df))\n\n  if (ncol(df_cols) &lt; 1 || nrow(df_cols) &lt; 1) {\n    df_cols &lt;- structure(list(),\n      class = c(\"tbl_df\", \"tbl\", \"data.frame\"),\n      row.names = integer(0),\n      names = character(0)\n    )\n    return(df_cols)\n  } else {\n    return(df_cols)\n  }\n}\n\n\n\nRecap: test data\nBelow is a summary of tips for adding data your tests.\n\n\n\n\n\n(a) Unit test fixtures\n\n\nFigureÂ 4: Unit test fixtures"
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#mezzo-iteration",
    "href": "series/testing/series-testing-p1/index.html#mezzo-iteration",
    "title": "How do I test shiny utility functions?",
    "section": "Mezzo-iteration",
    "text": "Mezzo-iteration\nThe select_column_class() will return a tibble() with the columns matching the class argument, but Iâ€™ll also need an argument that allows me to adjust the returned object to a named character vector.\nThatâ€™s the job of get_column_class()â€“this is a wrapper around select_column_class() with an additional return_tbl argument that, if FALSE, returns the column names as a named vector.\n\nAbstract syntax trees\nWhile developing R functions, Iâ€™ve found the ast() function from the lobstr package can be great for keeping track of nested function calls.\nFor example, select_column_class() has a nested col_class() function that isnâ€™t tested directly. So how do I make sure Iâ€™m keeping track of these nested functions in case they throw an error? Iâ€™ll build an abstract function tree for the function in the documentation.\nBelow is the abstract syntax tree for select_column_class():\n\n\nâ–ˆâ”€select_column_class \nâ””â”€â–ˆâ”€col_class \n\n\nThe tree above is simpleâ€“it only has two functions so farâ€“but as packages grow these abstract displays become more important for tracking function calls (and tests!).\n\n\nCombining tests\nget_column_class() calls select_column_class(), so Iâ€™ll place both unit tests in the tests/testthat/test-column_classes.R file, and create the corresponding R/column_classes.R file\nTo capture these nested functions visually, Iâ€™ll include a function tree in a vignette or other source documentation.\n\n\nâ–ˆâ”€get_column_class \nâ””â”€â–ˆâ”€select_column_class \n  â””â”€â–ˆâ”€col_class \n\n\nIâ€™ve combined select_column_class() and get_column_class() into a single file because I know every pull_[type]_cols() function would use get_column_class(). The following function tree captures this relationship.\n\n\nâ–ˆâ”€get_column_class \nâ”œâ”€â–ˆâ”€select_column_class \nâ”‚ â””â”€â–ˆâ”€col_class \nâ”œâ”€â–ˆâ”€pull_binary_cols \nâ”œâ”€â–ˆâ”€pull_facet_cols \nâ”œâ”€â–ˆâ”€pull_cat_cols \nâ””â”€â–ˆâ”€pull_numeric_cols \n\n\n\n\n\n\n\n\nFunction file names\n\n\n\n\n\nIn shiny app-packages, itâ€™s common to combine related functions (i.e., function families) into a single .R file with a prefix.\nFor example, a standalone app function combines the code that would otherwise sit in ui.R and server.R.\n\nmyApp &lt;- function() {\n  shiny::shinyApp(ui = \n      shiny::tagList(\n        # code from ui.R\n      ),\n      server = # code from server.R\n    )\n}\n\nOther files that are automatically run with a standard shiny app (i.e., global.R or helpers.R files that used to load data, set themes/colors, etc.,) can be converted into functions and/or package files based on their purpose. For more information on organizing your R/ folder, read this section in R Packages.\nAlso check out golem::add_utils() and golem::add_fct() for creating function files specific to shiny modules.\n\n\n\nIn the test-column_classes.R test file, Iâ€™ll need more data for testing, but rather than create test data files for each test, Iâ€™ll use test helpers to create the test data.\n\n\nTest helpers\nTest helpers are stored in tests/testthat/helper.R and usually contain functions or code that 1) is too long to repeat with each test, and 2) doesnâ€™t take too much time or memory to run. Read more about test helpers here.\nIâ€™ve created a set of test helpers in utap for creating different kinds of test data (because Iâ€™ll be repeatedly defining columns with slightly different attributes).\nFor example, col_maker() can be used to create a tibble with columns based on the col_type, size, and missing:\n\ncol_maker(col_type = c(\"log\", \"int\", \"dbl\", \n                       \"chr\", \"fct\", \"ord\"),\n          size = 6,\n          missing = TRUE)\n## # A tibble: 6 Ã— 6\n##   log_var int_var dbl_var chr_var fct_var ord_var\n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;  \n## 1 TRUE          1     0.1 item:1  group 1 level 1\n## 2 FALSE       135     3   item:2  group 2 level 2\n## 3 NA          269    NA   item:3  group 3 level 3\n## 4 TRUE        403     0.1 &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n## 5 FALSE        NA     3   item:1  group 1 level 1\n## 6 NA            1    NA   item:1  group 2 level 2\n\nI can also create tibbles with custom columns using individual helper _maker() functions:\n\ntibble::tibble(\n    log_var = log_maker(size = 2),\n    int_var = int_maker(size = 2),\n    dbl_var = dbl_maker(size = 2),\n    chr_var = chr_maker(size = 2),\n    list_var = list(fct_var = fct_maker(size = 3), \n                    ord_var = ord_maker(size = 3)),\n)\n## # A tibble: 2 Ã— 5\n##   log_var int_var dbl_var chr_var list_var    \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;named list&gt;\n## 1 TRUE          1     0.1 item: 1 &lt;fct [3]&gt;   \n## 2 FALSE         7     1   item: 2 &lt;ord [3]&gt;\n\nThese helpers make it easier to iterate through the test expectations and function development, because tibbles like the one above can be developed inside each test.\n\nBelow is an example for testing if get_column_class() will correctly identify the logical columns (for both return objects):\n\n\nusing test helpers\ntestthat::test_that(\"get_column_class() logical\", {\n  # test logical class\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n      class = \"log\") |&gt;\n      unlist() |&gt;\n      is.logical(),\n    expected = TRUE\n  )\n  # test logical names\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n     class = \"log\",\n      return_tbl = FALSE\n    ),\n    expected = c(log_var = \"log_var\")\n  )\n})\n\n\n\nWhen Iâ€™m confident with the get_column_class() function and itâ€™s tests, Iâ€™ll save the test file and run testthat::test_file().\n\n\nshow/hide get_column_class()\nget_column_class &lt;- function(df, class, return_tbl = TRUE) {\n  if (isFALSE(return_tbl)) {\n    col_types_df &lt;- select_column_class(df, class = class)\n    nms &lt;- names(col_types_df)\n    col_types &lt;- purrr::set_names(nms)\n  } else {\n    col_types &lt;- select_column_class(df, class = class)\n  }\n  return(col_types)\n}\n\n\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 23 ]\n\n\nTest coverage\nHow many tests should I write?\nAs function behavior grows in complexity, so does the number of expectations. In testthat, expectations are captured in tests, and code coverage measures the extent to which the tests in the tests/testthat/ folder cover the possible execution paths of the functions in the R/ folder (i.e.Â the package codebase).\nCode test coverage is a way to confirm that the unit tests are robust enough to verify that your code behaves as expected. In R packages, code coverage is discussed in the testing chapter using the covr package.\n\n\nCheck coverage interactively\nDuring development, check the code coverage of a test file with devtools::test_coverage_active_file(), or, if this function is being temperamental, use the combination of functions below from covr:\n\ncovr::file_coverage(\n  source_files = \"R/column_classes.R\", \n  test_files = \"tests/testthat/test-column_classes.R\") |&gt;\n  covr::report()\n\nBelow is the output in the Viewer when devtools::test_coverage_active_file() is entered in the Console:\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigureÂ 5: Unit test coverage interactively\n\n\n\nI can see from the output I donâ€™t have test coverage for the select_column_class() behavior when the class argument doesnâ€™t return any columns from df. The function is designed to return an empty tibble if this occurs:\n\n\n\n\n\n(a) Behavior not tested in select_column_class()\n\n\nFigureÂ 6: The area in red is the untested portion of select_column_class()\n\n\nTo test this behavior, Iâ€™ll write two expectations:\n\nThe first expectation (expect_s3_class()) checks the class of the return object from select_column_class():\n\n  # test class of empty tibble\n  testthat::expect_s3_class(\n    object = select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\"),\n    class = c(\"tbl_df\", \"tbl\", \"data.frame\"))\n\nThe second expectation verifies there are zero columns in this return tibble:\n\n  # test rows of empty tibble\n  testthat::expect_equal(\n    object = ncol(select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\")),\n    expected = 0L)\n\n\nAfter adding these tests to the test-column_classes.R test file, Iâ€™ll run testthat::test_file() and devtools::test_coverage_active_file() again:\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 25 ]\n\ndevtools::test_coverage_active_file()\n\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigureÂ 7: Complete code coverage for column_classes.R\n\n\n\n100% is great, but uncommon. Striving for a high percentage of coverage is a good practice, it doesnâ€™t guarantee that the function always behaves as expected. Unit tests might execute a line of code, but still not catch a bug due to the design of the test (itâ€™s easy to have high coverage if the unit tests are shallow and donâ€™t check for any potential edge cases).\nIâ€™ll address code coverage again in the next section, but checking coverage regularly will help ensure function behaviors donâ€™t go overlooked."
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#macro-iteration",
    "href": "series/testing/series-testing-p1/index.html#macro-iteration",
    "title": "How do I test shiny utility functions?",
    "section": "Macro-iteration",
    "text": "Macro-iteration\nAfter developing the functions in utap, the files in the R/ folder are organized into names based on the â€˜main function and its supporting helpersâ€™:\nR/\nâ”œâ”€â”€ column_classes.R\nâ”œâ”€â”€ pull_binary_cols.R\nâ”œâ”€â”€ pull_cat_cols.R\nâ”œâ”€â”€ pull_facet_cols.R\nâ”œâ”€â”€ pull_numeric_cols.R\nâ””â”€â”€ utils.R\n\nTest file organization\nThe tests/testthat/ folder file names have identical names as the files in the R/ folder.\ntests/testthat/\n        â”œâ”€â”€ test-column_classes.R\n        â”œâ”€â”€ test-pull_binary_cols.R\n        â”œâ”€â”€ test-pull_cat_cols.R\n        â”œâ”€â”€ test-pull_facet_cols.R\n        â”œâ”€â”€ test-pull_numeric_cols.R\n        â””â”€â”€ test-utils.R\n\nR/utils.R\nItâ€™s common for R packages to have a general R/utils.R file that defines the â€˜utilityâ€™ functions. This practice isnâ€™t discouraged in R Packages, but these files can become a catch-all for any functions that donâ€™t have a clear home (read more here).\nIâ€™ve only stored the %nin% operator in R/utils.R, and itâ€™s test is shown below:\n\ntestthat::test_that(\"%nin% works\", {\n  testthat::expect_false(\n    object = \"A\" %nin% LETTERS)\n  testthat::expect_false(\n    object = 1 %nin% 1:10)\n  testthat::expect_true(\n    object = 1 %nin% 2:10)\n})\n\n\n\n\nTest package\nWhen Iâ€™ve completed a set of test files, I can use devtools::test() to check if theyâ€™re passing.\n\ndevtools::test()\n\nâ„¹ Testing utap\nâœ” | F W S  OK | Context\nâœ” |        25 | column_classes                                                     \nâœ” |        29 | pull_binary_cols                                                   \nâœ” |         4 | pull_cat_cols                                                      \nâœ” |        20 | pull_facet_cols                                                    \nâœ” |         5 | pull_numeric_cols                                                  \nâœ” |         3 | utils                                                              \n\nâ•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nDuration: 2.1 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 86 ]\n\nğŸ¯ Your tests hit the mark ğŸ¯\nThe output above shows all tests are passing (and some helpful words of encouragement). As you can see, the number of tests correspond to the number of functions in each test file.\nFor example, pull_binary_cols() and pull_facet_cols() required additional internal functions to define their use:\n\n\nâ–ˆâ”€pull_binary_cols \nâ”œâ”€â–ˆâ”€check_binary_vec \nâ”‚ â”œâ”€â–ˆâ”€check_log_binary \nâ”‚ â”œâ”€â–ˆâ”€check_int_binary \nâ”‚ â””â”€â–ˆâ”€check_fct_binary \nâ””â”€â–ˆâ”€make_binary_vec \n\n\nâ–ˆâ”€pull_facet_cols \nâ”œâ”€â–ˆâ”€check_facet_vec \nâ”‚ â”œâ”€â–ˆâ”€check_chr_facet \nâ”‚ â””â”€â–ˆâ”€check_fct_facet \nâ””â”€â–ˆâ”€make_facet_vec \n\n\nWheras pull_cat_cols() and pull_numeric_cols() map onto existing classes:\n\n\nâ–ˆâ”€pull_cat_cols \nâ”œâ”€â–ˆâ”€is.factor \nâ””â”€â–ˆâ”€is.character \n\n\nâ–ˆâ”€pull_numeric_cols \nâ”œâ”€â–ˆâ”€is.integer \nâ””â”€â–ˆâ”€is.double \n\n\n\n\nCheck coverage on build/install\nTo check the code coverage for the utap package, I can run devtools::test_coverage() to view the output in the Viewer.\n\ndevtools::test_coverage()\n\nâ„¹ Computing test coverage for utap\n\n\n\n\n\n\n(a) Final test coverage for utap package\n\n\nFigureÂ 8: devtools::test_coverage()\n\n\n\nClicking on any of the Files will open the Source tab and give a summary like the one above from devtools::test_coverage_active_file(). I can also use covr::package_coverage() in the Console for simpler output:\nutap Coverage: 100.00%\nR/column_classes.R: 100.00%\nR/pull_binary_cols.R: 100.00%\nR/pull_cat_cols.R: 100.00%\nR/pull_facet_cols.R: 100.00%\nR/pull_numeric_cols.R: 100.00%\nR/utils.R: 100.00%\n\nOther metrics\nSometimes itâ€™s interesting to view the relationship between function size and number of tests using the cloc package..\n\nlibrary(cloc)\n\ncloc stands for Count Lines of Code, and itâ€™s a rough metric used to gauge code complexity. Itâ€™s simple, but apparently provides â€œjust as much predictive power as more elaborate constructs like cyclomatic complexity.â€source\nBelow is a count of the lines of code in each file in the R folder:\n\ncloc::cloc_by_file(\"R\")\n\n# A tibble: 8 Ã— 6\n  source filename                language   loc blank_lines comment_lines\n  &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;    &lt;int&gt;       &lt;int&gt;         &lt;int&gt;\n1 R      \"R/pull_binary_cols.R\"  R           53           2            57\n2 R      \"R/pull_facet_cols.R\"   R           42           2            73\n3 R      \"R/column_classes.R\"    R           41           6            65\n4 R      \"R/pull_numeric_cols.R\" R           19           1            24\n5 R      \"R/pull_cat_cols.R\"     R           13           0            19\n6 R      \"R/utils.R\"             R            3           0             7\n7 R      \"R/utap-package.R\"      R            2           0             7\n8 R      \"\"                      SUM        173          11           252\nThis output also confirms the relationship between lines of code and tests."
  },
  {
    "objectID": "series/testing/series-testing-p1/index.html#recap",
    "href": "series/testing/series-testing-p1/index.html#recap",
    "title": "How do I test shiny utility functions?",
    "section": "Recap",
    "text": "Recap\nThis post has been an introduction to unit testing utility functions in a shiny app-package. When Iâ€™m confident the utility functions are working, Iâ€™ll start adding them into modules (and testing with testServer() or shinytest2). Files names can change a lot throughout the course of developing a shiny app-package, so itâ€™s helpful to adopt (or create) a naming convention.\nIf youâ€™re using the golem framework to develop your shiny app-package, the utils_ and fct_ prefixes are used to define two different types of utility/helper functions:\n\nutils_ files contain â€˜small helper functions andâ€™top-level functions defining your user interface and your server functionâ€™\nfct_ files contain â€˜the business logic, which are potentially large functionsâ€¦the backbone of the application and may not be specific to a given moduleâ€™.\n\nThis particular file naming convention isnâ€™t required, but as with most conventions, itâ€™s better when someone else comes up with the standard (and I just have to adopt and implement it). And having and sticking to a naming convention is typically more important than the convention itself."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html",
    "href": "series/shiny-frameworks/golem/index.html",
    "title": "Creating shiny app-packages (golem)",
    "section": "",
    "text": "This post walks through building a shiny application using the golem framework. golem is a â€™an opinionated framework for building production-grade shiny applicationsâ€™â€“weâ€™ll explore some of the opinions in-depth (and offer my opinion on adopting these opinions).\ninstall.packages(\"devtools\")\ndevtools::install_github(\"mjfrigaard/gap\")\nFor consistency, Iâ€™ll be using the application from the RStudioâ€™s Building Web Applications with Shiny course. These materials are a great resource if youâ€™re new to shinyâ€“even if youâ€™re arenâ€™t, itâ€™s still worth checking outâ€“plus itâ€™s free!\nThe golem text is also a fantastic resource, but I found myself using the golem website as a great â€˜quick reference.â€™ If youâ€™re unfamiliar with R package development, I recommend bookmarking R packagesâ€“this is a great resource youâ€™ll return to often."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#outline",
    "href": "series/shiny-frameworks/golem/index.html#outline",
    "title": "Creating shiny app-packages (golem)",
    "section": "Outline",
    "text": "Outline\nIâ€™ve organized the app-package development process into three areas: Start, Build, and Use.\n\nStart covers the required steps launch your golem project in the console and IDE, some standard R package files, and any additional setup considerations.\nBuild covers the app-package development process, which includes writing and storing code, data, external resources (like CSS or JavaScript), testing, etc.\nUse shows how to launch a golem application locally (i.e., within the RStudio (Posit) IDE), common workflow tips, and anything I found confusing while building the application."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#start",
    "href": "series/shiny-frameworks/golem/index.html#start",
    "title": "Creating shiny app-packages (golem)",
    "section": "Start",
    "text": "Start\n\nTo create a new golem app from the console, enter the following:\n\ninstall.packages(\"golem\")\nlibrary(golem)\ngolem::create_golem(path = \"gap\")\n\nIf youâ€™re creating a golem app using the New Project Wizard, the following defaults are available:\n\n\n\n\n\nIDE wizard golem setup\n\n\nFigureÂ 1: Creating a new golem shiny app\n\n\nI recommend using golem comments (theyâ€™re helpful and donâ€™t change how the application code runs). When the new project opens, the initial folder structure for your new golem application is below:\n\n\nshow/hide golem folder structure\napp-name/\n  â”œâ”€â”€ DESCRIPTION\n  â”œâ”€â”€ NAMESPACE\n  â”œâ”€â”€ R\n  â”‚   â”œâ”€â”€ app_config.R\n  â”‚   â”œâ”€â”€ app_server.R\n  â”‚   â”œâ”€â”€ app_ui.R\n  â”‚   â””â”€â”€ run_app.R\n  â”œâ”€â”€ dev\n  â”‚   â”œâ”€â”€ 01_start.R\n  â”‚   â”œâ”€â”€ 02_dev.R\n  â”‚   â”œâ”€â”€ 03_deploy.R\n  â”‚   â””â”€â”€ run_dev.R\n  â”œâ”€â”€ [app-name].Rproj\n  â”œâ”€â”€ inst\n  â”‚   â”œâ”€â”€ app\n  â”‚   â”‚   â””â”€â”€ www\n  â”‚   â”‚       â””â”€â”€ favicon.ico\n  â”‚   â””â”€â”€ golem-config.yml\n  â””â”€â”€ man\n      â””â”€â”€ run_app.Rd\n  \n  7 directories, 14 files\n\n\n\ndev/ scripts\nNew golem apps automatically open the 01_start.R script. This is the first of three developments scripts in the dev/ folder:\n\n\n\ngolem dev/ scripts\n\n\nThe dev/ folder initially contains three .R scripts which serve as a â€˜guided tourâ€™ of golem framework (01_start.R, 02_dev.R, and 03_deploy.R). The run_dev.R is for running a development version of your app (more on this later).\n\n\n\n\n\n\ngolem development scripts\n\n\n\n\n\n\nIf youâ€™re familiar with R application development, you should recognize most of the items in the dev/ scripts. I recommend going through these scripts even if youâ€™re an experienced R package developerâ€“you can think of these as a â€˜shiny app-package development checklist.â€™\n\n\n\n\n\n\nFill the DESCRIPTION\nThere are three files in a new golem app-packageâ€“NAMESPACE, DESCRIPTION, and [app name].Rproj. dev/01_start.R starts by building the DESCRIPTION file with golem::fill_desc()\n\n\n\n\n\ngolem DESCRIPTION\n\n\nfill_desc() is from the desc package, and the sections are entered in a key = \"value\" format\n\nExample DESCRIPTION file contents:\n\ngolem::fill_desc(\n  pkg_name = \"gap\",\n  pkg_title = \"An example goelm app\",\n  pkg_description = \"A working example of the golem package.\",\n  author_first_name = \"Martin\",\n  author_last_name = \"Frigaard\",\n  author_email = \"mjfrigaard@pm.me\",\n  repo_url = NULL # The URL of the GitHub Repo (optional)\n)\n\n\n\nshow/hide output from golem::fill_desc()\nâœ” Setting `golem_version` to 0.0.0.9000\nâœ” Setting `golem_name` to gap\nâœ” DESCRIPTION file modified\n\n\n\n\n\n\n\n\n\n*Amending the DESCRIPTION\n\n\n\n\n\n\nIn dev/02_dev.R, the attachment::att_amend_desc() will â€˜Amend DESCRIPTION with dependencies read from package code parsingâ€™. If attachment is not installed, use install.package('attachment')\n\n\n\n\n\n\nSet {golem} options\n\n\n\n\n\ngolem config file\n\n\nThe golem::set_golem_options() wraps a collection of golemâ€˜s â€™opinionatedâ€™ application development and configuration options.\n\ngolem::set_golem_options()\n\n\n\nshow/hide output from golem::set_golem_optionss()\nâ”€â”€ Setting {golem} options in `golem-config.yml` â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ” Setting `golem_name` to gap\nâœ” Setting `golem_wd` to golem::pkg_path()\nYou can change golem working directory with set_golem_wd('path/to/wd')\nâœ” Setting `golem_version` to 0.0.0.9000\nâœ” Setting `app_prod` to FALSE\nâ”€â”€ Setting {usethis} project as `golem_wd` â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ” Setting active project to '/projects/dev/gap'\n\n\nset_golem_options() is a wrapper for a collection of golem option functions (Iâ€™ve included each function and a brief description of their behavior below):\n\n\nshow/hide golem options\ngolem::set_golem_options(\n  golem_name = golem::pkg_name(), # name of the app-package in DESCRIPTION\n  golem_version = golem::pkg_version(), # version in DESCRIPTION\n  golem_wd = golem::pkg_path(), # package root when starting a golem\n  app_prod = FALSE, # production mode?\n  talkative = TRUE, # Should the messages be printed to the console?\n  config_file = golem::get_current_config(golem_wd) # golem-config.yml location\n)\n\n\nThe new config file is located in the inst/ folder.\n\n\n\n\n\n\n\ngolem options\n\n\n\n\n\n\nTo fully understand the golem framework, I recommended running this function. The great thing about golemâ€™s options is you donâ€™t have to adopt all of them to have a production-quality app!\n\n\n\n\n\n\nInstall required dev dependencies\nThe golem::install_dev_deps() function makes sure the following packages are installed (Iâ€™ve grouped them into categories):\n\n\n\nDevelopment\n\ndevtools (loading, documenting, installing package)\n\npkgload (i.e., devtools::load_all())\n\nusethis (create package files)\nroxygen2 (document package functions and objects)\npkgbuild (create a .tar.gz file)\n\n\n\nDocumentation & testing\n\nattachment (deal with package dependencies)\ndesc (Parse DESCRIPTION files)\ntestthat (unit testing your code)\n\n\n\n\n\n\n\nInternals\n\nrstudioapi (interacting with RStudio IDE)\nprocessx (execute and control subprocesses from R)\n\n\n\nFiles & paths\n\nhere (file/folder path management)\nfs (file/folder path management)\n\n\n\nDeploy\n\ndockerfiler (deploying apps with docker)\nrsconnect (deploy shiny apps with RSConnect)\n\n\n\n\n\ngolem::install_dev_deps()\n\nBelow is an example with dockerfiler:\n\n\nshow/hide output from golem::install_dev_deps()\nâ„¹ The package \"dockerfiler\" is required.\nâœ– Would you like to install it?\n\n1: Yes\n2: No\n\nSelection: 1\nâœ” Updated metadata database: 5.32 MB in 12 files.                         \nâœ” Updating metadata database ... done                                     \n                                                                            \nâ†’ Will install 1 package.\nâ†’ Will download 1 CRAN package (104.29 kB).\n+ dockerfiler   0.2.1  â¬‡ (104.29 kB)\nâ„¹ Getting 1 pkg (104.29 kB)\nâœ” Got dockerfiler 0.2.1 (x86_64-apple-darwin17.0) (104.29 kB)             \nâœ” Downloaded 1 package (104.29 kB)in 1.1s                                 \nâœ” Installed dockerfiler 0.2.1  (54ms)                                    \nâœ” 1 pkg + 40 deps: kept 40, added 1, dld 1 (104.29 kB) [20.2s]  \n\n\n\n\n\n\n\n\nUsing golem devops\n\n\n\n\n\n\nI recommend using golemâ€™s options hereâ€“itâ€™s efficient and letâ€™s you know if a particular package isnâ€™t installed:\n\n\n\n\n\n\nCreate Common Files\nThe â€˜Create Common Filesâ€™ section of dev/01_start.R contains many of the functions and files covered in the â€˜Whole Gameâ€™ section of R packages:\n\nLICENSE\n\nusethis::use_mit_license(\"Golem User\")\n\n\nâœ” Adding 'MIT + file LICENSE' to License\nâœ” Writing 'LICENSE'\nâœ” Writing 'LICENSE.md'\nâœ” Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n\n\n\n\n\n\n\n\ngolem LICENSE file\n\n\n\nREADME.Rmd\n\nusethis::use_readme_rmd()\n\n\nâœ” Writing 'README.Rmd'\nâœ” Adding '^README\\\\.Rmd$' to '.Rbuildignore'\nâ€¢ Update 'README.Rmd' to include installation instructions.\n\n\nThe README.md is built with devtools::build_readme()\ndevtools::build_readme()\nâ„¹ Installing gap in temporary library\nâ„¹ Building /projects/dev/gap/README.Rmd\n\n\n\n\n\n\n\ngolem README.Rmd file\n\n\n\nCODE_OF_CONDUCT.md\n\nusethis::use_code_of_conduct()\n\n\nâœ” Writing 'CODE_OF_CONDUCT.md'\nâœ” Adding '^CODE_OF_CONDUCT\\\\.md$' to '.Rbuildignore'\nâ€¢ You may also want to describe the code of conduct in your README:\n  ## Code of Conduct\n\nPlease note that the gap project is released with a [Contributor Code of\n    Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html).\nBy contributing to this project, you agree to abide by its terms.\n  [Copied to clipboard]\n\n\nPaste of the code of conduct in the README.md is rebuild with devtools::build_readme()\ndevtools::build_readme()\nâ„¹ Installing gap in temporary library\nâ„¹ Building /projects/dev/gap/README.Rmd\n\n\n\n\n\n\n\ngolem code of conduct file\n\n\n\nLifecycle badge\n\nusethis::use_lifecycle_badge(\"Experimental\")\n\n\nâœ” Adding Lifecycle: experimental badge to 'README.Rmd'\nâ€¢ Re-knit 'README.Rmd' with `devtools::build_readme()`\n\n\nRebuild the README.md with devtools::build_readme()\nusethis::use_lifecycle_badge(\"Experimental\")\nâ„¹ Installing gap in temporary library\nâ„¹ Building /projects/dev/gap/README.Rmd\n\n\n\n\n\n\n\ngolem lifecycle badge\n\n\n\nNEWS.md\n\nusethis::use_news_md(open = FALSE)\n\n\nâœ” Writing 'NEWS.md'\n\n\n\n\n\n\n\ngolem NEWS.md file\n\n\n\nGit: usethis::use_git() will ask if youâ€™d like to commit the files in your golem app to a repo of the same name:\n\nusethis::use_git()\n\n\nâœ” Setting active project to '/projects/dev/gap'\nâœ” Initialising Git repo\nâœ” Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth',\n  '.DS_Store', '.quarto' to '.gitignore'\nThere are 16 uncommitted files:\n* '.gitignore'\n* '.here'\n* '.Rbuildignore'\n* 'CODE_OF_CONDUCT.md'\n* 'DESCRIPTION'\n* 'dev/'\n* 'gap.Rproj'\n* 'inst/'\n* 'LICENSE'\n* 'LICENSE.md'\n* ...\nIs it ok to commit them?\n\n1: Definitely\n2: Negative\n3: Not now\n\nSelection: 1\n\n\nTo initialize the Git pane, youâ€™ll need to restart RStudio (in the next dialogue)\nâœ” Adding files\nâœ” Making a commit with message 'Initial commit'\nâ€¢ A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Absolutely\n2: Negative\n3: No\nSelection: 1\n\n\n\n\n\n\n\n\ngolems common files\n\n\n\n\n\n\nEach of these files are important for an R package, so having them consolidated in 01_start.R makes it easier to get up and running quickly. However, if youâ€™d like to edit their contents before moving onto the next step (or youâ€™d like information on a particular function/file), I recommend consulting R packages for this section\n\n\n\n\n\n\nInit Testing Infrastructure\ngolem::use_recommended_tests() with set up the testthat architecture for unit tests.\n\ngolem::use_recommended_tests()\n\n\n\n\n\n\ngolem test files\n\n\n\nâœ” Setting active project to '/projects/dev/gap'\nâœ” Adding 'testthat' to Suggests field in DESCRIPTION\nâœ” Adding '3' to Config/testthat/edition\nâœ” Creating 'tests/testthat/'\nâœ” Writing 'tests/testthat.R'\nâ€¢ Call `use_test()` to initialize a basic test file and open it for editing\n\nIt also adds a few words to the WORDLIST file in the inst folder:\n\nâœ” Adding 'spelling' to Suggests field in DESCRIPTION\nâœ” Adding 'en-US' to Language\nThe following words will be added to the wordlist:\n - Lifecycle\n - goelm\n - golem\nAre you sure you want to update the wordlist?\n1: Yes\n2: No\n\nSelection: 1\nAdded 3 and removed 0 words in /projects/dev/gap/inst/WORDLIST\nUpdated /projects/dev/gap/tests/spelling.R\nâ€¢ Run `devtools::check()` to trigger spell check\nâœ” Tests added\n\ngolem::use_recommended_tests() also provides some examples for testing the UI, server, and other golem functions:\n\n\nshow/hide unit tests in test-golem-recommended.R\ntest_that(\"app ui\", {\n  ui &lt;- app_ui()\n  golem::expect_shinytaglist(ui)\n  # Check that formals have not been removed\n  fmls &lt;- formals(app_ui)\n  for (i in c(\"request\")) {\n    expect_true(i %in% names(fmls))\n  }\n})\n\ntest_that(\"app server\", {\n  server &lt;- app_server\n  expect_type(server, \"closure\")\n  # Check that formals have not been removed\n  fmls &lt;- formals(app_server)\n  for (i in c(\"input\", \"output\", \"session\")) {\n    expect_true(i %in% names(fmls))\n  }\n})\n\ntest_that(\n  \"app_sys works\",\n  {\n    expect_true(\n      app_sys(\"golem-config.yml\") != \"\"\n    )\n  }\n)\n\ntest_that(\n  \"golem-config works\",\n  {\n    config_file &lt;- app_sys(\"golem-config.yml\")\n    skip_if(config_file == \"\")\n\n    expect_true(\n      get_golem_config(\n        \"app_prod\",\n        config = \"production\",\n        file = config_file\n      )\n    )\n    expect_false(\n      get_golem_config(\n        \"app_prod\",\n        config = \"dev\",\n        file = config_file\n      )\n    )\n  }\n)\n\n# Configure this test to fit your need.\n# testServer() function makes it possible to test code in server functions and modules, without needing to run the full Shiny application\ntestServer(app_server, {\n\n  # Set and test an input\n  session$setInputs(x = 2)\n  expect_equal(input$x, 2)\n\n  # Example of tests you can do on the server:\n  # - Checking reactiveValues\n  # expect_equal(r$lg, 'EN')\n  # - Checking output\n  # expect_equal(output$txt, \"Text\")\n})\n\n# Configure this test to fit your need\ntest_that(\n  \"app launches\",\n  {\n    golem::expect_running(sleep = 5)\n  }\n)\n\n\nThese tests pass right out of the box, and they give a little â€˜sneak previewâ€™ of how the golem framework works.\n\n\nshow/hide results from unit tests in test-golem-recommended.R\n==&gt; Testing R file using 'testthat'\n\nâ„¹ Loading gap\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ]\nLoading required package: shiny\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 10 ]\n\nâ”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ€¢ interactive() is not TRUE\n  (1):\n  test-golem-recommended.R:72:5\n\n\nTest complete\n\n\n\n\n\n\n\n\ngolem recommended tests\n\n\n\n\n\n\nI love this feature of golem apps! in a single function I have the folders required for unit testing, words added to the WORDLIST (which I almost never remember to do), and an example test with shinyâ€™s testServer() function.\n\n\n\n\n\n\nFavicon\nA favicon is a the little image that shows up on your browser tab or address bar. golem has a default favicon in the inst/app/ folder:\n\n\n\n\n\ngolem favicon file\n\n\n\ninst/\n  â””â”€â”€ app\n       â””â”€â”€ www\n            â””â”€â”€ favicon.ico\n\n\n3 directories, 1 file\n\nThe inst/ folder serves a specific purpose in golem apps (and R packages), which Iâ€™ll cover more below. For our purpose, the golem::use_favicon() function can use the existing image:\n\ngolem::use_favicon(path = \"inst/app/www/favicon.ico\")\n\nThe output introduces another common golem function: golem_add_external_resources()\n\nâœ” favicon.ico created at \n/projects/gap/inst/app/www/favicon.ico\nFavicon is automatically linked in app_ui via `golem_add_external_resources()`\n\nThis function is used to add external resources to your application (and will come up often during development).\n\n\nAdd helper functions\nMost applications will have two types of codeâ€“shiny functions for running your application (app functions), and functions that do everything else (or utility functions). The golem further distinguished utility functions into two types: â€œsmall functions that are reused throughout the appâ€ (with a utils_ prefix), and â€œlarger functions, which are more central to the applicationâ€ (with a fct_ prefix).\nThese descriptions from the text are helpful for distinguishing between the two:\n\nutils_ functions: â€œâ€¦the hexmake app has two of these files, R/utils_ui.R and R/utils_server.R, in which you will find small functions that are reused throughout the app.â€\n\n\nfct_ functions: â€œâ€¦in hexmake, you will find R/fct_mongo.R, which is used to handle all the things related to connecting and interacting with the Mongodb database.â€\n\n\nuse_utils_ui()\nThe golem::use_utils_ui() function will add a collection of utility functions for the UI. Including with_test = TRUE will add a test for these functions.\n\n\n\n\n\ngolem UI utility functions & tests\n\n\n\ngolem::use_utils_ui(with_test = TRUE)\n\n\nâœ” File created at /projects/gap/R/golem_utils_ui.R\nâœ” Utils UI added\nâœ” File created at /projects/gap/tests/testthat/test-golem_utils_ui.R\nâœ” Tests on utils_server added\n\n\n\nuse_utils_server()\ngolem also includes a set of functions for the application server (or server modules), golem::use_utils_server(). The with_test = TRUE will also add a test to the tests/testthat/ folder:\n\ngolem::use_utils_server(with_test = TRUE)\n\n\nâœ” File created at /projects/gap/R/golem_utils_server.R\nâœ” Utils server added\nâœ” File created at /projects/gap/tests/testthat/test-golem_utils_server.R\nâœ” Tests on utils_server added\n\n\n\n\n\n\ngolem server utility functions & tests\n\n\n\n\n\n\n\n\ngolem utility functions\n\n\n\n\n\n\nI consider these functions optional, but the examples in each file have a broad enough application that youâ€™ll probably discover something helpful for your golem application. The with_test argument also provides more examples of unit tests for your application functions, so youâ€™re likely to find something useful!\n\n\n\n\nThis is the final function in the dev/01_start.R file. In the next golem dev script (dev/02_dev.R), Iâ€™ll cover development of your golem application."
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#build",
    "href": "series/shiny-frameworks/golem/index.html#build",
    "title": "Creating shiny app-packages (golem)",
    "section": "Build",
    "text": "Build\nThe dev/02_dev.R file is appropriately titled, â€˜Engineeringâ€™, and unlike the functions in the first script, these functions will be used repeatedly for creating files in the R/ and inst/ folders.\n\nApp files\nLetâ€™s start by examining the contents of the R/ folder in our new golem application:\n\n\n\n\n\ngolem application files\n\n\n\nR/\nâ”œâ”€â”€ app_config.R\nâ”œâ”€â”€ app_server.R\nâ”œâ”€â”€ app_ui.R\nâ””â”€â”€ run_app.R\n\n1 directory, 4 files\n\ngolem applications structure shiny apps into three files: R/app_ui.R, R/app_server.R, and R/run_app.R.\n\nThe R/app_ui.R and R/app_server.R scripts are golemâ€™s version of ui.R and server.R\nR/run_app.R is a standalone app function, and\nR/app_config.R is used to set/get golem configuration settings (which we will cover more below).\n\n\napp_ui.R\napp_ui.R wraps the UI functions in shiny::tagList() (youâ€™ll see this function in shiny UI module functions, too).\n\n\nshow/hide app_ui()\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"gap\")\n    )\n  )\n}\n\n\napp_ui() also contains a call to golem_add_external_resources(), which we used above to add the favicon image.\n\n\nshow/hide golem_add_external_resources()\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"gap\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\n\n\napp_server.R\nThe contents of app_server.R file looks similar to a standard shiny server function:\n\n\nshow/hide app_server()\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n}\n\n\n\n\napp_config.R\nThe app_config.R file contains the â€œinternal mechanics for golem, notably for referring to values in the inst/ folder, and to get values from the config file in the inst/ folderâ€. Two functions drive the internal mechanics of your golem app: app_sys() and get_golem_config()\n\napp_sys() is a wrapper around the system.file() function, and itâ€™s used to â€œquickly refer to the files inside the inst/ folderâ€\n\n\n\nshow/hide app_sys()\napp_sys &lt;- function(...) {\n  system.file(..., package = \"gap\")\n}\n\n\n\nget_golem_config() is where youâ€™ll set golem configuration options (covered here in the text).\n\n\n\nshow/hide get_golem_config()\nget_golem_config &lt;- function(\n  value,\n  config = Sys.getenv(\n    \"GOLEM_CONFIG_ACTIVE\",\n    Sys.getenv(\n      \"R_CONFIG_ACTIVE\",\n      \"default\"\n    )\n  ),\n  use_parent = TRUE,\n  # Modify this if your config file is somewhere else\n  file = app_sys(\"golem-config.yml\")\n) {\n  config::get(\n    value = value,\n    config = config,\n    file = file,\n    use_parent = use_parent\n  )\n}\n\n\nget_golem_config() reads the inst/golem-config.yml configuration file:\n\ndefault:\n  golem_name: gap\n  golem_version: 0.0.0.9000\n  app_prod: no\nproduction:\n  app_prod: yes\ndev:\n  golem_wd: !expr here::here()\n\ngolem-config.yml gives me access to the app version, name, and (development) working directory. This file is designed to add â€œproduction-only elementsâ€ and be â€œshareable across golem projectsâ€\n\n\nrun_app.R\nrun_app.R is the exported function Iâ€™ll use to run my golem app after loading/documenting/installing the package:\n\ndevtools::load_all(\".\")\n\n\nâ„¹ Loading gap\n\n\ndevtools::document()\n\n\nâ„¹ Updating gap documentation\nâ„¹ Loading gap\n\nRestarting R session...\n\n\nlibrary(gap)\ngap::run_app()\n\n\n\n\n\n\n\ngolem app functions\n\n\n\n\n\n\nThe great thing about golem applications is that despite having a somewhat overwhelming amount of code and options, most of these can be ignored until you need to use them. R/app_config.R is a great example of this. The get_golem_config() function is a powerful tool for deploying apps in production, but you can get started developing your application without diving into the details.\n\n\n\n\n\n\n\n\nDependencies\nDependency management is a necessary evil of package development. shiny has a large ecosystem of user-written add-on packages. To use the code from add-on packages in our application, we need a way to keep track of which function belongs to which package.\n\n\n\n\n\ngolem app dependencies\n\n\nThe DESCRIPTION file manages package-level dependencies. The Imports field in the DESCRIPTION file specifies packages that my package uses, so the functions from these packages will be available for my package, but not for users (unless they use the :: operator or load the package themselves).\nThe NAMESPACE file manages function-level access. The NAMESPACE file manages the functions that are exported from my package (i.e., functions available to users who install my package), and the functions my package imports from other packages.\nThe golem text describes the difference between these files in the following way,\n\nâ€œThe DESCRIPTION file dictates which packages have to be installed when your application is installedâ€\nâ€œThe NAMESPACE file describes how your app interacts with the R session at run time, i.e.Â when your application is launchedâ€\n\nThe attachment package makes it easier to manage the dependencies in your golem application. It does this by looking through the files in your package to make sure everything is properly documented in the NAMESPACE and DESCRIPTION file (note that these two files are not equivalent or connected).\nThe att_amend_desc() function removes a lot of the tedium involved in dependency management:\n\nattachment::att_amend_desc()\n\nThis function adds the appropriate parameters to golem-config.yml and sets up function documentation in the DESCRIPTION file\n\nSaving attachment parameters to yaml config file\nUpdating [app-name] documentation\nSetting `RoxygenNote` to \"7.2.3\"\n\nIt loads the contents of our package (i.e.Â devtools::load_all()) and writes the NAMESPACE file\n\nâ„¹ Loading [app-name]\nWriting NAMESPACE\n\nIt also writes the help files in the man/ folder.\n\nWriting run_app.Rd\n\n\n\n\n\n\n\ngolem app dependencies\n\n\n\n\n\n\nManaging the dependencies in your app is an essential part of getting your application to deploy in a production environment, and this is a very helpful addition to your package development workflow (whether youâ€™re building an app package or standard R package).\n\n\n\n\n\n\nAdd modules\ngolem has functions for quickly creating modules and utility/helper functions in the R/ folder.\n\nadd_module()\n\ngolem::add_module(name = \"name_of_module1\", with_test = TRUE) \ngolem::add_module(name = \"name_of_module2\", with_test = TRUE) \n\n\n\n\nAdd helper functions\ngolem apps differentiates two types of helper functions: uils_ and fct_.\n\nadd_utils()\n\nuils_ functions: â€œsmall functions that might be used several times in the applicationâ€ â€¦ â€œmore â€˜topic centeredâ€™, in the sense that they gather functions that relate to a specific feature of the application(+â€\n\n\ngolem::add_utils(\"helpers\", with_test = TRUE)\n\n\n\nadd_fct()\n\nfct_ functions: â€œlarger functions that are more central to the applicationâ€ â€¦ â€œmore used as a place to put miscellaneous functionsâ€\n\n\ngolem::add_fct(\"helpers\", with_test = TRUE)\n\nwith_test = TRUE ensures these functions will also create test files in tests/\n\n\n\nExternal resources\ndev/02_dev.R includes golem wrappers for including CSS, JavaScript, and SASS files to the inst/app/www/ folder:\n\nJavaScript files\nYou can add JavaScript to your application using the golem::add_js_file(\"script\") and golem::add_js_handler(\"handlers\") functions.\nThe golem text has an entire chapter dedicated to JavaScript which is worth reading (and Iâ€™ll demonstrate an example with these functions below).\n\n\nApp styling\nYou can add CSS or SASS styling to your application using the golem::add_css_file(\"custom\") and golem::add_sass_file(\"custom\") functions, too.\n\n\n\nAdd internal datasets\nIf you application uses data, you can add it to your application with the usethis functions (use_data_raw() or use_data()). I recommend reading the data section of R packages (and this section on adding data to inst/extdata).\n\nuse_data_raw()\nThe data-raw/ folder is for â€˜data-creating scriptâ€™ that was used to create the version of the data in your app-package. Newly created .R scripts in use_data_raw() will have a call to use_data().\n\n\nuse_data()\nThe data/ folder stores the data files created from the scripts in data-raw/ (and any other data you need in your app-package).\n\nâ€œstore R objects and make them available to the userâ€¦in data/â€\n\n\n\ninst/extdata\nAny other data youâ€™d like to make available to users of your package should be stored in inst/extdata/\n\nâ€œstore data in some raw, non-R-specific form and make it available to the userâ€¦in inst/extdata/â€\n\n\n\n\nTests\nThe tests/ folder was created in dev/01_start.R with golem::use_recommended_tests(), which is a wrapper around usethis::use_testthat()\nIn dev/02_dev.R, the golem::add_module() and golem::add_utils()/golem::add_fct() functions also include a with_test = TRUE argument, which creates a test file in the tests/ folder.\n\n\nDocumentation\nR package vignettes contain high-level, user-friendly explanations of the package, which includes a narrative that describes the functions, data, and behavior of the package. For shiny app-packages, the following types of documentation might be included in the vignettes:\n\n\n\n\n\n\nIntroduction to the package\nInstallation guide\nUsage examples\nDescription of the application and modules\n\n\n\n\n\nApplication workflow\nData preparation\nTroubleshooting\nFAQs\nAdvanced usage\nDetails on functions and datasets\nReferences and Contact information\n\n\n\n\n\nusethis::use_vignette(\"gap\")\n\n\nâœ” Setting active project to '/Users/mjfrigaard/projects/dev/gap'\nâœ” Adding 'knitr' to Suggests field in DESCRIPTION\nâœ” Adding 'rmarkdown' to Suggests field in DESCRIPTION\nâœ” Adding 'knitr' to VignetteBuilder\nâœ” Adding 'inst/doc' to '.gitignore'\nâœ” Creating 'vignettes/'\nâœ” Adding '*.html', '*.R' to 'vignettes/.gitignore'\nâœ” Writing 'vignettes/gap.Rmd'\nâ€¢ Modify 'vignettes/gap.Rmd'\n\nThe vignette file opens with the title matching the argument passed to use_vignette().\n\ndevtools::build_vignettes()\n\n\nCode Coverage\nTest code coverage measures the extent to which the test cases cover the possible execution paths in the package codebaseâ€“its a way to ensure that the tests are robust enough to verify that the code behaves as expected.\nThere are two functions/methods used to calculate code coverage in your application: usethis::use_coverage() and covrpage::covrpage().\n\nusethis::use_coverage()\nuse_coverage() is part of the usethis package and can be run interactively during development:\n\nusethis::use_coverage()\n\nâœ” Setting active project to '/Users/mjfrigaard/projects/pkgs/apps/gap'\n\n\ncovrpage::covrpage()\nInstall covrpage using the following:\n\n# install.packages(\"remotes\")\nremotes::install_github('yonicd/covrpage')\nlibrary(covrpage)\n\nTo use covrpage, run the following\n\n\n\nCI"
  },
  {
    "objectID": "series/shiny-frameworks/golem/index.html#use",
    "href": "series/shiny-frameworks/golem/index.html#use",
    "title": "Creating shiny app-packages (golem)",
    "section": "Use",
    "text": "Use\n\nWriting code\nNew modules and utility functions can be created with golem::add_module() or golem::add_utils()/golem::add_fct()\n\nThese functions are added to the R/ folder and include @noRd by default (which must be removed create the .Rd files in the man/ folder)\n\n\n# UI module template -------------------\n#' test UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd\n#'\n#' @importFrom shiny NS tagList\n# server module template ---------------\n#' test Server Functions\n#'\n#' @noRd\n\n\nUI module functions end with a _ui suffix:\n\nClick on Code to view code in R/mod_plot.R\n\n\n\n#' plot UI Function\n#'\n#' @param id\n#'\n#' @return shiny UI module\n#' @export mod_plot_ui\n#'\n#' @importFrom shiny NS tagList tags\n#' @importFrom shiny plotOutput verbatimTextOutput\nmod_plot_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\n          \"The code for this application comes from the \",\n          shiny::tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    ),\n    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\nServer module functions end with a _server suffix:\n\nClick on Code to view code in R/mod_plot.R\n\n\n\n\nshow/hide\n#' plot Server Functions\n#'\n#' @param id module id\n#' @param var_inputs inputs from mod_var_input\n#'\n#' @return shiny server module\n#' @export mod_plot_server\n#'\n#' @importFrom shiny NS moduleServer reactive\n#' @importFrom tools toTitleCase\n#' @importFrom shiny renderPlot\n#' @importFrom stringr str_replace_all\n#' @importFrom ggplot2 labs theme_minimal theme\nmod_plot_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    movies &lt;- gap::movies\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs$plot_title())\n      list(\n        x = var_inputs$x(),\n        y = var_inputs$y(),\n        z = var_inputs$z(),\n        alpha = var_inputs$alpha(),\n        size = var_inputs$size(),\n        plot_title = plot_title\n      )\n    })\n\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n## To be copied in the UI\n# mod_plot_ui(\"plot_1\")\n\n## To be copied in the server\n# mod_plot_server(\"plot_1\")\n\n\n\n\nSee all of the modules I use in this application here on GitHub examples\n\n\n\n\n\n\n\n\n\nModule names\n\n\n\n\n\n\nIncluding mod in the name of module scripts and functions makes it easier to separate them from other functions in my package namespace, if Iâ€™m using tab-completion, or if Iâ€™m searching for a particular file using Ctrl + .:\n\n\n\n\n\n\n\nFigureÂ 2: Go to File/Function in RStudio\n\n\n\n\n\n\n\nInclude tests for new modules and functions using the with_test = TRUE argument\n\n\ntests/testthat/\n            â”œâ”€â”€ _snaps\n            â”œâ”€â”€ test-golem-recommended.R\n            â”œâ”€â”€ test-golem_utils_server.R\n            â”œâ”€â”€ test-golem_utils_ui.R\n            â”œâ”€â”€ test-mod_plot.R\n            â”œâ”€â”€ test-mod_plot_utils_server.R\n            â””â”€â”€ test-mod_var_input.R\n\n2 directories, 6 files\n\n\n\n\n\nAdding resources\n\nTo include other files (like images), add the image file to inst/app/www/, then add the www/ to the path (see example UI code below)\n\n\n# add icon\nshiny::tags$img(src = \"www/shiny.png\")\n\n\nIf I wanted to include images in their own folder (like images/), I can use golem::addResourcePath() to add the name of the sub-folder to inst/app/\n\n\n# add icon\ngolem::add_resource_path(\n          prefix = 'images', \n          directoryPath = system.file('app/images', package = 'gap'))\n\n\nNow I can add the image file to the inst/app/www/images/ folder and include the following code in the UI:\n\n\n# add icon\nshiny::tags$img(src = \"www/images/golem-hex.png\")\n\n\nIn R/app_ui.R, the app_ui() function contains the UI layout functions (fluidPage(), sidebarLayout(), etc.), and a call to golem_add_external_resources():\n\nClick on Code to view the updated R/app_ui.R\n\n\n\n\nshow/hide\n#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_ui &lt;- function(request) {\n  shiny::tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    shiny::fluidPage(\n      shiny::tags$h1(\"gap\"),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          # add shiny hex in www/\n          shiny::tags$img(src = \"www/shiny.png\"),\n          mod_plot_ui(\"plot\"),\n          # add golem hex (in www/images/)\n          shiny::fluidRow(\n            shiny::tags$em(shiny::tags$h4(\n              \"Brought to you by: \",\n              shiny::tags$img(src = \"www/images/golem-hex.png\")\n            ))\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n\nClick on Code to view golem_add_external_resources()\n\n\n\n\nshow/hide\n# this is also included in the app_ui.R script\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"gap\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\n\nNow when I run devtools::load_all(), devtools::document(), install/restart, and load the package, I see the images properly rendered with the application:\n\n\n\nDeploy\n\nThe final step in the guided tour contains functions for deploying a new application to Posit Connect or Docker (it opens automatically after completing the dev/02_dev.R)\n\nClick on Code to view code in dev/03_deploy.R\n\n\n\n\nshow/hide\n## Run checks ----\n## Check the package before sending to prod\ndevtools::check()\nrhub::check_for_cran()\n\n# Deploy\n\n## Local, CRAN or Package Manager ----\n## This will build a tar.gz that can be installed locally,\n## sent to CRAN, or to a package manager\ndevtools::build()\n\n## RStudio ----\n## If you want to deploy on RStudio related platforms\ngolem::add_rstudioconnect_file()\ngolem::add_shinyappsio_file()\ngolem::add_shinyserver_file()\n\n## Docker ----\n## If you want to deploy via a generic Dockerfile\ngolem::add_dockerfile_with_renv()\n\n## If you want to deploy to ShinyProxy\ngolem::add_dockerfile_with_renv_shinyproxy()\n\n\n\n\nRStudio (Posit) Connect\n\ngolem::add_rstudioconnect_file(), golem::add_shinyappsio_file(), and golem::add_shinyserver_file()\n\nDocker\n\ngolem::add_dockerfile_with_renv() and golem::add_dockerfile_with_renv_shinyproxy()\n\nIâ€™ll deploy my app using shinyapps.io, so after running golem::add_shinyappsio_file() I will see the following output and a new app.R file.\n\n\nClick on Code to view the output from golem::add_shinyappsio_file()\n\n\n\n\nshow/hide\ngolem::add_shinyappsio_file()\nâ”€â”€ Creating _disable_autoload.R â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ” Created\nâœ” Setting active project to '/Users/mjfrigaard/projects/gap'\nâœ” Adding '^app\\\\.R$' to '.Rbuildignore'\nâœ” Adding '^rsconnect$' to '.Rbuildignore'\nâœ” Adding 'pkgload' to Imports field in DESCRIPTION\nâ€¢ Refer to functions with `pkgload::fun()`\nâœ” File created at /Users/mjfrigaard/projects/gap/app.R\nTo deploy, run:\nâ€¢ rsconnect::deployApp()\n\nâ€¢ Note that you'll need to upload the whole package to ShinyApps.io\n\n\n\n\nThe app.R contents\n\n\nClick on Code to view the contents of app.R\n\n\n\n\nshow/hide\n# Launch the ShinyApp (Do not remove this comment)\n# To deploy, run: rsconnect::deployApp()\n# Or use the blue button on top of this file\n\npkgload::load_all(export_all = FALSE, helpers = FALSE, attach_testthat = FALSE)\noptions( \"golem.app.prod\" = TRUE)\ngap::run_app() # add parameters here (if any)\n\n\n\n\nBuilding an application with golem is very similar to developing an R package. New code files are placed in R/, external resources are placed in inst/, etc. Iâ€™ll cover creating modules and utility functions in the next section."
  },
  {
    "objectID": "posts/box/index.html",
    "href": "posts/box/index.html",
    "title": "Writing modular code with box",
    "section": "",
    "text": "box provides a precise and concise method for using add-on packages and functions. box also doesnâ€™t require bundling your code into R packages to make it reusable. This post covers tackling some common workflow steps to demonstrate how box modules work."
  },
  {
    "objectID": "posts/box/index.html#what-is-box",
    "href": "posts/box/index.html#what-is-box",
    "title": "Writing modular code with box",
    "section": "",
    "text": "box provides a precise and concise method for using add-on packages and functions. box also doesnâ€™t require bundling your code into R packages to make it reusable. This post covers tackling some common workflow steps to demonstrate how box modules work."
  },
  {
    "objectID": "posts/box/index.html#packages-functions-and-namespaces",
    "href": "posts/box/index.html#packages-functions-and-namespaces",
    "title": "Writing modular code with box",
    "section": "Packages, functions, and namespaces",
    "text": "Packages, functions, and namespaces\nTo understand the problem box solves, weâ€™ll review the typical process for using add-on package functions in a standard R sesson and when developing R packages:\n\nR sessions\n\nAssume I want to use the glue() function from the glue package. The first step is to install it with install.packages(\"glue\")\n\nIâ€™ll use the example from the glue package website:\n\n\n\nshow/hide\ninstall.packages(\"glue\")\n## \n## The downloaded binary packages are in\n##  /var/folders/0x/x5wkbhmx0k74tncn9swz7xpr0000gn/T//RtmpAXeFDN/downloaded_packages\n\n\n\n\nTo use the functions from glue, Iâ€™ll need to run library(glue) in the same R session.\n\nIf I try to use a function from a package but it hasnâ€™t been attached with library or require, I see the following:\n\n\n\nshow/hide\nname &lt;- \"Fred\"\nglue('My name is {name}.')\n## Error in glue(\"My name is {name}.\"): could not find function \"glue\"\n\n\n\nThe error above can be confusing, because it doesnâ€™t tell us if the package hasnâ€™t been installed, or if the package hasnâ€™t been attached.\nHowever, after installing glue, I can get around using library by explicitly calling the function from the package namespace (i.e., pkg::foo()):\n\n\n\nshow/hide\nname &lt;- \"Fred\"\nglue::glue('My name is {name}.')\n## My name is Fred.\n\n\n\nWhile this method works, it doesnâ€™t attach the package to the search list (which I check with search())\n\n\n\nshow/hide\nbase::search()\n## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\n\n\n\nlibrary() attaches the glue package in the search list and makes the glue() function available to use (without the package:: prefix)\n\n\n\nshow/hide\nlibrary(glue)\nbase::search()\n##  [1] \".GlobalEnv\"        \"package:glue\"      \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n\n\n\nUnfortunately, library() also attaches all the objects from the glue package to the search() list, even though Iâ€™m only using a single function.\n\n\nRead more about namespaces in Advanced R and R packages.\n\n\nR packages\nIf I want to make the code I write using glue reusable, I can bundle it into an R package. Including glue as an add-on package (i.e., packages not loaded automatically with R) is done with the NAMESPACE file (created and edited via roxygen2 tags), and by listing these packages under Imports in the DESCRIPTION file.\n\nIn R/ files:\nAll .R files in R packages are placed in the R/ folder. If these files use add-on packages (i.e., library() or package::fun()), I include the @import or @importFrom tag. If Iâ€™d like to include and make my_name() available to users, I use the @export tag:\n\nIâ€™ve converted the use of glue() into a small function below:\n\nmy_name() is saved as R/my_name.R:\n\n\n\nshow/hide\nmy_name &lt;- function(x) {\n  name &lt;- x\n  glue::glue('My name is {name}.')\n}\nmy_name(\"Fred\")\n## My name is Fred.\n\n\n\nBelow is a default roxygen2 skeleton:\n\n\n\nshow/hide\n#' Introduce yourself \n#'\n#' @param x a name \n#'\n#' @return An glued introduction to R\n#' @export my_name\n#'\n#' @examples\n#' my_name(\"Fred\")\nmy_name &lt;- function(x) {\n  name &lt;- x\n  glue::glue('My name is {name}.')\n}\n\n\n\n\n\nAs we can see, the default roxygen2 skeleton doesnâ€™t include @import or @importFrom. The general advice is to prefer @importFrom over @import, because @import imports the entire package namespace (only use this in â€˜very special situationsâ€™ such as â€˜heavy useâ€™ of a package functions).\n\nBelow is an example of using @importFrom:\n\n\n\nshow/hide\n#' Introduce yourself \n#'\n#' @param x a name \n#'\n#' @return An glued introduction to R\n#' @export my_name\n#'\n#' @examples\n#' my_name(\"Fred\")\n#'\n#' @importFrom glue glue\nmy_name &lt;- function(x) {\n  name &lt;- x\n  glue::glue('My name is {name}.')\n}\n\n\n\n\n\n\nNAMESPACE\nWhile developing my R package, Iâ€™ll run devtools::load_all() and devtools::document() frequently, and each time the imported functions are available in the current session and the tags are converted into directives in the NAMESPACE file\nimport(package)\nimportFrom(package,function) \n\n\nDESCRIPTION\nA package DESCRIPTION file is managed completely independent of itâ€™s NAMESPACE file. This can be confusing during package development, because itâ€™s easy to assume some kind of connection between the roxygen2 tags, the NAMESPACE file, and the DESCRIPTION file:\n\nHowever, this is not the case:\n\nTo include glue in the DESCRIPTION under Imports, I also need to use usethis::use_package(\"glue\")\nAs noted in R packages, â€œThe Imports field [in the DESCRIPTION file] makes sure that the packages listed there are installed when your package is installed.â€ The DESCRIPTION file does not make functions available to the package developer (or the user).\n\n\nThe recommended practices for add-on packages are 1) use the namespace-qualified calls in the R/ scripts (i.e., package::function() with an accompanying @importFrom package function tag), and 2) list these packages in the DESCRIPTION file under Imports or Suggests to make sure a package is installed whenever your package is installed (i.e., with usethis::use_package(\"package\"))\nThe table below shows the connection between roxygen2 tags, the resulting NAMESPACE entry, and what should be listed in the DESCRIPTION (this is also covered in R packages)\n\n\n\n\n\n\n\n\nRefresher on roxygen2, NAMESPACE & DESCRPTION\n\n\n\n\n\n\n\n\n\n\n\nroxygen2 tag\n\n\nNAMESPACE directive\n\n\nDESCRIPTION\n\n\n\n\n\n\n@importFrom\n\n\nimportFrom() : import selected object from another namespace\n\n\nConsider listing under â€˜Suggestsâ€™\n\n\n\n\n@import\n\n\nimport(): import all objects from another packageâ€™s namespace\n\n\nList under â€˜Importsâ€™\n\n\n\n\n@export\n\n\nexport() : export the function, method, generic, or class so itâ€™s available outside of the package (in the namespace)\n\n\nNothing to list"
  },
  {
    "objectID": "posts/box/index.html#how-box-is-different",
    "href": "posts/box/index.html#how-box-is-different",
    "title": "Writing modular code with box",
    "section": "How box is different",
    "text": "How box is different\nbox doesnâ€™t require installing or attaching add-on packages. Instead, it uses modules to make package functions available. Iâ€™ll demonstrate with a simplified example using the glue() package. Assume I have a project folder pkg/,\n\n\n\nshow/hide\npkg/\n  â””â”€â”€ pkg.Rproj\n\n1 directory, 1 file\n\n\n\n\nProjects in RStudio have a hidden folder, .Rproj.user/:\n\nThe the following contents are automatically created with a new .Rproj file:\n\n\n\ncontents of .Rproj\npkg/\n  â”œâ”€â”€ .Rproj.user\n  â”‚      â”œâ”€â”€ 8CC5F70E\n  â”‚      â”‚      â”œâ”€â”€ bibliography-index\n  â”‚      â”‚      â”œâ”€â”€ ctx\n  â”‚      â”‚      â”œâ”€â”€ explorer-cache\n  â”‚      â”‚      â”œâ”€â”€ presentation\n  â”‚      â”‚      â”œâ”€â”€ profiles-cache\n  â”‚      â”‚      â”œâ”€â”€ sources\n  â”‚      â”‚      â”‚      â””â”€â”€ session-16ca0811\n  â”‚      â”‚      â”‚          â””â”€â”€ lock_file\n  â”‚      â”‚      â”œâ”€â”€ tutorial\n  â”‚      â”‚      â””â”€â”€ viewer-cache\n  â”‚      â””â”€â”€ shared\n  â”‚          â””â”€â”€ notebooks\n  â”‚              â””â”€â”€ patch-chunk-names\n  â””â”€â”€ pkg.Rproj\n\n14 directories, 3 files\n\n\n\nNone of these contents deal with installing or loading packages, but Iâ€™ve included it here for full transparency\n\n\n\nCreate a box module\nIâ€™ll put the modules in a box/fun.R file, which Iâ€™ll create from the command-line:\n\n\n\nshow/hide\nmkdir box \ntouch box/fun.R\n\n\n\nNow my pkg folder looks like this:\n\n\n\nshow/hide\npkg/\n  â”œâ”€â”€ box\n  â”‚    â””â”€â”€ fun.R\n  â”œâ”€â”€ pkg.Rproj\n  â””â”€â”€ use.R\n\n2 directories, 3 files\n\n\n\nIn pkg/box/fun.R Iâ€™ll add the following:\n\na brief comment with the path to the module\nthe @export tag from roxygen2\na call to box::use(glue[glue])\n\n\n\n\nshow/hide\n# box/fun.R\n#' @export\nbox::use(\n  glue[glue]\n  )\n\n\n\nIn the parent folder, create another file named use.R.\nIn use.R, use the fun module by calling box::use(box/fun)\n\n\n\nshow/hide\nbox::use(box/fun)\n\n\n\nView fun by printing it to the console:\n\n\n\nshow/hide\n# print\nfun\n\n\n\n\nshow/hide\n&lt;module: box/fun&gt;\n\n\n\nThis confirms the module has been created.\n\n\nUsing modules\nThe glue function is available from fun using the $ (like a column in a data.frame or tibble)\n\n\n\nshow/hide\n# use \nx &lt;- \"module\"\nfun$glue('This is a box {x}.')\n\n\n\n\nshow/hide\nThis is a box module.\n\n\n\nbox modules are combinations of named folders and files, but unlike R packages, these folders and files can be nested. The folder/file structure is used for separating modules, the same way we might separate files in a project (i.e., project/data/file.csv and project/code/analysis.R)\n\nbox makes the function and package namespacing explicit by using box::use(package[fun])\nbox also simplifies using module by calling the same function when building/using modules box::use(folder/file):\n\n\n# CREATE MODULE\n# box/fun.R\n#' @export\nbox::use(\n  glue[glue]\n  )\n\n\n# USE MODULE\nbox::use(box/fun)\n\nBelow is a slightly more involved example:"
  },
  {
    "objectID": "posts/box/index.html#module-workflow",
    "href": "posts/box/index.html#module-workflow",
    "title": "Writing modular code with box",
    "section": "Module workflow",
    "text": "Module workflow\nBelow Iâ€™m going to create a module that imports, wrangles, and visualizes data from the palmerpenguins package. (which is installed, but not loaded).\n\nbox/import\nThis workflow starts with an import module in a pengbox project. The code below is stored in pengbox/box/import.R:\n\n\n\nimport module\n# box/import.R\nbox::use(\n  readr[read_csv],\n)\n#' @export\nget_raw_csv &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/3SQJ6E3\"\n  read_csv(raw_csv_url)\n}\n\n\n\nIn a the master pengbox/run.R file, Iâ€™ll use import like so:\n\n\n\nshow/hide\n# import\nbox::use(box/import)\nstr(import$get_raw_csv(), give.attr = FALSE)\n\n\n\n\n\n\nshow/hide\nspc_tbl_ [344 Ã— 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie\" ...\n $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \n $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \n $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 ...\n $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 ...\n $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 ...\n $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA ...\n\n\n\nIâ€™ll re-write this module in box/import.R using an alias for readrs read_csv() function (rcsv) and include the readr::cols() function to remove the lengthy message.\nThis code is stored in the box/import.R file:\n\n\n\nimport module with alias\n# box/import.R\nbox::use(\n  readr[rcsv = read_csv, cols]\n)\n#' @export\nraw &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/3SQJ6E3\"\n  # use alias for read_csv()\n  rcsv(raw_csv_url, col_types = cols())\n}\n\n\n\nUsing import with the new module is more concise:\n\n\n\nshow/hide\n# import\nbox::use(box/import)\nstr(import$raw(), give.attr = FALSE)\n\n\n\n\n\n\nshow/hide\nspc_tbl_ [344 Ã— 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie\" ...\n $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \n $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \n $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 ...\n $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 ...\n $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 ...\n $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA ...\n\n\n\n\n\nbox/prep\nAfter importing the raw penguins data, Iâ€™ll write a module for wrangling the data (that also imports the import module).\nThis module takes the following steps:\n\nReset the box.path\n\nImport the box/import module\n\nLoad all the functions from dplyr using [...]\n\nLoad aliases for stringr::str_extract() and janitor::clean_names()\n\nCompose prep() with the wrangling steps\n\n\n\n\nprep module with import\n# box/prep.R\n\n# reset the path\noptions(box.path = getwd())\n\n# import alias import module\nbox::use(box/import)\n\n# wrangle packages, functions, and aliases\nbox::use(\n  dplyr[...],\n  stringr[str_ext = str_extract],\n  janitor[fix_cols = clean_names]\n)\n\n#' @export\nprep = function() {\n  raw &lt;- import$raw()\n  clean_cols &lt;- fix_cols(raw)\n  vars &lt;- select(clean_cols, \n    species, \n    island, \n    bill_length_mm = culmen_length_mm,\n    bill_depth_mm = culmen_depth_mm,\n    flipper_length_mm,\n    body_mass_g,\n    sex)\n  mutate(vars, \n    species = str_ext(species, \"([[:alpha:]]+)\"),\n    sex = factor(sex))\n}\n\n\n\nWe can now the prep module to access the import module for the wrangled dataset.\n\n\n# prepare\nbox::use(box/prep)\npeng_clean &lt;- prep$prep()\nstr(peng_clean, give.attr = FALSE)\n\n\n\n\ntibble [344 Ã— 7] (S3: tbl_df/tbl/data.frame)\n $ species          : chr [1:344] \"Adelie\" \"Adelie\" \"Adelie\" \"Adelie\" ...\n $ island           : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \"Torgersen\" ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: num [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ sex              : Factor w/ 2 levels \"FEMALE\",\"MALE\": 2 1 1 NA 1 2 1 2 NA NA ...\n\n\nThese data look like theyâ€™re ready for graphing! Time to write another moduleâ€¦\n\n\nbox/plot\nI will build my visualization with ggplot2 (in the box/plot.R module) and dplyr::filter():\n\n\n\nplot module with prep\n# pengbox/plot.R\n\n# reset the path\noptions(box.path = getwd())\n\n# import prep module\nbox::use(box/prep)\n\n# import ggplot2\nbox::use(\n  dplyr[filter],\n  ggplot2 = ggplot2[ggplot, aes, geom_point, \n                    facet_wrap, labs, theme_minimal])\n\n#' @export\nscatter &lt;- function() {\n  prepped &lt;- prep$prep()\n  # remove missing sex\n  filtered &lt;- filter(prepped, !is.na(sex)) \n    # plot filtered data\n  plotted &lt;- ggplot2$ggplot(data = filtered, \n    ggplot2$aes(\n      x = flipper_length_mm,\n      y = body_mass_g,\n      group = sex\n    )\n  ) +\n    ggplot2$geom_point(\n      ggplot2$aes(color = island)\n    ) +\n    ggplot2$facet_wrap(. ~ sex) +\n    ggplot2$labs(x = \"Flipper Length (mm)\", y = \"Body Mass (g)\", \n      color = \"Island\", title = \"Flipper vs. Body Mass\", \n      subtitle = \"Palmer Penguins\") +\n    ggplot2$theme_minimal()\n  plotted\n}\n\n\n\nCheck our scatter plot with plot$scatter()\n\n\n\nshow/hide\n# plot\nbox::use(box/plot)\nplot$scatter()\n\n\n\n\n\n\n\n\nAnd there you have it! A complete pipeline using box modules! And the total project size (files and folders) is much smaller than building an R package:\n\n\n\nshow/hide\npengbox/\n    â”œâ”€â”€ box\n    â”‚   â”œâ”€â”€ import.R\n    â”‚   â”œâ”€â”€ plot.R\n    â”‚   â””â”€â”€ prep.R\n    â”œâ”€â”€ penguins.Rproj\n    â””â”€â”€ run.R\n\n2 directories, 5 files\n\n\n\nBelow are the various ways to include packages and functions in box modules:\n\n\n\n\n\n\n\nOptions for creating box modules:\n\n\n\n\n\n\n\n\n\n\n\nInside box::use()\n\n\nAction\n\n\n\n\n\n\nbox::use( pkg )\n\n\nimports â€˜pkgâ€™, does not attach any function names\n\n\n\n\nbox::use( p = pkg )\n\n\nimports â€˜pkgâ€™ with alias (â€˜pâ€™), does not attach any function names\n\n\n\n\nbox::use( pkg = pkg[foo, bar] )\n\n\nimports â€˜pkgâ€™ and attaches the function names â€˜pkg::foo()â€™ and â€˜pkg::bar()â€™\n\n\n\n\nbox::use( pkg[my_foo = foo, â€¦] )\n\n\nimports â€˜pkgâ€™ with alias for â€˜fooâ€™ (â€˜my_fooâ€™) and attaches all exported function names"
  },
  {
    "objectID": "posts/box/index.html#nesting-modules",
    "href": "posts/box/index.html#nesting-modules",
    "title": "Writing modular code with box",
    "section": "Nesting modules",
    "text": "Nesting modules\nThe same workflow could be re-written as nested modules, with folders separating logical steps in an analysis workflow (or application). Consider the folder structure below:\n\n\n\nshow/hide\npengbox/\n    â”œâ”€â”€ box\n    â”‚   â””â”€â”€ graph\n    â”‚       â”œâ”€â”€ wrangle\n    â”‚       â”‚   â”œâ”€â”€ clean\n    â”‚       â”‚   â”‚   â”œâ”€â”€ import\n    â”‚       â”‚   â”‚   â”‚   â””â”€â”€ raw.R\n    â”‚       â”‚   â”‚   â””â”€â”€ cols.R\n    â”‚       â”‚   â””â”€â”€ vars.R\n    â”‚       â””â”€â”€ scatter.R\n    â”œâ”€â”€ penguins.Rproj\n    â””â”€â”€ run.R\n\n6 directories, 6 files\n\n\n\n\nimport\nWith this structure, the raw module is in the import folder:\n\n\n\nshow/hide\npengbox/box/graph/wrangle/clean/import\n                                    â””â”€â”€ raw.R\n\n1 directory, 1 file\n\n\n\n\nThe raw moduleâ€“the first stepâ€“is nested in the box/graph/wrangle/clean/import/raw.R file\n\nThe raw module imports the raw .csv data with an aliass for readrâ€™s read_csv()\n\n\n\n\nraw module\n# box/graph/wrangle/clean/import/raw.R\nbox::use(\n  readr[rcsv = read_csv, cols]\n)\n#' @export\ncsv &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/3SQJ6E3\"\n  # use alias for read_csv()\n  rcsv(raw_csv_url, col_types = cols())\n}\n\n\n\n\n\nraw\n\nIn run.R, I run box/graph/wrangle/clean/import/raw to import the raw module\n\nThe csv() function imports the raw data\n\n\n\n\nshow/hide\n# in use.R\nbox::use(box/graph/wrangle/clean/import/raw)\nstr(raw$csv(), give.attr = FALSE)\n\n\n\n\n\n\nraw module output\nspc_tbl_ [344 Ã— 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ studyName          : chr [1:344] \"PAL0708\" \"PAL0708\" \"PAL0708\" \"PAL0708\" ...\n $ Sample Number      : num [1:344] 1 2 3 4 5 6 7 8 9 10 ...\n $ Species            : chr [1:344] \"Adelie Penguin (Pygoscelis adeliae)\" \"Adelie\" ...\n $ Region             : chr [1:344] \"Anvers\" \"Anvers\" \"Anvers\" \"Anvers\" ...\n $ Island             : chr [1:344] \"Torgersen\" \"Torgersen\" \"Torgersen\" \n $ Stage              : chr [1:344] \"Adult, 1 Egg Stage\" \"Adult, 1 Egg Stage\" \n $ Individual ID      : chr [1:344] \"N1A1\" \"N1A2\" \"N2A1\" \"N2A2\" ...\n $ Clutch Completion  : chr [1:344] \"Yes\" \"Yes\" \"Yes\" \"Yes\" ...\n $ Date Egg           : Date[1:344], format: \"2007-11-11\" \"2007-11-11\" ...\n $ Culmen Length (mm) : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 ...\n $ Culmen Depth (mm)  : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 ...\n $ Flipper Length (mm): num [1:344] 181 186 195 NA 193 190 181 195 193 ...\n $ Body Mass (g)      : num [1:344] 3750 3800 3250 NA 3450 ...\n $ Sex                : chr [1:344] \"MALE\" \"FEMALE\" \"FEMALE\" NA ...\n $ Delta 15 N (o/oo)  : num [1:344] NA 8.95 8.37 NA 8.77 ...\n $ Delta 13 C (o/oo)  : num [1:344] NA -24.7 -25.3 NA -25.3 ...\n $ Comments           : chr [1:344] \"Not enough blood for isotopes.\" NA NA ...\n\n\n\n\n\n\n\nclean\nThe clean folder contains the cols module and the snakes() function\n\n\n\nshow/hide\nbox/graph/wrangle/\n              â”œâ”€â”€ clean\n              â”‚   â”œâ”€â”€ #import\n              â”‚   â”‚   #â””â”€â”€ raw.R\n              â”‚   â””â”€â”€ cols.R\n              â””â”€â”€ vars.R\n\n3 directories, 3 files\n\n\n\n\nsnakes\n\nThe box/graph/wrangle/clean/cols module standardizes the column names\n\ncols calls the snakes() function, which converts all the column names to lower_snake_case with an alias for janitor::clean_names(), then it imports select from dplyr to subset the columns\n\n\n\n\ncols module\n# box/graph/wrangle/clean/cols.R\n\n# reset the path\noptions(box.path = getwd())\n\n# use import raw module\nbox::use(box/graph/wrangle/clean/import/raw)\n\n# columns\nbox::use(\n  dplyr[select],\n  janitor[fix_cols = clean_names]\n)\n\n#' @export\nsnakes = function() {\n  raw &lt;- raw$csv()\n  clean_cols &lt;- fix_cols(raw)\n  vars &lt;- select(clean_cols, \n    species, \n    island, \n    bill_length_mm = culmen_length_mm,\n    bill_depth_mm = culmen_depth_mm,\n    flipper_length_mm,\n    body_mass_g,\n    sex)\n  return(vars)\n}\n\n\n\n\nBack in run.R, we call the cols module to convert the columns names with snakes():\n\n\n\n# clean columns\nbox::use(box/graph/wrangle/clean/cols)\nnames(cols$snakes())\n\n\n\n\n\ncols module output\n[1] \"species\"           \"island\"            \"bill_length_mm\"    \"bill_depth_mm\"                  \n[5] \"flipper_length_mm\" \"body_mass_g\"       \"sex\" \n\n\n\n\n\n\n\nwrangle\n\nNow that I have standardized columns and the subset of the variables to plot, I can call the vars module to wrangle the plot variables\n\n\n\n\nshow/hide\nbox/graph/wrangle/\n            â”œâ”€â”€ #clean\n            â”‚   #â”œâ”€â”€ #import\n            â”‚   #â”‚   #â””â”€â”€ raw.R\n            â”‚   #â””â”€â”€ cols.R\n            â””â”€â”€ vars.R\n\n3 directories, 3 files\n\n\n\n\nvars\n\nvars is nested in the wrangle folder, and imports the raw and cols modules\n\nThe vars module imports mutate and filter from dplyr and an alias for stringr::str_extract()\n\n\n\n\nvars module\n# box/graph/wrangle/vars.R\n\n# reset the path\noptions(box.path = getwd())\n\n# use clean names module\nbox::use(box/graph/wrangle/clean/cols)\n\n# wrangle packages/functions\nbox::use(dplyr[mutate, filter],\n  stringr[str_ext = str_extract])\n\n#' @export\nscatter = function() {\n  clean_cols &lt;- cols$snakes()\n  plot_vars &lt;- clean_cols |&gt;\n    mutate(\n      species = str_ext(species, \"([[:alpha:]]+)\"),\n      species = factor(species),\n      island = factor(island),\n      sex = factor(sex)\n    ) |&gt;\n    # remove missing sex\n    filter(!is.na(sex))\n  return(plot_vars)\n}\n\n\n\nIn run.R, we check the structure of the output from vars$scatter()\n\n\n\nshow/hide\n# in run.R\n# wrangle variables \nbox::use(box/graph/wrangle/vars)\nstr(vars$scatter())\n\n\n\n\n\n\nvars module output\ntibble [333 Ã— 7] (S3: tbl_df/tbl/data.frame)                                                     \n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:333] 39.1 39.5 40.3 36.7 39.3 38.9 39.2 41.1 38.6 34.6 ...\n $ bill_depth_mm    : num [1:333] 18.7 17.4 18 19.3 20.6 17.8 19.6 17.6 21.2 21.1 ...\n $ flipper_length_mm: num [1:333] 181 186 195 193 190 181 195 182 191 198 ...\n $ body_mass_g      : num [1:333] 3750 3800 3250 3450 3650 ...\n $ sex              : Factor w/ 2 levels \"FEMALE\",\"MALE\": 2 1 1 1 2 1 2 1 2 2 ...\n\n\n\n\n\n\n\ngraph\nFinally, we get to the graph module. This module import all preceding modules.\n\n\nbox/\nâ””â”€â”€ graph\n    â”œâ”€â”€ #wrangle\n    â”‚   #â”œâ”€â”€ #clean\n    â”‚   #â”‚   #â”œâ”€â”€ #import\n    â”‚   #â”‚   #â”‚   #â””â”€â”€ raw.R\n    â”‚   #â”‚   #â””â”€â”€ cols.R\n    â”‚   #â””â”€â”€ vars.R\n    â””â”€â”€ scatter.R\n\n5 directories, 4 files\n\n\n\nscatter\n\nThe scatter module imports the vars module with the data thatâ€™s been imported, cleaned, and wrangled.\n\nThe ggp2() function includes the ggplot2 functions to build a scatter plot.\n\n\n\n\nscatter module\n# box/graph/scatter.R\n\n# reset the path\noptions(box.path = getwd())\n\n# import plot vars module\nbox::use(box/graph/wrangle/vars)\n\n# import ggplot2\nbox::use(\n  ggplot2 = ggplot2[ggplot, aes, geom_point, \n                    facet_wrap, labs, theme_minimal]\n)\n\n#' @export\nggp2 &lt;- function() {\n  scatter_vars &lt;- vars$scatter()\n  # plot prepped data\n  ggp2_plot &lt;- ggplot2$ggplot(data = scatter_vars, \n    ggplot2$aes(\n      x = flipper_length_mm,\n      y = bill_length_mm,\n      group = island\n    )\n  ) +\n    ggplot2$geom_point(\n      ggplot2$aes(color = species)\n    ) +\n    ggplot2$facet_wrap(. ~ island) +\n    ggplot2$labs(\n      x = \"Flipper Length (mm)\", \n      y = \"Bill length (mm)\", \n      color = \"Species\",\n      group = \"Island\",\n      title = \"Flipper vs. Bill Length\", \n      subtitle = \"Palmer Penguins\"\n    ) +\n    ggplot2$theme_minimal()\n  ggp2_plot\n}\n\n\n\nIn run.R, the final module call produces the plot.\n\n\n# graph\nbox::use(box/graph/scatter)\nscatter$ggp2()"
  },
  {
    "objectID": "posts/box/index.html#recap",
    "href": "posts/box/index.html#recap",
    "title": "Writing modular code with box",
    "section": "Recap",
    "text": "Recap\nIn this post Iâ€™ve covered how the box package uses modules to separate your analysis and workflow into small, modular scripts. Nesting modules also adds a flexibility R packages do not have (because everything has to be contained in the R/ folder).\nBoth versions of the projects created in this example ended up with very few lines of code, and didnâ€™t require a creating a NAMESPACE or DESCRIPTION file.\nView the final project here."
  },
  {
    "objectID": "posts/test-shiny-p1/index.html",
    "href": "posts/test-shiny-p1/index.html",
    "title": "Unit testing shiny utility functions",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(lobstr)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(covr)\nThis post is the first in a series on testing shiny applications. Iâ€™ll cover developing and testing a set of utility functions for a shiny app-package using testhat. If youâ€™d like to follow along, all the code Iâ€™ll be using is contained in the utap R package on GitHub.\n# renv::install(\"mjfrigaard/utap\")\nlibrary(utap)"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#shiny-app-packages",
    "href": "posts/test-shiny-p1/index.html#shiny-app-packages",
    "title": "Unit testing shiny utility functions",
    "section": "Shiny app-packages",
    "text": "Shiny app-packages\nTesting the code in shiny app-packages can be more complicated than testing the code in a typical R package, because app-packages contain two types of code:\n\nApplication code: functions designed to run the application (i.e., the ui and server functions, modules, standalone app functions will a call to shinyApp(), etc.)\nEverything else: functions or code used for connecting to databases, uploading, importing, or manipulating data, building visualizations and/or tables, generating custom HTML layouts, etc. The non-application code and functions in app-packages are typically referred to as â€˜utilityâ€™ or â€˜helperâ€™ functions\n\nThese two types of code require different types of tests. Utility functions are usually accompanied by unit tests similar to the tests youâ€™d find in a standard R package, while application code is tested using the shiny::testServer() function, or with the shinytest2 package.\nThis post will cover writing unit tests for a set of utility functions using testthat and covr. Any tips or time-savers Iâ€™ve found will be in green callout boxes:\n\n\n\n\n\n\nTIP!\n\n\n\n\n\n\nThis is a tip!"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#what-are-unit-tests",
    "href": "posts/test-shiny-p1/index.html#what-are-unit-tests",
    "title": "Unit testing shiny utility functions",
    "section": "What are unit tests?",
    "text": "What are unit tests?\n\n\n\n\nâ€œA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed. A unit testâ€™s scope can span as little as a method or as much as multiple classes.â€ - The Art of Unit Testing, 2nd edition\n\nIâ€™ve found thinking of functions as â€˜units of workâ€™ and their desired behavior as an â€˜end resultsâ€™ provides a useful mental model during TDD. These terms also align nicely with the testing advice offered by testthat:\n\nStrive to test each behaviour in one and only one test. Then if that behaviour later changes you only need to update a single test.\n\nIn app-packages, the testthat package provides a comprehensive and flexible framework for performing unit tests.\n\ntestthat\nGet started with testthat in your app-package by running usethis::use_testthat(). This function will create following files and folders:\ntests/\n  â”œâ”€â”€ testthat/\n  â””â”€â”€ testthat.R\nTo create new tests, run usethis::use_test(\"utils_fun\") (with \"utils_fun\" being the name of the function youâ€™d like to test).\n\nusethis::use_test(\"utils_fun\")\n\nâœ” Setting active project to '/projects/apps/utap'\nâœ” Writing 'tests/testthat/test-utils_fun.R'\nâ€¢ Modify 'tests/testthat/test-utils_fun.R'\n\nTest files\nNew test files are be created and opened from the tests/testthat/ folder (with a test- prefix).\n\nThe initial contents of a new test file contains the boilerplate code below:\n\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n\n\n\n\n\n\n\nFigureÂ 1: testthat test file\n\n\nTest files\n\n\nTest structure\ntest_that() sets the test â€œscopeâ€ or â€œexecution environmentâ€, and encapsulates the expectations.\n\nNote the use of curly brackets after the code argument:\n\ntestthat::test_that(desc = \"description\", code = {\n\n})\n\n\n\n\n\n\n\nFigureÂ 2: tests\n\n\ntestthat test\n\n\nExpectations\nTest expectations are the code that comes into direct contact with the unit of work and end result for each function. There are usually multiple expectations for any given function, so these are stored in tests (and the desc describes the test context for the set of expectations).\n\nAll testthat expectations have an expect_* prefix:\n\ntestthat::expect_equal(object = 2 * 2, expected = 4)\n\n\n\n\n\n\n\nFigureÂ 3: expectations\n\n\ntestthat expectation\n\n\nUnit test development workflow\nI develop unit tests using the following workflow:\n\nCreate the test file and R script: Iâ€™ll start by creating these files with usethis::use_r() and usethis::use_test(), even if I know the names of these files will likely change as I develop (see more below).\nDefine test context: I use the test context (entered as a character string in the first argument of testthat::test_that()) to capture each â€œunit of workâ€ for each function. I like to keep the test context short and sweetâ€“the â€œunit of workâ€ followed by â€œworksâ€ will suffice in most circumstances, unless thereâ€™s a need for more specific details.\nWrite expectations: These are the third item in the workflow, but conceptually these comes firstâ€“these are the â€œend resultsâ€ I want from each function (i.e., compute a value, download a file, create a column, etc.).\n\nTests and expectations are grouped into test files based on their related objectives or goals, and should correspond to a similar .R file in the R/ folder.\nWhile this workflow is probably not technically considered test-driven development, I do set up the tests before I start writing any code in the R/ folder. This comes in handy if youâ€™re having to remind yourself where you stopped developing on a given projectâ€“Iâ€™ll just run devtools::test() and the first failing test reminds me where to look.\n\n\n\n\n\n\nTIPS: Unit tests\n\n\n\n\n\n\nThe advice on unit tests below (in bold) comes from Effective Software Testing, 2022. Iâ€™ve included descriptions of how testthat satisfies each recommendation:\n\nUnit tests should be fast: the text recommends unit tests take a â€˜couple of millisecondsâ€™ to execute. testthat tests typically fall within this threshold (and provide time measurements to identify bottlenecks).\nUnit tests are easy to control: i.e., â€˜input values and the expected result value are easy to adapt or modify in the test.â€™ testthat expectations give us ample access to 1) the expected result and 2) the observed result.\nUnit tests are easy to write: i.e., â€˜do not require a complicated setup or additional workâ€™. When used combination with usethis, testthat unit tests can be set up, created, written, and run with a few lines of code:\n\nusethis::use_testthat()\n\nusethis::use_test()\n\n&lt; write test &gt;\n\ntestthat::test_file(), testthat::test_dir(), or devtools::test()"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#app-utility-functions",
    "href": "posts/test-shiny-p1/index.html#app-utility-functions",
    "title": "Unit testing shiny utility functions",
    "section": "App utility functions",
    "text": "App utility functions\nThe utility functions Iâ€™ll be developing are designed to populate the choices argument for shiny::selectInput(). For example, the pull_numeric_cols() function would â€˜pullâ€™ the column names from an input data.frame or tibble (the example below uses palmerpenguins::penguins):\n\npull_numeric_cols(palmerpenguins::penguins)\n\n\n##      bill_length_mm       bill_depth_mm   flipper_length_mm \n##    \"bill_length_mm\"     \"bill_depth_mm\" \"flipper_length_mm\" \n##         body_mass_g                year \n##       \"body_mass_g\"              \"year\"\n\nThe return values would be passed to an updateSelectInput() in the server to provide column names by type (i.e., numeric, binary, or categorical). These functions can be used to quickly group variables into groups for data visualizations. For example, binary variables can be mapped the color aesthetic (if using ggplot2), and custom functions can be created for other graph layers (i.e., facets).\nThe unit of work for each hypothetical pull_[type]_cols() function would be, â€œingest a data.frame or tibble and identify columns by type,â€ and their end result might be â€œreturn a (named) vector of column names by type.â€ In this case, [type] refers to the variable type (i.e., numeric, categorical, binary, etc.). See the hypothetical UI output example below:\n\n# UI code\nshiny::selectInput(\n  inputId = ns(\"x\"),\n  label = \"X variable:\",\n  choices = NULL\n)\n\n\n# server code\nshiny::observe({\n  num_vars &lt;- pull_numeric_cols(df = data())\n  shiny::updateSelectInput(session,\n    inputId = \"x\",\n    choices = num_vars,\n    selected = num_vars[1])\n  }) |&gt;\n  shiny::bindEvent(data(),\n    ignoreNULL = TRUE)\n\nIn the example above, pull_numeric_cols() is passed a reactive dataset (data()), and the output is used to update the selectInput().\n\n\n\nX variable:\n\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nyear"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#micro-iteration",
    "href": "posts/test-shiny-p1/index.html#micro-iteration",
    "title": "Unit testing shiny utility functions",
    "section": "Micro-iteration",
    "text": "Micro-iteration\nIn R packages, micro-iteration is defined as, â€œthe interactive phase where you initiate and refine a function and its tests in tandem.â€ If youâ€™re using TDD, youâ€™ll write the test first, then write the function to pass the test.\nThe first unit test Iâ€™ll create is for select_column_class(), a function designed to return columns according to their class().\n\nFunction names\nComing up with names for functions can be challenging. I like to follow the tidyverse style guide and use short verbs as a prefix (make_, get_, check_ etc.). I also like to use names that give â€˜futureâ€™ me hints as to their behavior (i.e., select_column_class() imports and has similar behavior to dplyr::select(), while pull_[type]_cols() is more like dplyr::pull())\n\n\nCreate test file\nI create the test file and function file in the Console\n\nusethis::use_test(\"select_column_class\")\n\nâœ” Setting active project to '/projects/apps/utap'\nâœ” Writing 'tests/testthat/test-select_column_class.R'\nâ€¢ Modify 'tests/testthat/test-select_column_class.R'\n\nusethis::use_r(\"select_column_class\")\n\nâ€¢ Modify 'R/select_column_class.R'\n\n\nTest context\nThe test context (entered as a character string in the first argument of testthat::test_that()) includes the â€œunit of workâ€ for the function, followed by â€œworksâ€:\n\ntestthat::test_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  \n})\n\nBefore I can start developing the select_column_class() function and itâ€™s tests, Iâ€™ll need data. R comes with example data objects in the datasets package, but itâ€™s nice to have control over the data being used in your unit tests. Iâ€™ll cover how to add test data available in your app-package.\n\n\nTest data\nCreating test data is covered in R packages, but Iâ€™ll summarize the key points:\n\nTest data (and other objects) can either be created within a test, or as a persistent test fixture\n\nTest data fixtures should be stored in tests/testthat/fixtures/&lt;test_data.rds&gt;\nThe code used to create any test data fixtures should be stored in the same folder with a make_ prefix (i.e., tests/testthat/fixtures/&lt;make_test_data.R&gt;)\n\nThis is easier to picture with a demonstration: In the tests/testthat/ folder, Iâ€™ll create a new fixtures folder, and add a make_testdata_col_class.R file.\ntests/testthat/\n        â””â”€â”€ fixtures/\n                â””â”€â”€ make_testdata_col_class.R\nIn make_testdata_col_class.R, Iâ€™ll create testdata_col_class using the code below:\n\n\ntest_data for test-select_column_class.R\ntestdata_col_class &lt;- tibble::tibble(\n log_var = c(TRUE, FALSE, TRUE),\n int_var = c(1L, 2L, 3L),\n dbl_var = c(1.1, 2.2, 3.3),\n chr_var = c(\"item:1\", \"item:2\", \"item:3\"),\n fct_var = factor(\n   c(\"group 1\", \"group 2\", \"group 3\"),\n   levels = c(\n     \"group 1\", \"group 2\", \"group 3\")),\n ord_var = factor(\n   c(\"level 1\", \"level 2\", \"level 3\"),\n   levels = c(\"level 1\", \"level 2\", \"level 3\"),\n   ordered = TRUE),\n list_var = list(\n   log_vec = c(TRUE, FALSE),\n   dbl_vec = c(1.1, 2.2),\n   chr_var = c(\"item:1\", \"item:2\")))\n\n\n\ntestdata_col_class\n## # A tibble: 3 Ã— 7\n##   log_var int_var dbl_var chr_var fct_var ord_var list_var  \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;   &lt;named li&gt;\n## 1 TRUE          1     1.1 item:1  group 1 level 1 &lt;lgl [2]&gt; \n## 2 FALSE         2     2.2 item:2  group 2 level 2 &lt;dbl [2]&gt; \n## 3 TRUE          3     3.3 item:3  group 3 level 3 &lt;chr [2]&gt;\n\nIâ€™ll save testdata_col_class in tests/testthat/fixtures/ as testdata_col_class.rds:\ntests/testthat/\n        â””â”€â”€ fixtures/\n                â”œâ”€â”€ make_testdata_col_class.R\n                â””â”€â”€ testdata_col_class.rds\nTo load the data into my test, Iâ€™ll add the following to the top of the test context:\n\ntest_that(desc = \"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  \n})\n\ntestthat::test_path() will load the data from the testing directory when Iâ€™m ready to run my test.\n\n\nExpectations\nIn expect_equal(), Iâ€™ll verify the structure of the returned object is a data.frame/tibble.\n\ntest_that(\"select_column_class() is.tibble/is.data.frame works\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # check tibble\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"???\") |&gt;\n          tibble::is_tibble(),\n    expected = TRUE)\n})\n\nWriting my expectations first forces me to make some decisions about what the arguments will be for the select_column_class() function (i.e., df and class).\nselect_column_class() should return the columns according to their class, so Iâ€™ll tests to verify the class of the return columns.\n\n  # check logical\n  testthat::expect_equal(\n    object =\n      select_column_class(\n        df = testdata_col_class,\n        class = \"log\") |&gt;\n          lapply(is.logical) |&gt; unlist() |&gt; unique(),\n    expected = TRUE)\n\nI try to write these in a way thatâ€™s flexible (should the test data change in the future).\n\n\n\n\n\n\nExpectation-Driven Development\n\n\n\n\n\nWhether or not you decide to adopt Test-Driven Development, I strongly recommend writing test expectations while youâ€™re developing functions. Itâ€™s a great opportunity to clarify a functionâ€™s intended behaviors, arguments, and error/warning messages.\n\n\n\nAfter including tests for each class, Iâ€™ll include a test for the error message from select_column_class() with testthat::expect_error():\n\n# test error type\ntestthat::test_that(\"select_column_class() type error\", {\n  testdata_col_class &lt;- readRDS(test_path(\"fixtures\", \"testdata_col_class.rds\"))\n  # test type error\n  testthat::expect_error(\n    object = select_column_class(\n      df = testdata_col_class, \n      class = \"array\")\n  )\n})\n\nWhen Iâ€™ve covered my intended â€˜end resultsâ€™ for select_column_class() (i.e., when it works and what happens when it doesnâ€™t), Iâ€™ll write the function:\n\n\nselect_column_class()\nselect_column_class &lt;- function(df, class) {\n\n  col_class &lt;- function(df, class) {\n    switch(class,\n      log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),\n      int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),\n      dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),\n      chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),\n      fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),\n      ord = dplyr::select(tibble::as_tibble(df), dplyr::where(is.ordered)),\n      list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list))\n    )\n  }\n\n  cl &lt;- unique(class)\n  cl_check &lt;- cl %nin% c(\"log\", \"int\", \"dbl\", \"chr\", \"fct\", \"ord\", \"list\")\n  if (any(cl_check)) {\n    cli::cli_abort(\"Invalid `class` argument. Must be one of:\\n\n          'log', 'int', 'dbl', 'chr', 'fct', 'ord', 'list'\")\n  }\n\n  col_list &lt;- purrr::map(.x = class, .f = col_class, df = df)\n\n  df_cols &lt;- purrr::list_cbind(col_list, size = nrow(df))\n\n  if (ncol(df_cols) &lt; 1 || nrow(df_cols) &lt; 1) {\n    df_cols &lt;- structure(list(),\n      class = c(\"tbl_df\", \"tbl\", \"data.frame\"),\n      row.names = integer(0),\n      names = character(0)\n    )\n    return(df_cols)\n  } else {\n    return(df_cols)\n  }\n}\n\n\n\nRecap: test data\nBelow is a summary of tips for adding data your tests.\n\n\n\n\n\n(a) Unit test fixtures\n\n\nFigureÂ 4: Unit test fixtures"
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#mezzo-iteration",
    "href": "posts/test-shiny-p1/index.html#mezzo-iteration",
    "title": "Unit testing shiny utility functions",
    "section": "Mezzo-iteration",
    "text": "Mezzo-iteration\nThe select_column_class() will return a tibble() with the columns matching the class argument, but Iâ€™ll also need an argument that allows me to adjust the returned object to a named character vector.\nThatâ€™s the job of get_column_class()â€“this is a wrapper around select_column_class() with an additional return_tbl argument that, if FALSE, returns the column names as a named vector.\n\nAbstract syntax trees\nWhile developing R functions, Iâ€™ve found the ast() function from the lobstr package can be great for keeping track of nested function calls.\nFor example, select_column_class() has a nested col_class() function that isnâ€™t tested directly. So how do I make sure Iâ€™m keeping track of these nested functions in case they throw an error? Iâ€™ll build an abstract function tree for the function in the documentation.\nBelow is the abstract syntax tree for select_column_class():\n\n\nâ–ˆâ”€select_column_class \nâ””â”€â–ˆâ”€col_class \n\n\nThe tree above is simpleâ€“it only has two functions so farâ€“but as packages grow these abstract displays become more important for tracking function calls (and tests!).\n\n\nCombining tests\nget_column_class() calls select_column_class(), so Iâ€™ll place both unit tests in the tests/testthat/test-column_classes.R file, and create the corresponding R/column_classes.R file\nTo capture these nested functions visually, Iâ€™ll include a function tree in a vignette or other source documentation.\n\n\nâ–ˆâ”€get_column_class \nâ””â”€â–ˆâ”€select_column_class \n  â””â”€â–ˆâ”€col_class \n\n\nIâ€™ve combined select_column_class() and get_column_class() into a single file because I know every pull_[type]_cols() function would use get_column_class(). The following function tree captures this relationship.\n\n\nâ–ˆâ”€get_column_class \nâ”œâ”€â–ˆâ”€select_column_class \nâ”‚ â””â”€â–ˆâ”€col_class \nâ”œâ”€â–ˆâ”€pull_binary_cols \nâ”œâ”€â–ˆâ”€pull_facet_cols \nâ”œâ”€â–ˆâ”€pull_cat_cols \nâ””â”€â–ˆâ”€pull_numeric_cols \n\n\n\n\n\n\n\n\nFunction file names\n\n\n\n\n\nIn shiny app-packages, itâ€™s common to combine related functions (i.e., function families) into a single .R file with a prefix.\nFor example, a standalone app function combines the code that would otherwise sit in ui.R and server.R.\n\nmyApp &lt;- function() {\n  shiny::shinyApp(ui = \n      shiny::tagList(\n        # code from ui.R\n      ),\n      server = # code from server.R\n    )\n}\n\nOther files that are automatically run with a standard shiny app (i.e., global.R or helpers.R files that used to load data, set themes/colors, etc.,) can be converted into functions and/or package files based on their purpose. For more information on organizing your R/ folder, read this section in R Packages.\nAlso check out golem::add_utils() and golem::add_fct() for creating function files specific to shiny modules.\n\n\n\nIn the test-column_classes.R test file, Iâ€™ll need more data for testing, but rather than create test data files for each test, Iâ€™ll use test helpers to create the test data.\n\n\nTest helpers\nTest helpers are stored in tests/testthat/helper.R and usually contain functions or code that 1) is too long to repeat with each test, and 2) doesnâ€™t take too much time or memory to run. Read more about test helpers here.\nIâ€™ve created a set of test helpers in utap for creating different kinds of test data (because Iâ€™ll be repeatedly defining columns with slightly different attributes).\nFor example, col_maker() can be used to create a tibble with columns based on the col_type, size, and missing:\n\ncol_maker(col_type = c(\"log\", \"int\", \"dbl\", \n                       \"chr\", \"fct\", \"ord\"),\n          size = 6,\n          missing = TRUE)\n## # A tibble: 6 Ã— 6\n##   log_var int_var dbl_var chr_var fct_var ord_var\n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;fct&gt;   &lt;ord&gt;  \n## 1 TRUE          1     0.1 item:1  group 1 level 1\n## 2 FALSE       135     3   item:2  group 2 level 2\n## 3 NA          269    NA   item:3  group 3 level 3\n## 4 TRUE        403     0.1 &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n## 5 FALSE        NA     3   item:1  group 1 level 1\n## 6 NA            1    NA   item:1  group 2 level 2\n\nI can also create tibbles with custom columns using individual helper _maker() functions:\n\ntibble::tibble(\n    log_var = log_maker(size = 2),\n    int_var = int_maker(size = 2),\n    dbl_var = dbl_maker(size = 2),\n    chr_var = chr_maker(size = 2),\n    list_var = list(fct_var = fct_maker(size = 3), \n                    ord_var = ord_maker(size = 3)),\n)\n## # A tibble: 2 Ã— 5\n##   log_var int_var dbl_var chr_var list_var    \n##   &lt;lgl&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;named list&gt;\n## 1 TRUE          1     0.1 item: 1 &lt;fct [3]&gt;   \n## 2 FALSE         7     1   item: 2 &lt;ord [3]&gt;\n\nThese helpers make it easier to iterate through the test expectations and function development, because tibbles like the one above can be developed inside each test.\n\nBelow is an example for testing if get_column_class() will correctly identify the logical columns (for both return objects):\n\n\nusing test helpers\ntestthat::test_that(\"get_column_class() logical\", {\n  # test logical class\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n      class = \"log\") |&gt;\n      unlist() |&gt;\n      is.logical(),\n    expected = TRUE\n  )\n  # test logical names\n  testthat::expect_equal(\n    object = get_column_class(\n      # use test helper\n      df = col_maker(\n        col_type = c(\"log\", \"int\", \"dbl\", \"chr\"),\n          size = 6,\n          missing = FALSE,\n          lvls = 4),\n     class = \"log\",\n      return_tbl = FALSE\n    ),\n    expected = c(log_var = \"log_var\")\n  )\n})\n\n\n\nWhen Iâ€™m confident with the get_column_class() function and itâ€™s tests, Iâ€™ll save the test file and run testthat::test_file().\n\n\nshow/hide get_column_class()\nget_column_class &lt;- function(df, class, return_tbl = TRUE) {\n  if (isFALSE(return_tbl)) {\n    col_types_df &lt;- select_column_class(df, class = class)\n    nms &lt;- names(col_types_df)\n    col_types &lt;- purrr::set_names(nms)\n  } else {\n    col_types &lt;- select_column_class(df, class = class)\n  }\n  return(col_types)\n}\n\n\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 23 ]\n\n\nTest coverage\nHow many tests should I write?\nAs function behavior grows in complexity, so does the number of expectations. In testthat, expectations are captured in tests, and code coverage measures the extent to which the tests in the tests/testthat/ folder cover the possible execution paths of the functions in the R/ folder (i.e.Â the package codebase).\nCode test coverage is a way to confirm that the unit tests are robust enough to verify that your code behaves as expected. In R packages, code coverage is discussed in the testing chapter using the covr package.\n\n\nCheck coverage interactively\nDuring development, check the code coverage of a test file with devtools::test_coverage_active_file(), or, if this function is being temperamental, use the combination of functions below from covr:\n\ncovr::file_coverage(\n  source_files = \"R/column_classes.R\", \n  test_files = \"tests/testthat/test-column_classes.R\") |&gt;\n  covr::report()\n\nBelow is the output in the Viewer when devtools::test_coverage_active_file() is entered in the Console:\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigureÂ 5: Unit test coverage interactively\n\n\n\nI can see from the output I donâ€™t have test coverage for the select_column_class() behavior when the class argument doesnâ€™t return any columns from df. The function is designed to return an empty tibble if this occurs:\n\n\n\n\n\n(a) Behavior not tested in select_column_class()\n\n\nFigureÂ 6: The area in red is the untested portion of select_column_class()\n\n\nTo test this behavior, Iâ€™ll write two expectations:\n\nThe first expectation (expect_s3_class()) checks the class of the return object from select_column_class():\n\n  # test class of empty tibble\n  testthat::expect_s3_class(\n    object = select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\"),\n    class = c(\"tbl_df\", \"tbl\", \"data.frame\"))\n\nThe second expectation verifies there are zero columns in this return tibble:\n\n  # test rows of empty tibble\n  testthat::expect_equal(\n    object = ncol(select_column_class(\n      df = col_maker(col_type = c(\"int\", \"dbl\"),\n                                  size = 6, \n                                  missing = FALSE),\n      class = \"log\")),\n    expected = 0L)\n\n\nAfter adding these tests to the test-column_classes.R test file, Iâ€™ll run testthat::test_file() and devtools::test_coverage_active_file() again:\n\ntestthat::test_file(\"tests/testthat/test-column_classes.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 25 ]\n\ndevtools::test_coverage_active_file()\n\n\n\n\n\n\n\n(a) Test coverage using devtools::test_coverage_active_file()\n\n\nFigureÂ 7: Complete code coverage for column_classes.R\n\n\n\n100% is great, but uncommon. Striving for a high percentage of coverage is a good practice, it doesnâ€™t guarantee that the function always behaves as expected. Unit tests might execute a line of code, but still not catch a bug due to the design of the test (itâ€™s easy to have high coverage if the unit tests are shallow and donâ€™t check for any potential edge cases).\nIâ€™ll address code coverage again in the next section, but checking coverage regularly will help ensure function behaviors donâ€™t go overlooked."
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#macro-iteration",
    "href": "posts/test-shiny-p1/index.html#macro-iteration",
    "title": "Unit testing shiny utility functions",
    "section": "Macro-iteration",
    "text": "Macro-iteration\nAfter developing the functions in utap, the files in the R/ folder are organized into names based on the â€˜main function and its supporting helpersâ€™:\nR/\nâ”œâ”€â”€ column_classes.R\nâ”œâ”€â”€ pull_binary_cols.R\nâ”œâ”€â”€ pull_cat_cols.R\nâ”œâ”€â”€ pull_facet_cols.R\nâ”œâ”€â”€ pull_numeric_cols.R\nâ””â”€â”€ utils.R\n\nTest file organization\nThe tests/testthat/ folder file names have identical names as the files in the R/ folder.\ntests/testthat/\n        â”œâ”€â”€ test-column_classes.R\n        â”œâ”€â”€ test-pull_binary_cols.R\n        â”œâ”€â”€ test-pull_cat_cols.R\n        â”œâ”€â”€ test-pull_facet_cols.R\n        â”œâ”€â”€ test-pull_numeric_cols.R\n        â””â”€â”€ test-utils.R\n\nR/utils.R\nItâ€™s common for R packages to have a general R/utils.R file that defines the â€˜utilityâ€™ functions. This practice isnâ€™t discouraged in R Packages, but these files can become a catch-all for any functions that donâ€™t have a clear home (read more here).\nIâ€™ve only stored the %nin% operator in R/utils.R, and itâ€™s test is shown below:\n\ntestthat::test_that(\"%nin% works\", {\n  testthat::expect_false(\n    object = \"A\" %nin% LETTERS)\n  testthat::expect_false(\n    object = 1 %nin% 1:10)\n  testthat::expect_true(\n    object = 1 %nin% 2:10)\n})\n\n\n\n\nTest package\nWhen Iâ€™ve completed a set of test files, I can use devtools::test() to check if theyâ€™re passing.\n\ndevtools::test()\n\nâ„¹ Testing utap\nâœ” | F W S  OK | Context\nâœ” |        25 | column_classes                                                     \nâœ” |        29 | pull_binary_cols                                                   \nâœ” |         4 | pull_cat_cols                                                      \nâœ” |        20 | pull_facet_cols                                                    \nâœ” |         5 | pull_numeric_cols                                                  \nâœ” |         3 | utils                                                              \n\nâ•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nDuration: 2.1 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 86 ]\n\nğŸ¯ Your tests hit the mark ğŸ¯\nThe output above shows all tests are passing (and some helpful words of encouragement). As you can see, the number of tests correspond to the number of functions in each test file.\nFor example, pull_binary_cols() and pull_facet_cols() required additional internal functions to define their use:\n\n\nâ–ˆâ”€pull_binary_cols \nâ”œâ”€â–ˆâ”€check_binary_vec \nâ”‚ â”œâ”€â–ˆâ”€check_log_binary \nâ”‚ â”œâ”€â–ˆâ”€check_int_binary \nâ”‚ â””â”€â–ˆâ”€check_fct_binary \nâ””â”€â–ˆâ”€make_binary_vec \n\n\nâ–ˆâ”€pull_facet_cols \nâ”œâ”€â–ˆâ”€check_facet_vec \nâ”‚ â”œâ”€â–ˆâ”€check_chr_facet \nâ”‚ â””â”€â–ˆâ”€check_fct_facet \nâ””â”€â–ˆâ”€make_facet_vec \n\n\nWheras pull_cat_cols() and pull_numeric_cols() map onto existing classes:\n\n\nâ–ˆâ”€pull_cat_cols \nâ”œâ”€â–ˆâ”€is.factor \nâ””â”€â–ˆâ”€is.character \n\n\nâ–ˆâ”€pull_numeric_cols \nâ”œâ”€â–ˆâ”€is.integer \nâ””â”€â–ˆâ”€is.double \n\n\n\n\nCheck coverage on build/install\nTo check the code coverage for the utap package, I can run devtools::test_coverage() to view the output in the Viewer.\n\ndevtools::test_coverage()\n\nâ„¹ Computing test coverage for utap\n\n\n\n\n\n\n(a) Final test coverage for utap package\n\n\nFigureÂ 8: devtools::test_coverage()\n\n\n\nClicking on any of the Files will open the Source tab and give a summary like the one above from devtools::test_coverage_active_file(). I can also use covr::package_coverage() in the Console for simpler output:\nutap Coverage: 100.00%\nR/column_classes.R: 100.00%\nR/pull_binary_cols.R: 100.00%\nR/pull_cat_cols.R: 100.00%\nR/pull_facet_cols.R: 100.00%\nR/pull_numeric_cols.R: 100.00%\nR/utils.R: 100.00%\n\nOther metrics\nSometimes itâ€™s interesting to view the relationship between function size and number of tests using the cloc package..\n\nlibrary(cloc)\n\ncloc stands for Count Lines of Code, and itâ€™s a rough metric used to gauge code complexity. Itâ€™s simple, but apparently provides â€œjust as much predictive power as more elaborate constructs like cyclomatic complexity.â€source\nBelow is a count of the lines of code in each file in the R folder:\n\ncloc::cloc_by_file(\"R\")\n\n# A tibble: 8 Ã— 6\n  source filename                language   loc blank_lines comment_lines\n  &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;    &lt;int&gt;       &lt;int&gt;         &lt;int&gt;\n1 R      \"R/pull_binary_cols.R\"  R           53           2            57\n2 R      \"R/pull_facet_cols.R\"   R           42           2            73\n3 R      \"R/column_classes.R\"    R           41           6            65\n4 R      \"R/pull_numeric_cols.R\" R           19           1            24\n5 R      \"R/pull_cat_cols.R\"     R           13           0            19\n6 R      \"R/utils.R\"             R            3           0             7\n7 R      \"R/utap-package.R\"      R            2           0             7\n8 R      \"\"                      SUM        173          11           252\nThis output also confirms the relationship between lines of code and tests."
  },
  {
    "objectID": "posts/test-shiny-p1/index.html#recap",
    "href": "posts/test-shiny-p1/index.html#recap",
    "title": "Unit testing shiny utility functions",
    "section": "Recap",
    "text": "Recap\nThis post has been an introduction to unit testing utility functions in a shiny app-package. When Iâ€™m confident the utility functions are working, Iâ€™ll start adding them into modules (and testing with testServer() or shinytest2). Files names can change a lot throughout the course of developing a shiny app-package, so itâ€™s helpful to adopt (or create) a naming convention.\nIf youâ€™re using the golem framework to develop your shiny app-package, the utils_ and fct_ prefixes are used to define two different types of utility/helper functions:\n\nutils_ files contain â€˜small helper functions andâ€™top-level functions defining your user interface and your server functionâ€™\nfct_ files contain â€˜the business logic, which are potentially large functionsâ€¦the backbone of the application and may not be specific to a given moduleâ€™.\n\nThis particular file naming convention isnâ€™t required, but as with most conventions, itâ€™s better when someone else comes up with the standard (and I just have to adopt and implement it). And having and sticking to a naming convention is typically more important than the convention itself."
  },
  {
    "objectID": "posts/debugging/index.html",
    "href": "posts/debugging/index.html",
    "title": "Debugging in RStudio",
    "section": "",
    "text": "In this post Iâ€™ll cover using the browser() function with RStudioâ€™s debugger. RStudioâ€™s debugging tools are built into the IDE, which provides a seamless transition between writing, running, and debugging code."
  },
  {
    "objectID": "posts/debugging/index.html#getting-started",
    "href": "posts/debugging/index.html#getting-started",
    "title": "Debugging in RStudio",
    "section": "Getting started",
    "text": "Getting started\nI want to create a function that returns a table of â€˜data structureâ€™ columns that describe the available data.frame or tibble objects loaded with a package. Below is a small example of the desired return object from this function:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nDataset\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\ndplyr\nstarwars\ntbl_df, tbl, data.frame\n13\n19066\n0\n11\n1\n1\n0\n\n\ndatasets\nmtcars\ndata.frame\n11\n32\n0\n11\n0\n0\n0\n\n\n\n\n\n\nThis table shows the storms data from dplyr and the mtcars data from datasets. The columns include the Package the data came from, the dataset name (Dataset), the data Title from the documentation, the Class of the data object, the total number of Columns and Rows, and the number of columns by type (Logical, Numeric, Character, Factor and List).\nOne of the first steps for creating this function is to verify a packageâ€™s namespace is loaded. Iâ€™ve written the check_pkg_ns() to check this.\n\n\ncheck_pkg_ns()\ncheck_pkg_ns &lt;- function(pkg, quiet = FALSE) {\n  if (isFALSE(quiet)) {\n    # with messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = FALSE)) {\n        cat(paste0(\"Loading package: \", pkg, \"\\n\"))\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    } else {\n      cat(paste0(\"Package \", pkg, \" loaded\\n\"))\n    }\n  } else {\n    # without messages\n    if (!isNamespaceLoaded(pkg)) {\n      if (requireNamespace(pkg, quietly = TRUE)) {\n      } else {\n        stop(paste0(pkg, \" not available\"))\n      }\n    }\n  }\n}\n\n\ncheck_pkg_ns() checks if a packagesâ€™s namespace is loaded, and if not, loads it. This function assumes the package (pkg) has been installed with install.packages() (Iâ€™ve also written check_pkg_inst() to check if the package has been installed.)\n\nExperiment\nBefore debugging, Iâ€™ll read the documentation and help files to find examples or use cases for â€˜mini-experiments.â€™ These are designed to clarify any function arguments and learn how the code truly works. Experiments should produce predictable, definitive (preferably incompatible) outputs from each function.\n\nNamespace functions\nThe help file contains the following helpful statement on isNamespaceLoaded():\n\nâ€œisNamespaceLoaded(pkg) is equivalent to but more efficient than pkg %in% loadedNamespaces()â€\n\nFirst, Iâ€™ll check the loaded namespaces with loadedNamespaces(), then look for a package I know isnâ€™t in the namespace with isNamespaceLoaded(). Iâ€™ll use the fs package because it isnâ€™t loaded or attached to the search() list:\n\n# what's in the namespace? \nloadedNamespaces()\n\n [1] \"compiler\"   \"rsconnect\"  \"graphics\"  \n [4] \"tools\"      \"rstudioapi\" \"utils\"     \n [7] \"grDevices\"  \"stats\"      \"datasets\"  \n[10] \"methods\"    \"base\"\nCheck if fs is in the loaded namespace:\n\n# verify fs is not loaded\nisNamespaceLoaded(\"fs\")\n\n[1] FALSE\nThe help file tells me the following about requireNamespace:\n\nâ€œrequireNamespace is a wrapper for loadNamespace analogous to require() that returns a logical value.â€\n\nâ€¦andâ€¦\n\nâ€œrequireNamespace returns TRUE if it succeeds or FALSEâ€\n\nIâ€™ll load a package (\"fs\") with requireNamespace() and verify itâ€™s in the namespace with isNamespaceLoaded().\n\n# add \"fs\" to the namespace\nrequireNamespace(\"fs\")\n\nLoading required namespace: fs\n[1] TRUE\n\n# verify it's been added \nisNamespaceLoaded(\"fs\")\n\n[1] TRUE\nFinally, Iâ€™ll unload the \"fs\" package from the namespace so it can be tested in the debugger.\n\n# remove fs\nunloadNamespace(\"fs\")\n# verify fs has been unloaded\nisNamespaceLoaded(\"fs\")\n\n[1] FALSE\nThe great thing about designing these mini experiments is that they can be quickly converted into testthat tests. Iâ€™m now confident I can use the namespace functions to:\n\nView loaded packages namespaces\n\nCheck for a specific package in the loaded namespaces\n\nRequire a package namespace is loaded\n\nRemove a loaded package namespace\n\nThese are the behaviors I want to confirm in check_pkg_ns() using the browser() function."
  },
  {
    "objectID": "posts/debugging/index.html#browser",
    "href": "posts/debugging/index.html#browser",
    "title": "Debugging in RStudio",
    "section": "browser()",
    "text": "browser()\nIf I want to explore the behaviors of the namespace functions in check_pkg_ns(), I need to add browser() somewhere I can â€˜step intoâ€™ this function and then proceed through line-by-line. In this case, the top of the function makes sense:\n\n\n\n\n\n(a) browser() in check_pkg_ns()\n\n\nFigureÂ 1: browser() placement in check_pkg_ns()\n\n\n\nDebug mode\nTo enter debugging mode, Iâ€™ll need to run check_pkg_ns() or source R/check_pkg_ns.R with the package I used in my experiments.\n\ncheck_pkg_ns(\"fs\")\n\n\n\n\n\n\n\n(a) Debug mode\n\n\nFigureÂ 2: RStudio IDE in debug mode\n\n\n\nThe browser() function is one of the multiple methods for using RStudio debugging tools (see the TIP callout box below for more).\n\n\n\n\n\n\nTIP: Other debugging methods\n\n\n\n\n\n\nIn this post, I focused on using the browser() function to enter debug mode, but RStudio has several built-in tools that can help you debug your R code:\n\nDebug function on error: You can set R to automatically enter the debugger when an error occurs by using options(error = utils::recover). Then, when an error occurs, youâ€™ll be given a menu of places to browse, the most recent (the location where the error occurred) first.\nBreakpoints: Breakpoints can be set in your R scripts to pause execution at a particular line of code. You can add breakpoints by clicking to the left of the line number in the script editor or by pressing Shift+F9 with your cursor on the desired line. Then, run your code. Execution will stop just before the line with the breakpoint, allowing you to inspect the current state of the environment.\ndebug(): You can use debug(function_name) to flag a function for â€œdebugâ€ mode. When you call the function, the debugger will open and stop at the first line of the function, where you can step through the function line by line, inspect the environment, and see whatâ€™s happening at each step.\ntraceback(): When an error occurs, you can call traceback() to get a stack trace that shows you the sequence of calls that led up to the error.\nCode Diagnostics: RStudio provides real-time notifications about potential issues in your code, like syntax errors or unused variables. These are not technically part of the debugger, but diagnostics will help you avoid bugs before you run your code.\n\nYou should read this blog post and this chapter of Advanced R, 2nd Ed. for more information on the various debugging methods.\n\n\n\n\n\n\nConsole\nWhen the browser() function is called, the Console enters the â€˜reactive browser environment,â€™ tells me where the debugging function was called from, and changes the prompt to Browse[1]&gt;:\nCalled from: check_pkg_ns(\"fs\")\nBrowse[1]&gt; \nI can use the Console to inspect variables and â€˜step throughâ€™ the function code.\n\n\n\n\n\n\n(a) Debug mode in Console\n\n\nFigureÂ 3: Debug mode with browser() in Console\n\n\n\nThe debugger toolbar is also placed at the top of the Console:\n\n\n\n\n\n(a) Debug toolbar Console\n\n\nFigureÂ 4: Debug toolbar in Console\n\n\nI can use the toolbar or enter the following commands in the Console:\n\nn (next): execute the next step in the function\ns (step into): step into the function call on the current line\nc (continue): continue normal execution without stepping\nf (finish): execute the rest of the current loop or function\nQ (Quit): quit the debugger\n\nIâ€™ll return to the Console in a bit (this is where most of the debugging is done), but letâ€™s view the other changes to the IDE first.\n\n\nSource\nIn the Source pane, we can see the line with browser() has been highlighted with an arrow:\n\n\n\n\n\n\n(a) Debug mode in Source\n\n\nFigureÂ 5: Debug mode with browser() in Source\n\n\n\nThe Source pane will continually update and highlight my execution position (i.e., whatâ€™s going to be executed next) as I â€˜step throughâ€™ the code.\n*After weâ€™ve finished debugging, itâ€™s important to remember to remove the browser() function so it isnâ€™t triggered the next time it is executed.\n\n\nEnvironment\nThe (Environment) pane is changed from the global environment to the environment of the function thatâ€™s currently being executed in the Console:\n\n\n\n\n\n\n(a) Debug mode in Environment\n\n\nFigureÂ 6: Debug mode with browser() in Environment\n\n\n\nIn the case of check_pkg_ns(), I can see the Values section contains the pkg (\"fs\") and quiet (FALSE) arguments.\n\nOther environments\nThe drop-down list of environments above the Values is arranged in reverse hierarchical order: The Global Environment is listed under the drop-down list, but itâ€™s above the check_pkg_ns() environment in the search path:\n\n\n\n\n\n\n\n\n(a) Items in Environment debug mode\n\n\n\n\n\n\n\n(b) Package environments and the search path\n\n\n\n\nFigureÂ 7: Environments with debugger\n\n\n\n\n\nTraceback\nThe traceback (or â€˜call stackâ€™) is the â€˜stackâ€™ of functions that have been run thus far:\n\n\n\n\n\n(a) Traceback in Environment\n\n\nFigureÂ 8: Environment Traceback viewer\n\n\nClicking on an item in traceback will display the environment contents in the functionâ€™s code. Right now, it includes the call to source(\"R/check_pkg_ns.R\"), and â€˜Debug sourceâ€™ call to check_pkg_ns(\"fs\").\nIf the Show internals option is selected, the internal functions are shown (slightly subdued in gray).\n\n\n\n\n\n(a) Traceback internals\n\n\nFigureÂ 9: Traceback internals\n\n\n\n\n\nArguments\nThe pkg argument can be printed to verify itâ€™s contents.\nBrowse[1]&gt; pkg\n[1] \"fs\"\nThe debugger lets me view the state of a functionâ€™s values or variables at each execution step, which helps me understand any incorrect or unexpected values.\nBased on the help files and my experiments, check_pkg_ns() should be looking through the namespace to see if a pkg is loaded; if it isnâ€™t, that pkg is loaded in the namespace.\nI can also check the code from the mini experiments inside the debugger Console to see if the fs namespace has been loaded:\nBrowse[1]&gt; isNamespaceLoaded(\"fs\")\n[1] FALSE\nAt my current location in check_pkg_ns(), the fs package hasnâ€™t been loaded.\n\n\nStepping through\nI can begin â€˜stepping throughâ€™ check_pkg_ns() by entering n in the Console:\nBrowse[1]&gt; n\nNotice after the entering n in the Console, the debugger tells me where the browser() function has paused execution (debug at /path/to/function/file.R), the line number (#27), and the check_pkg_ns() function is printed to console (Iâ€™ve omitted it here):\nBrowse[1]&gt; n\ndebug at ~/projects/apps/dbap/R/check_pkg_ns.R#27:\n\n&lt;...check_pkg_ns() function...&gt;\n\nBrowse[2]&gt;\nThe prompt also changes from Browse[1]&gt; to Browse[2]&gt; to let me know Iâ€™m inside the check_pkg_ns() function.\nIâ€™ll use n (or Next) to continue following the path pkg takes through the function:\n\n\n\n\n\n\n(a) Use Console to step through function\n\n\nFigureÂ 10: Use n to step through check_pkg_ns()\n\n\n\nWhen I land on the line after the call to requireNamespace(), I can check to see if the fs namespace has been loaded with isNamespaceLoaded(\"fs\")\nBrowse[2]&gt; isNamespaceLoaded(\"fs\")\n[1] TRUE\n\n\nInspect values\nNow that Iâ€™ve confirmed check_pkg_ns() works with fs, I should also confirm it works with a development package (i.e., not on CRAN). I can test this with the roxygen2Comment packageâ€“it contains an addin for pasting roxygen2 comment blocks.\nTo quit debug mode, I can enter Q in the Console or click on the red square (Stop) icon in the toolbar.\nBrowse[2]&gt; Q\nIâ€™ll confirm roxygen2Comment is not loaded with isNamespaceLoaded(), then change the pkg argument in check_pkg_ns() and re-run the function\nisNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\n&gt; check_pkg_ns(\"roxygen2Comment\")\nCalled from: check_pkg_ns(\"roxygen2Comment\")\nBrowse[1]&gt; \nThis time, when I step through check_pkg_ns(), I notice pkg takes an alternative path:\n\n\n\n\n\n\n(a) Alternative path through function\n\n\nFigureÂ 11: Development package in check_pkg_ns()\n\n\n\nWhen the Source pane highlights the stop() function, I can check to confirm this package wasnâ€™t loaded:\nBrowse[2]&gt; isNamespaceLoaded(\"roxygen2Comment\")\n[1] FALSE\nIf I enter n one more time in the Console, I see the stop() error from the function is returned:\nBrowse[2]&gt; n\nError in check_pkg_ns(\"roxygen2Comment\") : \n  roxygen2Comment not available\nIâ€™ll perform one last check on check_pkg_ns(): what if I want to pass multiple packages to pkg? Iâ€™ll check this with fs and box.\n\n# First make sure these aren't loaded...\nunloadNamespace(\"fs\")\nunloadNamespace(\"box\")\n# Now combine into vector\npkgs &lt;- c(\"fs\", \"box\")\ncheck_pkg_ns(pkgs)\n\nAfter entering debug mode, I want to proceed to the control flow and verify the pkgs variable:\n&gt; check_pkg_ns(pkgs)\nCalled from: check_pkg_ns(pkgs)\nBrowse[1]&gt; n\nBrowse[2]&gt; pkgs\n[1] \"fs\"  \"box\"\nThis confirms both packages are in the pkg variable. If I use n to proceed through to end of check_pkg_ns(), I see the final line returns the successful loading message twice:\nBrowse[2]&gt; n\nLoading package: fs\nLoading package: box\n\n\nbrowser() recap\nOnce execution is paused with browser(), using the n command in the Console (or in the debugging toolbar at the top-right of the pane) lets me step through the code line-by-line.\n\n\n\n\n\n(a) Step through/over\n\n\nFigureÂ 12: Step through/over code\n\n\nThis allows me to inspect the state of the variables at various points within a function."
  },
  {
    "objectID": "posts/debugging/index.html#nested-functions",
    "href": "posts/debugging/index.html#nested-functions",
    "title": "Debugging in RStudio",
    "section": "Nested functions",
    "text": "Nested functions\nThe check_pkg_ns() function is fairly basic in that it performs a single â€˜unit of workâ€™ (i.e., check if add-on packages package have been loaded and attached; if not, load and attach them). When functions become more complex, itâ€™s more efficient to use nested functionsâ€“i.e., functions within other functionsâ€“which allow me to execute multiple commands simultaneously.\nAn example of this is the pkg_data_results() function below:\n\n\npkg_data_results()\npkg_data_results(\"dplyr\")\n## # A tibble: 5 Ã— 3\n##   Package Item              Title              \n##   &lt;chr&gt;   &lt;chr&gt;             &lt;chr&gt;              \n## 1 dplyr   band_instruments  Band membership    \n## 2 dplyr   band_instruments2 Band membership    \n## 3 dplyr   band_members      Band membership    \n## 4 dplyr   starwars          Starwars characters\n## 5 dplyr   storms            Storm tracks data\n\n\npkg_data_results() returns a data.frame with three columns: Package, Item, and Title.\nThe output from pkg_data_results() comes from the data(package = \"pkg\") output:\n\n\n\n\n\n(a) Output from data(package = )\n\n\nFigureÂ 13: data(package = \"dplyr\")\n\n\nThis output is normally opened in a separate window, but itâ€™s created as a matrix.\n\n\nstructure of data(package =)\nstr(data(package = \"dplyr\"))\n## List of 4\n##  $ title  : chr \"Data sets\"\n##  $ header : NULL\n##  $ results: chr [1:5, 1:4] \"dplyr\" \"dplyr\" \"dplyr\" \"dplyr\" ...\n##   ..- attr(*, \"dimnames\")=List of 2\n##   .. ..$ : NULL\n##   .. ..$ : chr [1:4] \"Package\" \"LibPath\" \"Item\" \"Title\"\n##  $ footer : NULL\n##  - attr(*, \"class\")= chr \"packageIQR\"\n\n\npkg_data_results() converts the matrix output into a data.frame three columns in (Package, Title, Item).\nIâ€™ve placed browser() at the top of pkg_data_results() and run it with the fivethirtyeight package.\npkg_data_results(\"fivethirtyeight\")\n\n\n\n\n\n(a) browser() in pkg_data_results(â€œfivethirtyeightâ€)\n\n\nFigureÂ 14: browser() in pkg_data_results(\"fivethirtyeight\")\n\n\n\nStep into\nWhen the debugger lands on check_pkg_ns(), I can follow the fivethirtyeight package through this function by â€˜stepping intoâ€™ this function by entering s in the Console (or the toolbar icon):\n\n\n\n\n\nStep into a function\n\n\n\n\n\n\n\n(a) browser() in pkg_data_results(â€œfivethirtyeightâ€)\n\n\nFigureÂ 15: Step into in pkg_data_results(\"fivethirtyeight\")\n\n\n\n\nDebugging â€˜atâ€™ vs â€˜inâ€™\nIn the Console, there are now debugging in and debug at locations:\nBrowse[2]&gt; s\ndebugging in: check_pkg_ns(pkg = pkg, quiet = TRUE)\ndebug at /apps/dbap/R/check_pkg_ns.R#25: \nThe debug at location is the the we location of the initial call to browser(), and debugging in is the function I stepped into.\nThe prompt has also changed from Browse[2]&gt; to Browse[3]&gt;:\nBrowse[3]&gt;\n\n\n\n\n\n\n(a) Use s to step into check_pkg_ns()\n\n\nFigureÂ 16: Use s to step through check_pkg_ns()\n\n\n\nThe R/check_pkg_ns.R file will open with the highlighted function. I can proceed through check_pkg_ns() using n until I reach requireNamespace():\n\n\n\n\n\n\n(a) Use n to step through check_pkg_ns()\n\n\nFigureÂ 17: Use n to step through check_pkg_ns()\n\n\n\nWhen I reach the final line in check_pkg_ns(), I can use either method below verify the pkg namespace is loaded:\nBrowse[3]&gt; pkg %in% loadedNamespaces()\n[1] TRUE\nBrowse[3]&gt; isNamespaceLoaded(pkg)\n[1] TRUE\nAfter the last line of check_pkg_ns() has been evaluated, the debugger will automatically return to the pkg_data_results() function. The Source pane will highlight the final step (and the prompt returns to Browse[2]&gt;):\n\n\n\n\n\n\n(a) Step into/through check_pkg_ns() from pkg_data_results()\n\n\nFigureÂ 18: Step into and through check_pkg_ns() from pkg_data_results()\n\n\n\nA final n command in the Console will return the output table:\nBrowse[2]&gt; n\n### A tibble: 129 Ã— 3\n##    Package         Item                Title\n##    &lt;chr&gt;           &lt;chr&gt;               &lt;chr&gt;\n##  1 fivethirtyeight US_births_1994_2003 Some People Are Too Superstitious To â€¦\n##  2 fivethirtyeight US_births_2000_2014 Some People Are Too Superstitious To â€¦\n##  3 fivethirtyeight ahca_polls          American Health Care Act Polls\n##  4 fivethirtyeight airline_safety      Should Travelers Avoid Flying Airlineâ€¦\n##  5 fivethirtyeight antiquities_act     Trump Might Be The First President Toâ€¦\n##  6 fivethirtyeight august_senate_polls How Much Trouble Is Ted Cruz Really  â€¦\n##  7 fivethirtyeight avengers            Joining The Avengers Is As Deadly As\n##  8 fivethirtyeight bachelorette        Bachelorette / Bachelor\n##  9 fivethirtyeight bad_drivers         Dear Mona, Which State Has The Worst â€¦\n## 10 fivethirtyeight bechdel             The Dollar-And-Cents Case Against Holâ€¦\n## # â„¹ 119 more rows\n## # â„¹ Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/debugging/index.html#put-it-all-together",
    "href": "posts/debugging/index.html#put-it-all-together",
    "title": "Debugging in RStudio",
    "section": "Put it all together",
    "text": "Put it all together\nThe initial pkg_data_str() function for returning a table of â€˜package data structuresâ€™ is below.\n\n\nexpand to see initial pkg_data_str()\npkg_data_str &lt;- function(pkg) {\n\n  data_results &lt;- pkg_data_results(pkg = pkg)\n\n  ds_list &lt;- purrr::map2(\n    .x = data_results[[\"Item\"]], \n    .y = data_results[[\"Package\"]],\n    .f = pkg_data_object, .progress = TRUE\n  )\n\n  cols_tbl &lt;- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |&gt;\n      purrr::map(paste0, collapse = \", \") |&gt; unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |&gt;\n      purrr::map(paste0, \" columns\") |&gt; unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |&gt;\n      purrr::map(paste0, \" rows\") |&gt; unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |&gt; unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |&gt; unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |&gt; unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |&gt; unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |&gt; unlist(),\n  )\n\n  pkg_tbls_dfs &lt;- dplyr::filter(cols_tbl,\n    stringr::str_detect(Class, \"data.frame\")\n  )\n\n  return(pkg_tbls_dfs)\n}\n\n\npkg_data_str() uses nested functions to create the following intermediate objects I can check while developing with browser() (the example below uses the forcats package)\n\nData results\nThe output from pkg_data_results() is stored in data_results:\n\ndata_results &lt;- pkg_data_results(pkg = pkg)\n\nBrowse[2]&gt; data_results\n# A tibble: 1 Ã— 3\n  Package Item    Title                                                           \n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                                                           \n1 forcats gss_cat A sample of categorical variables from the General Social su...\n\n\nPackage data objects\nAfter extracting the Package, Title, and Type columns from pkg_data_results(), I use purrr:map2() to iterate over each Item and Package, which builds a list of datasets (ds_list). The .f argument is a nested pkg_data_object() function, which calls base::get().\n\nds_list &lt;- purrr::map2(\n  .x = data_results[[\"Item\"]],\n  .y = data_results[[\"Package\"]],\n  .f = pkg_data_object, .progress = TRUE\n)\n\nIâ€™ll view the contents of the list with str()\nBrowse[2]&gt; str(ds_list)\nList of 1\n $ : tibble [21,483 Ã— 9] (S3: tbl_df/tbl/data.frame)\n  ..$ year   : int [1:21483] 2000 2000 2000 2000 2000 2000 2000 2000 ...\n  ..$ marital: Factor w/ 6 levels \"No answer\",\"Never married\",..: 2 4 ...\n  ..$ age    : int [1:21483] 26 48 67 39 25 25 36 44 44 47 ...\n  ..$ race   : Factor w/ 4 levels \"Other\",\"Black\",..: 3 3 3 3 3 3 3 3 3 3 ...\n  ..$ rincome: Factor w/ 16 levels \"No answer\",\"Don't know\",..: 8 8 16 16 ...\n  ..$ partyid: Factor w/ 10 levels \"No answer\",\"Don't know\",..: 6 5 7 6  ...\n  ..$ relig  : Factor w/ 16 levels \"No answer\",\"Don't know\",..: 15 15 15 ...\n  ..$ denom  : Factor w/ 30 levels \"No answer\",\"Don't know\",..: 25 23 3 ...\n  ..$ tvhours: int [1:21483] 12 NA 2 4 1 NA 3 NA 0 3 ...\n\n\nColumn counts\nThe ds_list created above is used to add the Class, Columns, and Rows columns to data_results using the class(), ncol(), nrow(). The column counts are added with the col_type_count() function.\n\n  cols_tbl &lt;- dplyr::mutate(data_results,\n    Class = purrr::map(.x = ds_list, .f = class) |&gt;\n      purrr::map(paste0, collapse = \", \") |&gt; unlist(),\n    Columns = purrr::map(.x = ds_list, .f = ncol) |&gt;\n      purrr::map(paste0, \" columns\") |&gt; unlist(),\n    Rows = purrr::map(.x = ds_list, .f = nrow) |&gt;\n      purrr::map(paste0, \" rows\") |&gt; unlist(),\n    Logical = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"log\"\n    ) |&gt; unlist(),\n    Numeric = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"num\"\n    ) |&gt; unlist(),\n    Character = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"chr\"\n    ) |&gt; unlist(),\n    Factor = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"fct\"\n    ) |&gt; unlist(),\n    List = purrr::map(\n      .x = ds_list,\n      .f = col_type_count, \"lst\"\n    ) |&gt; unlist(),\n  )\n\nBrowse[2]&gt; cols_tbl\n# A tibble: 1 Ã— 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n1 forcats gss_cat A sample of câ€¦ tbl_â€¦ 9 coluâ€¦ 2148â€¦       0       3         0      6     0\n\n\nRectangular objects\nFinally, cols_tbl is filtered to only those objects with a class() containing the string â€˜data.frameâ€™.\n\npkg_tbls_dfs &lt;- dplyr::filter(.data = cols_tbl,\n                  stringr::str_detect(Class, \"data.frame\"))\n\nThis is exactly the same as the previous tibble because forcats has only one data object (gss_cat), and itâ€™s a tibble:\nBrowse[2]&gt; pkg_tbls_dfs\n# A tibble: 1 Ã— 11\n  Package Item    Title          Class Columns Rows  Logical Numeric Character Factor  List\n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;   &lt;int&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n1 forcats gss_cat A sample of câ€¦ tbl_â€¦ 9 coluâ€¦ 2148â€¦       0       3         0      6     0\nIâ€™m explicitly returning pkg_tbls_dfs to view it in the debugger. When Iâ€™m confident itâ€™s behaving as expected, Iâ€™ll remove this final object and â€˜rely on R to return the result of the last evaluated expression.â€™\n\n\nError!\nWhen I tried using the initial pkg_data_str() with a package that had zero data objects (fs), I get the following error:\n\npkg_data_str(\"fs\")\n\nError in `dplyr::filter()` at dbap/R/pkg_data_str.R:78:2:\nâ„¹ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\nIn the debugger, I was able to pinpoint the source of this error (and the underlying condition causing it to occur).\n\nReplicate the error\nThe browser() beings at the top of pkg_data_str(), where Iâ€™ll step into pkg_data_results()\n\n\n\n\n\n\n(a) pkg_data_results() from pkg_data_str()\n\n\nFigureÂ 19: Step into pkg_data_results() from pkg_data_str()\n\n\n\nWhen Iâ€™m inside pkg_data_results(), Iâ€™ll use n to verify the fs package namespace was loaded and the tibble was created:\n\n\n\n\n\n\n(a) Step through pkg_data_results()\n\n\nFigureÂ 20: Step through pkg_data_results() (from pkg_data_str())\n\n\n\nBack in pkg_data_str(), the output from pkg_data_results() is stored as data_results. I can check the contents of data_results in the Console.\nBrowse[2]&gt; data_results\n# A tibble: 0 Ã— 3\n# â„¹ 3 variables: Package &lt;chr&gt;, Item &lt;chr&gt;, Title &lt;chr&gt;\nI see itâ€™s empty. An empty data_results results in an empty list output from purrr::map2():\n\n\n\n\n\n\n(a) Step out of pkg_data_results()\n\n\nFigureÂ 21: Step out of pkg_data_results() back into pkg_data_str()\n\n\n\nBrowse[2]&gt; ds_list\nlist()\nThe empty ds_list results in dplyr::mutate() being unable to create the Class column in cols_tbl:\n\n\n\n\n\n\n(a) dplyr::mutate() call in get_ds_strs()\n\n\nFigureÂ 22: Create Class column in get_ds_strs()\n\n\n\nBrowse[2]&gt; cols_tbl\n# A tibble: 0 Ã— 3\n# â„¹ 3 variables: Package &lt;chr&gt;, Item &lt;chr&gt;, Title &lt;chr&gt;\nWhich triggers the error in dplyr::filter()\nBrowse[2]&gt; n\nError in `dplyr::filter()` at dbap/R/get_ds_str.R:60:2:\nâ„¹ In argument: `stringr::str_detect(Class, \"data.frame\")`.\nCaused by error in `vctrs::vec_size_common()`:\n! object 'Class' not found\nRun `rlang::last_trace()` to see where the error occurred.\nThe full path for the fs package through the initial get_ds_str() is outlined in the figure below:\n\n\n\n\n\n\n(a) Error path in get_ds_strs()\n\n\nFigureÂ 23: Replicate the error from get_ds_strs()\n\n\n\n\n\n\nSolution\nTo fix this error, I had to make some changes to both pkg_data_results() and pkg_data_str():\nIn pkg_data_results(), I added control flow to return a tibble of logical columns (all NA) if the package doesnâ€™t have any data objects:\n\n\nExpand to view the updated pkg_data_results()\npkg_data_results &lt;- function(pkg) {\n  # load packages\n  check_pkg_ns(pkg = pkg, quiet = TRUE)\n\n  results &lt;- tibble::as_tibble(\n    data.frame(\n      Package = data(package = pkg)$results[, \"Package\"],\n      Item = data(package = pkg)$results[, \"Item\"],\n      Title = data(package = pkg)$results[, \"Title\"],\n      stringsAsFactors = FALSE,\n      check.names = FALSE,\n      row.names = NULL\n    )\n  )\n\n  if (nrow(results) == 0) {\n\n  data_results &lt;- tibble::as_tibble(\n    data.frame(\n        matrix(\n            nrow = 1, ncol = 11,\n            byrow = TRUE,\n            dimnames = list(NULL,\n              c(\"Package\", \"Item\", \"Title\",\n                \"Class\", \"Columns\", \"Rows\",\n                \"Logical\", \"Numeric\", \n                \"Character\", \"Factor\", \n                \"List\"))\n                ),\n        row.names = NULL))\n\n    return(data_results)\n\n\n  } else {\n\n    results\n\n  }\n\n}\n\n\nIn pkg_data_str(), I added two if statements:\n\nthe first if statement identifies the logical NA columns (indicating the results from data(package = pkg) didnâ€™t have any data objects)\nthe second if statement creates the Class column first, then filters the rows to only those containing a data.frame string pattern. If none of the data objects have the data.frame string pattern in their class, an empty data_results table is returned\n\n\n\nExpand to view the updated pkg_data_str()\npkg_data_str &lt;- function(pkg) {\n  \n  data_results &lt;- pkg_data_results(pkg = pkg)\n  \n  if (!is.logical(data_results[[\"Item\"]])) {\n    # data_results contains data objects\n    ds_list &lt;- purrr::map2(\n      .x = data_results[[\"Item\"]], \n      .y = data_results[[\"Package\"]],\n      .f = pkg_data_object, .progress = TRUE\n    )\n\n    class_tbl &lt;- dplyr::mutate(data_results,\n      Class = purrr::map(.x = ds_list, .f = class) |&gt;\n        purrr::map(paste0, collapse = \", \") |&gt; unlist()\n    )\n\n    df_tbl &lt;- dplyr::filter(\n      class_tbl,\n      stringr::str_detect(Class, \"data.frame\")\n    )\n\n    if (nrow(df_tbl) == 0) {\n      # df_tbl does not contain 'data.frame' classes\n      data_results &lt;- tibble::as_tibble(\n        data.frame(\n          matrix(\n            nrow = 1, ncol = 11,\n            byrow = TRUE,\n            dimnames = list(\n              NULL,\n              c(\n                \"Package\", \"Item\", \"Title\",\n                \"Class\", \"Columns\", \"Rows\",\n                \"Logical\", \"Numeric\", \"Character\",\n                \"Factor\", \"List\"\n              )\n            )\n          ),\n          row.names = NULL\n        )\n      )\n\n      return(data_results)\n      \n    } else {\n      \n      # df_tbl contains 'data.frame' classes\n      dplyr::mutate(df_tbl,\n        Columns = purrr::map(.x = ds_list, .f = ncol) |&gt;\n          purrr::map(paste0, \" columns\") |&gt; unlist(),\n        Rows = purrr::map(.x = ds_list, .f = nrow) |&gt;\n          purrr::map(paste0, \" rows\") |&gt; unlist(),\n        Logical = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"log\") |&gt; unlist(),\n        Numeric = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"num\") |&gt; unlist(),\n        Character = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"chr\") |&gt; unlist(),\n        Factor = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"fct\") |&gt; unlist(),\n        List = purrr::map(\n          .x = ds_list,\n          .f = col_type_count, \"lst\") |&gt; unlist())\n      \n    }\n    \n  } else {\n    \n    # data_results does not contains data objects\n    return(data_results)\n    \n  }\n  \n}\n\n\nRather than go through the debugger process again, Iâ€™ll go through each of the the mini experiments I used to check the updated pkg_data_results() and pkg_data_str() functions:\n\nCheck single package without any data objects (box)\n\nknitr::kable(\n  pkg_data_str(\"box\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nCheck single package with data objects, but none with classes that contain data.frame (stringr)\n\nknitr::kable(\npkg_data_str(\"stringr\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nCheck single package with multiple data objects (dplyr)\n\nknitr::kable(\npkg_data_str(\"dplyr\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\ndplyr\nband_instruments\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_instruments2\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_members\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nstarwars\nStarwars characters\ntbl_df, tbl, data.frame\n14 columns\n87 rows\n0\n3\n8\n0\n3\n\n\ndplyr\nstorms\nStorm tracks data\ntbl_df, tbl, data.frame\n13 columns\n19066 rows\n0\n11\n1\n1\n0\n\n\n\n\n\nCheck multiple packages with multiple data objects (dplyr, forcats and lubridate)\n\nknitr::kable(\npkg_data_str(c(\"dplyr\", \"forcats\", \"lubridate\")))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\nItem\nTitle\nClass\nColumns\nRows\nLogical\nNumeric\nCharacter\nFactor\nList\n\n\n\n\nforcats\ngss_cat\nA sample of categorical variables from the General Social survey\ntbl_df, tbl, data.frame\n9 columns\n21483 rows\n0\n3\n0\n6\n0\n\n\nlubridate\nlakers\nLakers 2008-2009 basketball data set\ndata.frame\n13 columns\n34624 rows\n0\n5\n8\n0\n0\n\n\ndplyr\nband_instruments\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_instruments2\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nband_members\nBand membership\ntbl_df, tbl, data.frame\n2 columns\n3 rows\n0\n0\n2\n0\n0\n\n\ndplyr\nstarwars\nStarwars characters\ntbl_df, tbl, data.frame\n14 columns\n87 rows\n0\n3\n8\n0\n3\n\n\ndplyr\nstorms\nStorm tracks data\ntbl_df, tbl, data.frame\n13 columns\n19066 rows\n0\n11\n1\n1\n0"
  },
  {
    "objectID": "posts/debugging/index.html#recap",
    "href": "posts/debugging/index.html#recap",
    "title": "Debugging in RStudio",
    "section": "Recap",
    "text": "Recap\nRStudioâ€™s debugger is a powerful tool that can save tons of time when youâ€™re developing new functions, discovering how a functionâ€™s code is executed, or dealing with errors. When youâ€™ve finished debugging, remember to remove the browser() call from your function.\nThe steps above should help get you started, and if youâ€™d like to learn more, check out the debugging chapter of Advanced R, and the documentation for browser(), debug()/debugonce()/undebug(), and traceback() functions."
  },
  {
    "objectID": "posts/purrr1.0/index.html",
    "href": "posts/purrr1.0/index.html",
    "title": "purrr updates (v1.0.0)",
    "section": "",
    "text": "show/hide\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(sloop)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(waldo)\nThis post is going to cover the recent updates to the purrr package. The release of version 1.0.0 (and dev version v1.0.1) had some breaking changes, which I will cover below. But first, Iâ€™ll dive into some attributes of Râ€™s functions and objects that make purrr particularly useful, and Iâ€™ll work through iteration problems Iâ€™ve encountered (and solved with purrr)."
  },
  {
    "objectID": "posts/purrr1.0/index.html#generic-functions-s3-objects",
    "href": "posts/purrr1.0/index.html#generic-functions-s3-objects",
    "title": "purrr updates (v1.0.0)",
    "section": "Generic functions & S3 objects",
    "text": "Generic functions & S3 objects\nRâ€™s syntax avoids explicit iteration by allowing certain generic functions to be used across different types (or objects). For example, the base plot() and summary() functions are S3 generic function:\n\n\n\nshow/hide\nsloop::ftype(plot)\n## [1] \"S3\"      \"generic\"\nsloop::ftype(summary)\n## [1] \"S3\"      \"generic\"\n\n\n\nWhich means plot() can be applied to S3 objects, like time-series (ts) and rectangular datasets (data.frame):\n\n\n\nshow/hide\nsloop::otype(datasets::LakeHuron)\n## [1] \"S3\"\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nsloop::otype(datasets::chickwts)\n## [1] \"S3\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n\n\n\n\nshow/hide\nsummary(datasets::LakeHuron)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   576.0   578.1   579.1   579.0   579.9   581.9\nsummary(datasets::chickwts)\n##      weight             feed   \n##  Min.   :108.0   casein   :12  \n##  1st Qu.:204.5   horsebean:10  \n##  Median :258.0   linseed  :12  \n##  Mean   :261.3   meatmeal :11  \n##  3rd Qu.:323.5   soybean  :14  \n##  Max.   :423.0   sunflower:12\n\n\n\n\nshow/hide\nplot(datasets::LakeHuron)\nplot(datasets::chickwts)\n\n\n\n\n\n\n\nTime-series plot\n\n\n\n\n\n\n\nScatter Plot\n\n\n\n\n\n\n\nsummary() is a particularly versatile function, because it can be used on data.frames, a single column in a data.frame, model outputs, and more.\n\nClick Code below to view an example using summary()\n\n\n\n\nshow/hide\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output  -------------------------------------------------------\nlm_mod &lt;- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024, Adjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(&gt;|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07"
  },
  {
    "objectID": "posts/purrr1.0/index.html#fp-oop",
    "href": "posts/purrr1.0/index.html#fp-oop",
    "title": "purrr updates (v1.0.0)",
    "section": "FP + OOP",
    "text": "FP + OOP\n\nFunctional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades. - Advanced R, 2nd edition\n\nplot() and summary() are parametric polymorphic (generic) functions, which means they have slightly different behaviors based on the objects passed into them.\nAs I can see, generic functions are flexible and efficient because of not having to re-define a new function for each input objectâ€“outputs from generic functions will automatically change (in part) depending on the structure of the object provided to them.\nThe relationship between functions and objects is what makes purrr (and other tools for iteration) extremely helpful for solving iteration problems we commonly encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools."
  },
  {
    "objectID": "posts/purrr1.0/index.html#iteration-problems",
    "href": "posts/purrr1.0/index.html#iteration-problems",
    "title": "purrr updates (v1.0.0)",
    "section": "Iteration problems",
    "text": "Iteration problems\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include:\n\nYou have a list of objects and youâ€™d like to apply a function (or a series of functions) over the elements in the list\nYou have a folder full of files youâ€™d like to rename or copy to a new directory\nYouâ€™d like to download a collection of files from separate URLS\nYou have several years of data, and each year is contained in separate file. Youâ€™d like to read these data into R, combine them into a single dataset\nYou have a non-rectangular (i.e., list) of datasets youâ€™d like to split into individual data.frames, then export these into separate file paths.\n\nThese are all problems Iâ€™ve personally encountered that required a variety of iteration tools to tackle. Iâ€™ll start with the first example because the principles remain the same (regardless of the size/scope of the problem):"
  },
  {
    "objectID": "posts/purrr1.0/index.html#lapply",
    "href": "posts/purrr1.0/index.html#lapply",
    "title": "purrr updates (v1.0.0)",
    "section": "lapply()",
    "text": "lapply()\nSticking with the my_list and tolower() example, the apply function I want is lapply() (pronounced â€˜l-applyâ€™), and the l stands for list.\nlapply() has only two required arguments:\n\nX the object we want to iterate over\nFUN being the function we want iterated\n\n\n\n\nshow/hide\nlapply(X = my_list, FUN = tolower)\n## $words\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"    \n## \n## $sentences\n## [1] \"we tried to replace the coin but failed.\"       \n## [2] \"he wrote his last novel there at the inn.\"      \n## [3] \"a whiff of it will cure the most stubborn cold.\"\n## \n## $letters\n##  [1] \"b\" \"t\" \"n\" \"o\" \"w\" \"h\" \"z\" \"u\" \"e\" \"m\""
  },
  {
    "objectID": "posts/purrr1.0/index.html#sapply",
    "href": "posts/purrr1.0/index.html#sapply",
    "title": "purrr updates (v1.0.0)",
    "section": "sapply()",
    "text": "sapply()\nsapply() attempts to simplify the result depending on the X argument. If X is a list containing vectors where every element has the same length (and itâ€™s greater than 1), then sapply() returns a matrix:\n\n\n\nshow/hide\nstr(my_list[1])\n## List of 1\n##  $ words: chr [1:5] \"SpaCE\" \"pOsitiOn\" \"sOcIetY\" \"sTufF\" ...\nsapply(X = my_list[1], FUN = tolower)\n##      words     \n## [1,] \"space\"   \n## [2,] \"position\"\n## [3,] \"society\" \n## [4,] \"stuff\"   \n## [5,] \"hand\"\n\n\n\nIf a vector is passed to X where every element is length 1, then a vector is returned:\n\n\n\nshow/hide\nstr(my_list[[1]])\n##  chr [1:5] \"SpaCE\" \"pOsitiOn\" \"sOcIetY\" \"sTufF\" \"hAnd\"\nsapply(X = my_list[[1]], FUN = tolower) \n##      SpaCE   pOsitiOn    sOcIetY      sTufF       hAnd \n##    \"space\" \"position\"  \"society\"    \"stuff\"     \"hand\"\n\n\n\nFinally, if X is a list where elements have a length greater than 1, then a list is returned (making it identical to lapply()\n\n\n\nshow/hide\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n## âœ” No differences\n\n\n\nThis is because sapply is a wrapper around lapply, but has simplify and USE.NAMES set to FALSE (see what happens below when I change them to TRUE)\n\n\n\nshow/hide\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n## `old` is a list\n## `new` is a character vector ('space', 'position', 'society', 'stuff', 'hand')"
  },
  {
    "objectID": "posts/purrr1.0/index.html#anonmymous-functions",
    "href": "posts/purrr1.0/index.html#anonmymous-functions",
    "title": "purrr updates (v1.0.0)",
    "section": "Anonmymous functions",
    "text": "Anonmymous functions\nThe FUN argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in my_list, I could pass an anonymous function the FUN (with the index):\n\n\n\nshow/hide\nlapply(X = my_list, FUN = function(x) x[[2]])\n## $words\n## [1] \"pOsitiOn\"\n## \n## $sentences\n## [1] \"He WrOTE HIS LaSt noVel ThErE aT ThE inn.\"\n## \n## $letters\n## [1] \"t\""
  },
  {
    "objectID": "posts/purrr1.0/index.html#vapply",
    "href": "posts/purrr1.0/index.html#vapply",
    "title": "purrr updates (v1.0.0)",
    "section": "vapply()",
    "text": "vapply()\nFinally vapply() is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n\n\nshow/hide\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n##                                       words \n##                                  \"pOsitiOn\" \n##                                   sentences \n## \"He WrOTE HIS LaSt noVel ThErE aT ThE inn.\" \n##                                     letters \n##                                         \"t\"\n\n\n\nThe apply functions get us much further than writing for loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) write less code. Unlike generic functions, apply functions are designed to work with specific object types, and return values depending on these objects.\nOne downside of apply functions is they donâ€™t play well with data.frames or tibbles. However, we can control their return values (and manually supply these to tibble::tibble() or data.frame()\n\n\n\nshow/hide\ntibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n\n\n\nAnother downside of the apply functions is theyâ€™re not very uniform. Each function has slight variations in their arguments and rules for return values. This is where purrr comes inâ€¦"
  },
  {
    "objectID": "posts/purrr1.0/index.html#do-it-for-one-element",
    "href": "posts/purrr1.0/index.html#do-it-for-one-element",
    "title": "purrr updates (v1.0.0)",
    "section": "1. Do it for one element",
    "text": "1. Do it for one element\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\nFor this example, I need to subset my_list for a single element at position [[1]], [[2]], or [[3]] (or using one of the vector names).\nIâ€™ll then pass this element to tolower() and make sure itâ€™s the desired behavior:\n\n# subset an element from the list\n? &lt;- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n\n\n? &lt;- my_list[[?]] = subset element from the list (my_list)\ntolower(?) = apply operation (i.e., function) to extracted element.\n\n\n\n\nshow/hide\nmy_words &lt;- my_list[['words']]\ntolower(my_words)\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"\n\n\n\nNow that I have a working example for one element, in the next step Iâ€™ll abstract these parts into the function arguments."
  },
  {
    "objectID": "posts/purrr1.0/index.html#turn-it-into-a-recipe",
    "href": "posts/purrr1.0/index.html#turn-it-into-a-recipe",
    "title": "purrr updates (v1.0.0)",
    "section": "2. Turn it into a recipe",
    "text": "2. Turn it into a recipe\nA standard purrr recipe defines .x (the object) and .f (the function), followed by any additional function arguments.\n\n.x = a list or atomic vector\n.f = the function we want to apply over every element in .x\n\n\n.x = my_list, .f = tolower"
  },
  {
    "objectID": "posts/purrr1.0/index.html#map-it-across-all-elements",
    "href": "posts/purrr1.0/index.html#map-it-across-all-elements",
    "title": "purrr updates (v1.0.0)",
    "section": "3. map() it across all elements",
    "text": "3. map() it across all elements\nIn purrr::map(), the .x argument is the object (list or atomic vector) I want to iterate over, and .f is the function (i.e., operation) I want applied to every element of .x\nIf I want to convert the case of every element in my_list to lowercase with tolower() I would use the following standard purrr::map() format:\n\n\n\nshow/hide\npurrr::map(.x = my_list, .f = tolower)\n## $words\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"    \n## \n## $sentences\n## [1] \"we tried to replace the coin but failed.\"       \n## [2] \"he wrote his last novel there at the inn.\"      \n## [3] \"a whiff of it will cure the most stubborn cold.\"\n## \n## $letters\n##  [1] \"b\" \"t\" \"n\" \"o\" \"w\" \"h\" \"z\" \"u\" \"e\" \"m\"\n\n\n\nAnd there you have it! map() is the core function and workhorse of the purrr package. Itâ€™s important to note that purrr::map() always returns a list, regardless of the object supplied to .x."
  },
  {
    "objectID": "posts/purrr1.0/index.html#map-updates",
    "href": "posts/purrr1.0/index.html#map-updates",
    "title": "purrr updates (v1.0.0)",
    "section": "map() updates",
    "text": "map() updates\nAs noted above, by default purrr::map() returns a list. If Iâ€™d like to return a vector, I can use one of the map_ variations (thereâ€™s one for each vector type).\n\nBy mapping the is.&lt;type&gt;() functions the elements in mixed_list, I can test which elements in mixed_list return TRUE:\n\nmap_lgl(): returns a logical vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_lgl(\\(x) is.logical(x))\n\n\nbooleans integers  doubles  strings    dates \n    TRUE    FALSE    FALSE    FALSE    FALSE \n\n\n\n\nmap_int(): returns an integer vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_int(\\(x) is.integer(x))\n\n\nbooleans integers  doubles  strings    dates \n       0        1        0        0        0 \n\n\n\n\nmap_dbl(): returns a double vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_dbl(\\(x) is.double(x))\n\n\nbooleans integers  doubles  strings    dates \n       0        0        1        0        1 \n\n\n\n\nmap_chr(): returns a character vector\n\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_chr(\\(x) is.character(x))\n\n\nWarning: Automatic coercion from logical to character was deprecated in purrr 1.0.0.\nâ„¹ Please use an explicit call to `as.character()` within `map_chr()` instead.\n\n\nbooleans integers  doubles  strings    dates \n \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\" \n\n\n\n\nWhen we test for characters in mixed_list, we see the following warning:\n\n\nWarning: Automatic coercion from logical to character was deprecated in purrr 1.0.0. Please use an explicit call to as.character() within map_chr() instead\n\n\nAs we can see from the output above, the logical return values from is.character() are coerced to characters (this behavior is now deprecated).\n\nmap_vec()\n\nHowever, the previous purrr::map_raw() function has been replaced with purrr::map_vec(), which â€œsimplifies to the common type of the output.â€ Iâ€™ll demonstrate below with the characters in mixed_list:\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_vec(\\(x) is.character(x))\n## booleans integers  doubles  strings    dates \n##    FALSE    FALSE    FALSE     TRUE    FALSE\n\n\n\nNotice the difference in output? The results are the same as above, but output is not commented (##). The same is true when I test the dates in mixed_list using lubridate::is.Date():\n\n\n\nshow/hide\nmixed_list |&gt; purrr::map_vec(\\(x) lubridate::is.Date(x))\n## booleans integers  doubles  strings    dates \n##    FALSE    FALSE    FALSE    FALSE     TRUE"
  },
  {
    "objectID": "posts/purrr1.0/index.html#anonymous-functions",
    "href": "posts/purrr1.0/index.html#anonymous-functions",
    "title": "purrr updates (v1.0.0)",
    "section": "Anonymous functions",
    "text": "Anonymous functions\nR introduced the shorthand anonymous function syntax in version 4.1.0:\n\nâ€œ\\(x) x + 1 is parsed as function(x) x + 1.â€\n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\nStandard anonymous function\n\n\n\nshow/hide\n(function(x) tolower(x))(\"pIrAtES Ship\")\n## [1] \"pirates ship\"\n\n\n\nThe updated anonymous syntax is below:\n\n\n\nshow/hide\n(\\(x) tolower(x))(\"pIrAtES Ship\")\n## [1] \"pirates ship\"\n\n\n\n\nWriting the code above using an anonymous function would look like this:\n\n\n\nshow/hide\nmy_list |&gt; purrr::map(\\(x) tolower(x))\n## $words\n## [1] \"space\"    \"position\" \"society\"  \"stuff\"    \"hand\"    \n## \n## $sentences\n## [1] \"we tried to replace the coin but failed.\"       \n## [2] \"he wrote his last novel there at the inn.\"      \n## [3] \"a whiff of it will cure the most stubborn cold.\"\n## \n## $letters\n##  [1] \"b\" \"t\" \"n\" \"o\" \"w\" \"h\" \"z\" \"u\" \"e\" \"m\"\n\n\n\nAnonymous functions make it easier to understand which arguments belong to which function and will tend to yield better error messages.\nIâ€™ll confirm the outputs from both methods are identical using waldo::compare():\n\n\n\nshow/hide\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |&gt; purrr::map(\\(x) tolower(x)))\n## âœ” No differences\n\n\n\n\n\n\n\n\n\nThe formula (~ .x + 1)\n\n\n\n\n\nPrior to purrr v1.0.0, I could also use the formula syntax, but now itâ€™s â€œonly recommended if you require backward compatibility with older versions of R.â€ Iâ€™ll cover the formula syntax briefly because youâ€™re likely to encounter it.\n\n\nThe formula syntax is typically used with pipes, so the contents of purrr::map() become the right-hand side of the formula, with the function we want to iterate (&lt;FUNCTION&gt;) and a placeholder (.x) in the appropriate argument.\n\n\n&lt;OBJECT&gt; |&gt; purrr::map(~ &lt;FUNCTION&gt;(.x))\n\n\nFor the example above, my_list is â€˜pipedâ€™ to purrr::map(), where the formula maps the tolower() function (using the .x placeholder).\n\n\n# written as normal expression\n my_list |&gt; purrr::map(~ tolower(.x))\n\n\nJenny Bryan offers a great description on her purrr tutorial,\n\nâ€œ[formula syntax] should start with the ~ symbol and then look like a typical top-level expression, as you might write in a script. Use .x to refer to the input, i.e.Â an individual element of the primary vector or list.â€\n\nI can double-check to see that the output from two variations are identical using waldo::compare().\n\n\n\n\nshow/hide\nwaldo::compare(\n  x = my_list |&gt; purrr::map(\\(x) tolower(x)), \n  y = my_list |&gt; purrr::map(~ tolower(.x)))\n## âœ” No differences"
  },
  {
    "objectID": "posts/purrr1.0/index.html#downloading-files",
    "href": "posts/purrr1.0/index.html#downloading-files",
    "title": "purrr updates (v1.0.0)",
    "section": "Downloading files",
    "text": "Downloading files\n\nYouâ€™d like to download a collection of files from separate URLS\n\nI have a collection of 30 .csv files from Doing Data Science by Cathy Oâ€™Neil and Rachel Schutt (Oâ€™Reilly Media) in a GitHub repo. Letâ€™s assume I want to download one week of these files into my RStudio session (without downloading the repo).\nIâ€™ll navigate to the raw url for the first data file (nyt1.csv), then paste this into a character vector:\n\n\n\nshow/hide\nnyt_url &lt;- \"https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n\n\n\nKnowing that all of the files on GitHub with have a similar sheme and domain, I can use nyt_url to generate urls for each of the 7 files.\n\nFirst I get the folder of the files on GitHub with fs::path_dir()\n\n\n\n\nshow/hide\n# create file urls \nnyt_dir_url &lt;- fs::path_dir(nyt_url)\nnyt_dir_url\n\n\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main\"\n\n\n\n\nI create a vector with the 7 file names\n\n\n\n\nshow/hide\n# create file names for 7th through 13th\nnyt_file_nms &lt;- paste0(\"nyt\", 7:13, \".csv\")\nnyt_file_nms\n\n\n[1] \"nyt7.csv\"  \"nyt8.csv\"  \"nyt9.csv\"  \"nyt10.csv\" \"nyt11.csv\" \"nyt12.csv\"\n[7] \"nyt13.csv\"\n\n\n\n\nI combine the directory portion of the url with file name in nyt_file_urls\n\n\n\n\nshow/hide\n# combine\nnyt_file_urls &lt;- paste(nyt_dir_url, nyt_file_nms, sep = \"/\")\nnyt_file_urls\n\n\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt7.csv\" \n[2] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt8.csv\" \n[3] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt9.csv\" \n[4] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt10.csv\"\n[5] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt11.csv\"\n[6] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt12.csv\"\n[7] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt13.csv\"\n\n\n\nIâ€™ll need another vector of destination file names on my local machine, which I can do by combining the file names (nyt_file_nms) with the local destination folder (dds-nyt).\n\n\n\nshow/hide\nnyt_local_pths &lt;- paste(\"dds-nyt\", nyt_file_nms, sep = \"/\")\nnyt_local_pths\n\n\n[1] \"dds-nyt/nyt7.csv\"  \"dds-nyt/nyt8.csv\"  \"dds-nyt/nyt9.csv\" \n[4] \"dds-nyt/nyt10.csv\" \"dds-nyt/nyt11.csv\" \"dds-nyt/nyt12.csv\"\n[7] \"dds-nyt/nyt13.csv\"\n\n\n\nAfter creating the destination folder, Iâ€™ll use the download.file() function to test downloading a single .csv files into my local folder (dds-nyt/). download.file() has a progress bar which tells me if the file downloaded successfully.\n\n\nshow/hide\n# do it for one\nfs::dir_create(\"dds-nyt\")\ndownload.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])\n\ntrying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'\nContent type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)\n==================================================\ndownloaded 4.7 MB\n\ndownload.file() takes two inputs (url and destfile), which changes the recipe a bit, because I need a purrr function with the following:\n\n.x the input vector of existing url paths\n.y the output vector of destination file paths\nAdditional arguments passed from download.file() (like quiet = TRUE)\n\nIn this case, I donâ€™t need purrr to return valueâ€“I just need the purrr function to iterate over the items and write them to the new location.\nwalk() is ideal for this circumstance:\n\nâ€œwalk() returns the input .x (invisibly)â€ and â€œThe return value of .f() is ignoredâ€\n\nWhat do â€˜return .x invisiblyâ€™ and â€˜the side-effect of .fâ€™ mean?\n\nReturn invisibly\nThe previous purrr functions I covered varied in the kinds of values they returned (lists vs.Â vectors), but for some operations I wonâ€™t need a return value. If Iâ€™m ever curious about whether I should be using map() or walk(), Iâ€™ll ask myself, â€œwould it make sense to assign the output from this function to an object?â€\nIf the answer is no, then I probably need to be thinking walk() instead of map()\n\n\nSide-effects\nIn the help documentation walk()â€™s description states, â€œcalls .f for its side-effectâ€, which can be generally interpreted as, â€œthereâ€™s nothing to assign the output from that function to.â€\n\n\npurrr progress bars\nIâ€™ll use walk2() below and add .progress = TRUE to view the purrr progress bar (and quiet = TRUE to silence the download.file() progress bar).\n\n\n\nshow/hide\nwalk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, \n      .progress = TRUE, quiet = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI can confirm the download using fs::dir_tree()\n\n\n\nshow/hide\nfs::dir_tree(\"dds-nyt\")\n## dds-nyt\n## â”œâ”€â”€ nyt10.csv\n## â”œâ”€â”€ nyt11.csv\n## â”œâ”€â”€ nyt12.csv\n## â”œâ”€â”€ nyt13.csv\n## â”œâ”€â”€ nyt7.csv\n## â”œâ”€â”€ nyt8.csv\n## â””â”€â”€ nyt9.csv"
  },
  {
    "objectID": "posts/purrr1.0/index.html#copying-a-directory-of-files",
    "href": "posts/purrr1.0/index.html#copying-a-directory-of-files",
    "title": "purrr updates (v1.0.0)",
    "section": "Copying a directory of files",
    "text": "Copying a directory of files\n\nYou have a folder of files youâ€™d like to rename or copy to a new directory\n\nThe collection of 7 .csv files from Doing Data Science by Cathy Oâ€™Neil and Rachel Schutt (Oâ€™Reilly Media) are now in the dds-nyt/ folder.\nAs with any project, I donâ€™t want to alter the raw data, so Iâ€™m going to copy these files into dds-nyt-raw/ and dds-nyt-processed/. I also want the processed file names to have a date stamp prefix.\n\n\n\nshow/hide\nfile_pths &lt;- list.files(\"dds-nyt\", full.names = TRUE, pattern = \".csv$\")\nfile_pths\n## [1] \"dds-nyt/nyt10.csv\" \"dds-nyt/nyt11.csv\" \"dds-nyt/nyt12.csv\"\n## [4] \"dds-nyt/nyt13.csv\" \"dds-nyt/nyt7.csv\"  \"dds-nyt/nyt8.csv\" \n## [7] \"dds-nyt/nyt9.csv\"\n\n\n\nIâ€™ll start with the raw data folder. I need to create a vector of the new raw file paths and names: raw_file_pths (the raw data paths will have the original file names)\n\n\n\nshow/hide\n# do it for one\ngsub(pattern = \"^dds-nyt\",\n  replacement = \"dds-nyt/raw\",\n  x = file_pths[1])\n## [1] \"dds-nyt/raw/nyt10.csv\"\n\n# write the recipe\nfile_pths |&gt; purrr::map_chr(\\(x) gsub(x, \n                                pattern = \"^dds-nyt\", \n                                replacement = \"dds-nyt/raw\")) |&gt; head()\n## [1] \"dds-nyt/raw/nyt10.csv\" \"dds-nyt/raw/nyt11.csv\" \"dds-nyt/raw/nyt12.csv\"\n## [4] \"dds-nyt/raw/nyt13.csv\" \"dds-nyt/raw/nyt7.csv\"  \"dds-nyt/raw/nyt8.csv\"\n\n# map it across all\nraw_file_pths &lt;- file_pths |&gt; \n                  purrr::map_chr(\\(x) gsub(x, \n                                        pattern = \"^dds-nyt\", \n                                        replacement = \"dds-nyt/raw\"))\n\n\n\nBefore copying the files, I need to create the destination folder for the raw data (dds-nyt/raw). Then, Iâ€™ll make sure I can copy the first element from file_pths into the path in the first element of raw_file_pths:\n\n\n\nshow/hide\nfs::dir_create(\"dds-nyt/raw\")\n# do it for one\nfs::file_copy(\n  path = file_pths[1], \n  new_path = raw_file_pths[1], \n  overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n## dds-nyt/raw\n## â””â”€â”€ nyt10.csv\n\n\n\nI can see this is working, so I can use purrr::walk2() to move all the files from dds-nyt/ to dds-nyt/raw/\n\n\n\nshow/hide\npurrr::walk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, \n      .progress = TRUE, overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n## dds-nyt/raw\n## â”œâ”€â”€ nyt10.csv\n## â”œâ”€â”€ nyt11.csv\n## â”œâ”€â”€ nyt12.csv\n## â”œâ”€â”€ nyt13.csv\n## â”œâ”€â”€ nyt7.csv\n## â”œâ”€â”€ nyt8.csv\n## â””â”€â”€ nyt9.csv\n\n\n\nNow that Iâ€™ve copied the files into their respective folders, Iâ€™ll need to remove the files from their original location in the parent dds-nyt folder.\nFortunately, I have a vector of these files in file_pths, and I can test removal with fs::file_delete():\n\n\n\nshow/hide\nfs::file_delete(file_pths[1])\n\n\n\nGreat! Now that I know this will work, Iâ€™ll use walk() because I want .x returned invisibly and the side-effect of .f.\nBut Iâ€™ve also deleted the first element in file_pths, so when fs::file_delete() goes looking for that file, it will find nothing and returned an error.\n\n\n\nshow/hide\nError in `map()`:\nâ„¹ In index: 1.\nCaused by error:\n! [ENOENT] Failed to remove 'dds-nyt/nyt10.csv': no such file or directory\n\n\n\nI can protect against this by supplying the output from list.files() directly to purrr::walk2(), but include a pattern so it only matches the .csv files.\n\n\n\nshow/hide\npurrr:::walk(\n  # list CURRENT files \n    .x = list.files(\n      path = \"dds-nyt\",\n      pattern = \".csv$\",\n      full.names = TRUE),\n    # map function\n    .f = fs::file_delete)\n\n\n\nAnd confirm the new folder contents and structure\n\n\n\nshow/hide\nfs::dir_tree(\"dds-nyt\", type = \"any\", recurse = TRUE)\n## dds-nyt\n## â””â”€â”€ raw\n##     â”œâ”€â”€ nyt10.csv\n##     â”œâ”€â”€ nyt11.csv\n##     â”œâ”€â”€ nyt12.csv\n##     â”œâ”€â”€ nyt13.csv\n##     â”œâ”€â”€ nyt7.csv\n##     â”œâ”€â”€ nyt8.csv\n##     â””â”€â”€ nyt9.csv"
  },
  {
    "objectID": "posts/purrr1.0/index.html#import-multiple-datasets",
    "href": "posts/purrr1.0/index.html#import-multiple-datasets",
    "title": "purrr updates (v1.0.0)",
    "section": "Import multiple datasets",
    "text": "Import multiple datasets\n\nYou have several days of data, and each day is contained in separate file. Youâ€™d like to read these data into R, and combine them into a single dataset\n\nNow that I have separate raw and processed folders, I can import the NYT data into R. Below Iâ€™ve imported a single file from the raw data folder to examine itâ€™s contents:\n\n\n\nshow/hide\nnyt1 &lt;- vroom::vroom(file = raw_file_pths[1],\n  delim = \",\", \n  show_col_types = FALSE)\nstr(nyt1)\n## spc_tbl_ [452,766 Ã— 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##  $ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##  $ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##  $ Impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##  $ Clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##  $ Signed_In  : num [1:452766] 1 0 1 1 1 1 1 1 0 1 ...\n##  - attr(*, \"spec\")=\n##   .. cols(\n##   ..   Age = col_double(),\n##   ..   Gender = col_double(),\n##   ..   Impressions = col_double(),\n##   ..   Clicks = col_double(),\n##   ..   Signed_In = col_double(),\n##   ..   .delim = \",\"\n##   .. )\n##  - attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nEach nyt file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: Age, Gender (0 = female, 1 = male), Impressions (number impressions), Clicks (number clicks), and a binary indicator for signed in or not Signed_in.\nIâ€™ll add some hypothetical wrangling steps to make this example more realistic.\n\nCreate age_group, an ordered factor which contains six levels of Age (â€œ&lt;18â€, â€œ18-24â€, â€œ25-34â€, â€œ35-44â€, â€œ45-54â€, â€œ55-64â€, and â€œ65+â€)\nCreate ctr_rate or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.\nCreate female, a factor version of Gender, where when Gender = 0, then female = \"yes\", and when Gender = 1, then female = \"no\"\nCreate signed_in, a factor variable with levels \"no\" and \"yes\" from the Signed_In = 0 and 1\n\nIâ€™ve bundled all of these steps into a function (nyt_data_processing()) that I can pass each dataset through:\n\n\n\nshow/hide\nnyt_data_processing &lt;- function(nyt_csv) {\n  orig_nms &lt;- c(\"Age\", \"Gender\", \"Impressions\", \"Clicks\", \"Signed_In\")\n  nyt_nms &lt;- names(nyt_csv)\n  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {\n    cli::cli_abort(\"these data don't have the correct columns!\")\n  } else {\n    nyt_proc &lt;- nyt_csv |&gt;\n      dplyr::mutate(\n        # create age_group variable\n        age_group = case_when(\n          Age &lt; 18 ~ \"&lt;18\",\n          Age &gt;= 18 & Age &lt; 25 ~ \"18-24\",\n          Age &gt;= 25 & Age &lt; 35 ~ \"25-34\",\n          Age &gt;= 35 & Age &lt; 45 ~ \"35-44\",\n          Age &gt;= 45 & Age &lt; 55 ~ \"45-54\",\n          Age &gt;= 55 & Age &lt; 65 ~ \"55-64\",\n          Age &gt;= 65 ~ \"65+\"\n        ),\n        # factor age_group (ordered)\n        age_group = factor(age_group,\n          levels = c(\n            \"&lt;18\", \"18-24\", \"25-34\",\n            \"35-44\", \"45-54\", \"55-64\", \"65+\"\n          ),\n          ordered = TRUE\n        ),\n        # create CTR variable\n        ctr_rate = round(x = Clicks / Impressions, digits = 3),\n        # create new Female variable\n        female = case_when(\n          Gender == 0 ~ \"yes\",\n          Gender == 1 ~ \"no\",\n          TRUE ~ NA_character_\n        ),\n        # factor female (un-ordered)\n        female = factor(female,\n          levels = c(\"no\", \"yes\")\n        ),\n        Signed_In = case_when(\n          Signed_In == 0 ~ \"no\", \n          Signed_In == 1 ~ \"yes\", \n          TRUE ~ NA_character_),\n        # factor Signed_In (un-ordered) \n        Signed_In = factor(Signed_In, levels = c(\"no\", \"yes\"))) |&gt;\n      # format columns\n      janitor::clean_names()\n  }\n  return(nyt_proc)\n}\n\n\n\nIâ€™ll do some quick checks to make sure it only works with the raw data columns:\n\n\n\nshow/hide\nnyt1_proc &lt;- nyt_data_processing(nyt1)\nstr(nyt1_proc)\n## spc_tbl_ [452,766 Ã— 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##  $ age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##  $ gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##  $ impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##  $ clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##  $ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 2 2 2 2 2 1 2 ...\n##  $ age_group  : Ord.factor w/ 7 levels \"&lt;18\"&lt;\"18-24\"&lt;..: 6 1 2 4 3 3 4 4 1 2 ...\n##  $ ctr_rate   : num [1:452766] 0 0.143 0 0 0 0 0 0 0.111 0 ...\n##  $ female     : Factor w/ 2 levels \"no\",\"yes\": 1 2 2 1 1 1 2 2 2 1 ...\n##  - attr(*, \"spec\")=\n##   .. cols(\n##   ..   Age = col_double(),\n##   ..   Gender = col_double(),\n##   ..   Impressions = col_double(),\n##   ..   Clicks = col_double(),\n##   ..   Signed_In = col_double(),\n##   ..   .delim = \",\"\n##   .. )\n##  - attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nIâ€™ll run nyt_data_processing() against a processed data file (nyt1_proc)\n\n\n\nshow/hide\nnyt_data_processing(nyt1_proc)\n## Error in `nyt_data_processing()`:\n## ! these data don't have the correct columns!\n\n\n\nNow Iâ€™m ready to write the import step. First Iâ€™ll store the raw file paths in raw_data_pths\n\n\n\nshow/hide\nraw_data_pths &lt;- list.files(path = \"dds-nyt/raw\", pattern = \".csv$\", full.names = TRUE)\n\n\n\nWeâ€™ll test purrr::map() and vroom::vroom() to import the .csv files in raw_data_pths into a list. I also add utils::head() and dplyr::glimpse() to limit the output.\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # import\n  purrr::map(\n    vroom::vroom, \n        delim = \",\", show_col_types = FALSE) |&gt; \n  utils::head(2) |&gt; \n  dplyr::glimpse()\n## List of 2\n##  $ : spc_tbl_ [452,766 Ã— 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##   ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##   ..$ Impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##   ..$ Clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##   ..$ Signed_In  : num [1:452766] 1 0 1 1 1 1 1 1 0 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt; \n##  $ : spc_tbl_ [478,066 Ã— 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:478066] 28 51 29 20 19 0 58 42 35 44 ...\n##   ..$ Gender     : num [1:478066] 1 0 1 1 0 0 0 0 1 0 ...\n##   ..$ Impressions: num [1:478066] 8 5 2 4 5 3 5 6 8 4 ...\n##   ..$ Clicks     : num [1:478066] 0 0 0 0 0 1 1 0 0 0 ...\n##   ..$ Signed_In  : num [1:478066] 1 1 1 1 1 0 1 1 1 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nThis returns a list, but you may have noticed I donâ€™t have a great way for keeping track of the data files in the listâ€“this is where purrr::set_names() comes in handy.\npurrr::set_names() works a lot like names(), but purrr::set_names() will automatically set the names of x to as.character(x) if no names are provided to nm. See below:\n\n\n\nshow/hide\nraw_data_pths |&gt; purrr::set_names()\n##   dds-nyt/raw/nyt10.csv   dds-nyt/raw/nyt11.csv   dds-nyt/raw/nyt12.csv \n## \"dds-nyt/raw/nyt10.csv\" \"dds-nyt/raw/nyt11.csv\" \"dds-nyt/raw/nyt12.csv\" \n##   dds-nyt/raw/nyt13.csv    dds-nyt/raw/nyt7.csv    dds-nyt/raw/nyt8.csv \n## \"dds-nyt/raw/nyt13.csv\"  \"dds-nyt/raw/nyt7.csv\"  \"dds-nyt/raw/nyt8.csv\" \n##    dds-nyt/raw/nyt9.csv \n##  \"dds-nyt/raw/nyt9.csv\"\n\n\n\nNow the imported file will have their file path and name associated with the dataset:\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import  \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  utils::head(2) |&gt; \n  dplyr::glimpse()\n## List of 2\n##  $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 Ã— 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##   ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##   ..$ Impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##   ..$ Clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##   ..$ Signed_In  : num [1:452766] 1 0 1 1 1 1 1 1 0 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt; \n##  $ dds-nyt/raw/nyt11.csv: spc_tbl_ [478,066 Ã— 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ Age        : num [1:478066] 28 51 29 20 19 0 58 42 35 44 ...\n##   ..$ Gender     : num [1:478066] 1 0 1 1 0 0 0 0 1 0 ...\n##   ..$ Impressions: num [1:478066] 8 5 2 4 5 3 5 6 8 4 ...\n##   ..$ Clicks     : num [1:478066] 0 0 0 0 0 1 1 0 0 0 ...\n##   ..$ Signed_In  : num [1:478066] 1 1 1 1 1 0 1 1 1 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\nTo add the wrangling function, I can pipe in another call to purrr::map(), and add nyt_data_processing().\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |&gt; \n  utils::head(2) |&gt; \n  dplyr::glimpse()\n## List of 2\n##  $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 Ã— 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n##   ..$ gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n##   ..$ impressions: num [1:452766] 4 7 5 5 4 3 1 3 9 1 ...\n##   ..$ clicks     : num [1:452766] 0 1 0 0 0 0 0 0 1 0 ...\n##   ..$ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 2 2 2 2 2 1 2 ...\n##   ..$ age_group  : Ord.factor w/ 7 levels \"&lt;18\"&lt;\"18-24\"&lt;..: 6 1 2 4 3 3 4 4 1 2 ...\n##   ..$ ctr_rate   : num [1:452766] 0 0.143 0 0 0 0 0 0 0.111 0 ...\n##   ..$ female     : Factor w/ 2 levels \"no\",\"yes\": 1 2 2 1 1 1 2 2 2 1 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt; \n##  $ dds-nyt/raw/nyt11.csv: spc_tbl_ [478,066 Ã— 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n##   ..$ age        : num [1:478066] 28 51 29 20 19 0 58 42 35 44 ...\n##   ..$ gender     : num [1:478066] 1 0 1 1 0 0 0 0 1 0 ...\n##   ..$ impressions: num [1:478066] 8 5 2 4 5 3 5 6 8 4 ...\n##   ..$ clicks     : num [1:478066] 0 0 0 0 0 1 1 0 0 0 ...\n##   ..$ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 2 2 2 2 1 2 2 2 2 ...\n##   ..$ age_group  : Ord.factor w/ 7 levels \"&lt;18\"&lt;\"18-24\"&lt;..: 3 5 3 2 2 1 6 4 4 4 ...\n##   ..$ ctr_rate   : num [1:478066] 0 0 0 0 0 0.333 0.2 0 0 0 ...\n##   ..$ female     : Factor w/ 2 levels \"no\",\"yes\": 1 2 1 1 2 2 2 2 1 2 ...\n##   ..- attr(*, \"spec\")=\n##   .. .. cols(\n##   .. ..   Age = col_double(),\n##   .. ..   Gender = col_double(),\n##   .. ..   Impressions = col_double(),\n##   .. ..   Clicks = col_double(),\n##   .. ..   Signed_In = col_double(),\n##   .. ..   .delim = \",\"\n##   .. .. )\n##   ..- attr(*, \"problems\")=&lt;externalptr&gt;\n\n\n\n\nlist_rbind()\nFor the final step, Iâ€™ll bind all the data into a data.frame with the updated purrr::list_rbind() function (set names_to = \"id\").\n\n\n\nshow/hide\nraw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |&gt; \n  # bind\n  purrr::list_rbind(names_to = \"id\") |&gt; \n  dplyr::glimpse()\n## Rows: 3,488,345\n## Columns: 9\n## $ id          &lt;chr&gt; \"dds-nyt/raw/nyt10.csv\", \"dds-nyt/raw/nyt10.csv\", \"dds-nytâ€¦\n## $ age         &lt;dbl&gt; 59, 0, 19, 44, 30, 33, 41, 41, 0, 23, 28, 34, 0, 17, 33, 6â€¦\n## $ gender      &lt;dbl&gt; 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0â€¦\n## $ impressions &lt;dbl&gt; 4, 7, 5, 5, 4, 3, 1, 3, 9, 1, 4, 4, 7, 3, 7, 6, 6, 2, 7, 2â€¦\n## $ clicks      &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0â€¦\n## $ signed_in   &lt;fct&gt; yes, no, yes, yes, yes, yes, yes, yes, no, yes, yes, yes, â€¦\n## $ age_group   &lt;ord&gt; 55-64, &lt;18, 18-24, 35-44, 25-34, 25-34, 35-44, 35-44, &lt;18,â€¦\n## $ ctr_rate    &lt;dbl&gt; 0.000, 0.143, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.â€¦\n## $ female      &lt;fct&gt; no, yes, yes, no, no, no, yes, yes, yes, no, no, no, yes, â€¦\n\n\n\nNow that we have a complete recipe, I store the result in nyt_data_proc. I can also confirm all files were imported and wrangled by checking the count() of id.\n\n\n\nshow/hide\nnyt_data_proc &lt;- raw_data_pths |&gt; \n  # names \n  purrr::set_names() |&gt; \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |&gt; \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |&gt; \n  # bind\n  purrr::list_rbind(names_to = \"id\") \n\n\n\n\nshow/hide\nnyt_data_proc |&gt; dplyr::count(id)\n## # A tibble: 7 Ã— 2\n##   id                         n\n##   &lt;chr&gt;                  &lt;int&gt;\n## 1 dds-nyt/raw/nyt10.csv 452766\n## 2 dds-nyt/raw/nyt11.csv 478066\n## 3 dds-nyt/raw/nyt12.csv 396308\n## 4 dds-nyt/raw/nyt13.csv 786044\n## 5 dds-nyt/raw/nyt7.csv  452493\n## 6 dds-nyt/raw/nyt8.csv  463196\n## 7 dds-nyt/raw/nyt9.csv  459472"
  },
  {
    "objectID": "posts/purrr1.0/index.html#export-multiple-datasets",
    "href": "posts/purrr1.0/index.html#export-multiple-datasets",
    "title": "purrr updates (v1.0.0)",
    "section": "Export multiple datasets",
    "text": "Export multiple datasets\n\nYou have a dataset youâ€™d like to split into individual data.frames, then export these into separate file paths\n\nI have a processed dataset with seven data files (nyt_data_proc), and I want to export these into seven processed data files in a dds-nyt/processed/ folder.\nCreating a vector of processed data file paths is a little more involved because I wanted to add a date prefix to the exported files, and because I want to add this path as a variable in the nyt_data_proc dataset.\nBelow I create a new file_nm and proc_file_pth column to nyt_data_proc:\n\n\n\nshow/hide\n# create file names \nnyt_data_proc &lt;- dplyr::mutate(.data = nyt_data_proc,\n        file_nm = tools::file_path_sans_ext(base::basename(id)),\n        proc_file_pth = paste0(\"dds-nyt/processed/\", \n                        as.character(Sys.Date()), \"-\", \n                        file_nm))\nnyt_data_proc |&gt; dplyr::count(proc_file_pth)\n## # A tibble: 7 Ã— 2\n##   proc_file_pth                           n\n##   &lt;chr&gt;                               &lt;int&gt;\n## 1 dds-nyt/processed/2023-07-08-nyt10 452766\n## 2 dds-nyt/processed/2023-07-08-nyt11 478066\n## 3 dds-nyt/processed/2023-07-08-nyt12 396308\n## 4 dds-nyt/processed/2023-07-08-nyt13 786044\n## 5 dds-nyt/processed/2023-07-08-nyt7  452493\n## 6 dds-nyt/processed/2023-07-08-nyt8  463196\n## 7 dds-nyt/processed/2023-07-08-nyt9  459472\n\n\n\nNote that I donâ€™t include the file extension in proc_file_pth, because I might want to use different file types when Iâ€™m exporting.\nIâ€™ll cover two methods for exporting datasets from a list.\nIn this first method, Iâ€™ll use the base::split() function to split nyt_data_proc by the proc_file_pth variable into a list of data frames. Iâ€™ll also use utils::head(), purrr::walk(), and dplyr::glimpse() to view the output.\n\n\n\nshow/hide\nsplit(x = nyt_data_proc, f = nyt_data_proc$proc_file_pth) |&gt;\n  utils::head(3) |&gt; \n  purrr::walk(.f = glimpse)\n## Rows: 452,766\n## Columns: 11\n## $ id            &lt;chr&gt; \"dds-nyt/raw/nyt10.csv\", \"dds-nyt/raw/nyt10.csv\", \"dds-nâ€¦\n## $ age           &lt;dbl&gt; 59, 0, 19, 44, 30, 33, 41, 41, 0, 23, 28, 34, 0, 17, 33,â€¦\n## $ gender        &lt;dbl&gt; 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0,â€¦\n## $ impressions   &lt;dbl&gt; 4, 7, 5, 5, 4, 3, 1, 3, 9, 1, 4, 4, 7, 3, 7, 6, 6, 2, 7,â€¦\n## $ clicks        &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n## $ signed_in     &lt;fct&gt; yes, no, yes, yes, yes, yes, yes, yes, no, yes, yes, yesâ€¦\n## $ age_group     &lt;ord&gt; 55-64, &lt;18, 18-24, 35-44, 25-34, 25-34, 35-44, 35-44, &lt;1â€¦\n## $ ctr_rate      &lt;dbl&gt; 0.000, 0.143, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, â€¦\n## $ female        &lt;fct&gt; no, yes, yes, no, no, no, yes, yes, yes, no, no, no, yesâ€¦\n## $ file_nm       &lt;chr&gt; \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nâ€¦\n## $ proc_file_pth &lt;chr&gt; \"dds-nyt/processed/2023-07-08-nyt10\", \"dds-nyt/processedâ€¦\n## Rows: 478,066\n## Columns: 11\n## $ id            &lt;chr&gt; \"dds-nyt/raw/nyt11.csv\", \"dds-nyt/raw/nyt11.csv\", \"dds-nâ€¦\n## $ age           &lt;dbl&gt; 28, 51, 29, 20, 19, 0, 58, 42, 35, 44, 62, 20, 0, 0, 43,â€¦\n## $ gender        &lt;dbl&gt; 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n## $ impressions   &lt;dbl&gt; 8, 5, 2, 4, 5, 3, 5, 6, 8, 4, 6, 4, 5, 4, 4, 5, 3, 2, 5,â€¦\n## $ clicks        &lt;dbl&gt; 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,â€¦\n## $ signed_in     &lt;fct&gt; yes, yes, yes, yes, yes, no, yes, yes, yes, yes, yes, yeâ€¦\n## $ age_group     &lt;ord&gt; 25-34, 45-54, 25-34, 18-24, 18-24, &lt;18, 55-64, 35-44, 35â€¦\n## $ ctr_rate      &lt;dbl&gt; 0.000, 0.000, 0.000, 0.000, 0.000, 0.333, 0.200, 0.000, â€¦\n## $ female        &lt;fct&gt; no, yes, no, no, yes, yes, yes, yes, no, yes, yes, yes, â€¦\n## $ file_nm       &lt;chr&gt; \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nâ€¦\n## $ proc_file_pth &lt;chr&gt; \"dds-nyt/processed/2023-07-08-nyt11\", \"dds-nyt/processedâ€¦\n## Rows: 396,308\n## Columns: 11\n## $ id            &lt;chr&gt; \"dds-nyt/raw/nyt12.csv\", \"dds-nyt/raw/nyt12.csv\", \"dds-nâ€¦\n## $ age           &lt;dbl&gt; 29, 0, 27, 0, 69, 0, 0, 39, 53, 27, 0, 13, 26, 63, 79, 0â€¦\n## $ gender        &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1,â€¦\n## $ impressions   &lt;dbl&gt; 4, 1, 2, 5, 9, 1, 6, 4, 7, 3, 1, 1, 2, 5, 6, 7, 3, 1, 5,â€¦\n## $ clicks        &lt;dbl&gt; 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,â€¦\n## $ signed_in     &lt;fct&gt; yes, no, yes, no, yes, no, no, yes, yes, yes, no, yes, yâ€¦\n## $ age_group     &lt;ord&gt; 25-34, &lt;18, 25-34, &lt;18, 65+, &lt;18, &lt;18, 35-44, 45-54, 25-â€¦\n## $ ctr_rate      &lt;dbl&gt; 0.250, 0.000, 0.000, 0.200, 0.111, 0.000, 0.000, 0.000, â€¦\n## $ female        &lt;fct&gt; yes, yes, yes, yes, no, yes, yes, no, yes, no, yes, no, â€¦\n## $ file_nm       &lt;chr&gt; \"nyt12\", \"nyt12\", \"nyt12\", \"nyt12\", \"nyt12\", \"nyt12\", \"nâ€¦\n## $ proc_file_pth &lt;chr&gt; \"dds-nyt/processed/2023-07-08-nyt12\", \"dds-nyt/processedâ€¦\n\n\n\nI can see this is returning a list of data frames as expected, so now I need to pass this list into purrr::walk2() so I can iterate vroom::vroom_write() over the processed data paths in proc_file_pth.\n\nFirst I create the processed data folder (dds-nyt/processed/)\n\n\n\n\nshow/hide\nfs::dir_create(\"dds-nyt/processed/\")\n\n\n\n\nSecond, I create the .x argument, which is the split list of nyt_data_proc by proc_file_pth\n\n\n\n\nshow/hide\n# split nyt_data_proc (.x)\nby_proc_pths &lt;- nyt_data_proc |&gt; \n  split(nyt_data_proc$proc_file_pth)\n\n\n\n\nThird, I get the unique processed data paths in the proc_file_pth column and store it as a vector for the .y\n\n\n\n\nshow/hide\n# get unique processed paths in nyt_data_proc (.y) with .csv extension\nproc_pths &lt;- paste0(unique(nyt_data_proc$proc_file_pth), \".csv\")\nproc_pths\n## [1] \"dds-nyt/processed/2023-07-08-nyt10.csv\"\n## [2] \"dds-nyt/processed/2023-07-08-nyt11.csv\"\n## [3] \"dds-nyt/processed/2023-07-08-nyt12.csv\"\n## [4] \"dds-nyt/processed/2023-07-08-nyt13.csv\"\n## [5] \"dds-nyt/processed/2023-07-08-nyt7.csv\" \n## [6] \"dds-nyt/processed/2023-07-08-nyt8.csv\" \n## [7] \"dds-nyt/processed/2023-07-08-nyt9.csv\"\n\n\n\nNow I can perform purrr::walk2() on by_proc_pths using proc_pths and vroom::vroom_write():\n\n\n\nshow/hide\n# iterate with .f\nwalk2(.x = by_proc_pths, .y = proc_pths, \n      .f = vroom::vroom_write, delim = \",\")\n# or as an anonymous function \n\n\n\nOr I could write this as an an anonymous function:\n\n\n\nshow/hide\nnyt_data_proc |&gt; \n  split(nyt_data_proc$proc_file_pth) |&gt; \n  walk2(.y = proc_pths, \n    \\(x, y)\n    vroom::vroom_write(x = x, \n      file = y,  delim = \",\"))\n\n\n\nIâ€™ll want to perform a sanity check on this output with the first exported item in dds-nyt/processed and check it against the nyt1_proc data to evaluate the differences.\n\n\n\nshow/hide\nnyt1_proc_check_01 &lt;- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n\n\n\nIâ€™ll check the differences with diffobj::diffStr(). Click on Code below to view the differences:\n\n\n\nshow/hide\nwaldo::compare(\n  x = names(nyt1_proc),\n  y = names(nyt1_proc_check_01), \n  max_diffs = 20)\n##     old           | new                 \n## [1] \"age\"         - \"id\"            [1] \n## [2] \"gender\"      - \"age\"           [2] \n## [3] \"impressions\" - \"gender\"        [3] \n## [4] \"clicks\"      - \"impressions\"   [4] \n## [5] \"signed_in\"   - \"clicks\"        [5] \n## [6] \"age_group\"   - \"signed_in\"     [6] \n## [7] \"ctr_rate\"    - \"age_group\"     [7] \n## [8] \"female\"      - \"ctr_rate\"      [8] \n##                   - \"female\"        [9] \n##                   - \"file_nm\"       [10]\n##                   - \"proc_file_pth\" [11]\n\n\n\nThese are differences Iâ€™d expect, given the two data frames will have slightly different columns (id, file_nm, and proc_file_pth)\n\ngroup_walk()\nAnother option involves the group_walk() function from dplyr (WARNING: this is experimental). But I need to remove the processed folder so Iâ€™m not confusing myself:\n\n\n\nshow/hide\nwalk(.x = list.files(path = \"dds-nyt/processed\", \n                     full.names = TRUE, \n                     pattern = \".csv$\"),\n    .f = fs::file_delete)\nfs::dir_tree(\"dds-nyt\", recurse = TRUE)\n## dds-nyt\n## â”œâ”€â”€ processed\n## â””â”€â”€ raw\n##     â”œâ”€â”€ nyt10.csv\n##     â”œâ”€â”€ nyt11.csv\n##     â”œâ”€â”€ nyt12.csv\n##     â”œâ”€â”€ nyt13.csv\n##     â”œâ”€â”€ nyt7.csv\n##     â”œâ”€â”€ nyt8.csv\n##     â””â”€â”€ nyt9.csv\n\n\n\nThe help file on group_walk() gives an example with purrrâ€™s formula syntax (which Iâ€™ve adapted below):\n\n\n\nshow/hide\nnyt_data_proc |&gt; \n  dplyr::group_by(proc_file_pth) |&gt;   \n  dplyr::group_walk( ~vroom::vroom_write(x = .x, \n                          file = paste0(.y$proc_file_pth, \".csv\"),\n                          delim = \",\"))\n\n\n\nIâ€™ve also re-written this as an anonymous function (which is more stable, since the formula syntax is no longer recommended).\n\n\n\nshow/hide\n# now re-create\nfs::dir_create(\"dds-nyt/processed/\")\nnyt_data_proc |&gt; \n  dplyr::group_by(proc_file_pth) |&gt;   \n  dplyr::group_walk(\\(x, y) \n    vroom::vroom_write(\n    x = x, \n    file = paste0(y$proc_file_pth, \".csv\"),\n    delim = \", \")\n    )\n# check\nfs::dir_tree(\"dds-nyt/processed/\", pattern = \"csv$\")\n## dds-nyt/processed/\n## â”œâ”€â”€ 2023-07-08-nyt10.csv\n## â”œâ”€â”€ 2023-07-08-nyt11.csv\n## â”œâ”€â”€ 2023-07-08-nyt12.csv\n## â”œâ”€â”€ 2023-07-08-nyt13.csv\n## â”œâ”€â”€ 2023-07-08-nyt7.csv\n## â”œâ”€â”€ 2023-07-08-nyt8.csv\n## â””â”€â”€ 2023-07-08-nyt9.csv\n\n\n\nOnce again, Iâ€™ll import the first file in the new processed data folder and check it against the columns nyt1_proc_check_01 data to evaluate the differences.\n\n\n\nshow/hide\n# now re-check\nnyt1_proc_check_02 &lt;- vroom::vroom(file = proc_pths[1], # grab the first file\n                                   delim = \",\", show_col_types = FALSE)\n\n\n\n\n\n\nshow/hide\nwaldo::compare(\n  x = names(nyt1_proc_check_01),\n  y = names(nyt1_proc_check_02), \n  max_diffs = 20)\n## `old[8:11]`: \"ctr_rate\" \"female\" \"file_nm\" \"proc_file_pth\"\n## `new[8:10]`: \"ctr_rate\" \"female\" \"file_nm\""
  },
  {
    "objectID": "posts/test-shiny-p3/index.html",
    "href": "posts/test-shiny-p3/index.html",
    "title": "Testing shiny module server functions",
    "section": "",
    "text": "This is the third post in a series on testing shiny applications. Iâ€™ll cover testing shiny module server functions using the testhat package and shinyâ€™s testServer() function."
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#testing-shiny-modules",
    "href": "posts/test-shiny-p3/index.html#testing-shiny-modules",
    "title": "Testing shiny module server functions",
    "section": "Testing shiny modules",
    "text": "Testing shiny modules\n\n\n\nShiny functions pose a couple of unique challenges for testing. First, we canâ€™t execute shiny server functions in the console. Second, as shiny apps become more complex, itâ€™s highly recommended to break up the code base into modules. Modules have additional challenges due to their reactivity being split between interconnected UI and server functions.\nshiny doesnâ€™t provide a direct, built-in way to test modules, but the testServer() function addresses these challenges by testing â€œreactive interactionsâ€ in module server functions. testServer() also works with testthat, which means we can structure these â€˜reactive interactionâ€™ tests just like other unit tests (for non-application functions)."
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#shiny-app-package",
    "href": "posts/test-shiny-p3/index.html#shiny-app-package",
    "title": "Testing shiny module server functions",
    "section": "Shiny app-package",
    "text": "Shiny app-package\ntestthat is designed to work within an R package, so Iâ€™ve put together the mstsap, (i.e., a Mastering Shiny testServer app-package) to demonstrate writing tests with testServer(). The functions, modules, and applications in mstsap come from the Shiny Modules chapter of Mastering Shiny. Specifically, sections 19.3 through 19.3.4. If you havenâ€™t read this chapterâ€“start there.\n\n# to get the mstsap package used in this post:\nrenv::install(\"mjfrigaard/mstsap\", prompt = FALSE)\nlibrary(mstsap)\n\n\n\n\n\n\n\nWhy create an app-package?\n\n\n\n\n\n\nA shiny app-package is a shiny application thatâ€™s been developed as (or converted to) an R package. The benefits of storing shiny apps in R packages have been well documented, but Iâ€™ll summarize just a few that are specific to testing:\n\nStandardized folder structure:\n\nIf unit tests are performed with testthat, minimal setup is required to perform tests.\nusethis::use_testthat() sets up test files in the tests/testthat/ folder (to test the code in the R/ folder)\n\nRead more about using testthat with R packages here.\n\nTest extras:\n\nTest data can be placed in tests/testthat/&lt;test dir&gt;/&lt;test_data.rds&gt;\n\nThe code used to create the test data should be placed in make_&lt;test_data.rds&gt;\n\nAdditional testing functions can be stored in tests/testthat/helpers.R\n\nRead more about test helpers here.\n\nDevelopment tools:\n\nIf youâ€™re using RStudio, tests can be run individually (testthat::test_file()) or collectively (devtools::test()), and code helpers and data are loaded using devtools::load_all()\n\nTests created with testthat remain isolated during development\n\nRead more about developing packages with RStudio in the R Packages text."
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#modules",
    "href": "posts/test-shiny-p3/index.html#modules",
    "title": "Testing shiny module server functions",
    "section": "Modules",
    "text": "Modules\nShiny modules are â€˜a pair of UI and server functionsâ€™ designed to compartmentalize input and output IDs into distinct namespaces (â€œa namespace is to an ID as a directory is to a fileâ€).\n\nâ–ˆâ”€shinyApp \nâ”œâ”€ui = â–ˆâ”€fluidPage \nâ”‚      â””â”€â–ˆâ”€mod_ui \nâ”‚        â””â”€id = \"X\" \nâ”œâ”€server = `function(input, output, session)` \nâ””â”€â–ˆâ”€mod_server \n  â””â”€id = \"X\" \n\nIn a previous post, I used the following definition for unit tests,\n\nâ€œA unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work.â€ - The Art of Unit Testing, 2nd edition\n\nModules can also be broken into discrete â€˜units of workâ€™ with expected â€˜end results.â€™ However, the â€˜unit of workâ€™ for a shiny module is usually accomplished using a combination of three functions: a module UI function, a module server function, and any helper/utility functions.\n\n\n\n\n\n\nShiny module refresher\n\n\n\n\n\nModule UI functions typically wrap the layout, input, and output functions in tagList(). Module server functions contain the â€˜backendâ€™ code that typically goes in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using NS() (namespace) in the UI function, and called in the server function with moduleServer().\n\nModule UI functions\nBelow is an example module UI function:\n\nmod_fun_ui &lt;- function(id) {\n  tagList(\n    numericInput(inputId = NS(namespace = id, id = \"num_input\")),\n    uiOutput(outputId = NS(namespace = id, id = \"num_out\"))\n  )\n}\n\n\nmod_fun_ui creates a dedicated namespace for one inputId and one outputId with shiny::NS():\n\nâ–ˆâ”€mod_fun_ui \nâ”œâ”€id \nâ””â”€â–ˆâ”€tagList \n  â”œâ”€â–ˆâ”€numericInput \n  â”‚ â””â”€inputId = â–ˆâ”€NS \n  â”‚             â”œâ”€namespace = id \n  â”‚             â””â”€id = \"num_input\" \n  â””â”€â–ˆâ”€uiOutput \n    â””â”€outputId = â–ˆâ”€NS \n                 â”œâ”€namespace = id \n                 â””â”€id = \"num_out\" \n\n\n\n\nModule server functions\nThe corresponding module server function is below:\n\nmod_fun_server &lt;- function(id) {\n        moduleServer(id, function(input, output, session) {\n            ns &lt;- session\n          output$num_out &lt;- uiOutput(outputId = input$num_input)\n      })\n}\n\n\nThe code to render the reactive input$num_input with output$num_out is contained in the nested call to moduleServer()\n\nâ–ˆâ”€mod_fun_server \nâ”œâ”€id \nâ””â”€â–ˆâ”€moduleServer \n  â”œâ”€id = id \n  â”œâ”€server = â–ˆâ”€`function(input, output, session)` \n  â”‚          â”œâ”€`ns &lt;- session` \n  â”‚          â”œâ”€`output$num_out &lt;-` \n  â”‚          â””â”€â–ˆâ”€renderUI \n  â”‚            â””â”€`input$num_input` \n  â””â”€session = session \n\n\n\n\nUsing modules\nBoth module functions are combined in the ui and server arguments of shinyApp():\n\nshinyApp(\n    ui = fluidPage(\n          mod_fun_ui(id = \"mod\")\n        ),\n   server = function(input, output, session) \n          mod_fun_server(\"mod\")\n  )\n\n\nThe id arguments connect the UI and server functions to communicate between the UI and backend of the app:\n\nâ–ˆâ”€shinyApp \nâ”œâ”€ui = â–ˆâ”€fluidPage \nâ”‚      â””â”€â–ˆâ”€mod_fun_ui \nâ”‚        â””â”€id = \"mod namespace\" \nâ””â”€server = â–ˆâ”€`function(input, output, session)` \n           â””â”€â–ˆâ”€mod_fun_server \n             â””â”€id = \"mod namespace\" \n\n\nI recommend creating test files when you create module files (i.e., with usethis::use_r() & usethis::use_test()).\n\n\n\n\n\nModules in mstsap\nmstsap contains three modules: dataset, selectVar, and selectDataVar. If youâ€™re like more information on a module, click on the links in the numbered list.\n\nDataset module\n\ndatasetInput/datasetServer: loads and returns data object from the datasets package (filtered by data frames or matrices)\n\n\n\n\n\n\n(a) dataset module\n\n\nFigureÂ 1: dataset module\n\n\n\nThe objects from datasets are filtered in the UI module function with a filter argument that can be used to â€œlimit the options to built-in datasets that are either data frames (filter = is.data.frame) or matrices (filter = is.matrix)â€. The names are passed to the choices in the selectInput():\n\n\nshow/hide choices in datasetInput()\nnames &lt;- ls(\"package:datasets\")\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n\nThe datasets object is returned with get() (wrapped in reactive()). See below:\n\n\nshow/hide returned data from datasetServer()\nshiny::reactive(\n      get(input$dataset, \"package:datasets\")\n    )\n\n\n\n\n\nselectVar module\n\nselectVarInput/selectVarServer: displays a selectInput() that â€œallows the user to select variables of specified type from a given reactive dataset.â€\n\n\n\n\n\n\n(a) selectVar module\n\n\nFigureÂ 2: selectVar module\n\n\nThe data argument in selectVarServer() is the returned value from datasetServer():\n\ndata() is used with the filter argument in the find_vars() function:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter) {\n # I've included the updated version with the 'stopifnot()' checks!\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\nThe filter argument can be used to return variables by class/type (using is.* functions like is.numeric() or is.character())\n\nWhen data() changes, the output from find_vars() updates the choices in the variable selectInput() (i.e., input$var) (see below)\n\n\n\n\n\n\n(a) selectVar and find_vars()\n\n\nFigureÂ 3: selectVar module and find_vars() function\n\n\n\nselectVarServer() also returns the selected variable (input$var) as a reactive value (var())\n\n\n\nselectDataVar module\n\nselectDataVarUI/selectDataVarServer: The selectDataVar module is from the section titled, â€œModules inside of modulesâ€, so here we see the dataset and selectVar modules placed inside the selectDataVar module (each with a new namespace (NS())).\n\n\n\n\n\n\n(a) selectDataVar module\n\n\nFigureÂ 4: selectDataVar module\n\n\n\n\n\n\n\n\nNaming modules\n\n\n\n\n\n\nWhen creating an app-packages, modules are stored in the R/ folder as a single file, typically following a naming convention that differentiates modules from the other package functions. The modules in this post use camelCase, with suffix variations (i.e., Input/Server and UI/Server) for each functions. Other options come from the golem and leprechaun packages.\ngolem modules are created with golem::add_module()\n\n\n\nexpand to see golem::add_module(â€œinputsâ€)\nmod_inputs_ui &lt;- function(id){\n  ns &lt;- NS(id)\n  tagList(\n  )\n}\nmod_inputs_server &lt;- function(id){\n  moduleServer( id, function(input, output, session){\n    ns &lt;- session$ns\n \n  })\n}\n## To be copied in the UI\n# mod_inputs_ui(\"inputs_1\")\n    \n## To be copied in the server\n# mod_inputs_server(\"inputs_1\")\n\n\n\ngolem modules the following naming convention:\n\nAll new module functions have a mod_ prefix\ngolem module functions are differentiated with either a _ui or _server suffix\nNew golem module files are named R/mod_&lt;name&gt;.R\n\nleprechaun modules are also created with a leprechaun::add_module() function.\n\n\n\nexpand to see leprechaun::add_module(â€œinputsâ€)\ninputsUI &lt;- function(id){\n    ns &lt;- NS(id)\n    tagList(\n        h2(\"inputs\")\n    )\n}\ninputs_server &lt;- function(id){\n  moduleServer(id, function(input, output, session) {\n                ns &lt;- session$ns\n                send_message &lt;- make_send_message(session)\n                # your code here\n        }\n    )\n}\n# UI\n# inputsUI('id')\n\n# server\n# inputs_server('id')\n\n\n\nleprechaun modules have a slightly different naming convention:\n\nAll new UI module functions have a UI suffix\nAll new module server functions have a _server suffix\nleprechaun module functions do not have a prefix\nNew leprechaun modules named module_&lt;name&gt;.R\n\nShiny app-packages often require multiple modules and utility functions, so uniform names will make it easier to manage (and test!) your code.\n\n\n\n\n\n\n\nStandalone app functions\nmstsap contains three standalone functions for running each set of module functions.\nIâ€™ve made a small change to each standalone app functionâ€“each app has a call to reactiveValuesToList() that displays in the UI.\n\n\nprint reactive values\n  shiny::verbatimTextOutput(\"vals\")\n\n  output$vals &lt;- shiny::renderPrint({\n    x &lt;- shiny::reactiveValuesToList(input,\n                            all.names = TRUE)\n    print(x)\n  })\n\n\n\ndatasetApp\ndatasetApp() contains a call to the dataset module, and includes a tableOutput() to render the selected data object:\n\n\n\n\n\n(a) datasetApp\n\n\nFigureÂ 5: datasetApp\n\n\nWhen datasetApp() is run, the app displays the dataset object in the tableOutput(), and the verbatimTextOutput() renders the reactive values as a text:\n\n\n\n\n\n(a) datasetApp with reactive values\n\n\nFigureÂ 6: datasetApp with reactiveValuesToList()\n\n\nThe output above shows what NS() does in the dataset moduleâ€“it appends the module id argument to the inputId (which is why we see dataset-dataset).\n\ndataset-: the module id\ndataset-dataset the inputId from the selectInput()\n\n\n\nselectVarApp\nselectVarApp() includes both dataset and selectVar modules, but instead of rendering the output in a table, the UI renders the variable output in a verbatimTextOutput().\n\n\n\n\n\n(a) selectVarApp\n\n\nFigureÂ 7: selectVarApp\n\n\nNote that selectVarApp() contains namespaces for two modules:\n\n\"data\": the namespace for the datasetnput() and datasetServer() modules, inheriting the filter argument and creating the data object\n\"var\": the selectVar modules are linked with the \"var\" id. selectVarServer() uses the data object created by datasetServer() (and also inherits the filter argument).\n\nThese namespaced IDs are rendered below with reactiveValuesToList():\n\n\n\n\n\n(a) selectVarApp with reactive values\n\n\nFigureÂ 8: selectVarApp with reactiveValuesToList()\n\n\nThereâ€™s a lot happening in selectVarApp(), so Iâ€™ve created the figure below to display the code for the modules with their displayed outputs:\n\n\n\n\n\n\n(a) selectVarApp schema\n\n\nFigureÂ 9: dataset and selectVar modules with rendered outputs\n\n\n\nAs we can see, the data output from the dataset module is used to generate the vars() reactive for the verbatimTextOutput() in selectVarApp(). Note that both dataset and selectVar modules donâ€™t contain any output functionsâ€“these have been provided in the UI for both datasetApp() and selectVarApp().\n\n\nselectDataVarApp\nThe final app in mstsap is selectDataVarApp(). Here the inputs from dataset and selectVar have been moved into the sidebarPanel(), and the output is rendered in the mainPanel().\n\n\n\n\n\n(a) selectDataVarApp\n\n\nFigureÂ 10: selectDataVarApp\n\n\nThe reactive values here show how the â€˜Modules inside of modulesâ€™ workâ€“by adding the additional call to NS() in the datasetInput() and selectVarInput() functions within selectDataVarUI() and selectDataVarServer(), an additional namespace is appended to the reactive values (input$dataset and input$var):\n\n\n\n\n\n(a) selectDataVarApp with reactive values\n\n\nFigureÂ 11: selectDataVarApp with reactiveValuesToList()\n\n\nBelow is a figure that displays the contents of the selectDataVar modules (Iâ€™ve removed the tagList() and moduleServer() for simplicity), the selectDataVarApp(), and the rendered outputs:\n\n\n\n\n\n\n(a) selectDataVarApp schema\n\n\nFigureÂ 12: dataset and selectVar modules inside selectDataVar module with rendered outputs"
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#testserver",
    "href": "posts/test-shiny-p3/index.html#testserver",
    "title": "Testing shiny module server functions",
    "section": "testServer()",
    "text": "testServer()\nModule server functions can be tested the same way as a traditional shiny server function, as long as you provide the inputs and verify the correct outputs. Below Iâ€™ll cover some general advice on module server tests (and the arguments in testServer()).\n\nTesting module server functions\nBefore writing tests, make sure you can answer the following:\n\nWhat is the overall purpose of the application?\n\nThis information is typically referred to as the â€˜business logicâ€™ of the application, and should be stored in a specifications or requirements document. If I canâ€™t answer this question, Iâ€™m probably better off not writing test for code that is likely to undergo major changes.\n\nHow does this module fit within that overall purpose?\n\nSpecifically, how does this module help the application achieve the specifications or requirements? This could also be considered the â€˜unit of workâ€™ and â€˜end resultâ€™ for the module.\n\nWhat dependencies (i.e., utility functions, data, add-on packages) are required for the module to execute?\n\nIf the module depends on other functions, data, or packages to perform itâ€™s expected behavior, those functions should either be included in the testServer() test, or have their own tests (or both).\n\n\n\nWhat should I test?\nThe items below have been compiled from Mastering Shiny, R Packages, and Engineering Production-Grade Shiny Apps:\n\nDo the inputs/outputs behave as expected?\n\nThese tests verify the module server function inputIds and outputIds are properly namespaced and accessible\n\nDoes the module contain the expected reactive values/objects?\n\nTests should verify itâ€™s reactivityâ€“module server functions will automatically recompute the outputs when itâ€™s inputs change, so tests should verify changes to inputs produce the expected behaviors and outputs. This includes any returned values from the module (and any additional function arguments).\n\nAre the calculations correct?\n\nIf the module server function performs calculations or data manipulations, the tests should verify the module produces the correct result (ideally for a variety of inputs and edge cases).\n\nHow are errors handled in the module?\n\nWhat errors are displayed from the module? Tests should simulate scenarios that can test if the module: 1) returns errors that are informative, 2) fails silently (when appropriate), or 3) falls back to the correct default behavior.\n\n\nThe last piece of advice Iâ€™ve found helpful when writing tests comes from R Packages,\n\nâ€œfocus your time on code that youâ€™re not sure about, is fragile, or has complicated interdependenciesâ€\n\nThe quote isnâ€™t in reference to testing modules or shiny application functions, but Iâ€™ve found itâ€™s easy to fall into the trap of trying to test everything when a targeted approach is more efficient (and equally valid).\nThe first test Iâ€™ll perform is for datasetServer(), the module used to return a data object from the datasets package.\n\n\n\ntestServer() arguments\n\napp can be a module server function (i.e., datasetServer), or any shiny.appobj\nexpr is where Iâ€™ll add the testthat expectations and other test code\nargs is a list() I can use to include any module server function arguments\n\n\n\nInputs\nI created the test file with usethis::use_test(\"datasetServer\") and the module server function is the first argument in testServer().\nIâ€™ll start by testing if the initial input value (input$dataset) in datasetServer() is set to NULL:\n\nshiny::testServer(app = datasetServer, expr = {\n  testthat::expect_equal(input$dataset, NULL)\n  cat(\"\\ndatasetServer: dataset$input is NULL\", \"\\n\")\n})\n\n\nIâ€™ll add a custom message with cat() and the inputId Iâ€™m testing, load, document, and install the package, then run the test with testthat::test_file():\ndevtools::load_all()\nâ„¹ Loading mstsap\ndevtools::document()\nâ„¹ Updating mstsap documentation\nâ„¹ Loading mstsap\n\nRestarting R session...\n\nlibrary(mstsap)\n\nAnd run the test with testthat::test_file():\n\n\ntest_file(\"tests/testthat/test-datasetServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\ndatasetServer: dataset$input is NULL \n\n\n\n\n\n\n\nCreating test messages with testServer()\n\n\n\n\n\n\nThe testServer() documentation has examples of using cat() to create custom messages. I put a function for creating testServer() messages (test_cmt()) in the helper.R file (read more about test helpers here).\nIt has two arguments (test and msg), and makes it easy to print messages to the console while Iâ€™m developing tests.\n\ntest_cmt(test = \"mod_server_function\", msg = \"test contents\")\n\n       mod_server_function: test contents \n\n\n\n\n\n\nSetting test inputs\ntestServer() allows us to mimic changing application (or module) inputIds with session$setInputs() like so:\n\nsession$setInputs(inputId = \"value\")\n\nIâ€™ll demonstrate with a test for input$dataset in datasetServer():\n\n  session$setInputs(dataset = \"faithful\")\n  testthat::expect_equal(\n    object = input$dataset,\n    expected = \"faithful\")\n  test_cmt(\"datasetServer\", \"dataset$input\")\n\nThe results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetServer: dataset$input\n\n\n\nReturned values\nAny returned values from module server functions can be accessed in testServer() with session$returned(). Iâ€™ll verify input$dataset returns an object from datasetServer() by testing the class of session$returned():\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"airquality\")\n  testthat::expect_equal(\n    object = class(session$returned()),\n    expected = \"data.frame\")\n  test_cmt(\"datasetServer\", \"class(session$returned())\")\n\n  session$setInputs(dataset = \"WorldPhones\")\n  testthat::expect_true(\n    object = is.matrix(session$returned()))\n  test_cmt(\"datasetServer\", \"is.matrix(session$returned())\")\n\n\nNote that both methods above can be used to check the class of the returned object.\nThe updated results from test_file() are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetServer: class(session$returned()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetServer: is.matrix(session$returned()) \n\nI can also use the typeof(datasets::mtcars) for a direct comparison:\n\n\nshow/hide test with session$returned()\n  session$setInputs(dataset = \"mtcars\")\n  expect_equal(\n    # app value...\n    object = typeof(session$returned()), \n    # ...compared to actual output\n    expected = typeof(datasets::mtcars)) \n  test_cmt(\"datasetServer\", \"typeof(session$returned())\")\n\n\n\n\n\nModule server arguments\nIf the module server function has additional arguments beyond id, then it has additional functionality to verify with unit tests. To test additional module server arguments, pass these to testServer(args = list()). The args list should include named arguments from the module server function, i.e., list(arg1 = \"param1\", arg2 = \"param2\").\nFor example, selectVarServer() has data and filter arguments:\n\ndata is the returned reactive object from datasetServer()\nfilter is the function passed to the find_vars() utility function\n\n\n\n\n\n\n\n(a) dataset() -&gt; selectVar()\n\n\nFigureÂ 13: Object returned from datasetServer() and passed to selectVarServer()\n\n\n\nBelow is a test for selectVarServer() using args to verify the reactive data() is datasets::mtcars:\n\nshiny::testServer(selectVarServer,\n  args = list(data = datasets::mtcars,\n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\nBut this fails with the following error:\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\nâ”€â”€ Error (test-selectVarServer.R:1:1): (code run outside of `test_that()`) â”€â”€â”€\nError in `(function (id, data, filter = is.numeric) \n{\n    stopifnot(shiny::is.reactive(data))\n    stopifnot(!shiny::is.reactive(filter))\n\nWhat happened?\n\nIâ€™ve included this example because itâ€™s not in the testServer() documentation, and itâ€™s common to pass values between modules (see here in Engineering Production-Grade Shiny Apps and here in Mastering Shiny)\n\nTesting module communication\nThe error message above tells me the issue is originating from the stopifnot() calls in selectVarServer().\n\n\n\n\n\n\nUpdating selectVarServer() and find_vars()\n\n\n\n\n\n\nBoth selectVarServer() and find_vars() are updated from their original versions to include stopifnot() checks for is.reactive(), is.data.frame() and is.function():\n\nOriginal versions:\n\nfind_vars &lt;- function(data, filter) {\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session, \"var\", choices = find_vars(data(), filter))\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\nUpdated versions:\n\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n\n  stopifnot(is.reactive(data))\n  stopifnot(!is.reactive(filter))\n\n  moduleServer(id, function(input, output, session) {\n    observeEvent(data(), {\n      updateSelectInput(session = session, \n        inputId = \"var\", \n        choices = find_vars(data(), filter)\n        )\n    })\n\n    reactive(data()[[input$var]])\n  })\n}\n\n\nfind_vars &lt;- function(data, filter) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\n\n\nIâ€™ll stop a moment here to address whatâ€™s happening in each module:\n\nThe datasetServer() returns the results of input$dataset as a reactive (data())\ndata() enters selectVarServer() in the data argument\nInside selectVarServer(), two stopifnot() functions evaluate the reactivity of data and filter with shiny::is.reactive()\n\nIn datasetServer(), the return object is wrapped in the reactive() function, so the items args = list() also need to be wrapped in reactive().\nIâ€™ll re-write the test above to a more basic test using is.reactive():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data()))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n       selectVarServer: is.reactive(data()) \nâ”€â”€ Failure (test-selectVarServer.R:1:1): (code run outside of `test_that()`) â”€â”€â”€\nis.reactive(data()) is not TRUE\n\n`actual`:   FALSE\n`expected`: TRUE \n\nAnother failure???\n\nThe results of this test might seem confusing given my advice to wrap the args list in reactive(), but some reading of the x argument in is.reactive() will clear up the error:\n\nFor is.reactive(), an object to test. For reactive(), an expression.\n\nRemoving the parentheses from data() will result in the proper test results:\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::mtcars), \n              filter = is.numeric), expr = {\n  testthat::expect_true(\n    object = is.reactive(data))\n  test_cmt(\"selectVarServer\", \"is.reactive(data())\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectVarServer.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectVarServer: is.reactive(data()) \n\n\n\nUtility functions\nNow that I have a reactive data() input, I can explore how this value is used inside selectVarServer(). To update input$var, the data() input is passed to find_vars() (a function that uses a filter argument â€œused to select which variables to listâ€). See the example below:\n\nmstsap::find_vars(\n  data = datasets::chickwts, \n  filter = is.factor)\n## [1] \"feed\"\n\nIâ€™ll write an expectation that captures the behavior of find_vars() in selectVarServer():\n\nshiny::testServer(selectVarServer,\n  args = list(data = reactive(datasets::chickwts),\n              filter = is.numeric), expr = {\n  testthat::expect_equal(\n    object = find_vars(data(), is.factor),\n    expected = \"feed\")\n  test_cmt(\"selectVarServer\", \"find_vars()\")\n})\n\nThe results are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectVarServer: find_vars()\nTo verify that the returned object from selectVarServer() is the selected column, Iâ€™ll need to simulate the application behavior in the tests:\n\nCreate a reactive data() input in selectVarServer():\n\n\nsetting args = list()\n  shiny::testServer(selectVarServer,\n    args = list(data = reactive(datasets::chickwts),\n                filter = is.numeric), expr = {\n\n    # include expectations below...\n\n  })\n\n\nSet the input$var and verify the input$var:\n\n\nverify input$var\n  session$setInputs(var = \"weight\")\n  testthat::expect_equal(object = input$var,\n      expected = \"weight\")\n  test_cmt(\"selectVarServer\", \"input$var\")\n\n\nSet the input$var and verify the session$returned()\n\n\nverify session$returned()\n  session$setInputs(var = \"feed\")\n  testthat::expect_equal(object = session$returned(),\n    expected = datasets::chickwts[[\"feed\"]])\n  test_cmt(\"selectVarServer\", \"session$returned()\")\n\n\n\nThe results from these tests are below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectVarServer: input$var \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       selectVarServer: session$returned() \n\n\nModule outputs\nRendered outputs can be accessed in testServer() just like inputs (i.e., with output$outputId). But the modules in mstsap donâ€™t have outputsâ€“these are included in the standalone app functions (datasetApp(), selectVarApp(), and selectDaraVarApp()).\nFortunately, app functions can also be passed to the app argument of testServer(). Iâ€™ll use datasetApp() to demonstrate.\n\n\n\n\n\nTesting a standalone app function is similar to testing a module server function, but with a few minor differences. First, the output from the standalone app function is assigned to an object (ds_app), then placed in the app argument:\n\nds_app &lt;- datasetApp()\n  shiny::testServer(ds_app, expr = {\n\n  })\n\nTo use session$setInputs() need to include the namespace for the inputId:\n\n\n\n\n\nThe output from reactiveValuesToList() in datasetApp() shows me how to access the inputId in the datasetServer() module (i.e., input$`dataset-dataset`):\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n\n})\n\n\nOutput testing strategy\nTesting outputs with testServer() is different than testing outputs in regular unit tests, because shiny outputs are executed in the server, but then rendered in the UI. The testServer() documentation outlines a testing strategy for complex outputs:\n\n*The goal for your tests should be to ask â€œis the code that I wrote producing the plot I want?â€ There are two components to that question:\n\nDoes the plot generate without producing an error?\nIs the plot visually correct?\n\ntestServer is great for assessing the first component here. By merely referencing output$plot in your test, youâ€™ll confirm that the plot was generated without an error.\n\nIf we replace plot with table in the advice above, the tests for datasetApp() should confirm output$data is generated without producing an error.\nInstead of writing an expectation, Iâ€™ll use cat() to display the contents of output$data after setting the `dataset-dataset` input:\n\nds_app &lt;- datasetApp()\nshiny::testServer(ds_app, expr = {\n  session$setInputs(`dataset-dataset` = \"chickwts\")\n  cat(\"\\n\\toutput$data:\\n\", output$data, \"\\n\")\n})\n\nThe results from the test is below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$data:\n &lt;table  class = 'table shiny-table table- spacing-s' style = 'width:auto;'&gt;\n  &lt;thead&gt; \n      &lt;tr&gt; \n        &lt;th style='text-align: right;'&gt; weight &lt;/th&gt; \n        &lt;th style='text-align: left;'&gt; feed &lt;/th&gt;  \n     &lt;/tr&gt; \n    &lt;/thead&gt; \n      &lt;tbody&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 179.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 160.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 136.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 227.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 217.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n      &lt;tr&gt; &lt;td align=\"right\"&gt; 168.00 &lt;/td&gt; &lt;td&gt; horsebean &lt;/td&gt; &lt;/tr&gt;\n   &lt;/tbody&gt; \n &lt;/table&gt; \nThe output is the HTML used to render the table in the UI. This doesnâ€™t add a passing test, but it confirms that the table is being generated from the data() reactive.\nThe tests for datasetApp() will confirm the inputId, and verify the class and names of the data() reactive (which will be passed to the renderTable() function):\n\n  testthat::expect_equal(\n    object = input$`dataset-dataset`,\n    expected = \"chickwts\")\n  test_cmt(\"datasetApp\", \"input$`dataset-dataset`\")\n\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  test_cmt(\"datasetApp\", \"is.data.frame(data())\")\n\n  testthat::expect_equal(\n    object = names(data()),\n    expected = names(datasets::chickwts))\n  test_cmt(\"datasetApp\", \"names(data())\")\n\nI can include a test for the class of output$data, but note that this is a character output:\n\n  testthat::expect_equal(\n    object = class(output$data),\n    expected = \"character\")\n  test_cmt(\"datasetApp\", \"class(output$data)\")\n\nThe results from test_file() are below:\n\ntestthat::test_file(\"tests/testthat/test-datasetApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       datasetApp: input$`dataset-dataset` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       datasetApp: is.data.frame(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       datasetApp: names(data()) \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 4 ]\n       datasetApp: class(output$data) \nThe same method can be used to test the selectVarApp(), but note this app requires passing both inputIds to session$setInputs():\n\n\nshow/hide selectVarApp() tests\nsv_app &lt;- selectVarApp()\nshiny::testServer(app = sv_app, expr = {\n  session$setInputs(`var-var` = \"Ozone\",\n                    `data-dataset` = \"airquality\")\n  # confirm contents of output$out\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n  \n  # confirm var is reactive \n  testthat::expect_true(object = is.reactive(var))\n  # confirm var input\n  testthat::expect_equal(\n    object = input$`var-var`,\n    expected = \"Ozone\")\n  # confirm data is reactive\n  testthat::expect_true(object = is.reactive(data))\n  # confirm data() is a data.frame\n  testthat::expect_true(\n    object = is.data.frame(data()))\n  # confirm 'data' can be subsetted with 'var'\n  testthat::expect_equal(\n    object = data()[[input$`var-var`]],\n    expected = airquality[[\"Ozone\"]])\n})\n\n\n\n\nTesting nested modules\nI highly recommend viewing the output of reactiveValuesToList() if your application has nested modules. Itâ€™s easy to lose track of ids if they span multiple layers.\nWe know selectDataVarApp() contains â€˜modules inside other modulesâ€™, and these layers are reflected in the namespaces:\n\n\n\n\n\nTo access the inputIds in the nested modules, we need to pass the full â€˜appendedâ€™ namespace:\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n})\n\nAfter setting the inputs, I can confirm the contents of output$out\n\ndv_app &lt;- selectDataVarApp()\nshiny::testServer(app = dv_app, expr = {\n  session$setInputs(`var-var-var` = \"Ozone\",\n                    `var-data-dataset` = \"airquality\")\n  cat(\"\\n\\toutput$out:\\n\", output$out, \"\\n\")\n})\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n    output$out:\n   [1]  41  36  12  18  NA  28  23  19   8  NA   7  16  11  14  18\n [16]  14  34   6  30  11   1  11   4  32  NA  NA  NA  23  45 115\n [31]  37  NA  NA  NA  NA  NA  NA  29  NA  71  39  NA  NA  23  NA\n [46]  NA  21  37  20  12  13  NA  NA  NA  NA  NA  NA  NA  NA  NA\n [61]  NA 135  49  32  NA  64  40  77  97  97  85  NA  10  27  NA\n [76]   7  48  35  61  79  63  16  NA  NA  80 108  20  52  82  50\n [91]  64  59  39   9  16  78  35  66 122  89 110  NA  NA  44  28\n[106]  65  NA  22  59  23  31  44  21   9  NA  45 168  73  NA  76\n[121] 118  84  85  96  78  73  91  47  32  20  23  21  24  44  21\n[136]  28   9  13  46  18  13  24  16  13  23  36   7  14  30  NA\n[151]  14  18  20 \nAfter confirming output$out, Iâ€™ll test the inputs:\n\n  testthat::expect_equal(\n    object = input$`var-var-var`,\n    expected = \"Ozone\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-var-var`\")\n\n  testthat::expect_equal(\n    object = input$`var-data-dataset`,\n    expected = \"airquality\")\n  test_cmt(\"selectDataVarApp\", \"input$`var-data-dataset`\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n       selectDataVarApp: input$`var-var-var` \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n       selectDataVarApp: input$`var-data-dataset`\nI can also verify the contents of the reactive var() inside the test:\n\n  testthat::expect_true(object = is.reactive(var))\n  test_cmt(\"selectDataVarApp\", \"is.reactive(var)\")\n  cat(\"\\n\\tvar:\\n\", var(), \"\\n\")\n\n\ntestthat::test_file(\"tests/testthat/test-selectDataVarApp.R\")\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 3 ]\n       selectDataVarApp: is.reactive(var) \n\n    var:\n 41 36 12 18 NA 28 23 19 8 NA 7 16 11 14 18 14 34 6 30 11 1 11 4 32 NA NA NA 23 \n    45 115 37 NA NA NA NA NA NA 29 NA 71 39 NA NA 23 NA NA 21 37 20 12 13 NA NA NA\n    NA NA NA NA NA NA NA 135 49 32 NA 64 40 77 97 97 85 NA 10 27 NA 7 48 35 61 79 \n    63 16 NA NA 80 108 20 52 82 50 64 59 39 9 16 78 35 66 122 89 110 NA NA 44 28 \n    65 NA 22 59 23 31 44 21 9 NA 45 168 73 NA 76 118 84 85 96 78 73 91 47 32 20 23\n    21 24 44 21 28 9 13 46 18 13 24 16 13 23 36 7 14 30 NA 14 18 20"
  },
  {
    "objectID": "posts/test-shiny-p3/index.html#recap",
    "href": "posts/test-shiny-p3/index.html#recap",
    "title": "Testing shiny module server functions",
    "section": "Recap",
    "text": "Recap\nThis post has shown how shinyâ€™s testServer() function allows you to isolate and test module server functions, which makes it easier to ensure that your server function behaves as expected (and locate and fix bugs).\nI hope you have a better understanding of how you can use testServer() to test a modules inputs/outputs, reactivity, calculations, and errors.\nIn the next post Iâ€™ll cover performing integration tests with shinytest2!"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html",
    "href": "posts/test-shiny-p4/index.html",
    "title": "Testing shiny apps with shinytest2",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(shinytest2)\nlibrary(vdiffr)\nThis is the fourth post in a series on testing shiny applications. My previous posts have covered unit testing utility functions and testing module server functions with testServer(). In this post, Iâ€™ll be covering testing shiny applications using testthat and shinytest2."
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#set-up",
    "href": "posts/test-shiny-p4/index.html#set-up",
    "title": "Testing shiny apps with shinytest2",
    "section": "Set up",
    "text": "Set up\nshinytest2 requires a few steps to get up and running, so Iâ€™ve included my start up steps below (in hopes that someone might find them useful).\n\nChromium\nFirst make sure you have Chromium headless browser installed. Chromium is the browser used to test and debug shiny apps with shinytest2.\nIf youâ€™re using macOS, you can install Chromium using homebrew:\n\nbrew install --cask chromium\n\n\n\nshow/hide output\n==&gt; Downloading https://download-chromium.appspot.com/dl/Mac?type=snapshots\n==&gt; Downloading from https://commondatastorage.googleapis.com/chromium-browser-s\n######################################################################### 100.0%\nWarning: No checksum defined for cask 'chromium', skipping verification.\n==&gt; Installing Cask chromium\n==&gt; Moving App 'Chromium.app' to '/Applications/Chromium.app'\n==&gt; Linking Binary 'chromium.wrapper.sh' to '/usr/local/bin/chromium'\nğŸº  chromium was successfully installed!\n\n\n\n\nchromote\nThe chromote package allows R to open Chromium. I had to make sure R knew where to find the Chromium application (this section helps) by passing the path to the app to Sys.setenv()\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\nYou can use find_chrome() to find your chrome app:\n\nchromote::find_chrome()\n\nYou can also locate the path to Chromium using by holding command âŒ˜ and clicking on the application icon\nThen set the CHROMOTE_CHROME environment variable to the Chromium path (make sure itâ€™s not the path to Chrome.app:\n\n\nshow/hide\nSys.setenv(CHROMOTE_CHROME = \"/Applications/Chromium.app/Contents/MacOS/Chromium\")\n\n\nVerify the Chromium app/chromote install with ChromoteSession$new()\n\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n\n\n\n(a) Chromium\n\n\n\n\nFigureÂ 1: Chromium headless browser\n\n\n\nGreat! Going through this step means shinytest2â€™s test recorder will (should) deploy when Iâ€™m recording tests."
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#app-package-contents",
    "href": "posts/test-shiny-p4/index.html#app-package-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "App-package contents",
    "text": "App-package contents\nIâ€™ve created msst2ap (i.e., Mastering Shiny shinytest2 app-package) with devtools and usethis. It somewhat resembles an application using the golem framework, but with fewer opinions. You can download msst2ap here or install it using the following:\n\nremotes::install_github(\"mjfrigaard/msst2ap\",\n  force = TRUE, quiet = TRUE\n)\nlibrary(msst2ap)\n\nThe applications in msst2ap can be run with the their standalone app functions.\n\nModules & apps\nThe modules in msst2ap are from the Modules chapter of Mastering Shiny, with a few minor adjustments. These modules create namespaces for their inputs and outputs with the shiny::NS() function, which appends a second id string to each inputId/outputId.\nEach standalone app also includes the output from shiny::reactiveValuesToList():\n\nIn the ui:\n\n# for printing reactive values in application modules\nshiny::verbatimTextOutput(\"vals\")\n\nIn the server:\n\n# for printing reactive values in application modules\noutput$vals &lt;- shiny::renderPrint({\n  x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n  print(x, width = 30, max.levels = NULL)\n}, width = 30)\n\n\n\ndataset module\nThe dataset module displays the objects in the datasets package in a selectInput() according to a filter argument (i.e., is.data.frame, is.matrix, etc.).\ndatasetServer() returns the selected object as a reactive value. Read more here.\n\n\ndatasetInput() & datasetServer()\ndatasetInput &lt;- function(id, filter = NULL) {\n  names &lt;- ls(\"package:datasets\")\n\n  if (!is.null(filter)) {\n    data &lt;- lapply(names, get, \"package:datasets\")\n    names &lt;- names[vapply(data, filter, logical(1))]\n  }\n\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n}\ndatasetServer &lt;- function(id) {\n  shiny::moduleServer(id, function(input, output, session) {\n    shiny::reactive(get(input$dataset, \"package:datasets\"))\n  })\n}\n\n\n\ndatasetApp()\n\n\ndatasetApp()\ndatasetApp &lt;- function(filter = NULL) {\n  ui &lt;- shiny::fluidPage(\n    datasetInput(\"dataset\", filter = is.data.frame),\n    shiny::tableOutput(\"data\"),\n    \n    # for printing reactive values in application modules\n    shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"dataset\")\n    output$data &lt;- shiny::renderTable(head(data()))\n    \n    # for printing reactive values in application modules\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n    }, width = 30)\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) datasetApp()\n\n\nFigureÂ 2: datasetApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nBelow the table output in datasetApp(), the reactive values displays the inputId from datasetInput() and the namespace value from the shared id argument with datasetServer():\n$`dataset-dataset`\n\n\n\nselectVar module\nThe selectVar module selects a numeric variable the data() object returned from datasetServer().\nIt has a single utility function (find_vars()) which is used to filter the columns (variables):\n\n\nshow/hide selectVarInput() & selectVarServer()\nselectVarInput &lt;- function(id) {\n  shiny::selectInput(\n    shiny::NS(id, \"var\"),\n    label = \"Variable\",\n    choices = NULL\n  )\n}\nselectVarServer &lt;- function(id, data, filter = is.numeric) {\n  \n  stopifnot(shiny::is.reactive(data))\n  stopifnot(!shiny::is.reactive(filter))\n\n  shiny::moduleServer(id, function(input, output, session) {\n\n    shiny::observe({\n      shiny::updateSelectInput(\n        session, \"var\",\n        choices = find_vars(data(), filter))\n    }) |&gt;\n      shiny::bindEvent(data())\n\n    return(\n      shiny::reactive({\n        if (input$var %in% names(data())) {\n          data()[input$var]\n        } else {\n          NULL\n        }\n      }) |&gt;\n      shiny::bindEvent(input$var)\n    )\n\n  })\n}\n\n\nIâ€™ve made a few small changes to selectVarServer():\n\nIn the original version, input$var is returned as a vector:\n\nreactive(data()[[input$var]])\n\nIâ€™ve added some validation and return input$var as a single column from data():\n\nshiny::reactive({\n    if (input$var %in% names(data())) {\n        data()[input$var]\n    } else {\n        NULL\n    }\n  }) \n\nThe find_vars() function is also below:\n\n\nshow/hide find_vars()\nfind_vars &lt;- function(data, filter = is.vector) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.function(filter))\n  names(data)[vapply(data, filter, logical(1))]\n}\n\n\n\n\nselectVarApp()\nThe selectVarApp() extends the dataset module by collecting the returned reactive value, passing it to find_vars(), and returning a single column.\n\n\nshow/hide selectVarApp()\nselectVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n            datasetInput(\"data\", is.data.frame),\n            selectVarInput(\"var\"),\n            shiny::tableOutput(\"out\"),\n            shiny::verbatimTextOutput(\"vals\")\n  )\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectVarApp()\n\n\nFigureÂ 3: selectVarApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe reactive values in selectVarApp() are displayed below the table:\n\n\n\n\nVariables\n\nthe 1st var is from the inputId in selectVarInput()\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module\n$`var-var` \n\n\n\nData\n\ndataset is from the inputId in datasetInput()\n$`-dataset`\ndata is the shared namespace id from the dataset module\n$`data-dataset`\n\n\n\n\n\n\nselectDataVar module\nselectDataVar is from the Modules inside of modules section, so true to form, both the dataset and selectVar modules are called inside of the UI and Server modules:\n\n\nselectDataVarUI() & selectDataVarServer()\nselectDataVarUI &lt;- function(id) {\n  shiny::tagList(\n    datasetInput(\n      shiny::NS(id, \"data\"), \n        filter = is.data.frame),\n    selectVarInput(\n      shiny::NS(id, \"var\"))\n  )\n}\nselectDataVarServer &lt;- function(id, filter = is.numeric) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n    var\n\n  })\n}\n\n\n\nselectDataVarApp()\nThe selectDataVarApp() places the inputs in the sidebarPanel() and the outputs in the mainPanel().\n\n\nselectDataVarApp()\nselectDataVarApp &lt;- function(filter = is.numeric) {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        selectDataVarUI(\"var\")\n        ),\n      shiny::mainPanel(\n        shiny::tableOutput(\"out\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n        )\n    )\n  )\n  server &lt;- function(input, output, session) {\n    var &lt;- selectDataVarServer(\"var\", filter)\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) selectDataVarApp()\n\n\nFigureÂ 4: selectDataVarApp() in msst2ap\n\n\n\nThe reactive values from selectDataVarApp() reflect the nested module structure:\n\n\n\n\nVariables\n\nThe first var belongs to the inputId in selectVarInput(),\n$`-var` \nthe 2nd var is the shared namespace id from the selectVar module,\n$`-var-var`\nthe 3rd var is the call to the selectVar module inside selectDataVar\n$`var-var-var` \n[1] \"Ozone\"\n\n\n\nData\n\ndataset belongs to the inputId in datasetInput(),\n$`-dataset` \ndata is the shared namespace id from the dataset module,\n$`-data-dataset` \nvar is the call to the dataset module inside selectDataVar\n$`var-data-dataset` \n[1] \"airquality\"\n\n\n\n\n\n\nhistogram module\nThe final modules and application Iâ€™ll use from Mastering Shiny are from the Case study: histogram section. This application uses the existing dataset and selectVar modules to pass a single variable to the render a histogram:\n\n\nshow/hide histogramOutput() & histogramServer()\nhistogramOutput &lt;- function(id) {\n  shiny::tagList(\n    shiny::numericInput(\n      shiny::NS(id, \"bins\"),\n      label = \"bins\",\n      value = 10,\n      min = 1,\n      step = 1\n    ),\n    shiny::plotOutput(\n      shiny::NS(id, \"hist\"))\n  )\n}\nhistogramServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n  stopifnot(shiny::is.reactive(x))\n  stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    output$hist &lt;- shiny::renderPlot({\n        shiny::req(x())\n        main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n        hist(purrr::as_vector(x()),\n          breaks = input$bins,\n          main = main\n        )\n      }, res = 96)\n\n    output$data &lt;- shiny::renderPrint({\n      shiny::req(x())\n      print(head(x()))\n    })\n  })\n}\n\n\nIâ€™ve made some changes to the histogramServer() function (to accomodate the changes to the selectVar module).\n\nThe original renderPlot() call in histogramServer():\n\n  output$hist &lt;- renderPlot({\n    req(is.numeric(x()))\n    main &lt;- paste0(title(), \" [\", input$bins, \"]\")\n    hist(x(), breaks = input$bins, main = main)\n  }, res = 96)\n\nThe updated renderPlot() call in histogramServer():\n\n  output$hist &lt;- shiny::renderPlot({\n    shiny::req(x())\n    main &lt;- paste0(title(), \" [bins =\", input$bins, \"]\")\n    hist(purrr::as_vector(x()),\n      breaks = input$bins,\n      main = main)\n  }, res = 96)\n\n\nAs you can see, req() is verifying x() exists, but doesnâ€™t check itâ€™s class with is.numeric().\nx() is also passed to purrr::as_vector() before itâ€™s plotted with hist()\n\n\n\nhistogramApp()\n\n\nhistogramApp()\nhistogramApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        \n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n    data &lt;- datasetServer(\"data\")\n    x &lt;- selectVarServer(\"var\", data)\n    histogramServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n  }\n  shiny::shinyApp(ui, server)\n}\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\nFigureÂ 5: histogramApp() in msst2ap\n\n\n\n\n\nReactive values (vals)\nThe displayed reactive values in histogramApp() are described below:\n\n\n\n\nPlot\n\nThe inputId from histogramOutput() and the shared namespace id\n$`hist-bins`\n[1] 10\n\n\n\nVariables\n\nThe inputId from selectVarInput() and the shared namespace id\n$`var-var`\n[1] \"Ozone\"\n\n\n\nData\n\nThe inputId from datasetInput() and the shared namespace id\n$`data-dataset` \n[1] \"airquality\""
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#using-shinytest2",
    "href": "posts/test-shiny-p4/index.html#using-shinytest2",
    "title": "Testing shiny apps with shinytest2",
    "section": "Using shinytest2",
    "text": "Using shinytest2\nshinytest2 is extremely well documentation. I highly recommended the Get Started vignette. In the next sections, Iâ€™ll cover some examples for what Iâ€™ve included in the msst2ap.\n\n\n\n\n\n\nWhy shinytest2?\n\n\n\n\n\n\nWhat happened to shinytest?\nshinytest2 replaced shinytest on 2022-04-27. If youâ€™ve previously written tests with shinytestâ€“or are curious how shinytest2 if differentâ€“I recommend going through the Migrating from shinytest vignette.\n\n\n\n\nRun shinytest2::use_shinytest2() to create the initial files for shinytest2:\n\nshinytest2::use_shinytest2()\n\n\n\nshow/hide output from use_shinytest2()\n! Runner already found: tests/testthat.R\nâœ” Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\nâœ” Adding '*_.new.png' to '.gitignore'\nâœ” Adding '_\\\\.new\\\\.png$' to '.Rbuildignore'\nâœ” Setting active project to '/projects/msst2ap'\nâœ” Adding 'shinytest2' to Suggests field in DESCRIPTION\nâ€¢ Use `requireNamespace(\"shinytest2\", quietly = TRUE)` to test if package is installed\nâ€¢ Then directly refer to functions with `shinytest2::fun()`\nâœ” Setting active project to '&lt;no active project&gt;'\n\n\n\nuse_shinytest2() adds the setup-shinytest2.R script to my tests/testthat/ folder:\n\ntests/testthat/\nâ”œâ”€â”€ _snaps/\nâ””â”€â”€ setup-shinytest2.R\n\n\nThe setup-shinytest2.R file contains a single call to shinytest2::load_app_env(), which â€œExecutes all ./R files and global.R into the current environmentâ€"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#recording-tests",
    "href": "posts/test-shiny-p4/index.html#recording-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recording tests",
    "text": "Recording tests\nNew tests with shinytest2 can be created by launching the test event recorder, which allows us interact with our application, observe itâ€™s behavior, and record inputs, reactive values, and outputs. To record a test, run shinytest2::record_test().\nThe first argument in record_test() is the path to application. If youâ€™ve stored your application in an app.R file, record_test() will automatically load that application.\n\nIf you encounter a message telling you Chromium is disconnected, try installing the development version of chromote:\n\n# run this in the console to make sure you have dev version of chromote\nremotes::install_github(\"rstudio/chromote\", force = TRUE, quiet = TRUE)\nlibrary(chromote)\n\n\nIn msst2ap, the application in app.R is the histogramApp(), so the test recorder will automatically open with this application if I run record_test() (without providing the path to a shiny app).\n\nshinytest2::record_test()\n\n\nIn Chromium\n\n\n\n\n\n\n\n\n(a) shinytest2::record_test()\n\n\n\n\nFigureÂ 6: record_test() with application in app.R\n\n\n\nThe app argument can also be a â€œpath to a Shiny applicationâ€. For example, I have â€˜developmentâ€™ versions of each application in msst2ap in inst/dev/:\n\n\nshow/hide contents of msst2ap/inst/dev\ninst/dev\nâ”œâ”€â”€ datasetApp\nâ”‚   â”œâ”€â”€ DESCRIPTION\nâ”‚   â”œâ”€â”€ R\nâ”‚   â”‚   â””â”€â”€ modules.R\nâ”‚   â”œâ”€â”€ README.md\nâ”‚   â””â”€â”€ app.R\nâ”œâ”€â”€ histogramApp\nâ”‚   â”œâ”€â”€ DESCRIPTION\nâ”‚   â”œâ”€â”€ R\nâ”‚   â”‚   â””â”€â”€ modules.R\nâ”‚   â”œâ”€â”€ README.md\nâ”‚   â””â”€â”€ app.R\nâ”œâ”€â”€ selectDataVarApp\nâ”‚   â”œâ”€â”€ DESCRIPTION\nâ”‚   â”œâ”€â”€ R\nâ”‚   â”‚   â””â”€â”€ modules.R\nâ”‚   â”œâ”€â”€ README.md\nâ”‚   â””â”€â”€ app.R\nâ””â”€â”€ selectVarApp\n    â”œâ”€â”€ DESCRIPTION\n    â”œâ”€â”€ R\n    â”‚   â””â”€â”€ modules.R\n    â”œâ”€â”€ README.md\n    â””â”€â”€ app.R\n\n9 directories, 16 files\n\n\nI can pass the path to each application to the app argument in record_test():\n\nshinytest2::record_test(app = \"inst/dev/histogramApp/\")\n\nThis opens Chromium with our shiny app:\n\n\n\n\n\n\n\n\n(a) record_test(â€œinst/dev/histogramApp/â€)\n\n\n\n\nFigureÂ 7: record_test() with app in inst/dev/histogramApp/ folder\n\n\n\nThe test event recorder displays the shiny app, but also includes a window for recording each application â€˜event.â€™\n\nExpectations\nIâ€™ll start by recording a test for histogramApp(). On the right-hand side of the Chromium headless browser, youâ€™ll see the shinytest2 expectations window:\n\n\n\n\n\n\n\n\n(a) shinytest2 expectations\n\n\n\n\nFigureÂ 8: shinytest2 expectations in record_test()\n\n\n\nThe initial value in the Code window displays the dimensions of the application in Chromium (app$set_window_size(width = , height = )).\n\n\nEvents\nWhen I interact with the application (i.e., make changes to the inputs), each change is an â€˜eventâ€™ that is recorded in the test:\n\n\n\n\n\n\n\n\n(a) change inputs\n\n\n\n\nFigureÂ 9: Changing app inputs\n\n\n\n\n\nCode\nAll events are recorded as code in the Code section of shinytest2 expectations:\n\n\n\n\n\n\n\n\n(a) shinytest2 code expectations\n\n\n\n\nFigureÂ 10: Recorded code for each event\n\n\n\n\n\nExpect Shiny values\nWhen Iâ€™ve finished interacting with the application, I click on the Expect Shiny values button at the top of shinytest2 expectations. This will add app$expect_values() to the Code section:\n\n\n\n\n\n\n\n\n(a) expect-shiny-values\n\n\n\n\nFigureÂ 11: Expect Shiny values in shinytest2 expectations\n\n\n\n\n\nSave test and exit\nFinally, to save the test, enter a Test name and click Save test and exit\n\n\n\n\n\n\n\n\n(a) name-save-exit\n\n\n\n\nFigureÂ 12: Name, save and exit record_test()\n\n\n\n\n\n\nIn Console\nBack in the Console, the shinytest2 test recorder is performing the following actions behind the scenes:\n\nThe Chromium headless browser opens with the histogramApp() and shiny is loaded\n\nListening on http://127.0.0.1:7418\n{shiny} R stderr ----------- Loading required package: shiny\n\nWarning: The first warning is a caused by the call to shiny::loadSupport(). Itâ€™s a known issue, so we can assume the developers are working on it!\n\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\n  contain an R package. Sourcing files in R/ may cause unexpected behavior.\n\nWe are told the application is being run in test mode, which â€˜lets the AppDriver retrieve valuesâ€™ from the app\n\n{shiny} R stderr ----------- Running application in test mode.\n{shiny} R stdout ----------- â„¹ Loading msst2ap\n\nWarning: The tests/testthat.R file (i.e., the â€˜test runnerâ€™) was overwritten and tests are now run with shinytest2::test_app()\n\nWarning: Overwriting test runner tests/testthat.R with `shinytest2::test_app()`\ncall to ensure proper a testing environment.\n\nWhen I clicked â€œSave test and exitâ€, the changes made to tests/testthat.R and tests/testthat/test-shinytest2.R are saved:\n\nâ€¢ Saving test runner: tests/testthat.R\nâ€¢ Saving test file: tests/testthat/test-shinytest2.R\n\nA call to shinytest2::load_app_env() is added to setup-shinytest2.R and the test file (tests/testthat/test-shinytest2.R) is opened:\n\nâœ” Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\nâ€¢ Modify '/projects/msst2ap/tests/testthat/test-shinytest2.R'\n\nThe new test is saved in the tests/testthat/test-shinytest2.R file and automatically run.\n\nâ€¢ Running recorded test: tests/testthat/test-shinytest2.R"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#test-contents",
    "href": "posts/test-shiny-p4/index.html#test-contents",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test contents",
    "text": "Test contents\nThe contents of the test file generated from the test recorder are below:\n\nlibrary(shinytest2)\n\ntest_that(\"{shinytest2} recording: histogramApp\", {\n  app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n  app$expect_values()\n})\n\nThe new test file is automatically run when I exit the test recorder (as noted above), but I can also do this by clicking on Run Test or by using test_file() from testthat:\n\ntestthat::test_file(\"tests/testthat/test-shinytest2.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nBecause msst2ap is a package, running tests with shinytest2 will produce the warning below:\n\n\n\nshiny::loadSupport() warning\n\n\nAs noted above, this warning is known by the shinytest2 package authors and is being addressed in a future release.\n\n\n\n\nNow that I know the first shinytest2 test is passing, Iâ€™ll dive into each line in the test.\n\nAppDriver\nshinytest2 uses the AppDriver to create â€œa full simulation of a Shiny appâ€. When recording tests, this will be the first argument (along with the name of the .png and .json snapshot testthat files, and the height and width of the ChromoteSession).\n\nThe example from the test above is below:\n\n app &lt;- AppDriver$new(name = \"histogramApp\", height = 657, width = 1069)\n\n\n\n\nset_inputs()\nWhen recording shinytest2 tests, every change to the applications inputs will result in a call to app$set_inputs(). This function is similar to the testServer() call to session$setInputs() (i.e., the inputs are provided as â€œname-value pairsâ€, i.e., inputId = \"value\").\n\nIn the histogramApp(), these are provided with the appended namespaces:\n\n  app$set_inputs(`data-dataset` = \"attitude\")\n  app$set_inputs(`var-var` = \"privileges\")\n  app$set_inputs(`hist-bins` = 11)\n  app$set_inputs(`hist-bins` = 12)\n  app$set_inputs(`hist-bins` = 13)\n  app$set_inputs(`hist-bins` = 14)\n  app$set_inputs(`hist-bins` = 15)\n\n\n\n\nexpect_values()\nThe documentation on expect_values() is definitely worth reading. expect_values() is added to the test file when Expect Shiny values is clicked in the test recorder and â€œcreates a list of values and compares them to the current values of the application.â€\n\nexpect_values() = â€œExpect all input, output, and export values are consistentâ€\n\n  app$expect_values()"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#test-results",
    "href": "posts/test-shiny-p4/index.html#test-results",
    "title": "Testing shiny apps with shinytest2",
    "section": "Test results",
    "text": "Test results\nThe results from running the new test file (test-shinytest2.R) are below:\n\nâ€¢ Running recorded test: tests/testthat/test-shinytest2.R\nâœ” | F W S  OK | Context\nâœ” |   2     1 | shinytest2 [6.3s]                                             \n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001_.png'\n\nWarning (test-shinytest2.R:12:3): {shinytest2} recording: histogramApp\nAdding new file snapshot: 'tests/testthat/_snaps/histogramApp-001.json'\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nDuration: 6.7 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\nTwo warnings are displayed because the test adds two new files to the tests/testthat/_snaps/ folder:\n\ntests/testthat/_snaps/\nâ””â”€â”€ shinytest2\n    â”œâ”€â”€ histogramApp-001.json\n    â””â”€â”€ histogramApp-001_.png\n\n2 directories, 2 files\n\nThese are the files new test runs will be compared against (i.e., our â€˜baselineâ€™ snapshots). Iâ€™ll briefly cover their contents below:\n\n_snaps\nexpect_values() generates two snapshot files in the tests/testthat/_snaps/ folder: one .png and one .json file:\n\n.png\nThe image saved in tests/testthat/_snaps/histogramApp-001_.png is below:\n\n\n\n\n\nThe image is a little grainy and hard to see, but it shows the changed dataset and variable values (attitude and privileges).\n\n\n.json\nThe .json file saved in tests/testthat/_snaps/histogramApp-001.json contains the snapshot inputs, outputs, and exports:\n\nThe inputs show the three changed values (\"data-dataset\", \"var-var\", and \"hist-bins\").\n\n\nshow/hide snapshot inputs\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n    \"hist-bins\": 15,\n    \"var-var\": \"privileges\"\n  },\n\n\n\nThe two outputs are stored in \"hist-hist\" and \"vals\":\n\n\"hist-hist\" holds the updated image (stored in the image data hash), along with various other characteristics of the plot:\n\n\nshow/hide snapshot outputs\n  \"output\": {\n    \"hist-hist\": {\n      \"src\": \"[image data hash: fde4089afc06a814d75c627b823d0806]\",\n      \"width\": 682.6640625,\n      \"height\": 400,\n      \"alt\": \"Plot object\",\n      \"coordmap\": {\n        \"panels\": [\n          {\n            \"domain\": {\n              \"left\": 27.8,\n              \"right\": 87.2,\n              \"bottom\": -0.24,\n              \"top\": 6.24\n            },\n            \"range\": {\n              \"left\": 78.79664956011726,\n              \"right\": 642.3048029692084,\n              \"bottom\": 301.08,\n              \"top\": 77.71999999999998\n            },\n            \"log\": {\n              \"x\": null,\n              \"y\": null\n            },\n            \"mapping\": {\n\n            }\n          }\n        ],\n        \"dims\": {\n          \"width\": 682.6640625,\n          \"height\": 400\n        }\n      }\n    },\n\n\n\"vals\" contains the reactive values from reactiveValuesToList():\n\n\nshow/hide snapshot outputs\n    \"vals\": \"$`hist-bins`\\n[1] 15\\n\\n$`var-var`\\n[1] \\\"privileges\\\"\\n\\n$`data-dataset`\\n[1] \\\"attitude\\\"\\n\"\n  },\n\n\nI didnâ€™t export any values in this test, so \"export\" is empty:\n\n\nshow/hide snapshot outputs\n  \"export\": {\n\n  }\n}\n\n\n\nIâ€™ll cover this in a later test.\n\n\n\n\nNamespaces\nThe contents of the .json snapshot should look somewhat familiar for the three modules contained in histogramApp():\n\nFor example, the inputId for \"dataset\" in the datasetInput/Server module communicates between the UI and server using the shared id argument \"data\"\n\n# in datasetInput()\n  shiny::selectInput(\n    shiny::NS(id, \"dataset\"),\n    \"Pick a dataset\",\n    choices = names)\n# in histogramApp()\n  shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame)\n      )\n\nThis creates the $`data-dataset` output we see the verbatimTextOutput() at the bottom of the application:\n\n$`data-dataset`\n[1] \"attitude\"\n\nIn the .json snapshot, this inputId is represented in the following \"input\":\n\n{\n  \"input\": {\n    \"data-dataset\": \"attitude\",\n  },\n\n\nNamespaces and inputIds will come up again if you start writing your own tests, which Iâ€™ll cover below."
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#writing-tests",
    "href": "posts/test-shiny-p4/index.html#writing-tests",
    "title": "Testing shiny apps with shinytest2",
    "section": "Writing tests",
    "text": "Writing tests\nThe great thing about testing with shinytest2 is the ability to interact with the AppDriver as you write tests. Iâ€™ll demo writing a test for the datasetApp() by adapting the contents of test-shinytest2.R into a new test-shinytest2-datasetApp.R file.\n\ntests/testthat/\nâ”œâ”€â”€ _snaps/\nâ”‚   â””â”€â”€ shinytest2/\nâ”‚       â”œâ”€â”€ histogramApp-001.json\nâ”‚       â””â”€â”€ histogramApp-001_.png\nâ”œâ”€â”€ setup-shinytest2.R\nâ”œâ”€â”€ test-shinytest2-datasetApp.R &lt;- new test file!\nâ””â”€â”€ test-shinytest2.R\n\n3 directories, 5 files\n\nIn the new test test-shinytest2-datasetApp.R file, Iâ€™ll start with a call to testthat::test_that(), then create a new app object with the Chromium headless browser.\nThe namespaced standalone app function can be used to create a ds_app object, then ds_app is passed to the first argument of AppDriver$new() (Iâ€™ve adjusted the height and weight to fit the datasetApp()).\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n})\n\nIn the Console, I can use app$view() to open the Chromium browser:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigureÂ 13: View application with app$view()\n\n\n\nChromium displays the same app I see when I run msst2ap::datasetApp() in the console, but the headless browser has some additional developer tools (read more).\n\nSetting inputs\nIf I continue to adapt each line in test-shinytest2.R to the datasetApp(), I see that next lines set the inputIds for dataset-dataset to the attitude dataset with app$set_input() (Note that this uses the module notation above (i.e., \"id-inputId\"):\n\ntest_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n})\n\nIf you can see both windows, youâ€™ll see the application values change in the Chromium browser:\n\n\n\n\n\n\n\n\n(a) app$set_inputs()\n\n\n\n\nFigureÂ 14: Set application inputs with app$set_inputs()\n\n\n\n\n\nChecking inputs\nIn the previous test, I used the expect_values() to capture a list of all the app values (input, output, export). I can also capture these values in a list inside the test by including a call to app$get_values() and assigning the output to app_values.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n})\n\napp_values has a similar structure to the .json snapshot covered above (i.e., with input, output, and export):\n\nstr(app_values)\n\n\nList of 3\n $ input :List of 1\n  ..$ dataset-dataset: chr \"attitude\"\n $ output:List of 2\n  ..$ data: chr \"&lt;table  class = 'table shiny-table table- \"| __truncated__\n  ..$ vals: chr \"$`dataset-dataset`\\n[1] \\\"attitude\\\"\\n\"\n $ export: Named list()\n\nI can narrow the scope of the test by using app_values to verify only the input that was changed with app$set_inputs()::\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n})\n\nAt the end of the test, Iâ€™ll add a call app$stop() to close the Chromium app.\n\ntestthat::test_that(\"{shinytest2}: datasetApp\", {\n  ds_app &lt;- msst2ap::datasetApp()\n  app &lt;- AppDriver$new(app_dir = ds_app, height = 600, width = 800)\n  app$set_inputs(`dataset-dataset` = \"attitude\")\n  app_values &lt;- app$get_values()\n  testthat::expect_equal(\n    object = app_values$input$`dataset-dataset`,\n    expected = \"attitude\")\n  app$stop()\n})\n\n\n\nRunning tests\nIâ€™ll save the test-shinytest2-datasetApp.R file and run the test with testthat::test_file():\n\ntest_file(\"tests/testthat/test-shinytest2-datasetApp.R\")\n\n\n\n\n\n\n\nWARNING\n\n\n\n\n\n\nIf you encounter the error message below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nError : Chromote: timed out waiting for response to command Target.createTarget\n[ FAIL 0 | WARN 0 | SKIP 1 | PASS 0 ]\n\nâ”€â”€ Skipped tests (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ€¢ `shinytest2::AppDriver` can not be initialized as {chromote} can not be \n  started (1): test-shinytest2-selectVarApp.R:4:3\n\nTry installing and loading chromote and shinytest2 again (this seemed to work for me).\n\nremotes::install_github(\"rstudio/chromote\", \n  force = TRUE, quiet = TRUE)\nlibrary(chromote)\nlibrary(shinytest2)\n\n\n\n\n\nIn the initial run of the test for datasetApp(), no snapshot files are generated because the test didnâ€™t include a call to app$export_values().\nI see this initial test passes:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#exporting-test-values",
    "href": "posts/test-shiny-p4/index.html#exporting-test-values",
    "title": "Testing shiny apps with shinytest2",
    "section": "Exporting test values",
    "text": "Exporting test values\nThe shinytest2 documentation repeatedly recommends exporting test values from shiny applications with shiny::exportTestValues().\n\nexportTestValues()\nIâ€™ll demonstrate exporting test values from selectVarApp() by adding the following to the server function in inst/dev/app.R:\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n    var &lt;- selectVarServer(\"var\", data, filter = filter)\n\n    output$out &lt;- shiny::renderTable(head(var()))\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                              all.names = TRUE)\n      print(x)\n    })\n\n    shiny::exportTestValues(\n      var = var(),\n      data = data()\n    )\n  }\n\n\n\nUsing system.file()\nAfter loading, documenting and installing the package, Iâ€™ll create a test-shinytest2-selectVarApp.R test file and add the initial contents to create the AppDriver object:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                           package = \"msst2ap\"),\n                     height = 600, width = 600)\n  \n})\n\nNote that to test the development version of selectVarApp(), I pass a call to system.file() to the app_dir argument (this is a similar folder structure to apps built with golem and leprechaun frameworks)\nAfter entering app$view() in the Console, the application opens in the Chromium headless browser again:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigureÂ 15: View selectVarApp() application with app$view()\n\n\n\nIn the test file, Iâ€™ll use app$set_values() to change the $`data-dataset` and $`var-var` inputs:\n\nChange $`data-dataset` to mtcars:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n    app$set_inputs(`data-dataset` = \"mtcars\")\n\n})\n\n\n\n\n\n\n\n\n\n\n(a) Set data-dataset\n\n\n\n\nFigureÂ 16: View selectVarApp() after setting data-dataset with app$set_inputs()\n\n\n\n\nChange $`var-var` to wt:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n\n})\n\n\n\n\n\n\n\n\n\n\n(a) Set var-var\n\n\n\n\nFigureÂ 17: View selectVarApp() after setting var-var with app$set_inputs()\n\n\n\n\n\nget_values()\nIâ€™ll use app$get_values() to store the exported input, output, and export test values in app_values:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n  \n    app$set_inputs(`data-dataset` = \"mtcars\")\n    app$set_inputs(`var-var` = \"wt\")\n    \n    app_values &lt;- app$get_values()\n    \n})\n\napp_values is a list (similar to the .json snapshot file), but now weâ€™ve explicitly exported values from the server in selectVarApp():\n\nnames(app_values$export)\n\n\n[1] \"data\" \"var\" \n\n\n\nexported expectations\nI can use app_values to verify the structure of each exported object:\n\ndata should be a data.frame()\n\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n\nvar should be a single column data.frame()\n\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\nOnce again, I end the test with a call to app$stop(). The completed test for selectVarApp() is below:\n\ntestthat::test_that(\"{shinytest2}: selectVarApp\", {\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"selectVarApp\",\n                                             package = \"msst2ap\"),\n                       height = 600, width = 600)\n\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app$set_inputs(`var-var` = \"wt\")\n\n  app_values &lt;- app$get_values()\n\n  testthat::expect_true(\n    object = is.data.frame(app_values$export$data))\n\n  testthat::expect_true(\n    object = ncol(app_values$export$var) == 1)\n\n  app$stop()\n})\n\nI can run the test with testthat::test_file().\n\ntestthat::test_file(path = \"tests/testthat/test-shinytest2-selectVarApp.R\")\n\nThe results are below:\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#testing-complex-outputs",
    "href": "posts/test-shiny-p4/index.html#testing-complex-outputs",
    "title": "Testing shiny apps with shinytest2",
    "section": "Testing complex outputs",
    "text": "Testing complex outputs\nIâ€™ve created an adapted version of the histogramApp() in the inst/dev/gghistApp/ folder (view contents here):\n\ninst/dev/gghistApp/\n            â”œâ”€â”€ DESCRIPTION\n            â”œâ”€â”€ R/\n            â”‚   â””â”€â”€ modules.R\n            â”œâ”€â”€ README.md\n            â””â”€â”€ app.R\n\n2 directories, 4 files\n\ngghistApp() renders a ggplot2 graph, which makes it easier to demonstrate this example of checking a plot from the shinytest2 package website.\n\n\n\n\n\n\n\n\n(a) histogramApp()\n\n\n\n\n\n\n\n(b) gghistApp()\n\n\n\n\nFigureÂ 18: histogramApp() vs.Â gghistApp()\n\n\n\nThe gghistApp() is similar to histogramApp(), but instead of using hist() to generate the plot, a reactive plot_obj() is passed to shiny::renderPlot() (like the example above).\nDue to the structure of the modules in the application, the exportTestValues() function is placed in the gghistServer() function:\n\n\nshow/hide gghistServer()\ngghistServer &lt;- function(id, x, title = reactive(\"Histogram\")) {\n\n    stopifnot(shiny::is.reactive(x))\n    stopifnot(shiny::is.reactive(title))\n\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # create plot object\n    plot_obj &lt;- shiny::reactive({\n                  shiny::req(x())\n                  purrr::as_vector(x())\n                  })\n    \n    # render plot object\n    output$hist &lt;- shiny::renderPlot({\n      shiny::req(x())\n      ggplot2::ggplot(\n        mapping =\n          ggplot2::aes(plot_obj())) +\n          ggplot2::geom_histogram(bins = input$bins) +\n          ggplot2::labs(\n            title = paste0(title(), \" [bins = \", input$bins, \"]\"),\n            y = \"Count\",\n            x = names(x())) +\n          ggplot2::theme_minimal()\n    }, res = 124) |&gt;\n      shiny::bindEvent(c(x(), input$bins),\n        ignoreNULL = TRUE)\n\n    # export app values\n    shiny::exportTestValues(\n      x = x(),\n      plot_obj = plot_obj()\n    )\n\n  })\n}\n\n\n\ngghistServer() is replaces histogramServer() in the standalone app function (gghistApp()):\n\n\nshow/hide gghistApp()\ngghistApp &lt;- function() {\n  ui &lt;- shiny::fluidPage(\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        datasetInput(\"data\", is.data.frame),\n        selectVarInput(\"var\"),\n      ),\n      shiny::mainPanel(\n        histogramOutput(\"hist\"),\n        shiny::verbatimTextOutput(\"vals\")\n      )\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n\n    data &lt;- datasetServer(\"data\")\n\n    x &lt;- selectVarServer(\"var\", data)\n\n    gghistServer(\"hist\", x)\n\n    output$vals &lt;- shiny::renderPrint({\n      x &lt;- shiny::reactiveValuesToList(input,\n                          all.names = TRUE)\n      print(x, width = 30, max.levels = NULL)\n      }, width = 30)\n\n  }\n\n  shiny::shinyApp(ui, server)\n}\n\n\n\nIn the test-shinytest2-gghistApp.R test file, Iâ€™ll verify the vdiffr package is installed with testthat::skip_if_not_installed(), then create the AppDriver object with a call to system.file() and set the height and width:\n\ntestthat::test_that(\"{shinytest2}: gghistApp\", {\n  skip_if_not_installed(\"vdiffr\")\n\n  app &lt;- AppDriver$new(app_dir = system.file(\"dev\", \"gghistApp\",\n                                             package = \"msst2ap\"),\n                       height = 750, width = 1200)\n})\n\nView the application in the Chromium browser by running app$view() in the Console:\n\napp$view()\n\n\n\n\n\n\n\n\n\n(a) app$view()\n\n\n\n\nFigureÂ 19: View gghistApp() application with app$view()\n\n\n\nIâ€™ll replicate the example from the website using the gghistApp():\n\nVerify initial input\n\nThe first expectations in the example test the default input values with app$get_value(input = ):\n\n  # Verify initial data\n  app_init_data &lt;- app$get_value(input = \"data-dataset\")\n  testthat::expect_equal(\n    object = app_init_data,\n    expected = \"BOD\")\n\n  # Verify initial variable\n  app_init_var &lt;- app$get_value(input = \"var-var\")\n  testthat::expect_equal(\n    object = app_init_var,\n    expected = \"Time\")\n\n\n\n\nSet and verify export\n\nNext, we check the exported values after changing the inputs with app$set_values() and app$get_value(export = )\n\n  # Verify exported `x()` data\n  app$set_inputs(`data-dataset` = \"mtcars\")\n  app_exp_x_01 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_01, \n    expected = mtcars[1])\n\n  # Verify exported `plot_obj()` data\n  app$set_inputs(`var-var` = \"wt\")\n  app_exp_plot_obj_01 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_01,\n    expected = purrr::as_vector(app_exp_plot_obj_01))\n\nThe bins are also set to a new value with app$set_inputs() after verifying the exported values:\n\n  # Verify `hist-bins` changes\n  app$set_inputs(`hist-bins` = 15)\n  app_set_bins_01 &lt;- app$get_value(input = \"hist-bins\")\n  testthat::expect_equal(\n    object = app_set_bins_01,\n    expected = 15)\n\n\n\n\n\n\n\n\n\n\n(a) set_inputs() and get_value() in gghistApp()\n\n\n\n\nFigureÂ 20: Set inputs and get exported values in gghistApp()\n\n\n\n\n\nVerify plot with vdiffr\n\nNow we verify the plot with the exported plot_obj (in the hist module) with expect_doppelganger() from the vdiffr package.\n\n  # Verify `hist-plot_obj` changes\n  plot_obj_15 &lt;- app$get_value(export = \"hist-plot_obj\")\n  vdiffr::expect_doppelganger(\n    title = \"hist-plot_obj-15\",\n    fig = plot_obj_15)\n\n\nI saved the test file and ran the test to confirm the snapshot file was created in tests/testthat/_snaps/:\n\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\nâ”€â”€ Warning (_test-shinytest2-gghistApp.R:45:3): {shinytest2}: gghistApp â”€â”€â”€\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-15.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 6 ]\n\n\n\n\nset_, get_, expect_\nThe process above is repeated with new values passed to app$set_inputs() and verified with app$get_value(export = ):\n\nThe x(), plot_obj() and hist-bins are updated again with new values:\n\n  ## Update `data` to USArrests\n  app$set_inputs(`data-dataset` = \"USArrests\")\n  app_exp_x_02 &lt;- app$get_value(export = \"hist-x\")\n  testthat::expect_equal(\n    object = app_exp_x_02,\n    expected = USArrests[1])\n\n  ## Update `var` to UrbanPop\n  app$set_inputs(`var-var` = \"UrbanPop\")\n  app_exp_plot_obj_02 &lt;- app$get_value(export = \"hist-plot_obj\")\n  testthat::expect_equal(\n    object = app_exp_plot_obj_02,\n    expected = purrr::as_vector(app_exp_plot_obj_02))\n\n  ## Update `bins` to 12\n  app$set_inputs(`hist-bins` = 12)\n  app_set_bins_02 &lt;- app$get_value(input = \"hist-bins\")\n  expect_equal(\n    object = app_set_bins_02,\n    expected = 12)\n\nThe new plot is verified again with expect_doppelganger()\n\n  ## Verify updates to `hist-plot_obj`\n  plot_obj_12 &lt;- app$get_value(export = \"hist-plot_obj\")\n  vdiffr::expect_doppelganger(\n    title = \"hist-plot_obj-12\",\n    fig = plot_obj_12)\n\n\nThis initial run of this test will show a warning again as the snapshot file is saved to tests/testthat/_snaps/:\n\n\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\nâ”€â”€ Warning (_test-shinytest2-gghistApp.R:77:3): {shinytest2}: gghistApp â”€â”€â”€\nAdding new file snapshot: 'tests/testthat/_snaps/hist-plot-obj-12.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 10 ]\n\n\n\n\nResults\nThe final results of the test-shinytest2-gghistApp.R are below:\n\ntest_file(\"tests/testthat/_test-shinytest2-gghistApp.R\")\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\n  wt1   wt2   wt3   wt4   wt5   wt6   wt7   wt8   wt9  wt10  wt11  wt12  wt13 \n2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 3.730 \n wt14  wt15  wt16  wt17  wt18  wt19  wt20  wt21  wt22  wt23  wt24  wt25  wt26 \n3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 3.845 1.935 \n wt27  wt28  wt29  wt30  wt31  wt32 \n2.140 1.513 3.170 2.770 3.570 2.780 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 9 ] \n UrbanPop1  UrbanPop2  UrbanPop3  UrbanPop4  UrbanPop5  UrbanPop6  UrbanPop7 \n        58         48         80         50         91         78         77 \n UrbanPop8  UrbanPop9 UrbanPop10 UrbanPop11 UrbanPop12 UrbanPop13 UrbanPop14 \n        72         80         60         83         54         83         65 \nUrbanPop15 UrbanPop16 UrbanPop17 UrbanPop18 UrbanPop19 UrbanPop20 UrbanPop21 \n        57         66         52         66         51         67         85 \nUrbanPop22 UrbanPop23 UrbanPop24 UrbanPop25 UrbanPop26 UrbanPop27 UrbanPop28 \n        74         66         44         70         53         62         81 \nUrbanPop29 UrbanPop30 UrbanPop31 UrbanPop32 UrbanPop33 UrbanPop34 UrbanPop35 \n        56         89         70         86         45         44         75 \nUrbanPop36 UrbanPop37 UrbanPop38 UrbanPop39 UrbanPop40 UrbanPop41 UrbanPop42 \n        68         67         72         87         48         45         59 \nUrbanPop43 UrbanPop44 UrbanPop45 UrbanPop46 UrbanPop47 UrbanPop48 UrbanPop49 \n        80         80         32         63         73         39         66 \nUrbanPop50 \n        60 \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]\n\nThe vector in each plot_obj() test is printed with expect_doppelganger(), but this doesnâ€™t interfere with the results.\nI can run devtools::test() to run all the tests in msst2ap:\n\ndevtools::test()"
  },
  {
    "objectID": "posts/test-shiny-p4/index.html#recap",
    "href": "posts/test-shiny-p4/index.html#recap",
    "title": "Testing shiny apps with shinytest2",
    "section": "Recap",
    "text": "Recap\nThis post has covered creating tests with testthat and shinytest2 for an app-package containing a shiny application (with modules!). As you can see, the test recorder makes it easier to test specific app behaviors, and the AppDriver makes it possible to build a set of test expectations iteratively. Other items to consider when writing shinytest2 tests include:\n\nDefine What to Test: Since Shiny apps are interactive, so shinytest2 tests should simulate user interaction as much as possible. The tests should focus on key user interactions and the output they should generate. shinytest2 provides functions for simulating user clicks, inputs, and other interactions. Not every interaction needs to be tested, but crucial ones and those that handle complex logic should be.\nOrganize Your Tests & Use Descriptive Test Names: Organize your tests into separate files based on what they are testing. Each test should have a descriptive name that clarifies what the test is for. Organizing your test files with unambiguous names will make it easier to manage multiple tests, and it will make it easier to understand whatâ€™s going wrong when a test fails.\nCreate snapshots for expected outputs: Use snapshot files to verify that an appâ€™s output matches the expected results. AppDriver$expect_values() generates .json and .png snapshot files for the application. The .json file contains input, output, and export values, and the .png file is a debug screenshot, which records how the app looked when the values where captured. These files can then be compared to a baseline snapshot.\nExport app values: While snapshot files are great for detecting changes, itâ€™s important to remember that â€œdifferences in the captured screenshot will never cause test failures.â€ Manually inspecting the snapshot .png files during test development can also be time-consuming and tedious. Wherever possible, export app values and compare them against expected reference values.\n\nIn general, shinytest2 is designed for end-to-end testing of shiny applications. These tests can capture the state of a shiny app (input, output, and exported values) during user interactions and compare them with a previous state (i.e., snapshots), which is useful for regression testing.\nshinytest2 tests can also simulate user interaction in a way that shiny::testServer() tests canâ€™t, such as waiting for reactive outputs to update after the input changes, clicking on action buttons, etc. shinytest2 can also be resource-intensive, so itâ€™s recommended to write these tests after youâ€™ve completed the standard testthat unit tests and testServer() tests."
  },
  {
    "objectID": "posts/duap/index.html",
    "href": "posts/duap/index.html",
    "title": "Creating shiny app-packages",
    "section": "",
    "text": "In this post, Iâ€™ll be using devtools and usethis to develop duap, an R package that contains a shiny application (i.e., devtools/usethis app-package).\nThe R package development workflow is well documented in R Packages and Mastering Shiny. Iâ€™ve written this post because I frequently encountered R developers who were comfortable with shiny application development, but had never developed an R package.\nThis post walks through converting an existing shiny application into an app-package in detail because R package development differs from creating a standalone shiny application. My hope is that by reading this will prevent you from having to rebuild your application entirely from scratch.\nIâ€™ve organized the app-package development process into three areas: Start, Build, and Use.\nThe GitHub repo with the code for duap is located here if youâ€™d like to follow along."
  },
  {
    "objectID": "posts/duap/index.html#from-console",
    "href": "posts/duap/index.html#from-console",
    "title": "Creating shiny app-packages",
    "section": "From Console",
    "text": "From Console\nIf I am creating a package from the console, the function for building a new package is usethis::create_package():\n\nusethis::create_package(path = \"duap\")\n\nA new RStudio session will open (and the name of the projectâ€“i.e., the name of the .Rproj fileâ€“will be identical to the package name)."
  },
  {
    "objectID": "posts/duap/index.html#from-project-wizard",
    "href": "posts/duap/index.html#from-project-wizard",
    "title": "Creating shiny app-packages",
    "section": "From Project Wizard",
    "text": "From Project Wizard\nIf I am using RStudioâ€™s New Project Wizard to create a new shiny app package, Iâ€™d see the following defaults:\n\n\n\n\n\n\n\nFigureÂ 1: Default usethis::create_package project setup\n\n\nThe new package built from the console will have the following folder and files:\nduap/\n  â”œâ”€â”€ DESCRIPTION\n  â”œâ”€â”€ NAMESPACE\n  â”œâ”€â”€ R/\n  â””â”€â”€ duap.Rproj\n  \n1 directory, 3 files\nPackages built from the New Project Wizard will have a few additional folders and files:\nduap/\n  â”œâ”€â”€ DESCRIPTION\n  â”œâ”€â”€ NAMESPACE\n  â”œâ”€â”€ R/\n  â”‚   â””â”€â”€ hello.R\n  â”œâ”€â”€ man/\n  â”‚   â””â”€â”€ hello.Rd\n  â”œâ”€â”€ myRPkg.Rproj\n  â””â”€â”€ renv/\n      â”œâ”€â”€ activate.R\n      â”œâ”€â”€ sandbox/\n      â”‚   â””â”€â”€ R-4.2\n      â””â”€â”€ settings.dcf\n\n4 directories, 7 files\nThese additional files are:\n\nhello.R in the R/ folder\n\nhello.Rd in the man/ folder\n\na renv/ folder for package management\n\nR/hello.R and man/hello.Rd are boilerplate files and can be deleted, but both package setups have a DESCRIPTION, NAMESPACE, R/ folder, and .Rproj file. These four items can be thought of as the â€˜minimal packageâ€™ setup required to access RStudioâ€™s Build tools."
  },
  {
    "objectID": "posts/duap/index.html#metadata-files",
    "href": "posts/duap/index.html#metadata-files",
    "title": "Creating shiny app-packages",
    "section": "Metadata files",
    "text": "Metadata files\nR packages have two metadata files: DESCRIPTION and NAMESPACE. Neither of these files have extensions, and both contain vital information for your package to function properly.\nWeâ€™ll manually edit the DESCRIPTION file, but the NAMESPACE file is automatically generated during the development process.\n\nDESCRIPTION\nThe DESCRIPTION file plays an important role in R packagesâ€“thatâ€™s why creating this file is the first step when converting an existing app (and when creating a new golem apps).\n\n\n\n\n\n\nDESCRIPTION files\n\n\n\n\n\n\n\n\n\n\n\nâ€˜RStudio and devtools consider any directory containing DESCRIPTION to be a packageâ€™ - R Packages\n\n\n\n\nThe initial DESCRIPTION file in duap is below:\nPackage: duap\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", \n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\nThe package name is automatically added, but the remaining fields need to be completed (consult R packages for more information on filling out the DESCRIPTION file).\nThe DESCRIPTION file in the duap prompts the RStudio IDE to activate the Build tools pane (see below):\n\n\n\n\n\n\n\nFigureÂ 2: Package Build tools"
  },
  {
    "objectID": "posts/duap/index.html#application-code",
    "href": "posts/duap/index.html#application-code",
    "title": "Creating shiny app-packages",
    "section": "Application code",
    "text": "Application code\nThe contents of the app.R and utils.R need to be moved into the R/ folder. When developing R packages, new .R files are created with usethis::use_r().\n\nuse_r()\nIâ€™m going to create duap using modules to separate the app into the following digestible mental â€˜chunksâ€™:\n\nThe app collects the inputs in the shiny::sidebarPanel()\nThese values are then used to create a plot in the shiny::mainPanel()\n\nBased on this layout, Iâ€™ll create one module to collect and return the user-inputs (mod_var_input), and another module to display the plot (mod_display_plot).\nIâ€™ll create these files using usethis::use_r() below:\n\nusethis::use_r(\"mod_var_input\")\n\nâœ” Setting active project to '/Users/mjfrigaard/projects/duap'\nâ€¢ Modify 'R/mod_var_input.R'\nâ€¢ Call `use_test()` to create a matching test file\n\nusethis::use_r(\"mod_display_plot\")\n\nâ€¢ Modify 'R/mod_display_plot.R'\nâ€¢ Call `use_test()` to create a matching test file\nThe display module also relies on a utility function (plot_points()), so I need to create a script for the utility function, which I put in a file with a name similar to the module it belongs to (i.e., utils_display_plot).\n\nusethis::use_r(\"utils_display_plot\")\n\nâ€¢ Modify 'R/utils_display_plot.R'\nâ€¢ Call `use_test()` to create a matching test file\nFinally, Iâ€™ll place the modules into basic ui and server arguments in a call to shiny::shinyApp():\n\nusethis::use_r(\"moviesApp\")\n\nâ€¢ Modify 'R/moviesApp.R'\nâ€¢ Call `use_test()` to create a matching test file\nModules consist of two functions; one in the UI (with a _ui suffix), and another in the server (with a _server suffix), but itâ€™s common practice to combine them in a single file.\nBelow is the mod_var_input module:\n\nThe ui function is stored in mod_var_input_ui:\n\nClick on Code to view the UI function in R/mod_var_input/R\n\n\n\nshow/hide\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\nThe server function is stored in mod_var_input_server:\n\nClick on Code to view the server function in R/mod_var_input/R\n\n\n\nshow/hide\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n      list(\n        \"x\" = shiny::reactive({\n          input$x\n        }),\n        \"y\" = shiny::reactive({\n          input$y\n        }),\n        \"z\" = shiny::reactive({\n          input$z\n        }),\n        \"alpha\" = shiny::reactive({\n          input$alpha\n        }),\n        \"size\" = shiny::reactive({\n          input$size\n        }),\n        \"plot_title\" = shiny::reactive({\n          input$plot_title\n        })\n      )\n    )\n  })\n}\n\n\n\nView the display module here.\n\n\n\n\nStandalone app function\nAfter Iâ€™ve written the modules and utility functions, I need to add these into a standalone app function moviesApp() (stored in R/moviesApp.R).\n\nThis file contains a call to shiny::shinyApp() and includes the module functions (in their relative positions)\n\nNote the ids in each module function pair must match to create the shared namespace.\n\n\nmoviesApp &lt;- function() {\n  # call to shinyApp()\n  shiny::shinyApp(\n\n    # UI ----\n    ui = shiny::fluidPage(\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          # UI input module ----\n          mod_var_input_ui(\"vars\")\n        ),\n        # UI display module ----\n        shiny::mainPanel(\n          mod_display_plot_ui(\"plot\")\n        )\n      )\n    ),\n\n    server = function(input, output, session) {\n      # server input module (capturing inputs) ----\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n      # server display module (rendering outputs) ----\n      mod_display_plot_server(\"plot\", \n                              var_inputs = selected_vars)\n    }\n  )\n}\n\n\n\n\nroxygen2\nWhen Iâ€™m confident my code works (and the app renders), I want to make sure these functions are properly documented by describing each function with roxygen2 tags. To quickly insert a roxygen2 skeleton, use the RStudio IDE (or the keyboard shortcut: Option + Shift + Command + R)\nThe standard roxygen2 skeleton tags include @param, @return, @export, and @examples\n\n@param lists the existing arguments (or variables) for the function\n@return should be a description of the object/side-effect/thing the function produces (and any warnings or errors if used incorrectly)\n\nThe following roxygen2 tags will be used to update the NAMESPACE file (which you should never edit manually!)\n\n@export will make the function available to other people when they use your package\n@importFrom vs.Â @import\n\nitâ€™s always a good idea to be explicit about the external functions and packages youâ€™re using, so most of the time you should use @importFrom (thereâ€™s even a handy helper usethis::use_import_from(\"package\", \"function\"))\n\n@import should only be used when â€œyou make such heavy use of so many functions from another package that you want to import its entire namespace. This should be relatively rare.â€\n\n\nroxygen2 imports and exports are covered in more depth in R packages..\nYou can see the full code for point_plot() below (or follow this link to view all the modules in the R/ folder):\n\nClick on Code to view\n\n\n\nshow/hide\n#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return plot object\n#' @export point_plot\n#'\n#' @importFrom ggplot2 ggplot aes geom_point\n#'\n#' @examples\n#' require(duap)\n#' movies &lt;- duap::movies\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n#' }\npoint_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\n\n\n\nTip: roxygen2 skeleton\n\n\n\n\n\n\nAs well as generating .Rd files, roxygen will also create a NAMESPACE for you, and will manage the Collate field in DESCRIPTION\n\n\n\n\n\n\n\nFigureÂ 3: Standard roxygen2 skeleton"
  },
  {
    "objectID": "posts/duap/index.html#test-drive",
    "href": "posts/duap/index.html#test-drive",
    "title": "Creating shiny app-packages",
    "section": "Test drive",
    "text": "Test drive\n\n\nâ€œThe load_all() function is arguably the most important part of the devtools workflow.â€ - R Packages, 2ed\n\n\nYouâ€™ll use the devtools::load_all() function frequently while youâ€™re developing your app-package. load_all() simulates how your functions will work when someone else uses your package. This removes the need to define them in the global workspace. It also gives you access to the functions from any add-on packages youâ€™ve imported into your NAMESPACE (i.e., you wonâ€™t need to run library()).\nI highly recommend using the keyboard shortcuts:\n\n\n\n\n\n\ndevtools::load_all() keyboard shortcuts\n\n\n\n\n\nmacOS: Cmd + Shift + L\nWindows/Linux: Ctrl + Shift + L\n\n\n\n\nThe full benefits of using load_all() are covered in R packages.\n\nload_all()\nAfter documenting everything with roxygen2, I want to make sure none of the functions are in my Environment (remove with rm() if necessary) and load the functions with devtools::load_all().\n\ndevtools::load_all()\n\nâ„¹ Loading duap"
  },
  {
    "objectID": "posts/duap/index.html#namespace-help-pages",
    "href": "posts/duap/index.html#namespace-help-pages",
    "title": "Creating shiny app-packages",
    "section": "NAMESPACE & Help pages",
    "text": "NAMESPACE & Help pages\ndevtools::document() processes the roxygen2 tags to generate the NAMESPACE and the .Rd files in the man/ folder. The .Rd files are used to access the help files (i.e., package::function() can be accessed with ??function).\nManaging your package NAMESPACE file is not something you do directly: itâ€™s handled with the roxygen2 tags we covered above. The keyboard shortcuts for devtools::document() are below:\n\n\n\n\n\n\ndevtools::document() keyboard shortcuts\n\n\n\n\n\nmacOS: Cmd + Shift + D\nWindows/Linux: Ctrl + Shift + D\n\n\n\n\n\ndocument()\nRun devtools::document() when youâ€™ve written a new function with roxygen2 tags or included a package in the DESCRIPTION file under Imports:\n\ndevtools::document()\n\nâ„¹ Updating duap documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\nâ„¹ Loading duap\nWriting NAMESPACE\nWriting mod_plot_ui.Rd\nWriting mod_plot_server.Rd\nWriting point_plot.Rd\nWriting mod_var_input_ui.Rd\nWriting mod_var_input_server.Rd\nWriting moviesApp.Rd\n\nNAMESPACE != DESCRIPTION\nItâ€™s important to understand that devtools::document() will use the roxygen2 tags to create the man/*.Rd files and update the NAMESPACE, but devtools::document() does not update the Imports: section in the DESCRIPTION.\nTo add packages dependencies to the DESCRIPTION, youâ€™ll need to use the usethis::use_package() function. Read more on this topic in Confusion about Imports.\nThe table below shows the connection between roxygen2 tags, the resulting NAMESPACE entry, and what should be listed in the DESCRIPTION.\n\n\n\n\n\n\n\nroxygen2, NAMESPACE & DESCRPTION\n\n\n\n\n\n\n\n\n\n\n\nroxygen2 tag\n\n\nNAMESPACE directive\n\n\nAdded in DESCRIPTION\n\n\n\n\n\n\n@importFrom\n\n\nimportFrom() : import selected object from another NAMESPACE\n\n\nNothing\n\n\n\n\n@import\n\n\nimport(): import all objects from another packageâ€™s NAMESPACE.\n\n\nImports:\n\n\n\n\n@export\n\n\nexport() : export the function, method, generic, or class so itâ€™s available outside of the package (in the NAMESPACE)\n\n\nNothing"
  },
  {
    "objectID": "posts/duap/index.html#checking-installation",
    "href": "posts/duap/index.html#checking-installation",
    "title": "Creating shiny app-packages",
    "section": "Checking installation",
    "text": "Checking installation\nAfter loading and documenting the duap package, I want to make sure I can install the package into my library with devtools::install(). The keyboard shortcut for devtools::install() is below:\n\n\n\n\n\n\ndevtools::document() keyboard shortcuts\n\n\n\n\n\nmacOS: Cmd + Shift + B\nWindows/Linux: Ctrl + Shift + B\n\n\n\n\n\ninstall()\n\ndevtools::install()\n\nâ”€â”€ R CMD build â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ”  checking for file â€˜/Users/mjfrigaard/projects/duap/DESCRIPTIONâ€™ ...\nâ”€  preparing â€˜duapâ€™: (1.8s)\nâœ”  checking DESCRIPTION meta-information\nâ”€  checking for LF line-endings in source and make files and shell scripts (520ms)\nâ”€  checking for empty or unneeded directories\n   Omitted â€˜LazyDataâ€™ from DESCRIPTION\nâ”€  building â€˜duap_0.1.0.tar.gzâ€™\n   \nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD INSTALL \n  --install-tests \n* installing to library ...\n* installing *source* package â€˜duapâ€™ ...\n** using staged installation ...\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (duap)\nRestart your R session and ensure you have a clean workspace:\n   Restarting R session...\n\n* Project '~/projects/duap' loaded. [renv 0.16.0]\nThen load your package with library():\n\nlibrary(duap)\n\nYou can also use Install icon in the Build pane, which installs the package, restarts the R session, and loads the package all with one click!\n\n\n\n\n\n\n\nFigureÂ 4: Build install package\n\n\n\n\n\n\n\n\n\nFigureÂ 5: Build restart and load\n\n\n\nRecap: the R/ folder\nThe sequence Iâ€™ve demonstrated above (create .R file, write function, document with roxygen2, load, document, install) is the â€˜minimal versionâ€™ of the full development workflow.\nOnce a â€˜betaâ€™ version of the app is deployed, you will want to come back to the app to refactor, write tests, and make sure all the items in devtools::check() pass.\nStoring the applicationâ€™s code in the R/ folder and (using RStudioâ€™s build tools) keeps files organized, well documented, and self-contained:\n\nAll the code is stored in the R/ folder\nIâ€™ve separated my code into smaller pieces (modules) that can be tested independently (more on this later)\nMy dependencies are being managed by roxygen2 and devtools::document(), which will update the NAMESPACE with any functions tagged with @importFrom (or @import)\n\nI can also access functions Iâ€™ve written outside by adding @export\n\n\n\n\n\n\n\n\n\nFigureÂ 6: Function documentation in man/ folder\n\n\nNow that I have the R version/package management being tracked and stored with renv/ & renv.lock, function documentation in the .Rd files, the DESCRIPTION and NAMESPACE, I can move onto adding and using data in a shiny app package."
  },
  {
    "objectID": "posts/duap/index.html#additional-package-files",
    "href": "posts/duap/index.html#additional-package-files",
    "title": "Creating shiny app-packages",
    "section": "Additional package files",
    "text": "Additional package files\nMost app-packages will require files beyond the .R files in the R/ folder. Apps will often use data files when theyâ€™re deployed, which weâ€™ll cover next.\n\nuse_data_raw()\nusethis::use_data() or usethis::use_data_raw() make it simple to add data to the application package:\n\nusethis::use_data_raw(\"movies\")\n\nâœ” Creating 'data-raw/'\nâœ” Writing 'data-raw/movies.R'\nâ€¢ Modify 'data-raw/movies.R'\nâ€¢ Finish the data preparation script in 'data-raw/movies.R'\nâ€¢ Use `usethis::use_data()` to add prepared data to package\nIn the data-raw/movies.R script, I want to import the movies.RData file, but where should I import it from? It depends. In R packages, data is stored in either data/ or data-raw/. To access a copy of the movies dataset in duap (i.e., with duap::movies), I can place the movies.RData file in data-raw/ and import it by adding the following to data-raw/movies.R:\n## code to prepare `movies` dataset goes here\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\nNote data-raw/movies.R includes a call to usethis::use_data(), and when itâ€™s executed, I can see a data/ folder is created and movies is saved as movies.rda:\n\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n\nâœ” Adding 'R' to Depends field in DESCRIPTION\nâœ” Creating 'data/'\nâœ” Saving 'movies' to 'data/movies.rda'\nâ€¢ Document your data (see 'https://r-pkgs.org/data.html')"
  },
  {
    "objectID": "posts/duap/index.html#installed-package-files",
    "href": "posts/duap/index.html#installed-package-files",
    "title": "Creating shiny app-packages",
    "section": "Installed package files",
    "text": "Installed package files\nThe inst/ folder plays a special role when developing R packages:\n\n\nâ€œWhen a package is installed, everything in inst/ is copied into the top-level directory of the installed packageâ€ - R Packages, 2ed\n\n\nConsider the example folder and files below: file.txt, CITATION, and extdata/my_data.csv:\n\n\n\nSource (development) form\ninst/\n  â”œâ”€â”€ file.txt\n  â”œâ”€â”€ CITATION\n  â””â”€â”€ extdata/\n        â””â”€â”€ my_data.csv\n\n\nBinary (installed) form\nfile.txt\nCITATION\nextdata/\n  â””â”€â”€ my_data.csv\n\n\n\nThe neat thing about the inst/ folder is that after weâ€™ve loaded and installed our package, we can access the files in inst/extdata/ with the system.file() function:\nIf I want to test functions in duap using movies.RData (or another dataset), those should be placed in inst/extdata/\n\ninst/\nA great way to understand what files are available in inst/ when your package is to pass system.file() to fs::dir_tree():\n\nfs::dir_tree( # wrap this in a folder tree\n  system.file(package = \"duap\"))\n\n\n\nexpand to see inst/ folder contents\n/path/to/installed/package/duap\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ INDEX\nâ”œâ”€â”€ LICENSE\nâ”œâ”€â”€ Meta\nâ”‚   â”œâ”€â”€ Rd.rds\nâ”‚   â”œâ”€â”€ data.rds\nâ”‚   â”œâ”€â”€ features.rds\nâ”‚   â”œâ”€â”€ hsearch.rds\nâ”‚   â”œâ”€â”€ links.rds\nâ”‚   â”œâ”€â”€ nsInfo.rds\nâ”‚   â””â”€â”€ package.rds\nâ”œâ”€â”€ NAMESPACE\nâ”œâ”€â”€ R\nâ”‚   â”œâ”€â”€ duap\nâ”‚   â”œâ”€â”€ duap.rdb\nâ”‚   â””â”€â”€ duap.rdx\nâ”œâ”€â”€ data\nâ”‚   â”œâ”€â”€ Rdata.rdb\nâ”‚   â”œâ”€â”€ Rdata.rds\nâ”‚   â””â”€â”€ Rdata.rdx\nâ”œâ”€â”€ extdata\nâ”‚   â””â”€â”€ movies.RData\nâ”œâ”€â”€ help\nâ”‚   â”œâ”€â”€ AnIndex\nâ”‚   â”œâ”€â”€ aliases.rds\nâ”‚   â”œâ”€â”€ duap.rdb\nâ”‚   â”œâ”€â”€ duap.rdx\nâ”‚   â”œâ”€â”€ figures\nâ”‚   â””â”€â”€ paths.rds\nâ””â”€â”€ html\n    â”œâ”€â”€ 00Index.html\n    â””â”€â”€ R.css\n\n\nThe system.file() function will show me the path to the locally installed version of the package (hence the /path/to/installed/package/ at the beginning of the path).\nThe inst/exdata/ folder comes in handy for adding example data, but itâ€™s also useful for application development (more on that later).\n\n\n\n\n\n\nThe inst/ folder\n\n\n\n\nTake a look at the inst/extdata/ folder readr::readr_example() function to understand more about how this works.\n\n\n\n\nRecap: data and installed files\nR Packages have a consistent and standardized way of storing data, and have designated locations for internal and external data.\n\n\n\n\n\n\n\nFigureÂ 7: Package data folders"
  },
  {
    "objectID": "posts/duap/index.html#documentation",
    "href": "posts/duap/index.html#documentation",
    "title": "Creating shiny app-packages",
    "section": "Documentation",
    "text": "Documentation\nFunction documentation is handled with the R/ folder and roxygen2 comments/tags, but duap needs a README file, and a place for long-form documentation. Fortuntely, RMarkdown handles each of these well:\n\nuse_readme_rmd()\nI can create a README file using usethis::use_readme_md() or usethis::use_readme_rmd()\n\nI prefer the .Rmd file because it comes with executable code chunks.\n\nusethis::use_readme_rmd()\n\nâœ” Setting active project to '/Users/mjfrigaard/projects/duap'\nâœ” Writing 'README.Rmd'\nâœ” Adding '^README\\\\.Rmd$' to '.Rbuildignore'\nâ€¢ Modify 'README.Rmd'\nâ€¢ Update 'README.Rmd' to include installation instructions.\nâœ” Writing '.git/hooks/pre-commit'\n\nWhen I knit README.Rmd, it automatically generates the README.md for the package.\n\n\n\n\nuse_vignette()\nFor long-form documentation I can use vignettes.\n\nVignettes can be created with usethis::use_vignette()\n\nusethis::use_vignette(\"duap\")\n\nâœ” Adding 'knitr' to Suggests field in DESCRIPTION\nâœ” Setting VignetteBuilder field in DESCRIPTION to 'knitr'\nâœ” Adding 'inst/doc' to '.gitignore'\nâœ” Creating 'vignettes/'\nâœ” Adding '*.html', '*.R' to 'vignettes/.gitignore'\nâœ” Adding 'rmarkdown' to Suggests field in DESCRIPTION\nâœ” Writing 'vignettes/duap.Rmd'\nâ€¢ Modify 'vignettes/duap.Rmd'\n\nVignettes are also written in RMarkdown and rendered whenever the package is built/installed.\nduap/\n    â””â”€â”€ vignettes/\n            â””â”€â”€ duap.Rmd\n\n1 directory, 1 file\nBy combining rmarkdown and knitr, R packages have a documentation framework that has the added benefit of being somewhat fool-proof: vignettes have to successfully render for the package to be installed.\n\n\n\n\n\n\n\nFigureÂ 8: Package vignettes\n\n\n\n\n\n\n\n\nVignette figures\n\n\n\n\n\n\nImages in vignettes are kept in man/figures/\nduap/\n  â”œâ”€â”€ vignettes/\n  â”‚       â””â”€â”€ duap.Rmd\n  â””â”€â”€ man/\n      â””â”€â”€ figures/\n          â””â”€â”€ duap-img-1.png\n\n\n\n\n\n\nRecap: documentation\nThe vignettes folder will long-form documentation about how the application works, use cases, and features (and roxygen2 will document each function).\n\n\n\n\n\n\n\nFigureÂ 9: Documentation in README and vignettes/"
  },
  {
    "objectID": "posts/duap/index.html#tests",
    "href": "posts/duap/index.html#tests",
    "title": "Creating shiny app-packages",
    "section": "Tests",
    "text": "Tests\nTesting is an important part of any package, and apps tend to require additional tests (especially when theyâ€™re moving from â€˜developmentâ€™ into â€˜productionâ€™ environments).\n\nuse_testthat()\nTo apply the testing framework provided by the testthat package. package, Iâ€™ll use usethis::use_testthat():\n\nusethis::use_testthat()\n\nâœ” Adding 'testthat' to Suggests field in DESCRIPTION\nâœ” Setting Config/testthat/edition field in DESCRIPTION to '3'\nâœ” Creating 'tests/testthat/'\nâœ” Writing 'tests/testthat.R'\nâ€¢ Call `use_test()` to initialize a basic test file and open it for editing.\nThis creates a new tests/ folder, with a testthat/ sub-folder and script.\nduap/\n    â””â”€â”€ tests/\n          â”œâ”€â”€ testthat/\n          â””â”€â”€ testthat.R\n        \n2 directories, 1 file\n\nWriting tests\ntestthat is designed for unit tests (i.e., testing each functional â€˜unitâ€™ in the code), but for shiny apps, we need to think beyond standard unit testing. We need to confirm the functions work and return predictable results, but we also need to make sure they play well with each other (integration tests), and that the application can be deployed (system tests).\n\n\nRecap: testing\nTesting is well described in the shiny documentation and in Mastering Shiny. Generally speaking, unit tests are performed with testthat, and module testing can be done with shiny::testServer(). To test the full application (or a specific behavior) use the shinytest2 package.\n\n\n\n\n\n\n\nFigureÂ 10: Testing framework from testthat"
  },
  {
    "objectID": "posts/duap/index.html#recap",
    "href": "posts/duap/index.html#recap",
    "title": "Creating shiny app-packages",
    "section": "Recap",
    "text": "Recap\nIâ€™ve skipped over some important development steps covered in R packages (license, using Git/GitHub, code coverage, NEWS, etc.), and you should bookmark this text as you start developing shiny app-packages. Hopefully this post has demonstrated that by building shiny apps as R packages, a suite of developer tools are available in the RStudio IDE (and the application files and folders have a uniform structure).\nduap is a substantial improvement over a vanilla shiny applicationâ€“the app-package holds the code, data, documentation, and includes explicit information on the dependencies and requirements (in the DESCRIPTION and NAMESPACE)."
  },
  {
    "objectID": "posts/test-shiny-p2/index.html",
    "href": "posts/test-shiny-p2/index.html",
    "title": "Unit tests for (non-package) shiny apps",
    "section": "",
    "text": "packages\nlibrary(testthat)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(shiny)\nlibrary(vdiffr)\nlibrary(shinytest2)\nThis post is the second in a series on testing shiny applications. Iâ€™ll cover testing shiny module server functions using the testhat package outside an R package. This application is stored in the noap GitHub repo if youâ€™d like to follow along."
  },
  {
    "objectID": "posts/test-shiny-p2/index.html#testing-module-server-functions",
    "href": "posts/test-shiny-p2/index.html#testing-module-server-functions",
    "title": "Unit tests for (non-package) shiny apps",
    "section": "Testing module server functions",
    "text": "Testing module server functions\n\nâ€¦the ABCs of testing shiny server modulesâ€¦\n\nThis post covers how shiny::testServer() works using the abcApp() shiny app.. The code for abcApp() is an RStudio project (i.e., there is a noap.Rproj file in the parent folder), but itâ€™s not part of an R package. Developing shiny applications as R packages is highly recommended, but itâ€™s possible to begin writing unit tests before your application is a fully developed shiny app-package.\nFor more information regarding performing tests outside of the package environment, see this issue on GitHub.\n\nabcApp()\nThe abcApp() application has been written using shiny modules and a single utility function.\ntestthat is designed to perform unit tests for R packages, but for the sake of simplicity,abcApp() has not been developed as part of a package. This will allow us to focus on the files involved in testing (and not all the other files that accompany R packages).\nThe standalone application function (abcApp()) is stored in app.R, the modules are contained in modules.R, and the single utility function is stored in utils.R:\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ app.R\nâ”œâ”€â”€ app.Rproj\nâ”œâ”€â”€ modules.R\nâ”œâ”€â”€ tests\nâ””â”€â”€ utils.R\n\n2 directories, 5 files\n\nThe tests folder contains the following:\ntests\nâ”œâ”€â”€ testthat\nâ”‚   â””â”€â”€ test-mod_abc_server.R\nâ””â”€â”€ testthat.R\n\n2 directories, 2 files\n\ntests/ has a testthat.R file\n\nNew test files should be placed in tests/testthat/ (see example test-mod_abc_server.R below):\n\n\n\nUI module function\nIn this small example app, both ui and server modules are stored in the modules.R file.\n\nUI module:\n\n\nmod_abc_ui() (example ui module function)\n# ui module\nmod_abc_ui &lt;- function(id) {\n\n  ns &lt;- shiny::NS(id)\n\n  shiny::tagList(\n    shiny::numericInput(\n      inputId = ns(\"num\"),\n      label = shiny::h4(\n        shiny::code(\"alphabet number\")),\n        value = 5, min = 1, max = 26\n    ),\n    shiny::verbatimTextOutput(\n      outputId = ns(\"txt\"))\n  )\n}\n\n\n\n\n\nServer module function\nThe counterpart to mod_abc_ui() is mod_abc_server():\n\nServer module:\n\n\nmod_abc_server() (example server module function)\n# server module\nmod_abc_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    # reactive \n    letter &lt;- shiny::reactive({ LETTERS[input$num] })\n    # super script\n    sup_scrpt &lt;- shiny::reactive({ \n      num_super_script(x = input$num)\n    })\n    # output\n    output$txt &lt;- shiny::renderPrint({\n      paste0(\"The \", input$num, sup_scrpt(), \n             \" letter in the alphabet is: \", letter())\n    })\n\n  })\n}\n\n\n\n\n\nModule utility function\nThe mod_abc_server() function uses the num_super_script() function stored in utils.R:\n\nUtility function:\n\n\nnum_super_script() (example utility function)\n# utility function\nnum_super_script &lt;- function(x) {\n      num &lt;- as.numeric(x)\n      if (num == 1) {\n        super_script &lt;- \"st\"\n      } else if (num == 2) {\n        super_script &lt;- \"nd\"\n      } else if (num == 3) {\n        super_script &lt;- \"rd\"\n      } else {\n        super_script &lt;- \"th\"\n      }\n    return(super_script)\n}\n\n\n\n\n\nStandalone app function\n\nStandalone app functions include a call to shiny::shinyApp():\n\n\nabcApp() (example app with modules)\n# standalone shiny app function\nabcApp &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      mod_abc_ui(\"x\")\n    ), \n    server = function(input, output, session) { \n      mod_abc_server(\"x\")\n    }\n  )\n}\nabcApp()\n\n\n\nThe call to shiny::shinyApp() is placed inside the abcApp() function\nThe ui argument is wrapped in shiny::fluidPage() and the ui module function (mod_abc_ui()) is placed inside\nThe server argument includes the standard function(input, output, session) and the module server companion functionâ€“mod_abc_server()â€“with a matching id arguments\nThe abcApp() function is stored in the app.R file\n\n\nBecause abcApp() is not part of a package, shiny and testthat are loaded and the modules and utility function are sourced in the top of the app.R file.\n\n\nsource utils.R and modules.R in app.R\n# packages --------------------------------------------------------\nlibrary(shiny)\nlibrary(testthat)\n\n# utils ------------------------------------------------------------------\nsource(\"utils.R\")\n\n# modules ------------------------------------------------------------------\nsource(\"modules.R\")\n\n\n\n\n\nUsing testServer()\nIn the test-mod_abc_server.R file, Iâ€™ll add testServer() and include the module server function as the first argument:\n\napp is the module server function (mod_abc_server) or any shiny.appobj\n\n\napp = shiny.appobj\nshiny::testServer(app = mod_abc_server, {\n\n})\n\n\n\n\nTesting input$s\n\nThe first test Iâ€™ll add will check the initial value of input$num\n\nIâ€™ll also include a custom message with cat()\n\n\n\ntest initial value with custom message\nshiny::testServer(mod_abc_server, {\n  # Test 1: check initial value\n  testthat::expect_equal(input$num, NULL)\n  cat(\"\\n Test 1 initial input$num = NULL: \", is.null(input$num), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nTest 1 initial input$num = NULL:  TRUE \n\ntestServer() allows me to set new input values with session$setInputs()\n\nUse session$setInputs() to set input$num to 3\nTest 2 confirms input$num has changed\nAdd another custom message with cat()\n\n\n\n\nsetInputs() and test inputs\nshiny::testServer(mod_abc_server, {\n  # set inputs\n  session$setInputs(num = 3)\n  # Test 2: check set inputs\n  testthat::expect_equal(input$num, 3)\n  cat(\"\\n Test 2 setInputs(num = 3):\", input$num, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 2 setInputs(num = 3): 3 \n\n\n\nTesting reactive values\n\nThe moduleâ€™s reactive values are also available to in testServer()\n\nTest 3 adds a test for sup_scrpt() (given the changed value of input$num)\n\nThe expected value is what Iâ€™m expecting num_super_script() to return.\n\n\n\n\nCheck sup_scrpt() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 3: check super script\n  testthat::expect_equal(object = sup_scrpt(), expected = \"rd\")\n  cat(\"\\n Test 3 sup_scrpt(): = 'rd':\", sup_scrpt(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 3 sup_scrpt(): = 'rd': rd  \n\nFor completeness Iâ€™ll add a test for letter()\n\n\n\nCheck letter() reactive value with expect_equal()\nshiny::testServer(mod_abc_server, {\n  # Test 4: check letter\n  testthat::expect_equal(object = letter(), expected = \"C\")\n  cat(\"\\n Test 4 letter() = C:\", letter(), \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 4 letter() = C: C \n\n\n\nTesting output$s\n\nThe module output values are also available as output$&lt;value&gt;\n\nTest 5 will verify the output$txt (given the updated input$num)\n\n\n\nCheck module output values\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\nâ”€- Failure (test-mod_abc_server.R:1:1): (code run outside of `test_that()`) â”€â”€\noutput$txt (`actual`) not equal to \"The 3rd letter in the alphabet is: C\" (`expected`).\n\n`actual`:   \"[1] \\\"The 3rd letter in the alphabet is: C\\\"\"\n`expected`: \"The 3rd letter in the alphabet is: C\"        \nBacktrace:\n  1. shiny::testServer(...)\n       at test-mod_abc_server.R:1:0\n 22. testthat::expect_equal(object = output$txt, \n   expected = \"The 3rd letter in the alphabet is: C\")\n       at test-mod_abc_server.R:17:4\n\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\nWhat happened? I forgot to add the escape characters (\\\") and line number ([1]) for the output\n\nIâ€™ll change the expected value and re-run the test:\n\n\n\n\nCheck module output values (again)\nshiny::testServer(mod_abc_server, {\n  # Test 5: check output\ntestthat::expect_equal(object = output$txt,\n  expected =  \"The 3rd letter in the alphabet is: C\")\ncat(\"\\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \\n\",\n  output$txt, \"\\n\")\n})\n\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \n\nFinally, Iâ€™ll run the tests with test_dir()\n\n\ntest_dir(path = \"/path/to/app/tests/testthat/\")\n\nâœ” | F W S  OK | Context\nâ  |         0 | mod_abc_server         \n\n Test 1 initial input$num = NULL:  TRUE \n\n Test 2 setInputs(num = 3): 3 \n\n Test 3 sup_scrpt(): = 'rd': rd \n\n Test 4 letter() = C: C \n\n Test 5 output$ = 'The 3rd letter in the alphabet is: C': \n [1] \"The 3rd letter in the alphabet is: C\" \nâœ” |         5 | mod_abc_server\nâ•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nDuration: 0.2 s\n [ FAIL 0 | WARN 0 | SKIP 0 | PASS 5 ]\nğŸŒˆ Your tests are over the rainbow ğŸŒˆ\n\nThe results show the tests passed! Now I am confident inputs, reactive values (sup_scrpt() & letter()), outputs behave as expected.\n\n\n\nRecap\nThe example above provides a workflow for using testServer() with testthat outside a package environment. The checklist below summarizes the steps required to test your applicationâ€™s module server functions:\n\nCreate test files (in tests/testthat/)\n\nAll test files should have the test- prefix\n\nVerify inputs with session$setInputs(inputId = &lt;value&gt;)\n\nAll input$ values should initially be NULL\n\nTest reactive values by referring to them as you would in the module server\n\nCompare expected values after changing inputs with session$setInputs()\n\nTest outputs using output$&lt;value&gt; to check changes to the inputs and reactives\n\nCheck output values with output$txt\n\n\nThis concludes running tests on abcApp(). Ideally, shiny applications are developed as an R package (which Iâ€™ll cover in a future post), but now you know how to perform tests if this isnâ€™t the case. The files for this demonstration are located here.\nFor a more comprehensive review of testing, check out the chapters on testing in R packages and Mastering Shiny."
  },
  {
    "objectID": "series.html",
    "href": "series.html",
    "title": "Series",
    "section": "",
    "text": "These posts focus on testing shiny applications with testthat, shiny::testServer(), and shinytest2.\n\n\n\n\n\n\nTypes of tests\n\n\n\n\n\n\n\ntestthat: testthat is a popular unit testing framework that allows R package developers to create tests scripts for functions and logic systematically. In a shiny app-package, itâ€™s used for testing the non-reactive components (i.e., utility functions). This includes functions for data processing, plots, modeling, and other code thatâ€™s part of the package. However, it is not designed to work with shinyâ€™s reactive model.\ntestServer(): testServer() comes from the shiny package and is designed to test the server-side logic of your app. These tests can be used to simulate user inputs and verify the corresponding outputs. testServer() can also test the functionality of module server functions (reactivity, outputs, and any returned values) in isolation from their UI function counterparts. However, testServer() doesnâ€™t capture how UI elements are rendered or simulate key user interactions (i.e., execution paths) through the application.\nshinytest2(): shinytest2 is designed to perform end-to-end testing of shiny apps. These tests can capture a shiny appâ€™s current state (i.e., a snapshot) and compare it with a previously saved (or expected) states. Snapshots are useful for end-to-end testing because they can simulate key user interaction in a way that unit tests and testServer() canâ€™t (i.e., the delay between input changes and rendering updated outputs, specific sequences of selections on action buttons, radio buttons, etc.). shinytest2 tests are resource-intensive, so itâ€™s recommended to write these tests after writing testthat unit tests and testServer() tests.\n\nIn summary, use testthat for unit testing utility/helper functions, then testServer() for the server-side logic, and finish off with shinytest2 tests for end-to-end functionality of your shiny app. These tools complement each other to provide a comprehensive testing framework.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDate\n\n\n\n\n\n\nUnit testing shiny utility functions\n\n\nMay 1, 2023\n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nMay 7, 2023\n\n\n\n\nTesting shiny module server functions\n\n\nJun 20, 2023\n\n\n\n\nTesting shiny apps with shinytest2\n\n\nJul 4, 2023\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\nUnit testing shiny utility functions: This post covers unit testing a set of utility functions with testthat. You can also read the documentation from the package website, in R packages, and in Mastering Shiny. The app-package for this post is stored in this Github Repo.\n\nPackage website\n\nUnit tests for (non-package) shiny apps: Your shiny app should be developed as a package, but this isnâ€™t always the case. If youâ€™d like to test your applicationâ€™s code without converting it to a package, check out the second post (GitHub repo with the code).\nTesting shiny module server functions: If youâ€™ve built your shiny application as a package and it contains modules, this post covers testing module server functions using the examples from the â€˜Modulesâ€™ chapter of Mastering Shiny. The code and examples are in this GitHub repo\n\nPackage website\n\nTesting shiny apps with shinytest2: This post picks up where the previous post left off with the shinytest2 package. The app-package used in the examples is stored in this GitHub repo.\n\nPackage website"
  },
  {
    "objectID": "series.html#testing-shiny-applications",
    "href": "series.html#testing-shiny-applications",
    "title": "Series",
    "section": "",
    "text": "These posts focus on testing shiny applications with testthat, shiny::testServer(), and shinytest2.\n\n\n\n\n\n\nTypes of tests\n\n\n\n\n\n\n\ntestthat: testthat is a popular unit testing framework that allows R package developers to create tests scripts for functions and logic systematically. In a shiny app-package, itâ€™s used for testing the non-reactive components (i.e., utility functions). This includes functions for data processing, plots, modeling, and other code thatâ€™s part of the package. However, it is not designed to work with shinyâ€™s reactive model.\ntestServer(): testServer() comes from the shiny package and is designed to test the server-side logic of your app. These tests can be used to simulate user inputs and verify the corresponding outputs. testServer() can also test the functionality of module server functions (reactivity, outputs, and any returned values) in isolation from their UI function counterparts. However, testServer() doesnâ€™t capture how UI elements are rendered or simulate key user interactions (i.e., execution paths) through the application.\nshinytest2(): shinytest2 is designed to perform end-to-end testing of shiny apps. These tests can capture a shiny appâ€™s current state (i.e., a snapshot) and compare it with a previously saved (or expected) states. Snapshots are useful for end-to-end testing because they can simulate key user interaction in a way that unit tests and testServer() canâ€™t (i.e., the delay between input changes and rendering updated outputs, specific sequences of selections on action buttons, radio buttons, etc.). shinytest2 tests are resource-intensive, so itâ€™s recommended to write these tests after writing testthat unit tests and testServer() tests.\n\nIn summary, use testthat for unit testing utility/helper functions, then testServer() for the server-side logic, and finish off with shinytest2 tests for end-to-end functionality of your shiny app. These tools complement each other to provide a comprehensive testing framework.\n\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDate\n\n\n\n\n\n\nUnit testing shiny utility functions\n\n\nMay 1, 2023\n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nMay 7, 2023\n\n\n\n\nTesting shiny module server functions\n\n\nJun 20, 2023\n\n\n\n\nTesting shiny apps with shinytest2\n\n\nJul 4, 2023\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\nUnit testing shiny utility functions: This post covers unit testing a set of utility functions with testthat. You can also read the documentation from the package website, in R packages, and in Mastering Shiny. The app-package for this post is stored in this Github Repo.\n\nPackage website\n\nUnit tests for (non-package) shiny apps: Your shiny app should be developed as a package, but this isnâ€™t always the case. If youâ€™d like to test your applicationâ€™s code without converting it to a package, check out the second post (GitHub repo with the code).\nTesting shiny module server functions: If youâ€™ve built your shiny application as a package and it contains modules, this post covers testing module server functions using the examples from the â€˜Modulesâ€™ chapter of Mastering Shiny. The code and examples are in this GitHub repo\n\nPackage website\n\nTesting shiny apps with shinytest2: This post picks up where the previous post left off with the shinytest2 package. The app-package used in the examples is stored in this GitHub repo.\n\nPackage website"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "@mjfrigaard",
    "section": "",
    "text": "Testing shiny apps with shinytest2\n\n\nPart 4: recording tests and snapshots\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJul 4, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nTesting shiny module server functions\n\n\nPart 3: Using testthat and testServer()\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nDebugging in RStudio\n\n\nDeveloping code with browser()\n\n\n\n\ncode\n\n\ndebugging\n\n\n\n\n\n\n\n\n\n\n\nJun 1, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nPart 2: Testing in non-package shiny apps\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 7, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nUnit testing shiny utility functions\n\n\nPart 1: Unit tests in shiny app-packages\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 1, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nWriting modular code with box\n\n\n\n\n\n\n\npackages\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 21, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\npurrr updates (v1.0.0)\n\n\n\n\n\n\n\niteration\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\n  \n\n\n\n\nCreating shiny app-packages\n\n\nBuilding a shiny app within an R package: whole-game\n\n\n\n\nshiny\n\n\nusethis\n\n\ndevtools\n\n\npackages\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2023\n\n\nMartin Frigaard\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! I am Martin Frigaard. This is my personal blog where I write about projects Iâ€™m currently working on (or topics Iâ€™m thinking about).\nIn my professional life, Iâ€™m a data visualization engineer at Atorus Research where I build shiny applications and write R packages. I also create training materials and workshops on data management, visualizations, and reproducible research. I have 15 years of experience with data analysis, statistics, and research. Iâ€™m also a fully certified tidyverse trainer.\nCheck out my other website here."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "@mjfrigaard",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTesting shiny apps with shinytest2\n\n\nPart 4: recording tests and snapshots\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJul 4, 2023\n\n\n\n\n\n\n\n\nTesting shiny module server functions\n\n\nPart 3: Using testthat and testServer()\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2023\n\n\n\n\n\n\n\n\nDebugging in RStudio\n\n\nDeveloping code with browser()\n\n\n\n\ncode\n\n\ndebugging\n\n\n\n\n\n\n\n\n\n\n\nJun 1, 2023\n\n\n\n\n\n\n\n\nUnit tests for (non-package) shiny apps\n\n\nPart 2: Testing in non-package shiny apps\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 7, 2023\n\n\n\n\n\n\n\n\nUnit testing shiny utility functions\n\n\nPart 1: Unit tests in shiny app-packages\n\n\n\n\nshiny\n\n\ntesting\n\n\n\n\n\n\n\n\n\n\n\nMay 1, 2023\n\n\n\n\n\n\n\n\nWriting modular code with box\n\n\n\n\n\n\n\npackages\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 21, 2023\n\n\n\n\n\n\n\n\npurrr updates (v1.0.0)\n\n\n\n\n\n\n\niteration\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2023\n\n\n\n\n\n\n\n\nCreating shiny app-packages\n\n\nBuilding a shiny app within an R package: whole-game\n\n\n\n\nshiny\n\n\nusethis\n\n\ndevtools\n\n\npackages\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2023\n\n\n\n\n\n\nNo matching items"
  }
]