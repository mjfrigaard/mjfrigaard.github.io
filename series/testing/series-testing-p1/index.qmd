---
title: "How do I test shiny utility functions?" 
subtitle: "Part 1: Unit tests in shiny app-packages"
author: "Martin Frigaard"
date: "2023-05-01"
categories: [shiny, testing]
image: "image.png"

callout-icon: false

freeze: true

execute:
  echo: true
  warning: false
  eval: false
  collapse: true
---

```{r}
#| label: setup
#| eval: true 
#| echo: false 
#| include: false
library(ggplot2)
library(dplyr)
library(shiny)
library(vdiffr)
library(testthat)
library(shinytest2)
options(width = 60)
source("https://raw.githubusercontent.com/mjfrigaard/utap/main/tests/testthat/helper.R")
# remotes::install_github("mjfrigaard/utap", force = TRUE, quiet = TRUE)
library(utap)
co_box <- function(color, header, contents = "Your text") {
  class <- switch(color,
    b = "note",
    g = "tip",
    r = "important",
    o = "caution",
    stop("Invalid `type`", call. = FALSE)
  )
  switch(color,
  b = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  g = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  o = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  r = cat(paste0(
    "\n",
    ":::: {.callout-", class, " collapse='false'}", "\n\n",
    "## ", header, "\n\n", 
    "::: {style='font-size: 1.10em; font-weight: bold; color: #696969;'}\n\n",
    glue::glue_collapse(contents), "\n\n",
    "::: \n\n",
    "::::", "\n")),
  stop("Invalid `type`", call. = FALSE)
  )
}
options(scipen = 999)
```

```{r}
#| label: pkgs
#| code-summary: packages
#| eval: true
library(testthat)
library(lobstr)
library(dplyr)
library(shiny)
library(covr)
```


```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: false
co_box(color = "r", header = "ALERT!", "This post is currently under development. Thank you for your patience.")
```

This post is the first in a series on testing shiny applications. I'll cover developing and testing a set of utility functions for a shiny app-package using [`testhat`](https://testthat.r-lib.org/). If you'd like to follow along, all the code I'll be using is contained in the [`utap` R package on GitHub](https://github.com/mjfrigaard/utap).

```{r}
#| label: install_utap
#| eval: true 
#| results: hide
#| code-fold: false
#| include: true
# renv::install("mjfrigaard/utap")
library(utap)
```

## Shiny app-packages

Testing the code in shiny app-packages can be more complicated than testing the code in a typical R package, because app-packages contain two types of code: 

1) **Application code**: functions designed to run the application  (i.e., the `ui` and `server` functions, modules, standalone app functions will a call to `shinyApp()`, etc.)

2) **Everything else**: functions or code used for connecting to databases, uploading, importing, or manipulating data, building visualizations and/or tables, generating custom HTML layouts, etc. The non-application code and functions in app-packages are typically referred to as '[utility](https://engineering-shiny.org/build-app-golem.html?#submodules-and-utility-functions)' or '[helper](https://mastering-shiny.org/scaling-functions.html#file-organisation)' functions

These two types of code require different types of tests. Utility functions are usually accompanied by unit tests similar to the tests you'd find in a [standard R package](https://r-pkgs.org/testing-basics.html), while application code is tested using the [`shiny::testServer()`](https://shiny.posit.co/r/reference/shiny/1.7.0/testserver) function, or with the [`shinytest2` package](https://rstudio.github.io/shinytest2/). 

This post will cover writing unit tests for a set of utility functions using [`testthat`](https://testthat.r-lib.org/) and [`covr`](https://covr.r-lib.org/). Any tips or time-savers I've found will be in green callout boxes:

```{r}
#| label: co_box_tip
#| echo: false
#| results: asis
#| eval: true
co_box(color = "g", header = "TIP!", "This is a tip!")
```

## What are unit tests?

::: {.column-margin}
![](testthat.png){width=40%}
:::


> "*A unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed. A unit test’s scope can span as little as a method or as much as multiple classes.*" - [The Art of Unit Testing, 2nd edition](https://www.manning.com/books/the-art-of-unit-testing-second-edition)

I've found thinking of functions as 'units of work' and their desired behavior as an 'end results' provides a useful mental model during TDD. These terms also align nicely with the testing advice offered by  [`testthat`](https://r-pkgs.org/testing-design.html#sec-testing-design-principles): 

> *Strive to test each behaviour in one and only one test. Then if that behaviour later changes you only need to update a single test.*

In app-packages, the `testthat` package provides a comprehensive and flexible framework for performing unit tests. 

### testthat

Get started with `testthat` in your app-package by running [`usethis::use_testthat()`](https://usethis.r-lib.org/reference/use_testthat.html). This function will create following files and folders: 

```{verbatim}
#| code-summary: testthat folder
#| eval: false
#| code-fold: show
#| echo: true
tests/
  ├── testthat/
  └── testthat.R
```

To create new tests, run `usethis::use_test("utils_fun")` (with `"utils_fun"` being the name of the function you'd like to test).

```{r}
#| code-fold: false
#| eval: false
usethis::use_test("utils_fun")
```

```{verbatim}
#| code-fold: false
#| eval: false
✔ Setting active project to '/projects/apps/utap'
✔ Writing 'tests/testthat/test-utils_fun.R'
• Modify 'tests/testthat/test-utils_fun.R'
```


#### Test files

New test files are be created and opened from the `tests/testthat/` folder (with a `test-` prefix).

-   The initial contents of a new test file contains the boilerplate code below:

    ```{r}
    #| code-fold: false
    #| eval: false
    test_that("multiplication works", {
      expect_equal(2 * 2, 4)
    })
    ```
    
::: {.column-margin}

![testthat test file](testthat-test-file.png){#fig-test-files width=60%}

Test files
:::

#### Test structure 

`test_that()` sets the test "scope" or "execution environment", and encapsulates the expectations. 

-   Note the use of curly brackets after the `code` argument:

    ```{r}
    #| code-fold: false
    #| eval: false
    testthat::test_that(desc = "description", code = {
      
    })
    ```
    

::: {.column-margin}

![tests](testthat-tests.png){#fig-tests width=90%}

`testthat` test
:::
    
#### Expectations

Test expectations are the code that comes into direct contact with the *unit of work* and *end result* for each function. There are usually multiple expectations for any given function, so these are stored in **tests** (and the `desc` describes the test context for the set of expectations).

-   All `testthat` expectations have an `expect_*` prefix:

    ```{r}
    #| code-fold: false
    #| eval: false
    testthat::expect_equal(object = 2 * 2, expected = 4)
    ```
    
::: {.column-margin}

![expectations](testthat-expectation.png){#fig-expectations width=40%}

`testthat` expectation
:::


#### Unit test development workflow

I develop unit tests using the following workflow:  

1. **Create the test file and R script**: I'll start by creating these files with `usethis::use_r()` and `usethis::use_test()`, even if I know the names of these files will likely change as I develop (see more below).

2. **Define test context**: I use the test context (entered as a character string in the first argument of `testthat::test_that()`) to capture each "unit of work" for each function. I like to keep the test context short and sweet--the "unit of work" followed by "works" will suffice in most circumstances, unless there's a need for more specific details.

3. **Write expectations:** These are the third item in the workflow, but conceptually these comes first--these are the "end results" I want from each function (i.e., compute a value, download a file, create a column, etc.). 

Tests and expectations are grouped into test files based on their related objectives or goals, and should correspond to a similar `.R` file in the `R/` folder. 

While this workflow is probably not *technically* considered [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development), I *do* set up the tests before I start writing any code in the `R/` folder. This comes in handy if you're having to remind yourself where you stopped developing on a given project--I'll just run `devtools::test()` and the first failing test reminds me where to look.

:::: {.callout-tip collapse='true'}
## TIPS: Unit tests
::: {style='font-size: 1.10em; color: #696969;'}

The advice on unit tests below (in **bold**) comes from [Effective Software Testing, 2022](https://www.manning.com/books/effective-software-testing). I've included descriptions of how `testthat` satisfies each recommendation:

1) **Unit tests should be fast**: the text recommends unit tests take a '*couple of milliseconds*' to execute. `testthat` tests typically fall within this threshold (and provide time measurements to identify bottlenecks).

2) **Unit tests are easy to control**: i.e., '*input values and the expected result value are easy to adapt or modify in the test*.' `testthat` expectations give us ample access to 1) the `expected` result and 2) the `observed` result. 

3) **Unit tests are easy to write**: i.e., '*do not require a complicated setup or additional work*'. When used combination with `usethis`, `testthat` unit tests can be set up, created, written, and run with a few lines of code: 
  
   1.   `usethis::use_testthat()`     
   2.   `usethis::use_test()`    
   3.    `< write test >`    
   4.    `testthat::test_file()`, `testthat::test_dir()`, or `devtools::test()`   
  

::: 
::::

## App utility functions

The utility functions I'll be developing are designed to populate the `choices` argument for  `shiny::selectInput()`. For example, the `pull_numeric_cols()` function would 'pull' the column names from an input `data.frame` or `tibble` (the example below uses `palmerpenguins::penguins`):

```{r}
#| eval: false 
#| echo: true
#| code-fold: false 
pull_numeric_cols(palmerpenguins::penguins)
```

```{r}
#| eval: true
#| echo: false
palmerpenguins::penguins |> 
  dplyr::select(dplyr::where(is.numeric)) |> 
  colnames() |> 
  purrr::set_names()
```

The return values would be passed to an `updateSelectInput()` in the `server` to provide column names by `type` (i.e., numeric, binary, or categorical). These functions can be used to quickly group variables into groups for data visualizations. For example, binary variables can be mapped the color aesthetic (if using `ggplot2`), and custom functions can be created for other graph layers (i.e., facets).

The **unit of work** for each hypothetical `pull_[type]_cols()` function would be, "*ingest a `data.frame` or `tibble` and identify columns by `type`*,"  and their **end result** might be "*return a (named) vector of column names by `type`.*" In this case, `[type]` refers to the variable type (i.e., numeric, categorical, binary, etc.). See the hypothetical UI output example below:

```{r}
#| eval: false
#| echo: true 
#| code-fold: false 
# UI code
shiny::selectInput(
  inputId = ns("x"),
  label = "X variable:",
  choices = NULL
)
```


```{r}
#| eval: false
#| echo: true 
#| code-fold: false 
# server code
shiny::observe({
  num_vars <- pull_numeric_cols(df = data())
  shiny::updateSelectInput(session,
    inputId = "x",
    choices = num_vars,
    selected = num_vars[1])
  }) |>
  shiny::bindEvent(data(),
    ignoreNULL = TRUE)
```

In the example above, `pull_numeric_cols()` is passed a reactive dataset (`data()`), and the output is used to update the `selectInput()`.

```{r}
#| eval: true
#| echo: false 
library(palmerpenguins)
shiny::selectInput(
  inputId = "num_cols", 
  label = "X variable:",
  choices = palmerpenguins::penguins |> 
  dplyr::select(dplyr::where(is.numeric)) |> 
  colnames() |> 
  purrr::set_names()
  )
```

<br>

## Micro-iteration

In [R packages](https://r-pkgs.org/testing-basics.html#run-tests), micro-iteration is defined as, "*the interactive phase where you initiate and refine a function and its tests in tandem.*" If you're using [TDD](https://en.wikipedia.org/wiki/Test-driven_development?oldformat=true), you'll write the test first, then write the function to pass the test.

The first unit test I'll create is for `select_column_class()`, a function designed to return columns according to their `class()`. 

#### Function names 

Coming up with names for functions can be challenging. I like to follow the [`tidyverse` style guide](https://style.tidyverse.org/syntax.html#object-names) and use short verbs as a prefix (`make_`, `get_`, `check_` etc.). I also like to use names that give 'future' me hints as to their behavior (i.e., `select_column_class()` imports and has similar behavior to `dplyr::select()`, while `pull_[type]_cols()` is more like `dplyr::pull()`)

### Create test file 

I create the test file and function file in the **Console**

```{r}
#| eval: false
#| echo: true
#| code-fold: false
usethis::use_test("select_column_class")
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
✔ Setting active project to '/projects/apps/utap'
✔ Writing 'tests/testthat/test-select_column_class.R'
• Modify 'tests/testthat/test-select_column_class.R'
```

```{r}
#| eval: false
#| echo: true
#| code-fold: false
usethis::use_r("select_column_class")
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
• Modify 'R/select_column_class.R'
```

### Test context 

The test context (entered as a character string in the first argument of `testthat::test_that()`) includes the "unit of work" for the function, followed by "works":

```{r}
#| eval: false
#| echo: true
#| code-fold: false
testthat::test_that(desc = "select_column_class() is.tibble/is.data.frame works", {
  
})
```

Before I can start developing the `select_column_class()` function and it's tests, I'll need data. R comes with example data objects in the `datasets` package, but it's nice to have control over the data being used in your unit tests. I'll cover how to add test data available in your app-package.

### Test data

Creating test data is covered in [R packages](https://r-pkgs.org/testing-design.html#storing-test-data), but I'll summarize the key points: 

1. Test data (and other objects) can either be created within a test, or as a persistent [test fixture](https://r-pkgs.org/testing-advanced.html#sec-testing-advanced-concrete-fixture)  
2. Test data fixtures should be stored in `tests/testthat/fixtures/<test_data.rds>`
2. The code used to create any test data fixtures should be stored in the same folder with a `make_` prefix (i.e., `tests/testthat/fixtures/<make_test_data.R>`)

This is easier to picture with a demonstration: In the `tests/testthat/` folder, I'll create a new `fixtures` folder, and add a `make_testdata_col_class.R` file. 

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
tests/testthat/
        └── fixtures/
                └── make_testdata_col_class.R
```

In `make_testdata_col_class.R`, I'll create `testdata_col_class` using the code below:

```{r}
#| eval: true
#| echo: true
#| code-fold: true 
#| code-summary: 'test_data for test-select_column_class.R'
testdata_col_class <- tibble::tibble(
 log_var = c(TRUE, FALSE, TRUE),
 int_var = c(1L, 2L, 3L),
 dbl_var = c(1.1, 2.2, 3.3),
 chr_var = c("item:1", "item:2", "item:3"),
 fct_var = factor(
   c("group 1", "group 2", "group 3"),
   levels = c(
     "group 1", "group 2", "group 3")),
 ord_var = factor(
   c("level 1", "level 2", "level 3"),
   levels = c("level 1", "level 2", "level 3"),
   ordered = TRUE),
 list_var = list(
   log_vec = c(TRUE, FALSE),
   dbl_vec = c(1.1, 2.2),
   chr_var = c("item:1", "item:2")))
```

```{r}
#| eval: true
#| echo: true
#| code-fold: false
testdata_col_class
```

I'll save `testdata_col_class` in `tests/testthat/fixtures/` as `testdata_col_class.rds`: 

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
tests/testthat/
        └── fixtures/
                ├── make_testdata_col_class.R
                └── testdata_col_class.rds
```

To load the data into my test, I'll add the following to the top of the test context: 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
test_that(desc = "select_column_class() is.tibble/is.data.frame works", {
  testdata_col_class <- readRDS(test_path("fixtures", "testdata_col_class.rds"))
  
})
```

`testthat::test_path()` will load the data from the testing directory when I'm ready to run my test.  

### Expectations

In `expect_equal()`, I'll verify the structure of the returned `object` is a `data.frame`/`tibble`. 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
test_that("select_column_class() is.tibble/is.data.frame works", {
  testdata_col_class <- readRDS(test_path("fixtures", "testdata_col_class.rds"))
  # check tibble
  testthat::expect_equal(
    object =
      select_column_class(
        df = testdata_col_class,
        class = "???") |>
          tibble::is_tibble(),
    expected = TRUE)
})
```

Writing my expectations first forces me to make some decisions about what the arguments will be for the `select_column_class()` function (i.e., `df` and `class`). 


`select_column_class()` should return the columns according to their `class`, so I'll tests to verify the class of the return columns. 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
  # check logical
  testthat::expect_equal(
    object =
      select_column_class(
        df = testdata_col_class,
        class = "log") |>
          lapply(is.logical) |> unlist() |> unique(),
    expected = TRUE)
```


I try to write these in a way that's flexible (should the test data change in the future). 

:::: {.callout-tip collapse='true'}
# **Expectation-Driven Development**

Whether or not you decide to adopt Test-Driven Development, I strongly recommend writing test expectations while you're developing functions. It's a great opportunity to clarify a function's intended behaviors, arguments, and error/warning messages.

::::

After including tests for each class, I'll include a test for the error message from `select_column_class()` with `testthat::expect_error()`: 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
# test error type
testthat::test_that("select_column_class() type error", {
  testdata_col_class <- readRDS(test_path("fixtures", "testdata_col_class.rds"))
  # test type error
  testthat::expect_error(
    object = select_column_class(
      df = testdata_col_class, 
      class = "array")
  )
})
```

When I've covered my intended 'end results' for `select_column_class()` (i.e., when it works and what happens when it doesn't), I'll write the function: 

```{r}
#| eval: true
#| echo: true
#| code-fold: true 
#| code-summary: 'select_column_class()'
select_column_class <- function(df, class) {

  col_class <- function(df, class) {
    switch(class,
      log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),
      int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),
      dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),
      chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),
      fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),
      ord = dplyr::select(tibble::as_tibble(df), dplyr::where(is.ordered)),
      list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list))
    )
  }

  cl <- unique(class)
  cl_check <- cl %nin% c("log", "int", "dbl", "chr", "fct", "ord", "list")
  if (any(cl_check)) {
    cli::cli_abort("Invalid `class` argument. Must be one of:\n
          'log', 'int', 'dbl', 'chr', 'fct', 'ord', 'list'")
  }

  col_list <- purrr::map(.x = class, .f = col_class, df = df)

  df_cols <- purrr::list_cbind(col_list, size = nrow(df))

  if (ncol(df_cols) < 1 || nrow(df_cols) < 1) {
    df_cols <- structure(list(),
      class = c("tbl_df", "tbl", "data.frame"),
      row.names = integer(0),
      names = character(0)
    )
    return(df_cols)
  } else {
    return(df_cols)
  }
}
```


#### Recap: test data

Below is a summary of tips for adding data your tests. 

::: {#fig-unit_test_dep_data}

![Unit test fixtures](unit_test_dep_data.png){#fig-unit_test_dep_data width=100%}

Unit test fixtures 
:::

## Mezzo-iteration

The `select_column_class()` will return a `tibble()` with the columns matching the `class` argument, but I'll also need an argument that allows me to adjust the returned object to a named character vector.  

That's the job of `get_column_class()`--this is a wrapper around `select_column_class()` with an additional `return_tbl` argument that, if `FALSE`, returns the column names as a named vector. 

#### Abstract syntax trees

While developing R functions, I've found the `ast()` function from the [`lobstr` package](https://lobstr.r-lib.org/reference/ast.html) can be great for keeping track of nested function calls.

For example, `select_column_class()` has a nested `col_class()` function that isn't tested directly. So how do I make sure I'm keeping track of these nested functions in case they throw an error? I'll build an abstract function tree for the function in the [documentation](https://github.com/mjfrigaard/utap/blob/main/vignettes/utap.Rmd).

Below is the abstract syntax tree for `select_column_class()`:

```{r}
#| eval: true
#| echo: false
#| code-fold: false
#| collapse: false
lobstr::ast(
    select_column_class(col_class())
)
```

The tree above is simple--it only has two functions so far--but as packages grow these abstract displays become more important for tracking function calls (and tests!).

### Combining tests

`get_column_class()` calls `select_column_class()`, so I'll place both unit tests in the `tests/testthat/test-column_classes.R` file, and create the corresponding [`R/column_classes.R` file](https://github.com/mjfrigaard/utap/blob/main/R/column_classes.R)

To capture these nested functions visually, I'll include a function tree in a vignette or other source documentation. 

```{r}
#| eval: true
#| echo: false
#| code-fold: false
#| collapse: false
lobstr::ast(
    get_column_class(select_column_class(col_class()))
)
```



I've combined `select_column_class()` and `get_column_class()` into a single file because I know every `pull_[type]_cols()` function would use `get_column_class()`. The following function tree captures this relationship. 

```{r}
#| eval: true
#| echo: false
#| code-fold: false
#| collapse: false
lobstr::ast(
    get_column_class(
      select_column_class(col_class()),
    pull_binary_cols(),
    pull_facet_cols(),
    pull_cat_cols(),
    pull_numeric_cols())
  )
```



:::: {.callout-tip collapse='true'}
# **Function file names**

In shiny app-packages, it's common to combine related functions (i.e., function families) into a single `.R` file with a prefix. 

For example, a standalone app function combines the code that would otherwise sit in `ui.R` and `server.R`. 

```{r}
#| eval: false
#| echo: true
#| code-fold: false 
myApp <- function() {
  shiny::shinyApp(ui = 
      shiny::tagList(
        # code from ui.R
      ),
      server = # code from server.R
    )
}
```


Other files that are automatically run with a standard shiny app (i.e., `global.R` or `helpers.R` files that used to load data, set themes/colors, etc.,) can be converted into functions and/or package files based on their purpose. For more information on organizing your `R/` folder, read [this section in R Packages](https://r-pkgs.org/code.html#sec-code-organising).

Also check out `golem::add_utils()` and `golem::add_fct()` for creating function files specific to shiny modules. 
::::

In the `test-column_classes.R` test file, I'll need more data for testing, but rather than create test data files for each test, I'll use test helpers to create the test data.

### Test helpers

Test helpers are stored in `tests/testthat/helper.R` and usually contain functions or code that 1) is too long to repeat with each test, and 2) doesn't take too much time or memory to run. Read more about test helpers  [here.](https://r-pkgs.org/testing-advanced.html#sec-testing-advanced-fixture-helper) 

I've created a [set of test helpers](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/helper.R) in `utap` for creating different kinds of test data (because I'll be repeatedly defining columns with slightly different attributes). 

For example, `col_maker()` can be used to create a `tibble` with columns based on the `col_type`, `size`, and `missing`:

```{r}
#| eval: true
#| echo: true
#| collapse: true
#| code-fold: false 
col_maker(col_type = c("log", "int", "dbl", 
                       "chr", "fct", "ord"),
          size = 6,
          missing = TRUE)
```

I can also create tibbles with custom columns using individual helper `_maker()` functions: 

```{r}
#| eval: true
#| echo: true
#| collapse: true
#| code-fold: false 
tibble::tibble(
    log_var = log_maker(size = 2),
    int_var = int_maker(size = 2),
    dbl_var = dbl_maker(size = 2),
    chr_var = chr_maker(size = 2),
    list_var = list(fct_var = fct_maker(size = 3), 
                    ord_var = ord_maker(size = 3)),
)
```

These helpers make it easier to iterate through the test expectations *and* function development, because `tibble`s like the one above can be developed *inside* each test. 

-   Below is an example for testing if `get_column_class()` will correctly identify the `logical` columns (for both return objects):

    ```{r}
    #| eval: false
    #| echo: true
    #| code-fold: true
    #| code-summary: 'using test helpers' 
    testthat::test_that("get_column_class() logical", {
      # test logical class
      testthat::expect_equal(
        object = get_column_class(
          # use test helper
          df = col_maker(
            col_type = c("log", "int", "dbl", "chr"),
              size = 6,
              missing = FALSE,
              lvls = 4),
          class = "log") |>
          unlist() |>
          is.logical(),
        expected = TRUE
      )
      # test logical names
      testthat::expect_equal(
        object = get_column_class(
          # use test helper
          df = col_maker(
            col_type = c("log", "int", "dbl", "chr"),
              size = 6,
              missing = FALSE,
              lvls = 4),
         class = "log",
          return_tbl = FALSE
        ),
        expected = c(log_var = "log_var")
      )
    })
    ```


When I'm confident with the `get_column_class()` function and it's tests, I'll save the test file and run `testthat::test_file()`.

```{r}
#| eval: true
#| echo: true
#| code-fold: true 
#| code-summary: 'show/hide get_column_class()'
get_column_class <- function(df, class, return_tbl = TRUE) {
  if (isFALSE(return_tbl)) {
    col_types_df <- select_column_class(df, class = class)
    nms <- names(col_types_df)
    col_types <- purrr::set_names(nms)
  } else {
    col_types <- select_column_class(df, class = class)
  }
  return(col_types)
}
```

```{r}
#| eval: false
#| echo: true
#| code-fold: false 
testthat::test_file("tests/testthat/test-column_classes.R")
```

```{verbatim}
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 23 ]
```

### Test coverage 

*How many tests should I write?* 

As function behavior grows in complexity, so does the number of expectations. In `testthat`, expectations are captured in tests, and code coverage measures the extent to which the tests in the `tests/testthat/` folder cover the possible execution paths of the functions in the `R/` folder (i.e. the package codebase). 

Code test coverage is a way to confirm that the unit tests are robust enough to verify that your code behaves as expected. In R packages, code coverage is discussed in the [testing chapter](https://r-pkgs.org/testing-design.html#sec-testing-design-coverage) using the [`covr` package](https://covr.r-lib.org/).

### Check coverage interactively 

During development, check the code coverage of a test file with `devtools::test_coverage_active_file()`, or, if this function is being temperamental, use the combination of functions below from `covr`: 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
covr::file_coverage(
  source_files = "R/column_classes.R", 
  test_files = "tests/testthat/test-column_classes.R") |>
  covr::report()
```


Below is the output in the **Viewer** when `devtools::test_coverage_active_file()` is entered in the **Console**:

:::: {.column-body-outset-right}

::: {#fig-column_classes_covr}

![Test coverage using `devtools::test_coverage_active_file()`](column_classes_covr.png){#fig-column_classes_covr width=100% fig-align="center"}

Unit test coverage interactively
:::

::::


I can see from the output I don't have test coverage for the `select_column_class()` behavior when the `class` argument doesn't return any columns from `df`. The function is designed to return an empty `tibble` if this occurs: 

::: {#fig-column_classes_covr_incomplete}

![Behavior not tested in `select_column_class()`](column_classes_covr_incomplete.png){#fig-column_classes_covr_incomplete width=100% fig-align="center"}


The area in red is the untested portion of `select_column_class()`
:::

To test this behavior, I'll write two expectations:

-   The first expectation (`expect_s3_class()`) checks the class of the return object from `select_column_class()`:

    ```{r}
    #| eval: false
    #| echo: true
    #| code-fold: false
      # test class of empty tibble
      testthat::expect_s3_class(
        object = select_column_class(
          df = col_maker(col_type = c("int", "dbl"),
                                      size = 6, 
                                      missing = FALSE),
          class = "log"),
        class = c("tbl_df", "tbl", "data.frame"))
    ```

-   The second expectation verifies there are zero columns in this return tibble:

    ```{r}
    #| eval: false
    #| echo: true
    #| code-fold: false
      # test rows of empty tibble
      testthat::expect_equal(
        object = ncol(select_column_class(
          df = col_maker(col_type = c("int", "dbl"),
                                      size = 6, 
                                      missing = FALSE),
          class = "log")),
        expected = 0L)
    ```

After adding these tests to the `test-column_classes.R` test file, I'll run `testthat::test_file()` and `devtools::test_coverage_active_file()` again: 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
testthat::test_file("tests/testthat/test-column_classes.R")
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 25 ]
```

```{r}
#| eval: false
#| echo: true
#| code-fold: false
devtools::test_coverage_active_file()
```

:::: {.column-body-outset-right}

::: {#fig-column_classes_covr_complete}

![Test coverage using `devtools::test_coverage_active_file()`](column_classes_covr_complete.png){#fig-column_classes_covr_complete width=100% fig-align="center"}

Complete code coverage for `column_classes.R`
:::

::::

100% is great, but uncommon. Striving for a high percentage of coverage is a good practice, it doesn't guarantee that the function always behaves as expected. Unit tests might execute a line of code, but still not catch a bug due to the design of the test (it's easy to have high coverage if the unit tests are shallow and don't check for any potential [edge cases](https://en.wikipedia.org/wiki/Edge_case)).

I'll address code coverage again in the next section, but checking coverage regularly will help ensure function behaviors don't go overlooked. 

## Macro-iteration

After developing the functions in `utap`, the files in the `R/` folder are organized into names [based on the](https://r-pkgs.org/code.html#sec-code-organising) '*main function and its supporting helpers*': 

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
R/
├── column_classes.R
├── pull_binary_cols.R
├── pull_cat_cols.R
├── pull_facet_cols.R
├── pull_numeric_cols.R
└── utils.R
```

### Test file organization

The `tests/testthat/` folder file names have identical names as the files in the `R/` folder.

```{verbatim}
#| eval: false
#| echo: false
#| code-fold: false
tests/testthat/
        ├── test-column_classes.R
        ├── test-pull_binary_cols.R
        ├── test-pull_cat_cols.R
        ├── test-pull_facet_cols.R
        ├── test-pull_numeric_cols.R
        └── test-utils.R
```


#### `R/utils.R`

It's common for R packages to have a general `R/utils.R` file that defines the 'utility' functions. This practice isn't discouraged in R Packages, but these files can become a catch-all for any functions that don't have a clear home (read more [here](https://rud.is/b/2018/04/08/dissecting-r-package-utility-belts/)).

I've only stored the `%nin%` operator in `R/utils.R`, and it's test is shown below: 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
testthat::test_that("%nin% works", {
  testthat::expect_false(
    object = "A" %nin% LETTERS)
  testthat::expect_false(
    object = 1 %nin% 1:10)
  testthat::expect_true(
    object = 1 %nin% 2:10)
})
```


### Test package 

When I've completed a set of test files, I can use `devtools::test()` to check if they're passing.

```{r}
#| eval: false
#| echo: true
#| code-fold: false 
devtools::test()
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false 
ℹ Testing utap
✔ | F W S  OK | Context
✔ |        25 | column_classes                                                     
✔ |        29 | pull_binary_cols                                                   
✔ |         4 | pull_cat_cols                                                      
✔ |        20 | pull_facet_cols                                                    
✔ |         5 | pull_numeric_cols                                                  
✔ |         3 | utils                                                              

══ Results ═════════════════════════════════════════════════════════════════════
Duration: 2.1 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 86 ]

🎯 Your tests hit the mark 🎯
```

The output above shows all tests are passing (and some helpful words of encouragement). As you can see, the number of tests correspond to the number of functions in each test file. 

For example, `pull_binary_cols()` and `pull_facet_cols()` required additional internal functions to define their use:

```{r}
#| eval: true
#| echo: false
#| code-fold: false
#| collapse: false
lobstr::ast(
    pull_binary_cols(check_binary_vec(
                          check_log_binary(),
                          check_int_binary(),
                          check_fct_binary()),
                     make_binary_vec()))
lobstr::ast(
    pull_facet_cols(check_facet_vec(
                          check_chr_facet(), 
                          check_fct_facet()),
                      make_facet_vec())
)
```

Wheras `pull_cat_cols()` and `pull_numeric_cols()` map onto existing classes:

```{r}
#| eval: true
#| echo: false
#| code-fold: false
#| collapse: false
lobstr::ast(
    pull_cat_cols(is.factor(), is.character())
)
lobstr::ast(
    pull_numeric_cols(is.integer(), is.double())
)
```

### Check coverage on build/install 

To check the code coverage for the utap package, I can run `devtools::test_coverage()` to view the output in the **Viewer**. 

```{r}
#| eval: false
#| echo: true
#| code-fold: false 
devtools::test_coverage()
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false 
ℹ Computing test coverage for utap
```



:::: {.column-body-outset-right}

::: {#fig-utap_coverage}

![Final test coverage for `utap` package](utap_coverage.png){#fig-utap_coverage width=100% fig-align="center"}

`devtools::test_coverage()`
:::

::::

Clicking on any of the **Files** will open the **Source** tab and give a summary like the one above from `devtools::test_coverage_active_file()`. I can also use `covr::package_coverage()` in the **Console** for simpler output:

```{verbatim}
utap Coverage: 100.00%
R/column_classes.R: 100.00%
R/pull_binary_cols.R: 100.00%
R/pull_cat_cols.R: 100.00%
R/pull_facet_cols.R: 100.00%
R/pull_numeric_cols.R: 100.00%
R/utils.R: 100.00%
```

#### Other metrics 

Sometimes it's interesting to view the relationship between function size and number of tests using the [`cloc` package.](https://github.com/hrbrmstr/cloc).

```{r}
#| eval: false
#| echo: true
#| code-fold: false 
library(cloc)
```

`cloc` stands for *Count Lines of Code*, and it's a rough metric used to gauge code complexity. It's simple, but apparently provides "*just as much predictive power as more elaborate constructs like cyclomatic complexity.*"[source](https://www.oreilly.com/library/view/software-design-x-rays/9781680505795/)

Below is a count of the lines of code in each file in the `R` folder: 

```{r}
#| eval: false
#| echo: true
#| code-fold: false
cloc::cloc_by_file("R")
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
# A tibble: 8 × 6
  source filename                language   loc blank_lines comment_lines
  <chr>  <chr>                   <chr>    <int>       <int>         <int>
1 R      "R/pull_binary_cols.R"  R           53           2            57
2 R      "R/pull_facet_cols.R"   R           42           2            73
3 R      "R/column_classes.R"    R           41           6            65
4 R      "R/pull_numeric_cols.R" R           19           1            24
5 R      "R/pull_cat_cols.R"     R           13           0            19
6 R      "R/utils.R"             R            3           0             7
7 R      "R/utap-package.R"      R            2           0             7
8 R      ""                      SUM        173          11           252
```

This output also confirms the relationship between lines of code and tests.

## Recap

This post has been an introduction to unit testing utility functions in a shiny app-package. When I'm confident the utility functions are working, I'll start adding them into modules (and testing with `testServer()` or `shinytest2`). Files names can change a lot throughout the course of developing a shiny app-package, so it's helpful to adopt (or create) a naming convention.

If you're using the `golem` framework to develop your shiny app-package, the `utils_` and `fct_` prefixes are used to define two different types of [utility/helper functions](https://engineering-shiny.org/structuring-project.html#conventions-matter): 

1. `utils_` files contain '*small helper functions* and '*top-level functions defining your user interface and your server function*' 

2. `fct_` files contain '*the business logic, which are potentially large functions*...*the backbone of the application and may not be specific to a given module*'.

This particular file naming convention isn't required, but as with most conventions, it's better when someone else comes up with the standard (and I just have to adopt and implement it). And having and sticking to a naming convention is typically more important than the convention itself. 

<!--

```{verbatim}
#| eval: false
#| echo: false
#| code-fold: false
test-column_classes.R:
            │
            └── select_column_class()
                  │
                  └── get_column_class() 
```

```{verbatim}
#| eval: false
#| echo: false
#| code-fold: false
tree/
  │
  └── get_column_class()
        │     │
        │     └── select_column_class()
        │
        ├── pull_binary_cols()
        │
        ├── pull_facet_cols()
        │
        ├── pull_cat_cols()
        │
        └── pull_numeric_cols()
```

```{verbatim}
#| eval: false
#| echo: true
#| code-fold: false
tree/
  │
  └── get_column_class() # used in all pull_[type]_cols()
        │     │
        │     └── select_column_class()
        │
        ├── pull_binary_cols()
        │        │
        │        ├── check_binary_vec()
        │        │      │
        │        │      ├── check_log_binary()
        │        │      ├── check_int_binary()
        │        │      └── check_fct_binary()
        │        │
        │        └── make_binary_vec()
        │
        ├── pull_facet_cols() # custom definition
        │        │
        │        ├── check_facet_vec()
        │        │      │
        │        │      ├── check_chr_facet()
        │        │      └── check_fct_facet()
        │        │
        │        └── make_facet_vec()
        │
        ├── pull_cat_cols() # is.character & is.factor
        │
        └── pull_numeric_cols() # is.integer & is.double
```

-->